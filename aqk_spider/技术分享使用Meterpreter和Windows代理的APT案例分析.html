<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:wb="http://open.weibo.com/wb" xml:lang="en" lang="en">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="viewport"
          content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"/>
    <link rel="shortcut icon" href="http://bobao.360.cn/favicon.ico?v=1.1"/>
    <link rel="alternate" title="安全资讯" href="/rss?type=news" type="application/rss+xml"/>
    <link rel="alternate" title="安全知识" href="/rss?type=learning" type="application/rss+xml"/>
    <link rel="alternate" title="安全圈活动" href="/rss?type=activity" type="application/rss+xml"/>
    <link rel="alternate" title="所有漏洞" href="/rss?type=vul" type="application/rss+xml"/>
    <link rel="alternate" title="通用型漏洞" href="/rss?type=commonvul" type="application/rss+xml"/>
    <link rel="alternate" title="事件型漏洞" href="/rss?type=eventvul" type="application/rss+xml"/>
    <link rel="alternate" title="热门漏洞" href="/rss?type=hotvul" type="application/rss+xml"/>

        <title>【技术分享】使用Meterpreter和Windows代理的APT案例分析 - 安全客 - 有思想的安全新媒体</title>
    
        <meta name="keywords" content="Meterpreter,apt,渗透,网络渗透,Windows代理"/>
    
        <meta name="description" content="在某些环境下，使用HTTPS协议的Meterpreter载荷工作不正常，作者在使用自己开发的APT工具时遇到了这种问题，本文主要记录了作者解决问题的思路，及最终的解决办法。"/>
        <meta property="wb:webmaster" content="224437c7be31d633"/>

    <script type="text/javascript" src="http://s7.qhimg.com/!56caa871/xpc_sync_height.js"></script>
    <link rel="stylesheet" type="text/css" href="/css/reset.css" />
    <link rel="stylesheet" type="text/css" href="/css/common_new.css?v=4.4.2.1" />
    <link rel="stylesheet" type="text/css" href="/css/jquery.notyfy.css" />
    <link rel="stylesheet" type="text/css" href="/css/notyfy.theme.default.css" />
    <link rel="stylesheet" type="text/css" href="/css/s_common.css?v=2.2.7" media="only screen and
    (max-device-width:900px), only screen and (max-width:900px)" />
    <script type="text/javascript" src="/js/jquery.min.js?v=3.1"></script>
    <script type="text/javascript" src="/js/jquery.notyfy.js"></script>
    <script type="text/javascript" src="/js/iscroll.js"></script>
    <script src="http://js.passport.qihucdn.com/5.0.3.js"></script>
    <script type="text/javascript">
        var myScroll, myNavScroll;

        function iscrollLoaded() {
            myScroll = new IScroll('#wrapper',
                {
                    scrollX: true,
                    scrollY: false,
                    bounceEasing: 'circular',
                    eventPassthrough: true,
                    preventDefault: false,
                    bounceTime: 500
                }
            );
        }

        $(function () {

            //导航横向滚动


            function setNavWidth() {

                /* 计算导航宽度 */
                var allWidth = $(window).width();
                var scroller = $('#scroller');

                if (allWidth > 900) {
                    scroller.find('ul').add(scroller.find('.scroll')).removeAttr('style');
                    scroller.css('overflow', 'visible');
                    if (myNavScroll) myNavScroll.destroy();
                } else {

                    var width = 0;
                    scroller.find('.scroll').children('ul').children('li').each(function (index, el) {
                        if (!$(this).hasClass('mobile-hide')) {
                            width += $(this).outerWidth();
                        }
                    });
                    scroller.find('ul').add(scroller.find('.scroll')).width(width);

                    if (myNavScroll) myNavScroll.destroy();

                    myNavScroll = new IScroll('#scroller', {
                        scrollX: true,
                        scrollY: false,
                        momentum: false,
                        click: true
                    });

                }

            }

            setNavWidth();
            $(window).resize(function (event) {
                setNavWidth();
            });

        });

    </script>
</head>
<body onload="iscrollLoaded();">
<div style='margin:0 auto;width:0px;height:0px;overflow:hidden;'>
    <img src=""/>
</div>

<div id="is-mobile"></div>
<div class="container">
        <div class="mobile-header">
        <div class="header clearfix">
            <div class="header-wrapper clearfix">
                <a href="/index/index" class="logo"><img class="slogan" src="/img/logo.png?v=1.5"/></a>
                                <form id="search" class="search-box" action="/search/index" method="GET">
                    <input class="keys" name="keywords" type="text" placeholder="搜索漏洞" required="required">
                    <input class="icon" type="submit" value="">
                    <input type="hidden" name="type" value=""/>
                </form>
                <div class="bug">
                    <div class="name"><span class="seled">全部</span><i class="arrow"></i></div>
                    <ul class="typelist">
                        <li data-index="3"><a href="javascript:void(0);">全部</a></li>
                        <li data-index="0"><a href="javascript:void(0);">漏洞</a></li>
                        <li data-index="1"><a href="javascript:void(0);">资讯</a></li>
                        <li data-index="2"><a href="javascript:void(0);">知识</a></li>
                    </ul>
                </div>
                                <div class="logNreg mobile-hide">
                    <div class="unlog">
                        <i></i>
                        <a href="log.html" class="log">登录</a>
                        <span>|</span>
                        <a href="reg.html" class="reg">注册</a>
                    </div>
                    <div class="loged">
                        <a href="/member/profile" class="user-center"><i></i><span class="user-name-tag">个人中心</span></a>
                        <div class="user-links">
                            <span class="arrow"></span>
                            <ul>
                                <li class="account-setting"><a href="http://i.360.cn/profile/accountmanage"
                                                               target="_blank"><i></i><span>账号设置</span></a></li>
                                <li class="alert-setting"><a href="/keywords/index"
                                                             target="_blank"><i></i><span>告警设置</span></a></li>
                                <li class="bug-alert"><a href="/myalarm/index" target="_blank"><i></i><span>漏洞告警</span></a>
                                </li>
                                <li class="my-knowl"><a href="/mylearn/index" target="_blank"><i></i><span>我的知识</span></a>
                                </li>
                                <li class="my-knowl"><a href="/mycourse/index" target="_blank"><i></i><span>我的课堂</span></a>
                                </li>
                                <li class="my-exit"><a
                                            href="http://login.360.cn/?src=pcw_adlab&op=logout&destUrl=http://bobao.360.cn"><i></i><span>退出系统</span></a>
                                </li>
                            </ul>
                        </div>

                        <a href="/message" class="message-center" target="_blank"><i></i><span>我的消息</span></a>
                        <div class="message-links">
                            <span class="arrow"></span>
                            <ul>
                                <li class="account-setting" style="display:none;"><a href="/myres/index"
                                                                                     target="_blank"><i></i><span>回复我的</span></a>
                                </li>
                                <li class="my-bug"><a href="/myvul/index"
                                                      target="_blank"><i></i><span>我的漏洞</span></a></li>
                                <!--<li class="my-bug"><a href="/myres/index" target="_blank"><i></i><span>我的评论</span></a></li>-->
                                <!--<li class="alert-setting"><a href="###" target="_blank"><i></i><span>提到我的</span></a>
                                </li>-->
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <style type="text/css">
            .nav {
                overflow: hidden;
            }

            .nav .scroll {
                width: auto;
            }
        </style>
        <div id="wrapper">
            <div id="scroller" class="nav">
                <div class="scroll">
                    <ul class="nav-list">
                        <li ><a class="link-nav"
                                                                                 href="/index/index">首页</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/vul/index">漏洞</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/introduce/list">招聘</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/news/index">资讯</a><!--<i class="arrow mobile-hide"></i>
                        <ul class="subnav-list mobile-hide">
                            <li><a class="link-subnav" href="/introduce/list">招聘</a></li>
                        </ul>
			-->
                        </li>
                        <li class="cur">
                        <a class="link-nav" href="/learning/index">知识</a><i class="arrow mobile-hide"></i>
                        <ul class="subnav-list mobile-hide">
                            <li><a class="link-subnav" href="/course/index">学院</a></li>
                        </ul>
                        </li>
                        <li ><a class="link-nav"
                                                               href="/activity/index">活动</a></li>
                        <li class="mobile-hide "><a class="link-nav"
                                                                                                   href="/ctf/index">CTF训练营</a>
                        </li>
                        <li ><a class="link-nav"
                                                               href="/interref/list">安全内参</a></li>
                        <li ><a class="link-nav" href="/app/index">APP</a></li>

                        <!--<li ><a href="/course/index">学院</a></li>-->
                        <!--<li ><a href="/introduce/list">招聘</a></li>-->
                        <!--<li  class="mobile-hide"><a href="/ctf/index">CTF训练营</a></li>-->
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <div class="mobile-content">
        <link rel="stylesheet" type="text/css" href="/css/news.css?v=3.5" />
<link rel="stylesheet" type="text/css" href="/ue/SyntaxHighlighter/shCoreDefault.css?v=1.0" />
<style>
    p .syntaxhighlighter {
        width: 80%;
    }
</style>

<div class="cur-pos w1000">当前位置：<a href="http://bobao.360.cn/">安全客</a> &gt;&gt; 知识详情</div>

<div class="content clearfix">
    <div class="main">
        <div class="article">
            <div id="article_box">
                <h2>【技术分享】使用Meterpreter和Windows代理的APT案例分析</h2>
                <div class="article-msg">
                    <span class="time">2017-05-17 14:13:26</span>
                    
                                        <span class="read">阅读：11797次</span>
                    <span><a style="display: none;" class="good" href="javascript:;"
                             data-target="/learning/good" data-value="g_3865"
                             data-type="learning">点赞(0)</a></span>
                    <span><a class="fav" href="javascript:;" data-target="/mylearning/add"
                             data-pk="3865" data-type="learning">收藏</a></span>
                                        <span><a style="margin-left: 4px;" class="fav" href="https://medium.com/@br4nsh/a-meterpreter-and-windows-proxy-case-4af2b866f4a1"
                             target="_blank">来源： medium.com/@br4nsh</a></span>
                    
                    
                    <div style="margin-top:10px; ">
                        <a href="/member/contribute?uid=2819002922" style="color:#848e99;">
                            <img src="http://p1.qhmsg.com/dm/150_150_100/t0104d1b8b4ca36e961.jpg" data-is-avatar="true"
                                 style="border: 1px solid #d5d5d5;padding: 2px; width: 80px;height: 80px;border-radius: 43px;"/>
                        </a>

                    </div>
                    <span class="orig">作者：<a href="/member/contribute?uid=2819002922" style="color:#848e99;">興趣使然的小胃</a></span>
                                    </div>
                <hr size="1">
                <div class="article-msg">
                    <p><!-- JiaThis Button BEGIN -->

<!--
<span class="jiathis_style"><span class="jiathis_txt">分享到：</span>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_tsina"></a>
    <a class="jiathis_button_tqq"></a>
    <a class="jiathis_button_qzone"></a>
    <a class="jiathis_button_renren"></a>
    <a class="jiathis_button_xiaoyou"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
</span>

-->
</p>
                </div>
                <p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></strong></span></p><p style="margin: 0px 25px 8px; white-space: normal; padding: 0px; line-height: 25px; color: rgb(70, 79, 85); word-break: break-all; font-family: Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Yahei&quot;, 微软雅黑, serif; background-color: rgb(255, 255, 255); text-indent: 0em; text-align: center;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(0, 112, 192); font-size: 18px; font-weight: 900;"><img src="http://p6.qhimg.com/t01612b8a73f0a0d60f.jpg" title="t01612b8a73f0a0d60f.jpg" alt="http://p6.qhimg.com/t01612b8a73f0a0d60f.jpg"/></span></p><p style="margin: 0px 25px 8px; white-space: normal; padding: 0px; line-height: 25px; color: rgb(70, 79, 85); word-break: break-all; font-family: Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Yahei&quot;, 微软雅黑, serif; text-indent: 2em; background-color: rgb(255, 255, 255);"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(0, 112, 192); font-size: 18px; font-weight: 900;">翻译：</span><a href="http://bobao.360.cn/member/contribute?uid=2819002922" target="_blank" textvalue="興趣使然的小胃"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 18px; color: rgb(0, 112, 192);"><strong>興趣使然的小胃</strong></span></a></p><p style="margin: 0px 25px 8px; white-space: normal; padding: 0px; line-height: 25px; word-break: break-all; text-indent: 2em; background-color: rgb(255, 255, 255);"><strong><span style="color: rgb(0, 112, 192); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><span style="font-size: 18px;">稿费：200RMB</span></span></strong></p><p style="margin: 0px 25px 8px; white-space: normal; padding: 0px; line-height: 25px; color: rgb(70, 79, 85); word-break: break-all; font-family: Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Yahei&quot;, 微软雅黑, serif; text-indent: 2em; background-color: rgb(255, 255, 255);"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(0, 112, 192); font-size: 18px; font-weight: 900;">投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">一、前言</span></strong></span><br/></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">几个月之前，我自己开发了一个APT工具，工具的使用场景为企业中的Windows攻击模拟环境，这个环境只能通过代理方式访问互联网。在测试工具时，我发现使用HTTPS协议的Meterpreter载荷工作不正常。说实话，一开始我并不确定这个问题是否与我的APT工具的工作机制有关（将Meterpreter载荷注入内存），还是与其他原因有关。在这个环境中，我的APT工具必须与代理打交道，因此我不得不找到确切原因，再去解决这个问题。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">在全面分析整个情况之后，我发现我正在使用的Meterpreter载荷可能无法正常工作。当时我使用的Meterpreter载荷为“windows/meterpreter/reverse_https”，Metasploit的版本为4.12.40-dev。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">在讨论技术细节之前，先介绍一下我的测试环境：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1、受害者机器系统及IP地址：Windows 8.1 x64 Enterprise/10.x.x.189；</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2、互联网访问方式：通过认证代理访问（设置DHCP选项，并且在IE中勾选“自动检测设置（Automatically detect settings）”选项）；</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">3、代理服务器的外部IP地址：190.x.x.x；</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">4、攻击者主机IP地址：190.y.y.y；</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">5、Meterpreter载荷：windows/meterpreter/reverse_https。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">需要注意的是，“reverse_https”载荷是一个传输器载荷（staged payload）。也就是说，这是一种“先遣队”类型的载荷，在受害者主机上运行，可以下载真正的Meterpreter DLL载荷（如metsrv.x86.dll或者metsrv.x64.dll），通过反射注入方式（reflective injection），将DLL注入到受害者主机内存中。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">受害者主机的外部IP如下图所示：</span></p><p style="text-align:center"><img src="http://p8.qhimg.com/t014873e4268815469b.png" title="t0189d93f67a5337021.png" alt="http://p3.qhimg.com/t0189d93f67a5337021.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">受害者主机的代理配置情况如下图所示（已勾选“自动检测设置”选项）：</span></p><p style="text-align:center"><img src="http://p4.qhimg.com/t01fccdc5a713f4fb4b.png" title="t01e7a8ed9f7ec0cc5a.png" alt="http://p9.qhimg.com/t01e7a8ed9f7ec0cc5a.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">“autoprox.exe”工具在受害者主机上的运行结果如下图所示。可以看到，受害者主机通过DHCP（252选项）获取代理配置信息。</span></p><p style="text-align:center"><img src="http://p8.qhimg.com/t01244fb7ea97d1e30e.png" title="t01e32052b7d17f0b22.png" alt="http://p0.qhimg.com/t01e32052b7d17f0b22.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">从上图可知，对于“www.google.com”来说，主机在访问这个地址必须使用“10.x.x.20:8080”这个代理。如果不使用工具，我们也可以手动下载wpad.dat文件（这个文件位置可通过DHCP的252选项获得），检查其中包含的规则，了解代理的具体使用场景。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">请注意：根据我的研究结果，autoprox.exe（pierrelc@microsoft.com写的一款工具）首先会使用Windows API搜索DHCP提供的代理信息，如果搜索失败，会尝试通过DNS获取代理信息。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">二、具体分析</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">在分析这个问题的过程中，我会修改Meterpreter载荷中的几行代码，并在受害者主机上测试运行，因此，我们需要创建一个使用HTTPs协议的meterpreter反弹载荷（windows/meterpreter/reverse_https）的后门程序，或者使用某个Web传输模块。对你而言，选择使用那种方式都可以。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">请注意：我们可以使用Shellter以及其他可信的程序（如putty.exe）创建一个简单的后门程序，除此之外，我建议使用Metasploit的Web传输载荷。我们将要修改的是传输体（stage）载荷，而不是传输器（stager）载荷，因此我们只需要创建一个后门程序，就能满足所有实验场景。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">接下来，我们在受害者主机上运行后门程序，在攻击者主机上运行Metasploit监听端，看一下执行结果。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">如下图所示， MSF handler在攻击者主机的443端口上监听，之后接收到来自于受害者主机的一个连接请求（源端口为18903）：</span></p><p style="text-align:center"><img src="http://p4.qhimg.com/t018c95f1f9c485fa5a.png" title="t0100ae10b62d17b679.png" alt="http://p7.qhimg.com/t0100ae10b62d17b679.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">从上图可知，受害者主机已经连接到攻击者主机上的handler，此时我们应该已经获得了一个Meterpreter shell。然而，不管我输入什么命令，我都收不到受害者主机的有效回应，然后会话就会被关闭。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">当传输器载荷（很小的一段代码）在受害者主机上运行时，它会回连到攻击者主机上的监听端，下载真正的攻击代码（即Meterpreter载荷）并将其注入到内存中，之后再将控制权交给攻击代码。加载成功后Meterpreter载荷会再次连接到攻击者主机上监听端，以便攻击者与受害主机系统进行交互。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">到目前为止，我们知道传输器载荷已经成功在受害者主机上运行，能够穿透代理回连到监听端。然而，当传输体载荷注入到受害者主机内存后（如果注入过程有效的话），哪里出了点问题导致传输体载荷不能正常工作。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">请注意：为了打消你的顾虑，我检查了整个攻击过程是否受到AV软件的影响，然而这些攻击载荷都不会被AV软件查杀。此外，为了避免网管对HTTPS的监听行为，我手动创建了一个PEM证书，配置监听端使用这个证书。使用浏览器观察手动访问Metasploit监听端时的指纹信息，将这个指纹与刚刚创建的证书的指纹信息进行对比，确保证书在传输过程中没有被替换。排除掉这些可能存在的问题之后，我决定继续在其他地方查找问题的真正原因。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">接下来我决定嗅探来自于受害者主机的网络流量，从黑盒测试角度获取更多的信息。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">在受害者主机上使用Wireshark抓的包如下图所示：</span></p><p style="text-align:center"><img src="http://p1.qhimg.com/t01cbfc5af111f2702f.png" title="t0168df40265ae0654d.png" alt="http://p6.qhimg.com/t0168df40265ae0654d.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">我们可以从上图中观察到受害者主机（10.x.x.189）与代理服务器（10.x.x.20:8080）之间所建立的TCP连接，受害者主机发送了一个CONNECT方法（第一个报文），请求与攻击者主机（190.x.x.x:443）建立一个安全的（SSL/TLS）通信渠道。此外，我们从第一和第二个数据包中可知，受害者主机的请求中使用了NTLM身份验证（NTLMSSP_AUTH），代理服务器的响应是“连接建立”（HTTP/1.1 200）。之后就是SSL/TLS握手过程。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">值得一提的是，上图反应的是第一阶段的发送和接收数据包，也就是传输器载荷执行时的通信数据包。连接建立完毕后，通信两端（即客户端和服务端）之间就会进行典型的SSL/TLS握手过程，建立加密通信信道，之后传输体载荷就会经过加密信道，从攻击者主机发往受害者主机。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">现在，我们可以确定Meterpreter在第一阶段的部署过程（即传输器载荷）工作正常，接下来我们需要了解第二阶段的工作过程，也就是传输体载荷和监听端之间的通信过程。为此，我们只需要继续分析Wireshark的抓包结果即可。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">传输器载荷和监听端的最后一部分通信数据包如下图所示，在这之后，受害者主机会尝试不经过代理，直接与攻击者主机建立连接：</span></p><p style="text-align:center"><img src="http://p5.qhimg.com/t01952f86e4631389d6.png" title="t0109882ed32de4b7d1.png" alt="http://p6.qhimg.com/t0109882ed32de4b7d1.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">在上图的前5个数据包中，我们可以看到受害者主机（10.x.x.189）与代理服务器（10.x.x.20）的TCP连接中断标识（FIN、ACK；ACK；FIN、ACK；ACK）。之后我们可以看到，第6个数据包为受害者主机直接发往攻击者主机的数据包，其中包含一个TCP SYN标志（用来初始化一个TCP握手过程），也就是说受害者主机没有使用代理服务器作为建连的跳板。最后，我们可以看到，第7个数据包为受害者主机所收到的网关响应报文，表明建连目的地（即攻击者主机）无法通过该网络直接访问（我在前文提到过，这个环境中必须使用代理服务器才能访问互联网）。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">通过上述抓包结果，我们知道Meterpreter会话建立失败。我们认为Meterpreter传输体载荷之所以不能访问监听端，原因在于传输体载荷使用了直接建连方式，没有像传输器载荷那样使用系统代理服务器。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">现在我们要做的就是下载Meterpreter源代码，尝试从源代码角度分析这种行为的根本原因。为此，我们需要遵循Rapid7在github上发布的如何在Windows上编译的指南（读者可以在本文的参考资料中找到相关链接）。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">根据指南给出的建议，我们使用Visual Studio 2013打开项目解决方案文件（\metasploit-payloads\c\meterpreter\workspace\meterpreter.sln），开始分析源代码。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">浏览源代码之后，我们发现在源代码的“server_transport_winhttp.c”文件中，有关于代理处理逻辑的具体实现（请阅读参考资料快速定位源代码文件）。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">Meterpreter中对代理设置情况的判断如以下部分代码所示：</span></p><p style="text-align:center"><img src="http://p0.qhimg.com/t0133633f78afb6b844.png" title="t01d1257cef1984109d.png" alt="http://p1.qhimg.com/t01d1257cef1984109d.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">我之前从github了解到，Meterpreter的reverse_https（第一次）会尝试使用WinHTTP Windows API访问互联网，正如我们在这部分代码中看到的情况一样。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">从代码中我们可以看到很多dprint调用语句，使用这些语句是为了方便调试，以便在运行时给我们提供有价值的信息。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">为了使这些调试信息对我们可见，我们需要编辑源代码中的common.h头文件，修改其中的DEBUGTRACE预处理器（pre-processor）常量，这样就可以使服务器（受害者主机中加载的Meterpreter DLL文件）在Visual Stuido的Output窗口打印调试信息，我们也可以使用SysInternals的DebugView工具或者Windbg工具查看调试信息。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">在原始的common.h头文件中，DEBUGTRACE常量在代码中处于被注释状态，如下图所示：</span></p><p style="text-align:center"><img src="http://p3.qhimg.com/t01b4613d76c8d0b05b.png" title="t0171ede93e3ccc6cb2.png" alt="http://p3.qhimg.com/t0171ede93e3ccc6cb2.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">现在我们可以编译工程文件，将生成的“metsrv.x86.dll”二进制文件（位于“\metasploit-payloads\c\meterpreter\output\x86\”文件夹中）拷贝到攻击者主机中（即运行metasploit监听端的主机）的正确文件目录中（对我来说，这个目录位于“/usr/share/metasploit-framework/vendor/bundle/ruby/2.3.0/gems/metasploit-payloads-1.1.26/data/meterpreter/”路径）。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">在调试主机上，我们运行DebugView工具，然后执行后门程序，使Meterpreter传输器载荷再次运行。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">受害者主机上的调试信息输出如下：</span></p><p style="text-align:center"><img src="http://p2.qhimg.com/t010f14d4a1d0e9b45b.png" title="t01a9a6c52aa8af73db.png" alt="http://p2.qhimg.com/t01a9a6c52aa8af73db.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">从Meterpreter生成的调试（日志）信息中，我们可以看到第70-74行对应的是 “server_transport_winhttp.c” 源代码文件中第48-52行的dprintf语句。具体说来，第71行（““[PROXY] AutoDetect: yes””）表明程序检测出来受害者主机上的代理被设置为“自动检测（AutoDetect）”。然而，获取的代理URL地址却为空（NULL）。最后，我们可以观察到传输体载荷试图发送GET请求（第75行）。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">感谢Meterpreter生成的调试信息，现在我们已经接近事实的真相。看起来程序中负责处理Windows代理的代码片段没有被正确实现。为了解决这个问题，我们需要对代码进行分析、修改以及测试。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">我需要重复多次编译Meterpreter的C工程文件，将生成的metsrv DLL拷贝到攻击者主机中，使用受害者主机进行测试，这个过程非常耗时。因此我决定使用Python语言，复制C文件中与代理有关的处理代码，这样一来整个处理过程会更加轻松（感谢Python ctypes库的强大功能）。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">提取“server_transport_winhttp.c”源代码中与Meterpreter的代理处理逻辑有关的代码，将其转换为Python语言，如下所示：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">import&nbsp;ctypes
import&nbsp;ctypes.wintypes
import&nbsp;sys
class&nbsp;WINHTTP_CURRENT_USER_IE_PROXY_CONFIG(ctypes.Structure):
_fields_&nbsp;=&nbsp;[(&quot;fAutoDetect&quot;,&nbsp;ctypes.wintypes.BOOL),
(&quot;lpszAutoConfigUrl&quot;,&nbsp;ctypes.wintypes.LPWSTR),
(&quot;lpszProxy&quot;,&nbsp;ctypes.wintypes.LPWSTR),
(&quot;lpszProxyBypass&quot;,&nbsp;ctypes.wintypes.LPWSTR)]
class&nbsp;WINHTTP_AUTOPROXY_OPTIONS(ctypes.Structure):
_fields_&nbsp;=&nbsp;[(&quot;dwFlags&quot;,&nbsp;ctypes.wintypes.DWORD),
(&quot;dwAutoDetectFlags&quot;,&nbsp;ctypes.wintypes.DWORD),
(&quot;lpszAutoConfigUrl&quot;,&nbsp;ctypes.wintypes.LPCWSTR),
(&quot;lpvReserved&quot;,&nbsp;ctypes.c_void_p),
(&quot;dwReserved&quot;,&nbsp;ctypes.wintypes.DWORD),
(&quot;fAutoLogonIfChallenged&quot;,&nbsp;ctypes.wintypes.BOOL)]
class&nbsp;WINHTTP_PROXY_INFO(ctypes.Structure):
_fields_&nbsp;=&nbsp;[(&quot;dwAccessType&quot;,&nbsp;ctypes.wintypes.DWORD),
(&quot;lpszProxy&quot;,&nbsp;ctypes.wintypes.LPCWSTR),
(&quot;lpszProxyBypass&quot;,&nbsp;ctypes.wintypes.LPCWSTR)]
#&nbsp;dwFlags&nbsp;values
WINHTTP_AUTOPROXY_AUTO_DETECT&nbsp;=&nbsp;0x00000001
WINHTTP_AUTOPROXY_CONFIG_URL&nbsp;=&nbsp;0x00000002
#&nbsp;dwAutoDetectFlags&nbsp;values
WINHTTP_AUTO_DETECT_TYPE_DHCP&nbsp;=&nbsp;0x00000001
WINHTTP_AUTO_DETECT_TYPE_DNS_A&nbsp;=&nbsp;0x00000002
#&nbsp;Parameters&nbsp;for&nbsp;WinHttpOpen
WINHTTP_USER_AGENT&nbsp;=&nbsp;&quot;Mozilla/5.0&nbsp;(Windows&nbsp;NT&nbsp;6.3;&nbsp;Trident/7.0;&nbsp;rv:11.0)&nbsp;like&nbsp;Gecko&quot;
WINHTTP_ACCESS_TYPE_DEFAULT_PROXY&nbsp;=&nbsp;0
WINHTTP_NO_PROXY_NAME&nbsp;=&nbsp;0
WINHTTP_NO_PROXY_BYPASS&nbsp;=&nbsp;0
WINHTTP_FLAG_ASYNC&nbsp;=&nbsp;0x10000000
test_url&nbsp;=&nbsp;&quot;http://www.google.com&quot;
#&nbsp;Gets&nbsp;the&nbsp;current&nbsp;user&nbsp;IE&nbsp;proxy&nbsp;configuration
ieConfig&nbsp;=&nbsp;WINHTTP_CURRENT_USER_IE_PROXY_CONFIG()
result&nbsp;=&nbsp;ctypes.windll.winhttp.WinHttpGetIEProxyConfigForCurrentUser(ctypes.byref(ieConfig))
if&nbsp;not&nbsp;result:
print&nbsp;&quot;[-]&nbsp;Error&nbsp;on&nbsp;WinHttpGetIEProxyConfigForCurrentUser:&nbsp;%s&quot;&nbsp;%&nbsp;ctypes.GetLastError()
sys.exit()
print&nbsp;&quot;[+]&nbsp;Got&nbsp;IE&nbsp;configuration&quot;
print&nbsp;&quot;\tAutoDetect:&nbsp;%s&quot;&nbsp;%&nbsp;ieConfig.fAutoDetect
print&nbsp;&quot;\tAuto&nbsp;URL:&nbsp;%s&quot;&nbsp;%&nbsp;ieConfig.lpszAutoConfigUrl
print&nbsp;&quot;\tProxy:&nbsp;%s&quot;&nbsp;%&nbsp;ieConfig.lpszProxy
print&nbsp;&quot;\tProxy&nbsp;Bypass:&nbsp;%s&quot;&nbsp;%&nbsp;ieConfig.lpszProxyBypass
#&nbsp;We&nbsp;have&nbsp;three&nbsp;alternatives:
#&nbsp;&nbsp;1.&nbsp;The&nbsp;configuration&nbsp;is&nbsp;set&nbsp;to&nbsp;&quot;auto&nbsp;detect&quot;&nbsp;the&nbsp;proxy,&nbsp;that&nbsp;is,&nbsp;via&nbsp;DHCP&nbsp;or&nbsp;DNS&nbsp;(in&nbsp;that&nbsp;order)
#&nbsp;&nbsp;2.&nbsp;There&nbsp;is&nbsp;a&nbsp;URL&nbsp;for&nbsp;downloading&nbsp;the&nbsp;script&nbsp;with&nbsp;the&nbsp;configuration&nbsp;(proxy&nbsp;autoconfiguration,&nbsp;PAC)
#&nbsp;&nbsp;3.&nbsp;A&nbsp;manually&nbsp;configured&nbsp;proxy&nbsp;is&nbsp;being&nbsp;used
if&nbsp;ieConfig.lpszAutoConfigUrl:
autoProxyOpts&nbsp;=&nbsp;WINHTTP_AUTOPROXY_OPTIONS()
proxyInfo&nbsp;=&nbsp;WINHTTP_PROXY_INFO()
print&nbsp;&quot;[+]&nbsp;IE&nbsp;config&nbsp;set&nbsp;to&nbsp;autodetect&nbsp;with&nbsp;URL&nbsp;%s&quot;&nbsp;%&nbsp;ieConfig.lpszAutoConfigUrl
autoProxyOpts.dwFlags&nbsp;=&nbsp;WINHTTP_AUTOPROXY_AUTO_DETECT&nbsp;|&nbsp;WINHTTP_AUTOPROXY_CONFIG_URL
autoProxyOpts.dwAutoDetectFlags&nbsp;=&nbsp;WINHTTP_AUTO_DETECT_TYPE_DHCP&nbsp;|&nbsp;WINHTTP_AUTO_DETECT_TYPE_DNS_A
autoProxyOpts.fAutoLogonIfChallenged&nbsp;=&nbsp;True
autoProxyOpts.lpszAutoConfigUrl&nbsp;=&nbsp;ieConfig.lpszAutoConfigUrl
hInternet&nbsp;=&nbsp;ctypes.windll.winhttp.WinHttpOpen(WINHTTP_USER_AGENT,&nbsp;WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,&nbsp;WINHTTP_NO_PROXY_NAME,&nbsp;WINHTTP_NO_PROXY_BYPASS,&nbsp;WINHTTP_FLAG_ASYNC)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if&nbsp;not&nbsp;hInternet:
print&nbsp;&quot;[-]&nbsp;Error&nbsp;on&nbsp;WinHttpOpen:&nbsp;%s&quot;&nbsp;%&nbsp;ctypes.GetLastError()
sys.exit()
result&nbsp;=&nbsp;ctypes.windll.winhttp.WinHttpGetProxyForUrl(hInternet,&nbsp;unicode(test_url),&nbsp;ctypes.byref(autoProxyOpts),&nbsp;ctypes.byref(proxyInfo))
if&nbsp;not&nbsp;result:
print&nbsp;&quot;[-]&nbsp;Error&nbsp;on&nbsp;WinHttpGetProxyForUrl:&nbsp;%s&quot;&nbsp;%&nbsp;ctypes.GetLastError()
sys.exit()
print&nbsp;&quot;[+]&nbsp;Proxy&nbsp;Host:&nbsp;%s&quot;&nbsp;%&nbsp;proxyInfo.lpszProxy
elif&nbsp;ieConfig.lpszProxy:
print&nbsp;&quot;[+]&nbsp;IE&nbsp;config&nbsp;set&nbsp;to&nbsp;proxy&nbsp;%s&nbsp;with&nbsp;bypass&nbsp;%s&quot;&nbsp;%&nbsp;(ieConfig.lpszProxy,&nbsp;ieConfig.lpszProxyBypass)</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">这一段脚本程序在受害者主机上的执行结果如下图所示：</span></p><p style="text-align:center"><img src="http://p7.qhimg.com/t01fc9c675a754e99f9.png" title="t01edbab5da85324fe1.png" alt="http://p0.qhimg.com/t01edbab5da85324fe1.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">从脚本的输出信息中，我们可知Python程序的执行结果与C版本的一致。程序检测到代理的自动配置选项，但没有获取到代理地址。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">如果我们再次检查代码，我们会发现，程序在某个“if”代码块内判断是否可能使用DHCP以及DNS获取代理信息，如果自动配置URL（ieConfig.lpszAutoConfigUrl）的条件为真就会执行这个代码块。然而，如果仅仅启用了AutoDetect选项，这部分代码并不会被执行，而这正是受害者主机上发生的情况。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">在这个特定场景中（受害者主机所处的环境），代理的配置信息需要通过DHCP的252选项获取。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">受害者主机上嗅探的DHCP传输数据包如下图所示：</span></p><p style="text-align:center"><img src="http://p0.qhimg.com/t01a26b737a24d7a1cb.png" title="t01e0875fa16c6a8c04.png" alt="http://p2.qhimg.com/t01e0875fa16c6a8c04.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">从这个传输数据包中我们可以看出，DHCP服务器的应答中包含252选项（“Private/Proxy autodiscovery”，私有选项，用于代理的自动发现），包含代理的URL地址。这正是我们在运行autoprox.exe工具时获得的信息。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">在继续分析之前，我们需要了解Windows为代理配置提供的三种选项：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1、自动检测代理设置：使用DHCP（252选项）获取代理URL地址，或者使用DNS、LLMNR、NBNS（如果启用的话）获取WPAD主机名；</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2、使用自动配置脚本：从某个URL下载配置脚本，通过这个脚本决定何时使用代理服务器；</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">3、手动设置代理服务器：为不同的协议手动配置代理服务器。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">关于这个问题的根本原因，现在我们又掌握了更多的信息，我会稍微修改程序代码，将代理自动检测的可能性考虑在内。让我们先修改Python代码，如果代码工作正常，我们就可以修改Meterpreter的C语言代码，然后再编译生成Meterpreter载荷。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">修改后的Python代码如下所示：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">import&nbsp;ctypes
import&nbsp;ctypes.wintypes
import&nbsp;sys
class&nbsp;WINHTTP_CURRENT_USER_IE_PROXY_CONFIG(ctypes.Structure):
&nbsp;&nbsp;&nbsp;&nbsp;_fields_&nbsp;=&nbsp;[(&quot;fAutoDetect&quot;,&nbsp;ctypes.wintypes.BOOL),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;lpszAutoConfigUrl&quot;,&nbsp;ctypes.wintypes.LPWSTR),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;lpszProxy&quot;,&nbsp;ctypes.wintypes.LPWSTR),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;lpszProxyBypass&quot;,&nbsp;ctypes.wintypes.LPWSTR)]
class&nbsp;WINHTTP_AUTOPROXY_OPTIONS(ctypes.Structure):
&nbsp;&nbsp;&nbsp;&nbsp;_fields_&nbsp;=&nbsp;[(&quot;dwFlags&quot;,&nbsp;ctypes.wintypes.DWORD),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;dwAutoDetectFlags&quot;,&nbsp;ctypes.wintypes.DWORD),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;lpszAutoConfigUrl&quot;,&nbsp;ctypes.wintypes.LPCWSTR),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;lpvReserved&quot;,&nbsp;ctypes.c_void_p),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;dwReserved&quot;,&nbsp;ctypes.wintypes.DWORD),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;fAutoLogonIfChallenged&quot;,&nbsp;ctypes.wintypes.BOOL)]
class&nbsp;WINHTTP_PROXY_INFO(ctypes.Structure):
&nbsp;&nbsp;&nbsp;&nbsp;_fields_&nbsp;=&nbsp;[(&quot;dwAccessType&quot;,&nbsp;ctypes.wintypes.DWORD),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;lpszProxy&quot;,&nbsp;ctypes.wintypes.LPCWSTR),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;lpszProxyBypass&quot;,&nbsp;ctypes.wintypes.LPCWSTR)]
#&nbsp;dwFlags&nbsp;values
WINHTTP_AUTOPROXY_AUTO_DETECT&nbsp;=&nbsp;0x00000001
WINHTTP_AUTOPROXY_CONFIG_URL&nbsp;=&nbsp;0x00000002
#&nbsp;dwAutoDetectFlags&nbsp;values
WINHTTP_AUTO_DETECT_TYPE_DHCP&nbsp;=&nbsp;0x00000001
WINHTTP_AUTO_DETECT_TYPE_DNS_A&nbsp;=&nbsp;0x00000002
#&nbsp;Parameters&nbsp;for&nbsp;WinHttpOpen
WINHTTP_USER_AGENT&nbsp;=&nbsp;&quot;Mozilla/5.0&nbsp;(Windows&nbsp;NT&nbsp;6.3;&nbsp;Trident/7.0;&nbsp;rv:11.0)&nbsp;like&nbsp;Gecko&quot;
WINHTTP_ACCESS_TYPE_DEFAULT_PROXY&nbsp;=&nbsp;0
WINHTTP_NO_PROXY_NAME&nbsp;=&nbsp;0
WINHTTP_NO_PROXY_BYPASS&nbsp;=&nbsp;0
WINHTTP_FLAG_ASYNC&nbsp;=&nbsp;0x10000000
test_url&nbsp;=&nbsp;&quot;http://www.google.com&quot;
#&nbsp;Gets&nbsp;the&nbsp;current&nbsp;user&nbsp;IE&nbsp;proxy&nbsp;configuration
ieConfig&nbsp;=&nbsp;WINHTTP_CURRENT_USER_IE_PROXY_CONFIG()
result&nbsp;=&nbsp;ctypes.windll.winhttp.WinHttpGetIEProxyConfigForCurrentUser(ctypes.byref(ieConfig))
if&nbsp;not&nbsp;result:
&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&quot;[-]&nbsp;Error&nbsp;on&nbsp;WinHttpGetIEProxyConfigForCurrentUser:&nbsp;%s&quot;&nbsp;%&nbsp;ctypes.GetLastError()
&nbsp;&nbsp;&nbsp;&nbsp;sys.exit()
print&nbsp;&quot;[+]&nbsp;Got&nbsp;IE&nbsp;configuration&quot;
print&nbsp;&quot;\tAutoDetect:&nbsp;%s&quot;&nbsp;%&nbsp;ieConfig.fAutoDetect
print&nbsp;&quot;\tAuto&nbsp;URL:&nbsp;%s&quot;&nbsp;%&nbsp;ieConfig.lpszAutoConfigUrl
print&nbsp;&quot;\tProxy:&nbsp;%s&quot;&nbsp;%&nbsp;ieConfig.lpszProxy
print&nbsp;&quot;\tProxy&nbsp;Bypass:&nbsp;%s&quot;&nbsp;%&nbsp;ieConfig.lpszProxyBypass
#&nbsp;We&nbsp;have&nbsp;three&nbsp;alternatives:
#&nbsp;&nbsp;1.&nbsp;The&nbsp;configuration&nbsp;is&nbsp;to&nbsp;&quot;auto&nbsp;detect&quot;&nbsp;the&nbsp;proxy,&nbsp;that&nbsp;is,&nbsp;via&nbsp;DHCP&nbsp;or&nbsp;DNS
#&nbsp;&nbsp;2.&nbsp;There&nbsp;is&nbsp;a&nbsp;URL&nbsp;for&nbsp;the&nbsp;script&nbsp;with&nbsp;the&nbsp;configuratoin&nbsp;(proxy&nbsp;autoconfiguration,&nbsp;PAC)
#&nbsp;&nbsp;3.&nbsp;A&nbsp;manually&nbsp;configured&nbsp;proxy&nbsp;is&nbsp;being&nbsp;used
if&nbsp;ieConfig.lpszAutoConfigUrl&nbsp;or&nbsp;ieConfig.fAutoDetect:
&nbsp;&nbsp;&nbsp;&nbsp;autoProxyOpts&nbsp;=&nbsp;WINHTTP_AUTOPROXY_OPTIONS()
&nbsp;&nbsp;&nbsp;&nbsp;proxyInfo&nbsp;=&nbsp;WINHTTP_PROXY_INFO()
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;ieConfig.lpszAutoConfigUrl:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&quot;[+]&nbsp;IE&nbsp;config&nbsp;set&nbsp;to&nbsp;autodetect&nbsp;with&nbsp;URL&nbsp;%s&quot;&nbsp;%&nbsp;ieConfig.lpszAutoConfigUrl
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;autoProxyOpts.dwFlags&nbsp;=&nbsp;WINHTTP_AUTOPROXY_CONFIG_URL
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;autoProxyOpts.dwAutoDetectFlags&nbsp;=&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;autoProxyOpts.lpszAutoConfigUrl&nbsp;=&nbsp;ieConfig.lpszAutoConfigUrl
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;ieConfig.fAutoDetect:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&quot;[+]&nbsp;IE&nbsp;config&nbsp;set&nbsp;to&nbsp;autodetect&nbsp;via&nbsp;DHCP&nbsp;or&nbsp;DNS&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;autoProxyOpts.dwFlags&nbsp;=&nbsp;WINHTTP_AUTOPROXY_AUTO_DETECT
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;autoProxyOpts.dwAutoDetectFlags&nbsp;=&nbsp;WINHTTP_AUTO_DETECT_TYPE_DHCP&nbsp;|&nbsp;WINHTTP_AUTO_DETECT_TYPE_DNS_A
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;autoProxyOpts.lpszAutoConfigUrl&nbsp;=&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;autoProxyOpts.fAutoLogonIfChallenged&nbsp;=&nbsp;True
&nbsp;&nbsp;&nbsp;&nbsp;hInternet&nbsp;=&nbsp;ctypes.windll.winhttp.WinHttpOpen(WINHTTP_USER_AGENT,&nbsp;&nbsp;WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,&nbsp;WINHTTP_NO_PROXY_NAME,&nbsp;WINHTTP_NO_PROXY_BYPASS,&nbsp;WINHTTP_FLAG_ASYNC)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;hInternet:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&quot;[-]&nbsp;Error&nbsp;on&nbsp;WinHttpOpen:&nbsp;%s&quot;&nbsp;%&nbsp;ctypes.GetLastError()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit()
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;ctypes.windll.winhttp.WinHttpGetProxyForUrl(hInternet,&nbsp;unicode(test_url),&nbsp;ctypes.byref(autoProxyOpts),&nbsp;ctypes.byref(proxyInfo))
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;result:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&quot;[-]&nbsp;Error&nbsp;on&nbsp;WinHttpGetProxyForUrl:&nbsp;%s&quot;&nbsp;%&nbsp;ctypes.GetLastError()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit()
&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&quot;[+]&nbsp;Proxy&nbsp;Host:&nbsp;%s&quot;&nbsp;%&nbsp;proxyInfo.lpszProxy
elif&nbsp;ieConfig.lpszProxy:
&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&quot;[+]&nbsp;IE&nbsp;config&nbsp;set&nbsp;to&nbsp;proxy&nbsp;%s&nbsp;with&nbsp;bypass&nbsp;%s&quot;&nbsp;%&nbsp;(ieConfig.lpszProxy,&nbsp;ieConfig.lpszProxyBypass)</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">修改后的代码考虑到了通过DHCP/DNS获取代理的可能性。现在我们可以运行这段代码，观察代码的执行结果。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">修改后的Python代码在受害者主机上的执行结果如下图所示：</span></p><p style="text-align:center"><img src="http://p1.qhimg.com/t01fe3ae6ddee64fcbc.png" title="t01d7d836d036006641.png" alt="http://p8.qhimg.com/t01d7d836d036006641.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">从上图可知，程序成功通过DHCP获取了代理信息，代理信息与本文开头给出的信息一致（即10.x.x.20）。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">Python版的代码工作正常，我们可以更新Meterpreter的C版代码（server_transport_winhttp.c），测试我们的后门程序能否正常运行。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">修改后的Meterpreter源代码如下所示：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">...
dprintf(&quot;[PROXY]&nbsp;Got&nbsp;IE&nbsp;configuration&quot;);
dprintf(&quot;[PROXY]&nbsp;AutoDetect:&nbsp;%s&quot;,&nbsp;ieConfig.fAutoDetect&nbsp;?&nbsp;&quot;yes&quot;&nbsp;:&nbsp;&quot;no&quot;);
dprintf(&quot;[PROXY]&nbsp;Auto&nbsp;URL:&nbsp;%S&quot;,&nbsp;ieConfig.lpszAutoConfigUrl);
dprintf(&quot;[PROXY]&nbsp;Proxy:&nbsp;%S&quot;,&nbsp;ieConfig.lpszProxy);
dprintf(&quot;[PROXY]&nbsp;Proxy&nbsp;Bypass:&nbsp;%S&quot;,&nbsp;ieConfig.lpszProxyBypass);
if&nbsp;(ieConfig.lpszAutoConfigUrl&nbsp;||&nbsp;ieConfig.fAutoDetect)
{
WINHTTP_AUTOPROXY_OPTIONS&nbsp;autoProxyOpts&nbsp;=&nbsp;{&nbsp;0&nbsp;};
WINHTTP_PROXY_INFO&nbsp;proxyInfo&nbsp;=&nbsp;{&nbsp;0&nbsp;};&nbsp;
if&nbsp;(ieConfig.fAutoDetect)
{
dprintf(&quot;[PROXY]&nbsp;IE&nbsp;config&nbsp;set&nbsp;to&nbsp;autodetect&nbsp;via&nbsp;DHCP&nbsp;or&nbsp;DNS&quot;);
autoProxyOpts.dwFlags&nbsp;=&nbsp;WINHTTP_AUTOPROXY_AUTO_DETECT;
autoProxyOpts.dwAutoDetectFlags&nbsp;=&nbsp;WINHTTP_AUTO_DETECT_TYPE_DHCP&nbsp;|&nbsp;WINHTTP_AUTO_DETECT_TYPE_DNS_A;
autoProxyOpts.lpszAutoConfigUrl&nbsp;=&nbsp;0;
}
else&nbsp;if&nbsp;(ieConfig.lpszAutoConfigUrl)
{
dprintf(&quot;[PROXY]&nbsp;IE&nbsp;config&nbsp;set&nbsp;to&nbsp;autodetect&nbsp;with&nbsp;URL&nbsp;%S&quot;,&nbsp;ieConfig.lpszAutoConfigUrl);
autoProxyOpts.dwFlags&nbsp;=&nbsp;WINHTTP_AUTOPROXY_CONFIG_URL;
autoProxyOpts.dwAutoDetectFlags&nbsp;=&nbsp;0;
autoProxyOpts.lpszAutoConfigUrl&nbsp;=&nbsp;ieConfig.lpszAutoConfigUrl;
}
autoProxyOpts.fAutoLogonIfChallenged&nbsp;=&nbsp;TRUE;
&nbsp;&nbsp;&nbsp;if&nbsp;(WinHttpGetProxyForUrl(ctx-&gt;internet,&nbsp;ctx-&gt;url,&nbsp;&amp;autoProxyOpts,&nbsp;&amp;proxyInfo))
...</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">代码修改完毕后，我们重新编译工程文件，将生成的metsrv Meterpreter DLL文件拷贝到监听端主机上，再次运行监听端，等待客户端连接。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">监听端在攻击者主机上的运行情况如下图所示：</span></p><p style="text-align:center"><img src="http://p8.qhimg.com/t0179751baae409fe6b.png" title="t012913ac388d7001c8.png" alt="http://p5.qhimg.com/t012913ac388d7001c8.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">从上图可知，当受害者主机使用“自动探测”代理选项时（本例中使用的是DHCP的252选项），我们能够成功建立Meterpreter会话。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">三、分析问题的根本原因</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">文章阅读至此，现在是时候讨论以下这些问题了：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1、为什么最开始时，传输器载荷能够到达攻击者主机？</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2、传输器载荷与传输体载荷在通信上有什么区别？</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">为了找到这些问题的答案，我们首先需要理解Meterpreter（在本文撰写时）的工作机制。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">Windows API提供了两种方式（或接口）与HTTP(s)进行交互：WinInet以及WinHTTP。对于Meterpreter而言，我们需要关注它在处理HTTPs通信时的两个功能：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1、Meterpreter可以验证HTTPs服务器（即运行在攻击者主机上的Metasploit监听端）所提供的证书签名，避免代理设备（如L7网络防火墙）检查其通信内容。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2、Meterpreter可以透明地使用当前用户的代理设置，通过互联网访问监听端。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这两个功能无法同时在同一个Windows API中找到，具体如下：</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192); font-size: 18px;"><strong><span style="color: rgb(0, 112, 192); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">WinInet：</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1、可以透明感知代理。也就是说，如果当前用户系统的代理设置适用于Internet Explorer浏览器，那么这个设置对使用WinInet的程序来说同样适用。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2、不支持SSL/TLS证书的自定义验证。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192); font-size: 18px;"><strong><span style="color: rgb(0, 112, 192); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">WinHTTP：</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1、允许自定义验证服务器所提供的SSL证书。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2、不能透明地使用当前用户的系统代理设置。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">现在，对于Meterpreter而言，我们可以使用两种不同的传输器载荷：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1、Meterpreter的reverse_https载荷。该载荷使用的是WinInet这个Windows API，这意味着它不能验证服务器证书，但可以透明地使用系统代理。也就是说，如果用户可以通过IE浏览器访问互联网，那么这个传输器载荷也可以。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2、Meterpreter的reverse_winhttps载荷。该载荷使用的是WinHTTP这个Windows API，这意味着它可以验证服务器证书，但必须手动设置代理信息才能访问互联网。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">对Meterpreter传输体载荷来说，默认情况下它使用的是WinHTTP Windows API，如果出现问题则会切换为使用WinInet API（读者可以阅读官方文档，查看旧版本中如何判断代理是否存在问题）。这种切换是自动发生的，除非用户决定使用“paranoid”（偏执）模式，这种模式优先级较高。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">请注意：对于Meterpreter而言，使用“paranoid”模式意味着SSL/TLS证书签名必须被验证，如果证书签名被替换（比如，Palo Alto网络防火墙会替换证书以检查通信内容），那么传输体载荷就不会被下载，当然会话也无法成功建立。如果用户确实需要使用“paranoid”模式，那么传输器载荷就必须使用WinHTTP这个Windows API。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">现在对于这个问题，我们已经掌握了必要的背景知识。之前我使用的是“reverse_https” Meterpreter载荷（出于测试目的，没有使用“paranoid”模式），这意味着传输器载荷使用的是WinInet API来访问监听端，也就是说它透明地使用了当前用户的代理设置，可以正常工作。然而，Meterpreter传输体载荷默认使用的是WinHTTP API，根据我们前面的分析结论，这个载荷在处理代理时有个bug，因此无法回连到攻击者主机上的监听端。我想这足以回答我们前面提出来的两个问题。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">四、代理识别方法</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">我们并没有回答另外一个问题，那就是：在使用WinHTTP Windows API时，获取当前用户代理设置的最佳方法是什么？</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">为了回答这个问题，我们需要探索系统在处理代理时的优先级。当系统中配置了多个代理的情况下，如果某个代理无法正常工作，Windows如何处理这种情况（即Windows是否会尝试另一个代理选项）。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">根据我的研究结论，代理设置的优先级与Internet选项中设置的代理顺序一致。也就是说，系统首先会检查“自动检测设置”选项是否已设置，然后再检查“使用自动配置脚本”选项是否已设置，最后再检查“为LAN使用代理服务器”选项是否设置。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">此外，我们可以在微软MSDN的“开发者代码示例”中，找到使用WinHTTP API的示例代码，其中关于代理的优先级，有这样一段说明：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">//&nbsp;WinHTTP&nbsp;API会按照以下顺序检测代理：&nbsp;
&nbsp;//&nbsp;1)&nbsp;自动检测
//&nbsp;2)&nbsp;自动配置的URL
//&nbsp;3)&nbsp;静态配置的代理</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">这个说明跟我们前面提到的代理优先级一样。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">五、容错机制</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">前面我们提到的问题是，假设当前主机配置了多个代理选项，如果某个优先选项失效了，结果会如何？Windows是否会按照优先级继续尝试下一选项，直到找到一个可用的代理？</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">为了回答这个问题，我们可以做个简单的实验，或者花无数个小时，逆向分析与代理有关的Windows组件（主要是wininet.dll）。我们可以先尝试做个实验，至少这个过程花费的时间没那么多。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192); font-size: 18px;"><strong><span style="color: rgb(0, 112, 192); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">5.1 实验环境</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">为了进一步分析Windows的代理设置及功能，我创建了如下的实验环境：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">使用1台域控的Windows域环境：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1、域：lab.bransh.com</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2、域控IP：192.168.0.1</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">3、DHCP地址范围：192.168.0.100–150</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">3个微软Forefront TMG（Thread Management Gateway）服务器：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1、tmg1.lab.bransh.com：192.168.0.10</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2、tmg2.lab.bransh.com：192.168.0.11</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">3、tmg3.lab.bransh.com：192.168.0.12</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">每个TMG服务器都有两个网络接口：“内部（internal）”接口（地址范围为192.168.0.x）连接到域中，客户端可以通过这个接口访问互联网。“外部（external）”接口连接到另一个网络，代理使用这个接口直接访问互联网。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1台Windows主机（Windows 8.1 x64）：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1、通过DHCP获取IP地址</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2、代理设置情况：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">（1）通过DHCP获取的代理（252选项）：tmg1.lab.bransh.com</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">（2）通过脚本配置的代理：http://tmg2.lab.bransh.com/wpad.dat</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">（3）手动设置的代理：tmg3.lab.bransh.com:8080</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">3、Windows主机无法直接访问互联网</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">4、Firefox浏览器设置为使用系统代理</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">Windows主机的代理设置情况如下图所示：</span></p><p style="text-align:center"><img src="http://p9.qhimg.com/t015bb79a511ff83c63.png" title="t01ba43b796e4a36a2f.png" alt="http://p2.qhimg.com/t01ba43b796e4a36a2f.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">通过DHCP（252选项）获取的代理信息如下图所示：</span></p><p style="text-align:center"><img src="http://p8.qhimg.com/t01be6422c83e8d6d38.png" title="t0188ba0452adca55ab.png" alt="http://p2.qhimg.com/t0188ba0452adca55ab.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">请注意：“自动检测设置”选项可以通过DHCP或DNS获取代理信息。我们在使用Windows API时，可以指定使用哪种（或者同时使用两种）方式获取代理信息。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">我们可以编写一段简单的代码，使用Windows提供的API，测试几种代理场景。我先写了一段Python代码，因为这样我可以更加简单地修改和运行代码，而不需要像C/C++代码那样每次修改后都需要重新编译。读者可以根据自己的喜好选择喜欢的语言完成这一任务。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">Python代码如下：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">import&nbsp;ctypes
import&nbsp;ctypes.wintypes
import&nbsp;sys
class&nbsp;WINHTTP_CURRENT_USER_IE_PROXY_CONFIG(ctypes.Structure):
&nbsp;&nbsp;&nbsp;&nbsp;_fields_&nbsp;=&nbsp;[(&quot;fAutoDetect&quot;,&nbsp;ctypes.wintypes.BOOL),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;lpszAutoConfigUrl&quot;,&nbsp;ctypes.wintypes.LPWSTR),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;lpszProxy&quot;,&nbsp;ctypes.wintypes.LPWSTR),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;lpszProxyBypass&quot;,&nbsp;ctypes.wintypes.LPWSTR)]
class&nbsp;WINHTTP_AUTOPROXY_OPTIONS(ctypes.Structure):
&nbsp;&nbsp;&nbsp;&nbsp;_fields_&nbsp;=&nbsp;[(&quot;dwFlags&quot;,&nbsp;ctypes.wintypes.DWORD),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;dwAutoDetectFlags&quot;,&nbsp;ctypes.wintypes.DWORD),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;lpszAutoConfigUrl&quot;,&nbsp;ctypes.wintypes.LPCWSTR),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;lpvReserved&quot;,&nbsp;ctypes.c_void_p),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;dwReserved&quot;,&nbsp;ctypes.wintypes.DWORD),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;fAutoLogonIfChallenged&quot;,&nbsp;ctypes.wintypes.BOOL)]
class&nbsp;WINHTTP_PROXY_INFO(ctypes.Structure):
&nbsp;&nbsp;&nbsp;&nbsp;_fields_&nbsp;=&nbsp;[(&quot;dwAccessType&quot;,&nbsp;ctypes.wintypes.DWORD),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;lpszProxy&quot;,&nbsp;ctypes.wintypes.LPCWSTR),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;lpszProxyBypass&quot;,&nbsp;ctypes.wintypes.LPCWSTR)]
WINHTTP_USER_AGENT&nbsp;=&nbsp;ctypes.c_wchar_p(&#39;Mozilla/5.0&nbsp;(Windows&nbsp;NT&nbsp;6.3;&nbsp;Trident/7.0;&nbsp;rv:11.0)&nbsp;like&nbsp;Gecko&#39;)
WINHTTP_ACCESS_TYPE_DEFAULT_PROXY&nbsp;=&nbsp;0
WINHTTP_ACCESS_TYPE_NO_PROXY&nbsp;=&nbsp;1
WINHTTP_ACCESS_TYPE_NAMED_PROXY&nbsp;=&nbsp;3
WINHTTP_NO_PROXY_NAME&nbsp;=&nbsp;0
WINHTTP_NO_PROXY_BYPASS&nbsp;=&nbsp;0
def&nbsp;ShowLastError(message,&nbsp;alignment&nbsp;=&nbsp;0):
&nbsp;&nbsp;&nbsp;&nbsp;error_id&nbsp;=&nbsp;ctypes.GetLastError()
&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;&nbsp;&#39;&nbsp;*&nbsp;alignment&nbsp;+&nbsp;&#39;[-]&nbsp;Error&nbsp;on&nbsp;%s:&nbsp;%s&#39;&nbsp;%&nbsp;(message,&nbsp;error_id)
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;error_id&nbsp;==&nbsp;12167:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;=&nbsp;&#39;ERROR_WINHTTP_UNABLE_TO_DOWNLOAD_SCRIPT&#39;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message&nbsp;=&nbsp;&#39;The&nbsp;PAC&nbsp;file&nbsp;cannot&nbsp;be&nbsp;downloaded.&nbsp;For&nbsp;example,&nbsp;the&nbsp;server&nbsp;referenced&nbsp;by&nbsp;the&nbsp;PAC&nbsp;URL&nbsp;may&nbsp;not&nbsp;have&nbsp;been&nbsp;reachable,&nbsp;or&nbsp;the&nbsp;server&nbsp;returned&nbsp;a&nbsp;404&nbsp;NOT&nbsp;FOUND&nbsp;response.&#39;
&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;error_id&nbsp;==&nbsp;12007:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;=&nbsp;&#39;ERROR_WINHTTP_NAME_NOT_RESOLVED&#39;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message&nbsp;=&nbsp;&#39;The&nbsp;server&nbsp;name&nbsp;cannot&nbsp;be&nbsp;resolved.&#39;
&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;error_id&nbsp;==&nbsp;12029:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;=&nbsp;&#39;ERROR_WINHTTP_CANNOT_CONNECT&#39;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message&nbsp;=&nbsp;&#39;Returned&nbsp;if&nbsp;connection&nbsp;to&nbsp;the&nbsp;server&nbsp;failed.&#39;
&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;error_id&nbsp;==&nbsp;12002:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;=&nbsp;&#39;ERROR_WINHTTP_TIMEOUT&#39;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message&nbsp;=&nbsp;&#39;The&nbsp;request&nbsp;has&nbsp;timed&nbsp;out.&#39;
&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;error_id&nbsp;==&nbsp;12180:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;=&nbsp;&#39;ERROR_WINHTTP_AUTODETECTION_FAILED&#39;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message&nbsp;=&nbsp;&#39;Returned&nbsp;by&nbsp;WinHttpDetectAutoProxyConfigUrl&nbsp;if&nbsp;WinHTTP&nbsp;was&nbsp;unable&nbsp;to&nbsp;discover&nbsp;the&nbsp;URL&nbsp;of&nbsp;the&nbsp;Proxy&nbsp;Auto-Configuration&nbsp;(PAC)&nbsp;file.&#39;
&nbsp;&nbsp;&nbsp;&nbsp;else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;=&nbsp;&#39;UNKNOWN&#39;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message&nbsp;=&nbsp;&#39;unknown&#39;
&nbsp;&nbsp;&nbsp;&nbsp;msg_max_len&nbsp;=&nbsp;70
&nbsp;&nbsp;&nbsp;&nbsp;msg_list&nbsp;=&nbsp;[message[i:i+msg_max_len]&nbsp;for&nbsp;i&nbsp;in&nbsp;range(0,&nbsp;len(message),&nbsp;msg_max_len)]
&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;&nbsp;&#39;&nbsp;*&nbsp;alignment&nbsp;+&nbsp;&#39;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;%s&#39;&nbsp;%&nbsp;title
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;msg&nbsp;in&nbsp;msg_list:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;&nbsp;&#39;&nbsp;*&nbsp;alignment&nbsp;+&nbsp;&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%s&#39;&nbsp;%&nbsp;msg
def&nbsp;GetCurrentProxies():
&nbsp;&nbsp;&nbsp;&nbsp;pProxyConfig&nbsp;=&nbsp;WINHTTP_CURRENT_USER_IE_PROXY_CONFIG()
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;ctypes.windll.winhttp.WinHttpGetIEProxyConfigForCurrentUser(ctypes.byref(pProxyConfig))
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;result&nbsp;==&nbsp;False:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShowLastError(&#39;WinHttpGetIEProxyConfigForCurrentUser&#39;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False,&nbsp;None
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;True,&nbsp;pProxyConfig
def&nbsp;GetProxyInfoList(pProxyConfig,&nbsp;target_url):
&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;\n[*]&nbsp;Checking&nbsp;proxy&nbsp;configuration&nbsp;alternatives...&#39;
&nbsp;&nbsp;&nbsp;&nbsp;proxy_list&nbsp;=&nbsp;[]
&nbsp;&nbsp;&nbsp;&nbsp;hSession&nbsp;=&nbsp;ctypes.windll.winhttp.WinHttpOpen(WINHTTP_USER_AGENT,&nbsp;&nbsp;WINHTTP_ACCESS_TYPE_NO_PROXY,&nbsp;WINHTTP_NO_PROXY_NAME,&nbsp;WINHTTP_NO_PROXY_BYPASS,&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;hSession&nbsp;is&nbsp;None:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShowLastError(&#39;WinHttpOpen&#39;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit()
&nbsp;&nbsp;&nbsp;&nbsp;WINHTTP_AUTOPROXY_AUTO_DETECT&nbsp;=&nbsp;0x00000001
&nbsp;&nbsp;&nbsp;&nbsp;WINHTTP_AUTO_DETECT_TYPE_DHCP&nbsp;=&nbsp;0x00000001
&nbsp;&nbsp;&nbsp;&nbsp;WINHTTP_AUTO_DETECT_TYPE_DNS_A&nbsp;=&nbsp;0x00000002
&nbsp;&nbsp;&nbsp;&nbsp;WINHTTP_AUTOPROXY_CONFIG_URL&nbsp;=&nbsp;0x00000002
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;pProxyConfig.fAutoDetect:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;\n&nbsp;&nbsp;(1)&nbsp;Automatically&nbsp;detect&nbsp;settings&nbsp;(enabled)&#39;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[*]&nbsp;Trying&nbsp;to&nbsp;get&nbsp;the&nbsp;proxy&nbsp;using&nbsp;the&nbsp;conventional&nbsp;method...&#39;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pAutoProxyOptions&nbsp;=&nbsp;WINHTTP_AUTOPROXY_OPTIONS()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pProxyInfo&nbsp;=&nbsp;WINHTTP_PROXY_INFO()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pAutoProxyOptions.dwFlags&nbsp;=&nbsp;WINHTTP_AUTOPROXY_AUTO_DETECT
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pAutoProxyOptions.dwAutoDetectFlags&nbsp;=&nbsp;WINHTTP_AUTO_DETECT_TYPE_DHCP&nbsp;|&nbsp;WINHTTP_AUTO_DETECT_TYPE_DNS_A
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pAutoProxyOptions.lpszAutoConfigUrl&nbsp;=&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lpcwszUrl&nbsp;=&nbsp;ctypes.wintypes.LPCWSTR(target_url)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;ctypes.windll.winhttp.WinHttpGetProxyForUrl(hSession,&nbsp;lpcwszUrl,&nbsp;ctypes.byref(pAutoProxyOptions),&nbsp;ctypes.byref(pProxyInfo))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;result&nbsp;==&nbsp;False:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShowLastError(&#39;WinHttpGetProxyForUrl&#39;,&nbsp;6)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[*]&nbsp;Trying&nbsp;to&nbsp;get&nbsp;the&nbsp;proxy&nbsp;using&nbsp;the&nbsp;AutoConfigURL...&#39;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dwAutoDetectFlags&nbsp;=&nbsp;WINHTTP_AUTO_DETECT_TYPE_DHCP&nbsp;|&nbsp;WINHTTP_AUTO_DETECT_TYPE_DNS_A
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ppwszAutoConfigUrl&nbsp;=&nbsp;ctypes.wintypes.LPWSTR()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;ctypes.windll.winhttp.WinHttpDetectAutoProxyConfigUrl(dwAutoDetectFlags,&nbsp;ctypes.byref(ppwszAutoConfigUrl))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;result&nbsp;==&nbsp;False:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShowLastError(&#39;WinHttpDetectAutoProxyConfigUrl&#39;,&nbsp;10)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[+]&nbsp;Trying&nbsp;to&nbsp;get&nbsp;the&nbsp;proxy&nbsp;from&nbsp;the&nbsp;obtained&nbsp;URL&nbsp;(%s)&#39;&nbsp;%&nbsp;ppwszAutoConfigUrl.value
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pAutoProxyOptions.dwFlags&nbsp;=&nbsp;WINHTTP_AUTOPROXY_CONFIG_URL
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pAutoProxyOptions.dwAutoDetectFlags&nbsp;=&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pAutoProxyOptions.fAutoLogonIfChallenged&nbsp;=&nbsp;True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pAutoProxyOptions.lpszAutoConfigUrl&nbsp;=&nbsp;ppwszAutoConfigUrl
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;ctypes.windll.winhttp.WinHttpGetProxyForUrl(hSession,&nbsp;lpcwszUrl,&nbsp;ctypes.byref(pAutoProxyOptions),&nbsp;ctypes.byref(pProxyInfo))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;result:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[+]&nbsp;Proxy:&nbsp;%s&#39;&nbsp;%&nbsp;(pProxyInfo.lpszProxy)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_list.append(pProxyInfo)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShowLastError(&#39;WinHttpGetProxyForUrl&#39;,&nbsp;10)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[+]&nbsp;Proxy:&nbsp;%s&#39;&nbsp;%&nbsp;(pProxyInfo.lpszProxy)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_list.append(pProxyInfo)
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;pProxyConfig.lpszAutoConfigUrl:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;\n&nbsp;&nbsp;(2)&nbsp;Use&nbsp;automatic&nbsp;configuration&nbsp;script&nbsp;(%s)&#39;&nbsp;%&nbsp;pProxyConfig.lpszAutoConfigUrl
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pAutoProxyOptions&nbsp;=&nbsp;WINHTTP_AUTOPROXY_OPTIONS()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pProxyInfo&nbsp;=&nbsp;WINHTTP_PROXY_INFO()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pAutoProxyOptions.dwFlags&nbsp;=&nbsp;WINHTTP_AUTOPROXY_CONFIG_URL
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pAutoProxyOptions.dwAutoDetectFlags&nbsp;=&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pAutoProxyOptions.fAutoLogonIfChallenged&nbsp;=&nbsp;True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pAutoProxyOptions.lpszAutoConfigUrl&nbsp;=&nbsp;pProxyConfig.lpszAutoConfigUrl
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lpcwszUrl&nbsp;=&nbsp;ctypes.wintypes.LPCWSTR(target_url)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;ctypes.windll.winhttp.WinHttpGetProxyForUrl(hSession,&nbsp;lpcwszUrl,&nbsp;ctypes.byref(pAutoProxyOptions),&nbsp;ctypes.byref(pProxyInfo))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;result&nbsp;==&nbsp;False:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShowLastError(&#39;WinHttpGetProxyForUrl&#39;,&nbsp;6)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[+]&nbsp;Proxy:&nbsp;%s&#39;&nbsp;%&nbsp;(pProxyInfo.lpszProxy)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_list.append(pProxyInfo)
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;pProxyConfig.lpszProxy:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;\n&nbsp;&nbsp;(3)&nbsp;Use&nbsp;a&nbsp;proxy&nbsp;server&nbsp;for&nbsp;your&nbsp;LAN&#39;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pProxyInfo&nbsp;=&nbsp;WINHTTP_PROXY_INFO()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WINHTTP_ACCESS_TYPE_NAMED_PROXY&nbsp;=&nbsp;3
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pProxyInfo.dwAccessType&nbsp;=&nbsp;WINHTTP_ACCESS_TYPE_NAMED_PROXY
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pProxyInfo.lpszProxy&nbsp;=&nbsp;pProxyConfig.lpszProxy
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pProxyInfo.lpszProxyBypass&nbsp;=&nbsp;pProxyConfig.lpszProxyBypass
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[+]&nbsp;Proxy:&nbsp;%s&#39;&nbsp;%&nbsp;pProxyConfig.lpszProxy
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[+]&nbsp;Proxy&nbsp;Bypass:&nbsp;%s&#39;&nbsp;%&nbsp;pProxyConfig.lpszProxyBypass
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_list.append(pProxyInfo)
&nbsp;&nbsp;&nbsp;&nbsp;ctypes.windll.winhttp.WinHttpCloseHandle(hSession)
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;proxy_list
def&nbsp;CheckProxyStatus(proxyInfo,&nbsp;target_server,&nbsp;target_port):
&nbsp;&nbsp;&nbsp;&nbsp;hSession&nbsp;=&nbsp;ctypes.windll.winhttp.WinHttpOpen(WINHTTP_USER_AGENT,&nbsp;&nbsp;WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,&nbsp;WINHTTP_NO_PROXY_NAME,&nbsp;WINHTTP_NO_PROXY_BYPASS,&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;hSession&nbsp;is&nbsp;None:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShowLastError(&#39;WinHttpOpen&#39;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
&nbsp;&nbsp;&nbsp;&nbsp;server_name&nbsp;=&nbsp;ctypes.c_wchar_p(target_server)
&nbsp;&nbsp;&nbsp;&nbsp;INTERNET_DEFAULT_HTTP_PORT&nbsp;=&nbsp;target_port
&nbsp;&nbsp;&nbsp;&nbsp;hInternet&nbsp;=&nbsp;ctypes.windll.winhttp.WinHttpConnect(hSession,&nbsp;server_name,&nbsp;INTERNET_DEFAULT_HTTP_PORT,&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;hInternet&nbsp;is&nbsp;None:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShowLastError(&#39;WinHttpConnect&#39;,&nbsp;8)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False
&nbsp;&nbsp;&nbsp;&nbsp;WINHTTP_FLAG_BYPASS_PROXY_CACHE&nbsp;=&nbsp;0x00000100
&nbsp;&nbsp;&nbsp;&nbsp;WINHTTP_FLAG_SECURE&nbsp;=&nbsp;0x00800000
&nbsp;&nbsp;&nbsp;&nbsp;dwFlags&nbsp;=&nbsp;WINHTTP_FLAG_BYPASS_PROXY_CACHE
&nbsp;&nbsp;&nbsp;&nbsp;pwszVerb&nbsp;=&nbsp;ctypes.c_wchar_p(&#39;GET&#39;)
&nbsp;&nbsp;&nbsp;&nbsp;pwszObjectName&nbsp;=&nbsp;ctypes.c_wchar_p(&#39;&#39;)
&nbsp;&nbsp;&nbsp;&nbsp;hRequest&nbsp;=&nbsp;ctypes.windll.winhttp.WinHttpOpenRequest(hInternet,&nbsp;pwszVerb,&nbsp;pwszObjectName,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;dwFlags)
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;hRequest&nbsp;is&nbsp;None:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShowLastError(&#39;WinHttpOpenRequest&#39;,&nbsp;8)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False
&nbsp;&nbsp;&nbsp;&nbsp;WINHTTP_OPTION_PROXY&nbsp;=&nbsp;38
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;ctypes.windll.winhttp.WinHttpSetOption(hRequest,&nbsp;WINHTTP_OPTION_PROXY,&nbsp;ctypes.byref(proxyInfo),&nbsp;ctypes.sizeof(proxyInfo))
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;result&nbsp;==&nbsp;False:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShowLastError(&#39;WinHttpSetOption&#39;,&nbsp;8)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False
&nbsp;&nbsp;&nbsp;&nbsp;WINHTTP_NO_ADDITIONAL_HEADERS&nbsp;=&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;WINHTTP_NO_REQUEST_DATA&nbsp;=&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;ctypes.windll.winhttp.WinHttpSendRequest(hRequest,&nbsp;WINHTTP_NO_ADDITIONAL_HEADERS,&nbsp;0,&nbsp;WINHTTP_NO_REQUEST_DATA,&nbsp;0,&nbsp;0,&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;result&nbsp;==&nbsp;False:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShowLastError(&#39;WinHttpSendRequest&#39;,&nbsp;8)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False
&nbsp;&nbsp;&nbsp;&nbsp;else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WINHTTP_QUERY_STATUS_CODE&nbsp;=&nbsp;19
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WINHTTP_QUERY_STATUS_TEXT&nbsp;=&nbsp;20
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WINHTTP_QUERY_RAW_HEADERS_CRLF&nbsp;=&nbsp;22
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WINHTTP_HEADER_NAME_BY_INDEX&nbsp;=&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WINHTTP_NO_HEADER_INDEX&nbsp;=&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dwInfoLevel&nbsp;=&nbsp;WINHTTP_QUERY_RAW_HEADERS_CRLF
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lpdwBufferLength&nbsp;=&nbsp;ctypes.wintypes.DWORD()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lpdwIndex&nbsp;=&nbsp;ctypes.wintypes.DWORD()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;ctypes.windll.winhttp.WinHttpReceiveResponse(hRequest,&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;result:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;ctypes.windll.winhttp.WinHttpQueryHeaders(hRequest,&nbsp;WINHTTP_QUERY_RAW_HEADERS_CRLF,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WINHTTP_HEADER_NAME_BY_INDEX,&nbsp;0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctypes.byref(lpdwBufferLength),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WINHTTP_NO_HEADER_INDEX)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERROR_INSUFFICIENT_BUFFER&nbsp;=&nbsp;122
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;ctypes.GetLastError()&nbsp;==&nbsp;ERROR_INSUFFICIENT_BUFFER:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lpBuffer&nbsp;=&nbsp;ctypes.create_string_buffer(lpdwBufferLength.value)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;ctypes.windll.winhttp.WinHttpQueryHeaders(hRequest,&nbsp;WINHTTP_QUERY_RAW_HEADERS_CRLF,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WINHTTP_HEADER_NAME_BY_INDEX,&nbsp;ctypes.byref(lpBuffer),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctypes.byref(lpdwBufferLength),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WINHTTP_NO_HEADER_INDEX)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;result:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;=&nbsp;lpBuffer.raw.replace(&#39;\x00&#39;,&nbsp;&#39;&#39;).split(&#39;\n&#39;)[0]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;space_1&nbsp;=&nbsp;line.find(&#39;&nbsp;&#39;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;space_2&nbsp;=&nbsp;line.find(&#39;&nbsp;&#39;,&nbsp;space_1+1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;code&nbsp;=&nbsp;line[space_1:space_2].strip()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text&nbsp;=&nbsp;line[space_2:].strip()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&quot;\t[*]&nbsp;HTTP&nbsp;Query&nbsp;Status&nbsp;Code&nbsp;/&nbsp;Text:&nbsp;\n\t&nbsp;&nbsp;&nbsp;&nbsp;%s&nbsp;/&nbsp;%s&quot;&nbsp;%&nbsp;(code,&nbsp;text)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;code&nbsp;!=&nbsp;&quot;200&quot;:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;True
&nbsp;&nbsp;&nbsp;&nbsp;ctypes.windll.winhttp.WinHttpCloseHandle(hRequest)
&nbsp;&nbsp;&nbsp;&nbsp;ctypes.windll.winhttp.WinHttpCloseHandle(hInternet)
&nbsp;&nbsp;&nbsp;&nbsp;ctypes.windll.winhttp.WinHttpCloseHandle(hSession)
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;True
def&nbsp;main():
&nbsp;&nbsp;&nbsp;&nbsp;result,&nbsp;pProxyConfig&nbsp;=&nbsp;GetCurrentProxies()
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;result&nbsp;==&nbsp;False:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit()
&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;\n[*]&nbsp;We&nbsp;got&nbsp;the&nbsp;proxy&nbsp;configuration.&#39;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;pProxyConfig&nbsp;is&nbsp;None:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;[*]&nbsp;No&nbsp;proxy&nbsp;setting&nbsp;found&nbsp;for&nbsp;the&nbsp;current&nbsp;user.&#39;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit()
&nbsp;&nbsp;&nbsp;&nbsp;target_server&nbsp;=&nbsp;&#39;www.google.com&#39;
&nbsp;&nbsp;&nbsp;&nbsp;target_url&nbsp;=&nbsp;&#39;http://&#39;&nbsp;+&nbsp;target_server
&nbsp;&nbsp;&nbsp;&nbsp;target_port&nbsp;=&nbsp;80
&nbsp;&nbsp;&nbsp;&nbsp;proxy_list&nbsp;=&nbsp;GetProxyInfoList(pProxyConfig,&nbsp;target_url)
&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;\n[*]&nbsp;Number&nbsp;of&nbsp;proxies:&nbsp;%s&#39;&nbsp;%&nbsp;str(len(proxy_list))
&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;\n[*]&nbsp;Testing&nbsp;if&nbsp;proxy&nbsp;servers&nbsp;actually&nbsp;work...&#39;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;proxy&nbsp;in&nbsp;proxy_list:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;\n&nbsp;&nbsp;&nbsp;&nbsp;[*]&nbsp;Proxy&nbsp;&quot;%s&quot;&nbsp;...&nbsp;&#39;&nbsp;%&nbsp;proxy.lpszProxy
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;CheckProxyStatus(proxy,&nbsp;target_server,&nbsp;target_port)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;result:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[+]&nbsp;Works!&nbsp;:)&#39;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-]&nbsp;Does&nbsp;not&nbsp;work&nbsp;:(&#39;
if&nbsp;__name__&nbsp;==&nbsp;&#39;__main__&#39;:
&nbsp;&nbsp;&nbsp;&nbsp;main()</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">以上代码有两个重要函数：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1、GetProxyInfoList(pProxyConfig, target_url)：这个函数会评估当前用户的代理设置，根据传入的URL地址，返回一个代理套接字（IP:PORT）列表。需要注意的是这个代理列表中包含具体的代理地址，我们有可能使用这些代理地址访问目标URL，但是这并不意味着代理服务器一定处于正常工作状态。比如，这个列表中可能包含从WPAD.DAT文件中读取的代理信息，这个WPAD.DAT文件为“使用自动配置脚本”选项中设置的脚本文件，但在访问目标URL时这个代理可能不起作用。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2、CheckProxyStatus(proxy, target_server, target_port)：这个函数会使用给定的代理，访问目标服务器和端口（直接访问根目录），以测试代理是否实际可用。我们可以使用这个函数判断某个代理是否可用。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192); font-size: 18px;"><strong><span style="color: rgb(0, 112, 192); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">5.2 测试场景 #1</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">在这个测试场景中，代理服务器tmg1以及tmg2的内部网络接口（192.168.0.x）在客户机启动前已被禁用。这意味着客户机只能通过代理服务器TMG3访问互联网。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">脚本程序的输出结果如下所示。此外，我们还可以从输出结果中看到IE和Firefox浏览器如何处理这种场景：</span></p><p style="text-align:center"><img src="http://p7.qhimg.com/t01bb011a2a7785baa5.png" title="t01def687e422a6b98a.png" alt="http://p4.qhimg.com/t01def687e422a6b98a.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">从测试程序的输出结果中我们可知以下信息：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1、“自动检测设置”选项已启用，获取的代理为“192.168.0.10:8080”（Windows会在后台下载WPAD.PAC文件，同时在代理服务器内部接口被禁用前缓存已获取的代理信息）。然而，这个代理并不能正常工作，因为TMG1的内部接口已被禁用，客户机不可能通过网络访问到这个接口（会出现访问超时情况）。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2、“使用自动配置脚本”选项已启用，获取的代理为“192.168.0.11:8080”（Windows会在后台下载WPAD.PAC文件，同时在代理服务器内部接口被禁用前缓存已获取的代理信息）。然而这个代理依然不能正常工作，因为TMG2的内部接口已被禁用，客户机不可能通过网络访问到这个接口（会出现访问超时情况）。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">3、手动配置的代理服务器为“tmg3.lab.bransh.com:8080”。这个代理可以正常使用，客户机可以通过它发送请求。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">同时我们还知道，在当前的代理环境下，不管是IE还是Firefox浏览器都不能访问互联网。然而，使用tmg3作为代理服务器的自定义应用程序可以成功访问互联网。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192); font-size: 18px;"><strong><span style="color: rgb(0, 112, 192); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">5.3 测试场景 #2</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这个场景与测试场景#1非常类似，代理服务器tmg1和tmg2的内部网络接口（192.168.0.x）在客户机启动前已被禁用。这意味着客户机只能通过代理服务器TMG3访问互联网。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">脚本程序的输出结果如下图所示。此外，我们还可以从输出结果中看到IE和Firefox浏览器如何处理这种场景：</span></p><p style="text-align:center"><img src="http://p9.qhimg.com/t01d81896f5d8ae8095.png" title="t018ed2a5c5ca79ce2e.png" alt="http://p1.qhimg.com/t018ed2a5c5ca79ce2e.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">从测试程序的输出结果中我们可知以下信息：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1、“自动检测设置”选项已启用（tmg1.lab.bransh.com/wpad.dat），但没有获取到任何一个代理信息。之所以出现这种情况，原因在于当客户机收到DHCP配置信息（252选项）时，代理服务器（tmg1）并不可达，因此客户机无法下载wpad.dat代理配置文件。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2、“使用自动配置脚本”选项已启用，配置文件所使用的URL地址为“tmg2.lab.bransh.com/wpad.dat”。然而客户机无法下载配置脚本，因为代理服务器此时并不可达。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">3、手动配置的代理服务器为“tmg3.lab.bransh.com:8080”。这个代理可以正常使用，客户机可以通过它发送请求。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">同时我们还知道，在当前的代理环境下，IE浏览器能够正确识别代理信息，访问互联网，然而Firefox浏览器却不能做到这一点。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192); font-size: 18px;"><strong><span style="color: rgb(0, 112, 192); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">5.4 测试场景 #3</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">在这个场景中，代理服务器TMG2的内部网络接口（192.168.0.11）在客户机启动前已被禁用。这意味着客户机可以通过代理服务器TMG1和TMG3代理服务器访问互联网。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">脚本程序的输出结果如下图所示。此外，我们还可以从输出结果中看到IE和Firefox浏览器如何处理这种场景：</span></p><p style="text-align:center"><img src="http://p3.qhimg.com/t0153aa47df99d7fa23.png" title="t0165ca43b6541a6bec.png" alt="http://p5.qhimg.com/t0165ca43b6541a6bec.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">从测试程序的输出结果中我们可知以下信息：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1、“自动检测设置”选项已启用，客户机可以使用已获取的代理信息（192.168.0.10:8080）访问互联网。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2、“使用自动配置脚本”选项已启用，配置文件所使用的URL地址为“tmg2.lab.bransh.com/wpad.dat”。然而由于这个代理服务器的网络接口已被禁用，客户机无法下载配置脚本。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">3、手动配置的代理服务器为“tmg3.lab.bransh.com:8080”。这个代理可以正常使用，客户机可以通过它发送请求。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">同时我们还知道，在当前的代理环境下，IE浏览器能够正确识别代理信息，访问互联网，然而Firefox浏览器却不能做到这一点。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192); font-size: 18px;"><strong><span style="color: rgb(0, 112, 192); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">5.5 测试场景 #4</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">在这个场景中，只有TMG2代理服务器的内部网络接口（192.168.0.11）处于启用状态：</span></p><p style="text-align:center"><img src="http://p5.qhimg.com/t012f1ff17c4ba2ed16.png" title="t0193d581f6f68f4d53.png" alt="http://p3.qhimg.com/t0193d581f6f68f4d53.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">从测试程序的输出结果中我们可知以下信息：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1、“自动检测设置”选项已启用，客户机无法通过这个代理（192.168.0.10:8080）访问互联网。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2、“使用自动配置脚本”选项已启用，配置文件所使用的URL地址为“tmg2.lab.bransh.com/wpad.dat”。此外，获取到的代理地址为“192.168.0.11:8080”，客户机可以通过这个代理访问互联网。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">3、手动配置的代理服务器为“tmg3.lab.bransh.com:8080”。这个代理可以正常使用，客户机可以通过它发送请求。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">同时我们还知道，在当前的代理环境下，IE浏览器不能识别代理信息，无法访问互联网。然而Firefox成功获取了代理配置信息，能够正常访问互联网。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192); font-size: 18px;"><strong><span style="color: rgb(0, 112, 192); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">5.6 测试场景 #5</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">在这个场景中，所有三个代理服务器的内部网络接口全部处于启用状态。然而，TMG1和TMG2服务器的外部接口处于禁用状态：</span></p><p style="text-align:center"><img src="http://p2.qhimg.com/t01c6d130c55afb3da5.png" title="t01a06751ae86f5ed3c.png" alt="http://p8.qhimg.com/t01a06751ae86f5ed3c.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">从测试程序的输出结果中我们可知以下信息：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1、“自动检测设置”选项已启用，对应的代理服务器（192.168.0.10:8080）也可达。然而代理服务器返回了一个错误应答（502错误），表明客户机无法通过此代理服务器访问互联网。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2、“使用自动配置脚本”选项已启用，对应的代理服务器（192.168.0.11:8080）也可达。然而代理服务器返回了一个错误应答（502错误），表明客户机无法通过此代理服务器访问互联网。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">3、手动配置的代理服务器为“tmg3.lab.bransh.com:8080”。这个代理可以正常使用，客户机可以通过它访问互联网。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">在当前的代理环境下，IE和Firefox浏览器都不能访问互联网，然而使用TMG3作为代理服务器的自定义应用程序可以成功访问互联网。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">六、总结</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">在某些场景下（比如本文第一部分描述的场景），我们会发现我们最喜爱的工具无法像预期那样正常工作。在这些情况下，我们主要有两种选择：尝试找到另一种解决方案，或者亲自上手修改工具，使其能正常工作。在本文所描述的企业网络场景中，我们修改了Meterpreter载荷源码，重新编译载荷Dll后，Meterpreter载荷能够在上文描述的代理环境中正常工作。我不确定我的这些修改是否会反馈到Meterpreter官方代码中，但如果你面临的是类似的场景，现在你应该知道该如何处理。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">另一方面，我们知道Windows会按一定优先级顺序使用代理（如前文提到的优先级顺序）。然而，我们似乎发现，如果Windows已经获取了某个代理信息（如场景 #1给出的结果），即使这个代理无法正常工作，Windows也不会继续尝试使用另一个可用的代理选项。此外，我们发现在启用“使用系统代理设置”选项的条件下，IE和Firefox浏览器在查找代理时的表现也不尽相同。最后我们也发现，如果某个代理可达，但这个代理出于某些原因（比如互联网连接失败），无法提供互联网访问服务，此时这两个浏览器都不会尝试使用其他可能生效的代理服务器访问互联网。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">考虑到这些测试结果，我们可以看到，我们的确可以使用某些API函数来评估所有的代理配置情况，甚至可以测试这些代理，以确认它们能否访问互联网资源。因此，我们只需要修改几行代码，就可以增加我们APT工具的鲁棒性，使其可以在这种网络环境下正常工作。然而，我必须承认，客户工作站存在多个代理的情况的确比较罕见，我不大相信管理员能够妥善处理这种混乱场面。另一方面，在连IE浏览器都不能正常工作的场景中，如果我们的APT工具还能正常工作的话，我不敢完全确定这是一个好主意。如果人们认为某个主机肯定不能访问互联网，但突然某一天，它开始通过可用的代理服务器访问互联网，这种情况对于蓝队来说可能比较奇怪。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">最后总结一下，我认为如果我们的APT工具能够像IE浏览器那样健壮，那么它已经足以应付大多数情况。如果IE浏览器能够访问互联网，那么我们的APT工具也可以。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">七、参考资料</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">[1] 自动代理：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><a href="https://blogs.msdn.microsoft.com/askie/2014/02/07/optimizing-performance-with-automatic-proxyconfiguration-scripts-pac/" _src="https://blogs.msdn.microsoft.com/askie/2014/02/07/optimizing-performance-with-automatic-proxyconfiguration-scripts-pac/">https://blogs.msdn.microsoft.com/askie/2014/02/07/optimizing-performance-with-automatic-proxyconfiguration-scripts-pac/</a>&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">[2] Windows Web代理配置：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><a href="https://blogs.msdn.microsoft.com/ieinternals/2013/10/11/understanding-web-proxy-configuration/" _src="https://blogs.msdn.microsoft.com/ieinternals/2013/10/11/understanding-web-proxy-configuration/">https://blogs.msdn.microsoft.com/ieinternals/2013/10/11/understanding-web-proxy-configuration/</a>&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">[3] 编译Meterpreter：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><a href="https://github.com/rapid7/metasploit-payloads/tree/master/c/meterpreter" _src="https://github.com/rapid7/metasploit-payloads/tree/master/c/meterpreter">https://github.com/rapid7/metasploit-payloads/tree/master/c/meterpreter</a>&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">[4] Meterpreter WinHTTP源代码：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><a href="https://github.com/rapid7/metasploit-payloads/blob/master/c/meterpreter/source/server/win/server_transport_winhttp.c" _src="https://github.com/rapid7/metasploit-payloads/blob/master/c/meterpreter/source/server/win/server_transport_winhttp.c">https://github.com/rapid7/metasploit-payloads/blob/master/c/meterpreter/source/server/win/server_transport_winhttp.c</a>&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">[5] Meterpreter common.h源代码：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><a href="https://github.com/rapid7/metasploit-payloads/blob/master/c/meterpreter/source/common/common.h" _src="https://github.com/rapid7/metasploit-payloads/blob/master/c/meterpreter/source/common/common.h">https://github.com/rapid7/metasploit-payloads/blob/master/c/meterpreter/source/common/common.h</a>&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">[6] Sysinternals DebugView：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><a href="https://technet.microsoft.com/en-us/sysinternals/debugview.aspx" _src="https://technet.microsoft.com/en-us/sysinternals/debugview.aspx">https://technet.microsoft.com/en-us/sysinternals/debugview.aspx</a>&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">[7] 对比WinHTTP与WinInet：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><a href="https://github.com/rapid7/metasploit-framework/wiki/The-ins-and-outs-of-HTTP-and-HTTPS-communications-in-Meterpreter-and-Metasploit-Stagers" _src="https://github.com/rapid7/metasploit-framework/wiki/The-ins-and-outs-of-HTTP-and-HTTPS-communications-in-Meterpreter-and-Metasploit-Stagers">https://github.com/rapid7/metasploit-framework/wiki/The-ins-and-outs-of-HTTP-and-HTTPS-communications-in-Meterpreter-and-Metasploit-Stagers</a>&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">[8] Metasploit bug反馈：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><a href="https://github.com/rapid7/metasploit-payloads/issues/151" _src="https://github.com/rapid7/metasploit-payloads/issues/151">https://github.com/rapid7/metasploit-payloads/issues/151</a>&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">[9] WinHTTP示例代码：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><a href="http://code.msdn.microsoft.com/windowsdesktop/WinHTTP-proxy-sample-eea13d0c" _src="http://code.msdn.microsoft.com/windowsdesktop/WinHTTP-proxy-sample-eea13d0c">http://code.msdn.microsoft.com/windowsdesktop/WinHTTP-proxy-sample-eea13d0c</a>&nbsp;</span></p></p>
                <hr/>
                <p style="text-align: center;">
                    <img src="http://bobao.360.cn/img/app.jpeg"/>
                    <img src="http://bobao.360.cn/img/weixin.jpeg"/>
                </p>
                                <p>本文由 安全客 翻译，转载请注明“转自安全客”，并附上链接。<br/><a class="text-more" href="https://medium.com/@br4nsh/a-meterpreter-and-windows-proxy-case-4af2b866f4a1" target="_blank">原文链接：https://medium.com/@br4nsh/a-meterpreter-and-windows-proxy-case-4af2b866f4a1</a></p>
                            </div>
            <div style="margin-top: 20px;background-color:#FFFFFF">
    <input type="hidden" id="detail_title" name="detail_title" value="【技术分享】使用Meterpreter和Windows代理的APT案例分析 - 安全客 - 有思想的安全新媒体" />
    <input type="hidden" id="use_nickname" name="use_nickname" value="0" />
    <a name="mao"></a>
    <div class="reg-log mobile-hiden">
        <div class="" id="userTo">   
            <div id="to-list" class="input-text" style="">
                <textarea disabled="disabled" class="hide"  id="comment-content" to="to"></textarea>
                <ul id="preadded" style="display:none">       
                </ul>
                <div id="to-auto" style="width: 200px">
                    <ul id="feed">
                    </ul>
                </div>
            </div>
        </div>
        <input type="hidden" id="source-id" value="3865" />
        <input type="hidden" id="source-type" value="learning" />
        <input type="hidden" id="post-comment-url" value="/comment/add" />
        <input type="hidden" id="post-nickname-url-ajax" value="/comment/randnicknameajax" />
        <input type="hidden" id="post-check-login-url-ajax" value="/comment/checklogin" />
        <input type="hidden" id="stoken_comment_set" value="ea3898fb4df38673fdeb61c458234054">                 <span class="join">参与讨论，请先 <a href="javascript:;" class="comment-login">登录</a> | <a href="javascript:;" class="comment-reg">注册</a> |  <a href="javascript:;" class="anonymous-comment">匿名评论</a></span>
            </div>
    <div class="mobile-hide" style="width: 870px; margin: 0 auto;">
        <label style="vertical-align:middle;" for="use_nickname">匿名</label> 
        <input style="vertical-align:middle;" id="trigger-nickname" name="use_nickname" class="use_nickname" type="checkbox" value="0" />

        <a href="javascript:;" class="apply-use button" id="submit-comment" data-target="/comment/add">发布</a>
    </div>


    <div class="clearfix"></div>
    <div class="comments">
        <div class="comments-head">
            <span class="title">用户评论</span>
        </div>
                <div class="comment">
    <div class="avatar">
        <a href="javascript:;">
                                    <img src="/img/photo/11x48x48.png">
                    </a>
    </div>
    <div class="comment-main">
        <div class="comment-user">
                        <a user-id="0" class="response" data-bind-id="0" data-target="14221" user-name="nU1I" href="javascript:;">
                nU1I            </a>
                        <span class="comment-time">2017-05-17 14:41:10</span>
            <div class="comment-action">
                <span class="comment-response"><a href="javascript:;" class="response" data-bind-id="0" data-target="14221">回复</a></span>&nbsp;|&nbsp;
                <span><a href="javascript:;"  class="good" data-target="/comment/good" data-value="g_14221" data-type="comment">点赞</a></span>
            </div>
        </div>

        <p class="content">再考虑下认证代理的情况，可以再写一篇了</p>
        <style>
    .comment-user p{font-size: 13px; margin: 0;}
</style>
    </div>
    <div>

    </div>
</div>
<div class="clearfix"></div>

        <a class="more-long comment-more" href="javascript:;" data-target="/comment/more" data-type="learning" data-source-id="3865" data-page="2">查看更多</a>
            </div>
</div>
<script>
    $(function () {
        $('.anonymous-comment').click(function () {
            $(".join").hide();
            $(".reg-log textarea").first().removeAttr("disabled").show();
            $('#use_nickname').val('1');
//            $('#trigger-nickname').attr('checked', true);
            $('#trigger-nickname').trigger('click');
        });
        //为所有复选框绑定事件
//        checkbox_on_click();
        //ajax随机获取昵称
//        randnicknameajax(0);
        //ajax检测登录状态
        comment_check_login();
    });



    function input_checkbox(flag) {
        $('input:checkbox').each(function () {
            var value = flag ? 1 : 0;
            $(this).prop('checked', flag);
            $(this).val(value);
        });
    }

//ajax随机获取昵称
    function randnicknameajax(flag) {
        $.ajax({
            type: 'POST',
            url: $('#post-nickname-url-ajax').val(),
            data: {limit: 1, flag: flag},
            dataType: "json",
            success: function (data) {
                $('#nick-name').val(data.data[0]);
                _nick_name=data.data[0];
            }
        });
    }
    $();
//ajax检测登录状态
    function comment_check_login() {
        $.ajax({
            type: 'POST',
            url: $('#post-check-login-url-ajax').val(),
            data: {},
            dataType: "json",
            success: function (data) {
                if (data.success) {
                    $('.join').hide();
                    $(".reg-log textarea").first().removeAttr("disabled").show();
                    $("#span_use_nickname").show();
                    $('#use_nickname').val('0');
                    $('#use_nickname').attr('checked', false);
                }
            }
        });
    }
</script>        </div>
    </div>
    <div class="side-bar">
        <div class="mod hot-news">
    <div class="head-bar clearfix">
        <h2><i class="icon icon-hot"></i><span>热门知识</span></h2>
    </div>
    <ul class="links-list">
                                <li><a href="/learning/detail/4411.html" alt="【漏洞预警】一个换行符引发的奥斯卡0day漏洞(CVE-2017-8759)重现——最新的Office高级威胁攻击预警" target="_blank">【漏洞预警】一个换行符引发的奥斯卡...</a></li>
                                <li><a href="/learning/detail/4416.html" alt="【漏洞预警】Microsoft .NET Framework漏洞（CVE–2017–8759）预警" target="_blank">【漏洞预警】Microsoft .NE...</a></li>
                                <li><a href="/learning/detail/4414.html" alt="【技术分享】妙用JavaScript绕过XSS过滤" target="_blank">【技术分享】妙用JavaScrip...</a></li>
                                <li><a href="/learning/detail/4418.html" alt="【技术分享】利用威胁情报数据平台拓展APT攻击线索一例" target="_blank">【技术分享】利用威胁情报数据平台拓...</a></li>
                                <li><a href="/learning/detail/4417.html" alt="【知识】9月15日 - 每日安全知识热点" target="_blank">【知识】9月15日 - 每日安全知识热...</a></li>
                                <li><a href="/learning/detail/4425.html" alt="【安全报告】XShellGhost事件技术回顾报告" target="_blank">【安全报告】XShellGhost事件...</a></li>
            </ul>
</div>        <!-- 友情链接 -->
        <div class="mod blog-links mobile-hide">
    <div class="head-bar clearfix">
        <h2><i class="icon icon-link"></i><span>友情链接</span></h2>
        <a href="/links/index.html" class="more">更多<i></i></a>
    </div>
        <ul class="links-list">
                <li><a href="http://bbs.360safe.com" alt="360安全社区" target="_blank">360安全社区</a></li>
                <li><a href="http://zhuji.360.cn" alt="360主机卫士" target="_blank">360主机卫士</a></li>
                <li><a href="http://blogs.360.cn/" alt="奇虎360技术博客" target="_blank">奇虎360技术博客</a></li>
                <li><a href="http://wangzhan.360.cn/" alt="360网站卫士" target="_blank">360网站卫士</a></li>
                <li><a href="http://webscan.360.cn/" alt="360网站安全检测" target="_blank">360网站安全检测</a></li>
                <li><a href="http://research.360.cn/report/" alt="360研究报告" target="_blank">360研究报告</a></li>
                <li><a href="http://unicorn.360.cn/" alt="360 Unicorn Team" target="_blank">360 Unicorn Team</a></li>
                <li><a href="http://appscan.360.cn/" alt="360捉虫猎手" target="_blank">360捉虫猎手</a></li>
                <li><a href="https://threathunter.org/" alt="ThreatHunter社区" target="_blank">ThreatHunter社区</a></li>
                <li><a href="http://security.360.cn/" alt="360安全应急响应中心" target="_blank">360安全应急响应中心</a></li>
            </ul>
    </div>
        <!-- 联系我们 -->
        <div class="mod contact mobile-hide" style="text-align:center">
    <div class="head-bar clearfix">
        <h2><i></i><span>关注我们</span></h2>
    </div>
    <!-- 微信关注 -->
    <ul class="contact-way">
        <li><a>微信关注</a></li>
    </ul>
    <div style="padding-left:20px;padding-bottom:15px;">
    <img src="/img/qrcode_adlab_weixin.png?v=1.1"  width="145px" height="145px;"/>
    </div>
    
    <!-- APP下载 -->
    <ul class="contact-way">
        <li><a>安全播报APP</a></li>
    </ul>
    <div style="padding-left:20px;padding-bottom:15px;">
    <img src="/img/scan_code_big.png?v=1.1"  width="145px" height="145px;"/>
    </div>
    
</div>

    </div>
</div>

<script type="text/javascript" src="/js/jquery-ui.min.js?v=3.0"></script>
<script type="text/javascript" src="/js/jquery.noty.packaged.min.js?v=3.0"></script>
<script type="text/javascript" src="/js/common.js?v=4.5"></script>
<script>$(function() {sync_count('comment');});</script>


<!-- 语法高亮 -->
<script type="text/javascript" src="/ue/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">SyntaxHighlighter.all();sync_count('vul');sync_count('news');sync_count('learning');sync_count('activity');sync_count('course');sync_count('ctf');</script>
    </div>

        <div class="footer">
        <div class="friend-link">
            <a href="http://www.360.cn/" target="_blank">360首页</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">关于我们</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">联系我们</a>
            <span>|</span>
            <a href="/links/index.html" target="_blank">友情链接</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">招贤纳士</a>
        </div>
        <div class="copy">
            Copyright &copy; 360网络攻防实验室 All Rights Reserved <span class="copy_icp">京ICP证080047号[京ICP备08010314号-6]</span>
        </div>
    </div>
    
</div>

<!--奇舞团统计-->

<script src='https://s.ssl.qhimg.com/static/f5407c785655e6a1/monitor_analytic.js'></script>
<script>
    monitor.setProject('QH_171_1').getTrack().getClickAndKeydown().getClickHeatmap(10, 1);
</script>

<div class="hide">
    <script src="https://s95.cnzz.com/z_stat.php?id=1253147824&web_id=1253147824" language="JavaScript"></script>
</div>
<div class="backToTop_wrap off">
    <a id="back_to_top" class="backToTop" href="javascript:;" title="返回顶部"></a>
</div>
<script>
    var $backToTop_wrap = $(".backToTop_wrap"),
        $backToTop_btn = $("#back_to_top");

    if ($(window).scrollTop() > 100) {
        $backToTop_wrap.removeClass("off");
    }
    else {
        $backToTop_wrap.addClass("off");
    }

    $(window).on("scroll", function () {
        if ($(this).scrollTop() > 100) {
            $backToTop_wrap.removeClass("off");
        }
        else {
            $backToTop_wrap.addClass("off");
        }
    });

    $backToTop_btn.on("click", function () {
        $("html, body").animate({scrollTop: 0}, 120);
    });

    $(function () {
        var navlist = $('.nav-list > li');

        navlist.each(function () {
            $(this).on('mouseenter', function () {
                $(this).addClass('selected');
            });

            $(this).on('mouseleave', function () {
                $(this).removeClass('selected');
            });
        });
    })
</script>



</body>
</html>
