<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:wb="http://open.weibo.com/wb" xml:lang="en" lang="en">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="viewport"
          content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"/>
    <link rel="shortcut icon" href="http://bobao.360.cn/favicon.ico?v=1.1"/>
    <link rel="alternate" title="安全资讯" href="/rss?type=news" type="application/rss+xml"/>
    <link rel="alternate" title="安全知识" href="/rss?type=learning" type="application/rss+xml"/>
    <link rel="alternate" title="安全圈活动" href="/rss?type=activity" type="application/rss+xml"/>
    <link rel="alternate" title="所有漏洞" href="/rss?type=vul" type="application/rss+xml"/>
    <link rel="alternate" title="通用型漏洞" href="/rss?type=commonvul" type="application/rss+xml"/>
    <link rel="alternate" title="事件型漏洞" href="/rss?type=eventvul" type="application/rss+xml"/>
    <link rel="alternate" title="热门漏洞" href="/rss?type=hotvul" type="application/rss+xml"/>

        <title>【技术分享】BlackHat2016——JDNI注入/LDAP Entry污染攻击技术研究 - 安全客 - 有思想的安全新媒体</title>
    
        <meta name="keywords" content="BlackHat2016,JNDI攻击,LDAP条目污染,攻击 技术研究"/>
    
        <meta name="description" content="议题中介绍了两种新型的攻击方式——JNDI攻击和LDAP条目污染。两种方式都是非常高危的漏洞，并且可以执行任意的代码。"/>
        <meta property="wb:webmaster" content="224437c7be31d633"/>

    <script type="text/javascript" src="http://s7.qhimg.com/!56caa871/xpc_sync_height.js"></script>
    <link rel="stylesheet" type="text/css" href="/css/reset.css" />
    <link rel="stylesheet" type="text/css" href="/css/common_new.css?v=4.4.2.1" />
    <link rel="stylesheet" type="text/css" href="/css/jquery.notyfy.css" />
    <link rel="stylesheet" type="text/css" href="/css/notyfy.theme.default.css" />
    <link rel="stylesheet" type="text/css" href="/css/s_common.css?v=2.2.7" media="only screen and
    (max-device-width:900px), only screen and (max-width:900px)" />
    <script type="text/javascript" src="/js/jquery.min.js?v=3.1"></script>
    <script type="text/javascript" src="/js/jquery.notyfy.js"></script>
    <script type="text/javascript" src="/js/iscroll.js"></script>
    <script src="http://js.passport.qihucdn.com/5.0.3.js"></script>
    <script type="text/javascript">
        var myScroll, myNavScroll;

        function iscrollLoaded() {
            myScroll = new IScroll('#wrapper',
                {
                    scrollX: true,
                    scrollY: false,
                    bounceEasing: 'circular',
                    eventPassthrough: true,
                    preventDefault: false,
                    bounceTime: 500
                }
            );
        }

        $(function () {

            //导航横向滚动


            function setNavWidth() {

                /* 计算导航宽度 */
                var allWidth = $(window).width();
                var scroller = $('#scroller');

                if (allWidth > 900) {
                    scroller.find('ul').add(scroller.find('.scroll')).removeAttr('style');
                    scroller.css('overflow', 'visible');
                    if (myNavScroll) myNavScroll.destroy();
                } else {

                    var width = 0;
                    scroller.find('.scroll').children('ul').children('li').each(function (index, el) {
                        if (!$(this).hasClass('mobile-hide')) {
                            width += $(this).outerWidth();
                        }
                    });
                    scroller.find('ul').add(scroller.find('.scroll')).width(width);

                    if (myNavScroll) myNavScroll.destroy();

                    myNavScroll = new IScroll('#scroller', {
                        scrollX: true,
                        scrollY: false,
                        momentum: false,
                        click: true
                    });

                }

            }

            setNavWidth();
            $(window).resize(function (event) {
                setNavWidth();
            });

        });

    </script>
</head>
<body onload="iscrollLoaded();">
<div style='margin:0 auto;width:0px;height:0px;overflow:hidden;'>
    <img src=""/>
</div>

<div id="is-mobile"></div>
<div class="container">
        <div class="mobile-header">
        <div class="header clearfix">
            <div class="header-wrapper clearfix">
                <a href="/index/index" class="logo"><img class="slogan" src="/img/logo.png?v=1.5"/></a>
                                <form id="search" class="search-box" action="/search/index" method="GET">
                    <input class="keys" name="keywords" type="text" placeholder="搜索漏洞" required="required">
                    <input class="icon" type="submit" value="">
                    <input type="hidden" name="type" value=""/>
                </form>
                <div class="bug">
                    <div class="name"><span class="seled">全部</span><i class="arrow"></i></div>
                    <ul class="typelist">
                        <li data-index="3"><a href="javascript:void(0);">全部</a></li>
                        <li data-index="0"><a href="javascript:void(0);">漏洞</a></li>
                        <li data-index="1"><a href="javascript:void(0);">资讯</a></li>
                        <li data-index="2"><a href="javascript:void(0);">知识</a></li>
                    </ul>
                </div>
                                <div class="logNreg mobile-hide">
                    <div class="unlog">
                        <i></i>
                        <a href="log.html" class="log">登录</a>
                        <span>|</span>
                        <a href="reg.html" class="reg">注册</a>
                    </div>
                    <div class="loged">
                        <a href="/member/profile" class="user-center"><i></i><span class="user-name-tag">个人中心</span></a>
                        <div class="user-links">
                            <span class="arrow"></span>
                            <ul>
                                <li class="account-setting"><a href="http://i.360.cn/profile/accountmanage"
                                                               target="_blank"><i></i><span>账号设置</span></a></li>
                                <li class="alert-setting"><a href="/keywords/index"
                                                             target="_blank"><i></i><span>告警设置</span></a></li>
                                <li class="bug-alert"><a href="/myalarm/index" target="_blank"><i></i><span>漏洞告警</span></a>
                                </li>
                                <li class="my-knowl"><a href="/mylearn/index" target="_blank"><i></i><span>我的知识</span></a>
                                </li>
                                <li class="my-knowl"><a href="/mycourse/index" target="_blank"><i></i><span>我的课堂</span></a>
                                </li>
                                <li class="my-exit"><a
                                            href="http://login.360.cn/?src=pcw_adlab&op=logout&destUrl=http://bobao.360.cn"><i></i><span>退出系统</span></a>
                                </li>
                            </ul>
                        </div>

                        <a href="/message" class="message-center" target="_blank"><i></i><span>我的消息</span></a>
                        <div class="message-links">
                            <span class="arrow"></span>
                            <ul>
                                <li class="account-setting" style="display:none;"><a href="/myres/index"
                                                                                     target="_blank"><i></i><span>回复我的</span></a>
                                </li>
                                <li class="my-bug"><a href="/myvul/index"
                                                      target="_blank"><i></i><span>我的漏洞</span></a></li>
                                <!--<li class="my-bug"><a href="/myres/index" target="_blank"><i></i><span>我的评论</span></a></li>-->
                                <!--<li class="alert-setting"><a href="###" target="_blank"><i></i><span>提到我的</span></a>
                                </li>-->
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <style type="text/css">
            .nav {
                overflow: hidden;
            }

            .nav .scroll {
                width: auto;
            }
        </style>
        <div id="wrapper">
            <div id="scroller" class="nav">
                <div class="scroll">
                    <ul class="nav-list">
                        <li ><a class="link-nav"
                                                                                 href="/index/index">首页</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/vul/index">漏洞</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/introduce/list">招聘</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/news/index">资讯</a><!--<i class="arrow mobile-hide"></i>
                        <ul class="subnav-list mobile-hide">
                            <li><a class="link-subnav" href="/introduce/list">招聘</a></li>
                        </ul>
			-->
                        </li>
                        <li class="cur">
                        <a class="link-nav" href="/learning/index">知识</a><i class="arrow mobile-hide"></i>
                        <ul class="subnav-list mobile-hide">
                            <li><a class="link-subnav" href="/course/index">学院</a></li>
                        </ul>
                        </li>
                        <li ><a class="link-nav"
                                                               href="/activity/index">活动</a></li>
                        <li class="mobile-hide "><a class="link-nav"
                                                                                                   href="/ctf/index">CTF训练营</a>
                        </li>
                        <li ><a class="link-nav"
                                                               href="/interref/list">安全内参</a></li>
                        <li ><a class="link-nav" href="/app/index">APP</a></li>

                        <!--<li ><a href="/course/index">学院</a></li>-->
                        <!--<li ><a href="/introduce/list">招聘</a></li>-->
                        <!--<li  class="mobile-hide"><a href="/ctf/index">CTF训练营</a></li>-->
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <div class="mobile-content">
        <link rel="stylesheet" type="text/css" href="/css/news.css?v=3.5" />
<link rel="stylesheet" type="text/css" href="/ue/SyntaxHighlighter/shCoreDefault.css?v=1.0" />
<style>
    p .syntaxhighlighter {
        width: 80%;
    }
</style>

<div class="cur-pos w1000">当前位置：<a href="http://bobao.360.cn/">安全客</a> &gt;&gt; 知识详情</div>

<div class="content clearfix">
    <div class="main">
        <div class="article">
            <div id="article_box">
                <h2>【技术分享】BlackHat2016——JDNI注入/LDAP Entry污染攻击技术研究</h2>
                <div class="article-msg">
                    <span class="time">2016-09-05 18:09:19</span>
                    
                                        <span class="read">阅读：11437次</span>
                    <span><a style="display: none;" class="good" href="javascript:;"
                             data-target="/learning/good" data-value="g_2999"
                             data-type="learning">点赞(0)</a></span>
                    <span><a class="fav" href="javascript:;" data-target="/mylearning/add"
                             data-pk="2999" data-type="learning">收藏</a></span>
                    
                    
                    <div style="margin-top:10px; ">
                        <a href="/member/contribute?uid=2545987194" style="color:#848e99;">
                            <img src="http://p1.qhmsg.com/dm/150_150_100/t01774623463a9b9308.jpg" data-is-avatar="true"
                                 style="border: 1px solid #d5d5d5;padding: 2px; width: 80px;height: 80px;border-radius: 43px;"/>
                        </a>

                    </div>
                    <span class="orig">作者：<a href="/member/contribute?uid=2545987194" style="color:#848e99;">隐形人真忙</a></span>
                                    </div>
                <hr size="1">
                <div class="article-msg">
                    <p><!-- JiaThis Button BEGIN -->

<!--
<span class="jiathis_style"><span class="jiathis_txt">分享到：</span>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_tsina"></a>
    <a class="jiathis_button_tqq"></a>
    <a class="jiathis_button_qzone"></a>
    <a class="jiathis_button_renren"></a>
    <a class="jiathis_button_xiaoyou"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
</span>

-->
</p>
                </div>
                <p><p style="text-align: center; text-indent: 0em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p0.qhimg.com/t01a4c2280fa424ab56.png" title="t01a4c2280fa424ab56.png" alt="http://p0.qhimg.com/t01a4c2280fa424ab56.png"/></span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">(一)基本概念</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></strong></span><br/></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">1.1 JNDI</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">JNDI（Java Naming and DirectoryInterface），直译为命名与目录接口。JNDI是一组客户端通过名称（Naming）来寻找和发现数据和对象的API。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">JNDI的概念分为命名系统和目录系统：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（1） &nbsp; &nbsp;命名系统（Naming Service）：将实体使用名称和值的方式联系起来，俗称绑定。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">l &nbsp;DNS：将机器的网络地址和域名进行映射；</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">l &nbsp;文件系统：将文件名和存储在磁盘的数据进行映射。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（2） &nbsp; &nbsp;目录系统（Directory Service）：是一种特殊的命名系统，目录系统中支持“目录对象”的存储和查询。LDAP就是一种目录系统，允许以树状的形式存储目录对象，并且可以对这些对象进行索引。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">明确一下对象的概念，对象可以在本地，也可以部署在远程服务器。学习过RMI原理的同学应该对远程对象并不陌生，其实RMI就是JNDI的一种，类似的还有CORBA,LDAP以及众所周知的DNS服务。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">1.2 JNDI的代码片段</span></strong></p><p style="text-align:center"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p9.qhimg.com/t0132bd65b81e47008d.png" title="t01060c0f150de38c8f.png" alt="http://p9.qhimg.com/t01060c0f150de38c8f.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">上图的代码片段是使用JNDI接口来创建RMI服务，这和sun.rmi.*包提供的创建方式有所不同，关键在于map对象env和上下文对象ctx，通过这两个对象来标识一些信息。这里有几个方法要说明一下：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（1） &nbsp; &nbsp;bind方法：将服务名称和实体进行绑定，比如这里调用bind方法来使用foo字符串指定一个字符串”Sample String”。当然这个代码直接运行会出错，原因在于bind方法接收的对象必须是远程对象。源码如下：</span></p><p style="text-align:center"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p7.qhimg.com/t0118731d483b542e72.png" title="t013cce0937a65ac416.png" alt="http://p9.qhimg.com/t013cce0937a65ac416.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（2）lookup方法：从系统中寻找命名标识的对象。这里使用foo字符串来在命名与目录系统中寻找对应的对象（字符串对象）。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">最后print出的是“Sample String”</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">1.3 引用与地址</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在JNDI系统中，需要存储一些对象，存储对象的方式通常会采用存储该对象的引用的方式。对于学习过OOP概念的同学，对象的引用并不难理解。所谓引用（Reference）就是指在内存中定位对象的一个指针。通过对象的引用，我们可以在JNDI系统中操作对象或者获取对象的一些信息。</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p4.qhimg.com/t0128d3b99498863521.png" title="t01c27840f2842b709b.png" alt="http://p2.qhimg.com/t01c27840f2842b709b.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">比较有趣的是，使用Reference对象可以指定工厂来创建一个java对象，用户可以指定远程的对象工厂地址，当远程对象地址用户可控时，这也会带来不小的问题。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">1.4 远程代码与安全管理器</span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">1.4.1 Java中的安全管理器</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Java中的对象分为本地对象和远程对象，本地对象是默认为可信任的，但是远程对象是不受信任的。比如，当我们的系统从远程服务器加载一个对象，为了安全起见，JVM就要限制该对象的能力，比如禁止该对象访问我们本地的文件系统等，这些在现有的JVM中是依赖安全管理器（SecurityManager）来实现的。</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p5.qhimg.com/t01cb04f89d62590267.png" title="t01b80e3e5ca2c79cb0.png" alt="http://p3.qhimg.com/t01b80e3e5ca2c79cb0.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">JVM中采用的最新模型见上图，引入了“域”的概念，在不同的域中执行不同的权限。JVM会把所有代码加载到不同的系统域和应用域，系统域专门负责与关键资源进行交互，而应用域则通过系统域的部分代理来对各种需要的资源进行访问，存在于不同域的class文件就具有了当前域的全部权限。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">关于安全管理机制，可以详细阅读：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><a href="http://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/" _src="http://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/">http://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/</a></span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">1.4.2 JNDI安全管理器架构</span></strong></p><p style="text-align:center"><img src="http://p2.qhimg.com/t01a0efca303bfc256e.png" title="t014c2a9a8d3b896c87.png" alt="http://p8.qhimg.com/t014c2a9a8d3b896c87.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">对于加载远程对象，JDNI有两种不同的安全控制方式，对于Naming Manager来说，相对的安全管理器的规则比较宽泛，但是对JNDI SPI层会按照下面表格中的规则进行控制：</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p7.qhimg.com/t019e7beb28d2b536e6.png" title="t01882794d52d260124.png" alt="http://p0.qhimg.com/t01882794d52d260124.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">针对以上特性，黑客可能会找到一些特殊场景，利用两者的差异来执行恶意代码。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（二）click-to-play绕过</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></strong></span><br/></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">2.1 点击运行保护</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">有了以上的基础知识作为铺垫，我们来了解下“Click-to-play”的绕过（CVE-2015-4902），该0day是从趋势科技捕获的一个蠕虫病毒Pawn Storm中发现的。详细请参考趋势科技的具体blog：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><a href="http://blog.trendmicro.com/trendlabs-security-intelligence/new-headaches-how-the-pawn-storm-zero-day-evaded-javas-click-to-play-protection/" _src="http://blog.trendmicro.com/trendlabs-security-intelligence/new-headaches-how-the-pawn-storm-zero-day-evaded-javas-click-to-play-protection/">http://blog.trendmicro.com/trendlabs-security-intelligence/new-headaches-how-the-pawn-storm-zero-day-evaded-javas-click-to-play-protection/</a></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">要想真正理解这个CVE的原理，还需要一些基础知识的讲解。</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">2.2 JNLP协议</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">JNLP全称为Java Network Launch Protocol，这项技术被用来通过URL打开一个远程的Java可执行文件。通过这个技术，可以快速部署applet或者web应用。而在攻击场景下，攻击者用于部署applet应用。</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">2.3 jndi.properties文件</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">jndi.properties文件用来创建Context上下文对象。如果正常使用代码的方式，我们可以创建一个Properties对象来设置一些JNDI服务需要的一些配置，然后通过这个对象创建出相关的上下文对象：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Properties p = new Properties();&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">p.put(Cotnext.PROVIDER_URL, &quot;localhost:1099 &quot;）；//主机名和端口号&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">//InitialContext的创建工厂类</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">p.put(Context.InitialContextFactroy, &quot;com.sun.InitialContextFactory&quot;);&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">InitialContext ctx = new InitialContext(p);&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">如果使用jndi.properties文件来创建上下文对象，我们可以将这些配置写入到properties文件中，从而使代码的可配置性更高：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">java.naming.factory.initial=com.sun.NamingContextFactory&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">java.naming.provider.url=localhost:1099&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">如果直接创建初始上下文,如下：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">InitialContext &nbsp; ctx &nbsp; = &nbsp; new &nbsp;InitialContext();&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">InitialContext的构造器会在类路径中找jndi.properties文件，如果找到，通过里面的属性，创建初始上下文。&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">两种方式是相同的效果。</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">2.4 攻击思路</span></strong></p><p style="text-indent: 2em; text-align: center;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p6.qhimg.com/t01fb18c035dbad780f.png" title="t01c9591611decd0d86.png" alt="http://p1.qhimg.com/t01c9591611decd0d86.png"/></span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">攻击发生前，攻击者做了这样三件事情：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（1） &nbsp; &nbsp;配置一个恶意的web页面，该页面包含一个applet应用，具体代码如下：</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p1.qhimg.com/t011aaadd4379eb3a6c.png" title="t01f87a6d836f3e1419.png" alt="http://p5.qhimg.com/t01f87a6d836f3e1419.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（1） &nbsp; &nbsp;攻击者创建一个RMI服务（公网IP）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（2） &nbsp; &nbsp;攻击者创建一个托管java恶意代码的服务器（公网IP）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">接下来就是攻击发生的具体步骤了：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Ø &nbsp;在受害者机器上，访问含有applet应用的html页面之后，浏览器进程会启动jp2launcher.exe，然后从恶意服务器请求init.jnlp文件。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Ø &nbsp;恶意服务器上返回一个jnpl文件，文件内容如下：</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p1.qhimg.com/t01b5bb3d12690681c9.png" title="t015423eb6115e06ff8.png" alt="http://p7.qhimg.com/t015423eb6115e06ff8.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这里jnpl文件中，progress-class指定为javax.naming.InitialContext。通过官网文档，我们获知这个属性指定的类名需要实现DownloadServiceListener接口才行，但是jre似乎没有校验这个情况。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Ø &nbsp;受害者主机会执行这个类的构造方法，InitialContext构造方法会从恶意服</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">务器上请求jndi.properties文件，用于创建context对象，该文件如下：</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p6.qhimg.com/t011fa1e14e4a85b8b9.png" title="t01e97d83bce179cd7f.png" alt="http://p5.qhimg.com/t01e97d83bce179cd7f.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">可以看到指定了Context的工厂类为RMI服务的，并且指定rmi的URL。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Ø &nbsp;然后受害者主机与RMI服务器建立了通讯，随后客户端发起查找Go对象</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（其实就是个恶意的工厂类）的请求，相应地，RMI服务器返回一个恶意的Go.class。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Ø &nbsp;这个恶意文件在受害者主机被执行，从而实现静默执行效果。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">从上面的过程来看，攻击者用到了JNDI实现了静默执行applet的方法，从而执行了恶意代码，绕过click-to-play，过程非常巧妙和精彩。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（三）JNDI注入漏洞</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><strong><span style="font-size: 18px;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></span><br/></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3.1 攻击条件</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">漏洞利用的条件：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（1） &nbsp; &nbsp;上下文对象必须通过InitialContext或者它的子类（InitialDirContextor InitialLdapContext）来实例化。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（2） &nbsp; &nbsp;InitialContext的一些属性可以通过传入lookup方法的参数进行修改。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">关于条件中的第二条，来解读一下，首先看下面的代码片段：</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p7.qhimg.com/t0116abed11d71372fa.png" title="t01ac6a4d7a5f0f099a.png" alt="http://p6.qhimg.com/t01ac6a4d7a5f0f099a.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">如果攻击者对传入lookup的参数是可控的，那么无论context中配置过什么URL，比如这里指定了RMI的URL为rmi://sercure-server:1099，但是攻击者如果在lookup中指定一个绝对路径，如rmi://evil-server:1099/foo，那么会以lookup参数指定的URL为准。</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3.2 RMI攻击向量</span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3.2.1 RMI介绍</span></strong></p><p style="text-indent: 2em; text-align: center;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p2.qhimg.com/t01ddf5db53946b98ef.png" title="t01c1eafbde454ddb18.png" alt="http://p1.qhimg.com/t01c1eafbde454ddb18.png"/></span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">RMI全称为远程方法调用，上图描述了RMI的架构，可以看到，客户端和服务器的通讯运用了代理对象，分别是Stub和Skeleton对象，这两个代理对象负责实现客户端和服务器之间的通讯，提供远程对象的副本，返回远程对象调用的结果等功能，从而实现远程对象的调用。</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3.2.2 JNDI Ref payload</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Reference是JNDI中的对象引用，因为在JNDI中，对象传递要么是序列化方式存储（对象的拷贝，对应按值传递），要么是按照引用（对象的引用，对应按引用传递）来存储，当序列化不好用的时候，我们可以使用Reference将对象存储在JNDI系统中。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">JNDI提供了一个Reference类来表示某个对象的引用，这个类中包含被引用对象的类信息和地址。地址属性是用RefAddr类表示。用Reference也可以创建对象：</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p7.qhimg.com/t01fec74d6c22bbba60.png" title="t01fa574c4e0a079742.png" alt="http://p9.qhimg.com/t01fa574c4e0a079742.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">上面的代码片段是官方文档中的demo，通过Reference构造函数，传入要实例化类的全名、地址信息、工厂类的全名、工厂类的地址等信息，就能实例化一个类，值得注意的是，这里支持传入工厂类的URL地址，也就是支持远程工厂类的引入。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">如果在RMI服务器端使用Reference创建远程对象后，绑定到rmi中：</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p7.qhimg.com/t01c028470da1533cda.png" title="t01817a355d367b2c0d.png" alt="http://p9.qhimg.com/t01817a355d367b2c0d.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">注意，这里的FactoryURL需要攻击者可控，因此攻击者可以自己写一个恶意的工厂类，然后在服务端执行恶意代码。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">看两个Demo来说明一下：</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">场景1：攻击者可控FactoryUrl</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">首先是提供正常RMI服务的服务器，代码看上去是这样的：</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p8.qhimg.com/t016d38fde7e8ec15b6.png" title="t01e0a5406baf3ebe2b.png" alt="http://p1.qhimg.com/t01e0a5406baf3ebe2b.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">如果上面圈出来的地方是攻击者可控的话，那么攻击者通过这个URL可以构造一个工厂类来影响服务器端的逻辑。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这个工程类如果包含了恶意的代码，比如可以把工厂类构造成这样：</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p2.qhimg.com/t01423ebc901debff78.png" title="t01c4bbf2d2ab9de4d2.png" alt="http://p5.qhimg.com/t01c4bbf2d2ab9de4d2.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这里demo中，恶意代码放在了getObjectInstance里，因为在执行lookup时，JNDI会调用工厂对象中的getObjectInstance方法：</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p3.qhimg.com/t01d917face305da756.png" title="t0154d71b788e276b70.png" alt="http://p4.qhimg.com/t0154d71b788e276b70.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">其实直接把恶意代码放在工厂类的构造函数中也行，因为lookup执行时会对其进行实例化，相关代码可以从RMI实现中找到。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">当然我们还需要自己做一个RMI服务器，当然是恶意的服务器，代码如下：</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p6.qhimg.com/t01c9f4b6e22e504cb1.png" title="t016b25ecf3e86ac5e6.png" alt="http://p3.qhimg.com/t016b25ecf3e86ac5e6.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在恶意服务器上，我们将恶意的工厂类绑定在RMI服务上。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这样，服务器上bind的对象，实际上是我们工厂方法所提供的。一旦有客户端连接这个受到污染的RMI服务器，并且调用了lookup方法来寻找受污染的远程对象，恶意代码就会被执行。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">写个客户端代码模拟一下：</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p2.qhimg.com/t010125f4f2f1417180.png" title="t01db2b0c8f7176344b.png" alt="http://p0.qhimg.com/t01db2b0c8f7176344b.png"/></span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3.2.3 直接注入lookup</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">直接看代码：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p0.qhimg.com/t0140e59ca4c94e0ef7.png" title="t0154cc2b03800a6c12.png" alt="http://p8.qhimg.com/t0154cc2b03800a6c12.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">清晰明了，没啥可说的。而且原理实际上和ref注入差不多，为了好懂，还是举个栗子。</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">场景2：利用恶意工厂类exploit</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">上个场景有点蜜汁难懂，其实是我自己YY的，我们来看下议题的作者给出的姿势。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">首先，我们在可控的服务器上搭建一个RMI服务，这个服务上绑定一个恶意的工厂类：</span></p><p style="text-indent: 2em; text-align: center;"><img src="http://p9.qhimg.com/t0179bfb12c1ce0cde7.png" title="t0191049b97cadb2247.png" alt="http://p8.qhimg.com/t0191049b97cadb2247.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">恶意服务器开放了12345端口，并绑定了一个恶意的工厂类，这次我们将恶意代码放入到这个工厂类的构造函数中，比如：</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p5.qhimg.com/t016e247017465c1a2a.png" title="t01b895a66975808913.png" alt="http://p1.qhimg.com/t01b895a66975808913.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">然后，如果某个应用的lookup方法的参数是我们可控的，就可以填入我们的恶意服务URL，类似下面这种。</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p1.qhimg.com/t019bde52000e8471c6.png" title="t01a294bd82d474f1c3.png" alt="http://p5.qhimg.com/t01a294bd82d474f1c3.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">原理很简单，工厂类最终会在客户端进行实例化，实例化时就会调用构造函数中的代码，从而达到任意代码执行的效果，注意，实例化工厂类的是NamingManager，根据JNDI的架构，这个类是不受Java安全管理器约束的。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3.2.4 恶意远程对象</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">通过远程对象来进行JNDI注入，难度比较大，要求有权限修改codebase以及java.rmi.server.useCodebaseOnly必须为False（JDK 7u21后默认为true）。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">由于运用难度大并且有很大的局限性，所以这里就不进行介绍了。</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3.2.5 攻击过程</span></strong></p><p style="text-indent: 2em; text-align: center;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p7.qhimg.com/t013dc79f4f212e4e31.png" title="t01b6d116bff3f6a1f1.png" alt="http://p8.qhimg.com/t01b6d116bff3f6a1f1.png"/></span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">配合Ref Payload的Demo，我们不难理解通过RMI进行JNDI注入的攻击流程：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（1） &nbsp; &nbsp;首先攻击者将RMI绝对路径注入到lookup方法中。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（2） &nbsp; &nbsp;受害者RMI服务器会请求攻击者事先搭建好的恶意RMI服务器</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（3） &nbsp; &nbsp;恶意服务器返回Payload（恶意远程对象）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（4） &nbsp; &nbsp;恶意代码在受害者服务器执行。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">值得注意的是，像InitialContext.rename()和InitialContext.lookupLink()方法也会受到影响，因为它们最终还是调用了lookup方法。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3.2.6 Toplink/EclipseLink</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">JPA（持久化技术）是ORM的统一标准，Toplink是JPA的一种实现，常用的hibernate也是。EclipseLink是以Toplink为基础的开源项目。来看看JNDI的真实场景：</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p2.qhimg.com/t01a2bdd0a3d3f797aa.png" title="t01a385b2341845cc8c.png" alt="http://p1.qhimg.com/t01a385b2341845cc8c.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在基础操作中处理POST请求的过程中，调用了callSessionBeanInternal，跟进这个方法：</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p3.qhimg.com/t01ccfecdd902c37e15.png" title="t019b994c3dcf365591.png" alt="http://p4.qhimg.com/t019b994c3dcf365591.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Lookup传入的参数是可控的，通过http请求可以做到，标准的JNDI注入。攻击者可以利用JNDI注入漏洞来实现任意代码执行。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3.2.7 与反序列化配合</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">本质上原理相同，readObject方法中有可控的lookup参数。</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p4.qhimg.com/t011671fe5bd34cab82.png" title="t013a86687c20bc4740.png" alt="http://p1.qhimg.com/t013a86687c20bc4740.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">比如Spring框架爆出的这个反序列化漏洞，执行过程如下：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">org.springframework.transaction.jta.JtaTransactionManager.readObject()方法中调用了IntinailContext.lookup方法，调用过程如下：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">l &nbsp;initUserTransactionAndTransactionManager()</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">l &nbsp;initUserTransactionAndTransactionManager()</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">l &nbsp;JndiTemplate.lookup()</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">l &nbsp;InitialContext.lookup()</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">InitialContext.lookup()这个方法中的传入参数”userTransactionName”是用户可控的，所以造成了JNDI注入。BlackHat上的议题中还提到了其他的例子，这里就不一一介绍了。</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3.3 CORBA攻击向量</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">CORBA的JNDI注入原理和RMI的差不多，但是有SecurityManager的限制，然而，议题的演讲者找到了一个绕过SecurityManager的方法，但是由于正在被修复中，所以在议题中并没有透漏这个方法。感兴趣的同学可以关注一下，在几个绕过中，已经有一个获得了CVE编号（CVE-2016-5018）。</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3.4 LDAP攻击向量</span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3.4.1 LDAP基础</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">LDAP是轻量级目录访问协议，通过LDAP，用户可以连接，查询，更新远程服务器上的目录。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">对象在LDAP上有两种存储方式：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（1） &nbsp; &nbsp;利用Java序列化方式</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（2） &nbsp; &nbsp;利用JDNI的References对象引用</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这两种方式都有可能造成命令执行。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3.4.2 攻击流程</span></strong></p><p style="text-indent: 2em; text-align: center;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p8.qhimg.com/t0102799da955a58cac.png" title="t01e71382d81bca60ba.png" alt="http://p0.qhimg.com/t01e71382d81bca60ba.png"/></span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">1. &nbsp; &nbsp; &nbsp;攻击者提供一个LDAP的绝对路径URL注入到JNDI的lookup方法</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">2. &nbsp; &nbsp; &nbsp;受害者服务器连接到攻击者的恶意LDAP服务，并返回一个恶意的远程对象引用。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3. &nbsp; &nbsp; &nbsp;受害者服务器对JNDI远程对象引用Reference进行decode操作。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">4. &nbsp; &nbsp; &nbsp;受害者服务器获取到了恶意的工厂对象。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">5. &nbsp; &nbsp; &nbsp;受害者服务器实例化这个工厂对象。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">6. &nbsp; &nbsp; &nbsp;工厂对象中的恶意代码被触发执行。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">LDAP的情境下，对于lookup方法的注入和漏洞触发原理本质上和RMI的一致。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3.4.3 LDAP实体投毒</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">实际上，lookup方法恶意注入的场景是非常少见的。大部分的操作都是在对象层面的操作，比如增删改查等。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">LDAP编程中，通常会使用search方法来查询一个目录对象，单纯的一个查询是无法做到命令执行的，但是议题作者发现，当returnObjFlag设置为true时，攻击者可以控制LDAP的返回并引发任意命令执行的漏洞。</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">对象返回查询</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">LDAP编程中使用</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">SearchControls对象作为参数来标识查询范围以及查询返回值的形式。这个对象中有个方法是setReturningObjFlag(boolean)，当设置为true时（默认为false），使用search方法查询后会返回一个对象结构。</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p3.qhimg.com/t0175ff2469362cbfd1.png" title="t0174ed76dbd8c4bbaa.png" alt="http://p7.qhimg.com/t0174ed76dbd8c4bbaa.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">当returnObjFlag设置为true时，查看源码，可以看到调用了decodeObject方法转化为对象。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Java对象表现协议</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在RFC 2713中，详细的定义了不同的Java对象在LDAP目录系统中的表现和存储形式。</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">1. &nbsp; &nbsp; &nbsp;序列化对象</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">序列化对象在LDAP中的表示如下：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">l &nbsp;javaClassName：类的全称</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">l &nbsp;javaClassNames：类定义所继承的父类，接口的名称集合</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">l &nbsp;javaCodebase：指向class定义的位置</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">l &nbsp;javaSerializedData：包含序列化之后的对象数据</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">2. &nbsp; &nbsp; &nbsp;Marshalled Objects</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">和序列化对象差不多，但是会记录javaCodebase.</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3. &nbsp; &nbsp; &nbsp;JNDI References</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">引用类型对象包含了javaClassName,javaClassNames, javaCodebase。除此之外，还有：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">l &nbsp;javaReferenceAddress：存储引用地址的列表。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">l &nbsp;javaFactory：存储工厂类的类名全称。</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">攻击向量</span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">1. &nbsp; &nbsp; &nbsp;反序列化</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">当JNDI中对象的javaSerializedData不为空时，decodeObject方法就会对这个字段的内容进行反序列化（Obj.decodeObject(Attributesattrs)）：</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p8.qhimg.com/t01742d50f4ce46d8f3.png" title="t012e985a1ea6898096.png" alt="http://p2.qhimg.com/t012e985a1ea6898096.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这里javaCodebase可以指定远程的URL，黑客只需要在readObject方法中编写恶意代码就能执行，当然需要服务器端配置com.sun.jndi.object.trustURLCodebase=true</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">来避开JVM的安全管理器。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">当LDAP服务器没有这种设置时，攻击者仍然可以使用一些存在于服务器端的有漏洞的类来执行代码。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">LDAP投毒的代码如下，这里是指定了javaCodebase进行攻击：</span></p><p style="text-align:center"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p8.qhimg.com/t01f2125c921a063c76.png" title="t01a34c220c8f4af93d.png" alt="http://p4.qhimg.com/t01a34c220c8f4af93d.png"/></span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">2. &nbsp; &nbsp; &nbsp;JNDIReference</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">LDAP中，也是由Naming Manager来处理引用类型的对象，并做实例化的。Naming Manager会检查javaFactory和javaCodebase是否是存在的，如果存在，则从javaCodebase中获取javaFactory进行实例化。正如前面所说的，对于Naming Manager，JVM的安全管理机制太过于宽松。因此，攻击者就可以通过控制这些属性来执行恶意代码。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">下面的代码是Obj.decodeObject(Attributesattrs)中实例化Reference的代码：</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p2.qhimg.com/t01b8f33e5b19f02303.png" title="t0103f536df1e8d2271.png" alt="http://p4.qhimg.com/t0103f536df1e8d2271.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这里的decodeReference方法中对Reference进行了组装：</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p6.qhimg.com/t014b2a4728db19d102.png" title="t01512e14b6e83ea8a1.png" alt="http://p8.qhimg.com/t01512e14b6e83ea8a1.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">可以看到这个代码和JNDI注入的代码是一致的。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">攻击代码如下：</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p3.qhimg.com/t01521e659e856f0032.png" title="t012f809e99cc7fb7e8.png" alt="http://p3.qhimg.com/t012f809e99cc7fb7e8.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3. &nbsp; &nbsp; &nbsp;RemoteLocation</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">javaRemoteLocation属性在RFC中是被废除的，但是JNDI还是能支持这个属性的处理。相关代码如下：</span></p><p style="text-align:center"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p7.qhimg.com/t01afa7d7cbec21b4d6.png" title="t01320f22e48ec7f913.png" alt="http://p9.qhimg.com/t01320f22e48ec7f913.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">可以看到，当指定javaRemoteLocation时，JNDI会根据URL获取到对应的Reference，实例化之后就会触发漏洞代码，和RMI的情景如出一辙。</span></p><p style="text-align:center"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p8.qhimg.com/t01f249544564545ef2.png" title="t0199beddcf63e47b65.png" alt="http://p0.qhimg.com/t0199beddcf63e47b65.png"/></span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3.4.4 攻击场景</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在LDAP中修改对应的Java属性，当LDAP中查询后实例化查询结果时，就会触发漏洞。具体来讲，是LdapSearchEnumeration类对LDAP查询响应进行实例化，本质上还是通过注入外部的工厂类来污染Reference。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">对攻击过程进行总结，大致是两个方向：</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">1. &nbsp; &nbsp; &nbsp;针对LDAP条目</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（1） &nbsp; &nbsp;攻击者污染一个LDAP条目，并且注入恶意的Java协议属性。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（2） &nbsp; &nbsp;攻击者向LDAPserver发起一个查询（比如LDAP认证的时候）。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（3） &nbsp; &nbsp;受害应用执行LDAP查询并获取受到污染的实体。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（4） &nbsp; &nbsp;受害应用将条目转换为java对象。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（5） &nbsp; &nbsp;受害应用从攻击者控制的服务器上获取恶意的工厂类。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（6） &nbsp; &nbsp;受害应用在实例化工厂类的时候执行了恶意代码。</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">2. &nbsp; &nbsp; &nbsp;针对LDAP响应</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（1） &nbsp; &nbsp;攻击者强制受害应用发起一个LDAP查询（比如认证的时候），或者等待该应用发起一次LDAP查询。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（2） &nbsp; &nbsp;应用发起一次LDAP查询，并获取一个条目</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（3） &nbsp; &nbsp;攻击者拦截并修改LDAP查询的响应，将恶意的Java协议属性注入到响应中。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（4） &nbsp; &nbsp;受害应用对该响应进行实例化时触发恶意代码</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3.4.5 返回对象的查询方式</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">设置returnObjFlag为true的写法还是挺常见的，因为查询过后直接返回对象，操作起来非常方便。</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Spring Security案例</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Spring security是一个Java应用常见的认证和鉴别的框架。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这个库提供了一个查询指定用户名的方法：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">FilterBasedLdapUserSearch.searchForUser(String username). 这个方法是Spring Security获取正在认证的用户信息的。这个方法用到了SpringSecurityLdapTemplate类：</span></p><p style="text-align:center"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p0.qhimg.com/t01ff2d9fd8ee2ee7c2.png" title="t01f6c6287b60f19f16.png" alt="http://p3.qhimg.com/t01f6c6287b60f19f16.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">跟进这个方法：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">继续跟进，可以看到查询的代码：</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p3.qhimg.com/t012a656f31dd5e751e.png" title="t014b1e6d9468b0dd60.png" alt="http://p6.qhimg.com/t014b1e6d9468b0dd60.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在buildControls中，可以看到设置了RETURN_OBJECT为true：</span></p><p style="text-align:center"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p0.qhimg.com/t015ea60200a66012c4.png" title="t010ae0935a01e29d87.png" alt="http://p0.qhimg.com/t010ae0935a01e29d87.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">显然，这个漏洞是针对条目的一种形式，由于设置了查询结果返回为java对象，JNDI会自动将查询结果进行某种decode来转为Java对象，实例化过程中触发漏洞。通过修改java协议属性来复现：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">1. &nbsp; &nbsp; &nbsp;首先写一个恶意的工厂类，在构造函数中执行恶意代码。</span></p><p style="text-align:center"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p2.qhimg.com/t017093c2d1007ef207.png" title="t01abb40786d758488c.png" alt="http://p4.qhimg.com/t01abb40786d758488c.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">2. &nbsp; &nbsp;污染条目</span></p><p style="text-align:center"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p0.qhimg.com/t01992c58c8fac8f396.png" title="t0113b3094cfea0b326.png" alt="http://p6.qhimg.com/t0113b3094cfea0b326.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">重点是修改了javaFactory和javaCodebase，指向了我们的恶意工厂类。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3. &nbsp; &nbsp; &nbsp;触发search方法</span></p><p style="text-align:center"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p8.qhimg.com/t01f9944221396ecced.png" title="t0137d2e41e70254f3a.png" alt="http://p3.qhimg.com/t0137d2e41e70254f3a.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">只需要尝试登陆一下即可触发LDAP执行search操作，从而执行我们的恶意代码。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">1. &nbsp; &nbsp; &nbsp;执行恶意代码。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Spring LDAP案例</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">还是同样的原因，这里只分析下源码：</span></p><p style="text-indent: 2em; text-align: center;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p4.qhimg.com/t0126db0fcfb2fc4e5e.png" title="t01e7cd851845e7b825.png" alt="http://p4.qhimg.com/t01e7cd851845e7b825.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">受影响的是authenticate方法，调用了search方法，跟进之后发现也同样设置了returnObjFlag，利用思路和前面一致。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（四）总结</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></strong></span><br/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">议题中介绍了两种新型的攻击方式——JNDI攻击和LDAP条目污染。两种方式都是非常高危的漏洞，并且可以执行任意的代码。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">为了防范这两种类型的漏洞，可以做以下措施：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">1. &nbsp; &nbsp; &nbsp;不要将不可信的数据传入InitialContext.lookup方法中。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">如果必须这么做，那么要确保参数不是绝对路径的URL。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">2. &nbsp; &nbsp; &nbsp;使用安全管理器时，需要仔细审计安全策略。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3. &nbsp; &nbsp; &nbsp;尽可能禁止远程的codebase</span></p></p>
                <hr/>
                <p style="text-align: center;">
                    <img src="http://bobao.360.cn/img/app.jpeg"/>
                    <img src="http://bobao.360.cn/img/weixin.jpeg"/>
                </p>
                                <p>本文转载自 <br/><a class="text-more" href="http://blog.csdn.net/u011721501/article/details/52316225" target="_blank">原文链接：http://blog.csdn.net/u011721501/article/details/52316225</a></p>
                            </div>
            <div style="margin-top: 20px;background-color:#FFFFFF">
    <input type="hidden" id="detail_title" name="detail_title" value="【技术分享】BlackHat2016——JDNI注入/LDAP Entry污染攻击技术研究 - 安全客 - 有思想的安全新媒体" />
    <input type="hidden" id="use_nickname" name="use_nickname" value="0" />
    <a name="mao"></a>
    <div class="reg-log mobile-hiden">
        <div class="" id="userTo">   
            <div id="to-list" class="input-text" style="">
                <textarea disabled="disabled" class="hide"  id="comment-content" to="to"></textarea>
                <ul id="preadded" style="display:none">       
                </ul>
                <div id="to-auto" style="width: 200px">
                    <ul id="feed">
                    </ul>
                </div>
            </div>
        </div>
        <input type="hidden" id="source-id" value="2999" />
        <input type="hidden" id="source-type" value="learning" />
        <input type="hidden" id="post-comment-url" value="/comment/add" />
        <input type="hidden" id="post-nickname-url-ajax" value="/comment/randnicknameajax" />
        <input type="hidden" id="post-check-login-url-ajax" value="/comment/checklogin" />
        <input type="hidden" id="stoken_comment_set" value="ea3898fb4df38673fdeb61c458234054">                 <span class="join">参与讨论，请先 <a href="javascript:;" class="comment-login">登录</a> | <a href="javascript:;" class="comment-reg">注册</a> |  <a href="javascript:;" class="anonymous-comment">匿名评论</a></span>
            </div>
    <div class="mobile-hide" style="width: 870px; margin: 0 auto;">
        <label style="vertical-align:middle;" for="use_nickname">匿名</label> 
        <input style="vertical-align:middle;" id="trigger-nickname" name="use_nickname" class="use_nickname" type="checkbox" value="0" />

        <a href="javascript:;" class="apply-use button" id="submit-comment" data-target="/comment/add">发布</a>
    </div>


    <div class="clearfix"></div>
    <div class="comments">
        <div class="comments-head">
            <span class="title">用户评论</span>
        </div>
                <div class="comment-none alarm-info bg-primary">无任何评论</div>
            </div>
</div>
<script>
    $(function () {
        $('.anonymous-comment').click(function () {
            $(".join").hide();
            $(".reg-log textarea").first().removeAttr("disabled").show();
            $('#use_nickname').val('1');
//            $('#trigger-nickname').attr('checked', true);
            $('#trigger-nickname').trigger('click');
        });
        //为所有复选框绑定事件
//        checkbox_on_click();
        //ajax随机获取昵称
//        randnicknameajax(0);
        //ajax检测登录状态
        comment_check_login();
    });



    function input_checkbox(flag) {
        $('input:checkbox').each(function () {
            var value = flag ? 1 : 0;
            $(this).prop('checked', flag);
            $(this).val(value);
        });
    }

//ajax随机获取昵称
    function randnicknameajax(flag) {
        $.ajax({
            type: 'POST',
            url: $('#post-nickname-url-ajax').val(),
            data: {limit: 1, flag: flag},
            dataType: "json",
            success: function (data) {
                $('#nick-name').val(data.data[0]);
                _nick_name=data.data[0];
            }
        });
    }
    $();
//ajax检测登录状态
    function comment_check_login() {
        $.ajax({
            type: 'POST',
            url: $('#post-check-login-url-ajax').val(),
            data: {},
            dataType: "json",
            success: function (data) {
                if (data.success) {
                    $('.join').hide();
                    $(".reg-log textarea").first().removeAttr("disabled").show();
                    $("#span_use_nickname").show();
                    $('#use_nickname').val('0');
                    $('#use_nickname').attr('checked', false);
                }
            }
        });
    }
</script>        </div>
    </div>
    <div class="side-bar">
        <div class="mod hot-news">
    <div class="head-bar clearfix">
        <h2><i class="icon icon-hot"></i><span>热门知识</span></h2>
    </div>
    <ul class="links-list">
                                <li><a href="/learning/detail/4411.html" alt="【漏洞预警】一个换行符引发的奥斯卡0day漏洞(CVE-2017-8759)重现——最新的Office高级威胁攻击预警" target="_blank">【漏洞预警】一个换行符引发的奥斯卡...</a></li>
                                <li><a href="/learning/detail/4416.html" alt="【漏洞预警】Microsoft .NET Framework漏洞（CVE–2017–8759）预警" target="_blank">【漏洞预警】Microsoft .NE...</a></li>
                                <li><a href="/learning/detail/4414.html" alt="【技术分享】妙用JavaScript绕过XSS过滤" target="_blank">【技术分享】妙用JavaScrip...</a></li>
                                <li><a href="/learning/detail/4418.html" alt="【技术分享】利用威胁情报数据平台拓展APT攻击线索一例" target="_blank">【技术分享】利用威胁情报数据平台拓...</a></li>
                                <li><a href="/learning/detail/4417.html" alt="【知识】9月15日 - 每日安全知识热点" target="_blank">【知识】9月15日 - 每日安全知识热...</a></li>
                                <li><a href="/learning/detail/4425.html" alt="【安全报告】XShellGhost事件技术回顾报告" target="_blank">【安全报告】XShellGhost事件...</a></li>
            </ul>
</div>        <!-- 友情链接 -->
        <div class="mod blog-links mobile-hide">
    <div class="head-bar clearfix">
        <h2><i class="icon icon-link"></i><span>友情链接</span></h2>
        <a href="/links/index.html" class="more">更多<i></i></a>
    </div>
        <ul class="links-list">
                <li><a href="http://bbs.360safe.com" alt="360安全社区" target="_blank">360安全社区</a></li>
                <li><a href="http://zhuji.360.cn" alt="360主机卫士" target="_blank">360主机卫士</a></li>
                <li><a href="http://blogs.360.cn/" alt="奇虎360技术博客" target="_blank">奇虎360技术博客</a></li>
                <li><a href="http://wangzhan.360.cn/" alt="360网站卫士" target="_blank">360网站卫士</a></li>
                <li><a href="http://webscan.360.cn/" alt="360网站安全检测" target="_blank">360网站安全检测</a></li>
                <li><a href="http://research.360.cn/report/" alt="360研究报告" target="_blank">360研究报告</a></li>
                <li><a href="http://unicorn.360.cn/" alt="360 Unicorn Team" target="_blank">360 Unicorn Team</a></li>
                <li><a href="http://appscan.360.cn/" alt="360捉虫猎手" target="_blank">360捉虫猎手</a></li>
                <li><a href="https://threathunter.org/" alt="ThreatHunter社区" target="_blank">ThreatHunter社区</a></li>
                <li><a href="http://security.360.cn/" alt="360安全应急响应中心" target="_blank">360安全应急响应中心</a></li>
            </ul>
    </div>
        <!-- 联系我们 -->
        <div class="mod contact mobile-hide" style="text-align:center">
    <div class="head-bar clearfix">
        <h2><i></i><span>关注我们</span></h2>
    </div>
    <!-- 微信关注 -->
    <ul class="contact-way">
        <li><a>微信关注</a></li>
    </ul>
    <div style="padding-left:20px;padding-bottom:15px;">
    <img src="/img/qrcode_adlab_weixin.png?v=1.1"  width="145px" height="145px;"/>
    </div>
    
    <!-- APP下载 -->
    <ul class="contact-way">
        <li><a>安全播报APP</a></li>
    </ul>
    <div style="padding-left:20px;padding-bottom:15px;">
    <img src="/img/scan_code_big.png?v=1.1"  width="145px" height="145px;"/>
    </div>
    
</div>

    </div>
</div>

<script type="text/javascript" src="/js/jquery-ui.min.js?v=3.0"></script>
<script type="text/javascript" src="/js/jquery.noty.packaged.min.js?v=3.0"></script>
<script type="text/javascript" src="/js/common.js?v=4.5"></script>
<script>$(function() {sync_count('comment');});</script>


<!-- 语法高亮 -->
<script type="text/javascript" src="/ue/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">SyntaxHighlighter.all();sync_count('vul');sync_count('news');sync_count('learning');sync_count('activity');sync_count('course');sync_count('ctf');</script>
    </div>

        <div class="footer">
        <div class="friend-link">
            <a href="http://www.360.cn/" target="_blank">360首页</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">关于我们</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">联系我们</a>
            <span>|</span>
            <a href="/links/index.html" target="_blank">友情链接</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">招贤纳士</a>
        </div>
        <div class="copy">
            Copyright &copy; 360网络攻防实验室 All Rights Reserved <span class="copy_icp">京ICP证080047号[京ICP备08010314号-6]</span>
        </div>
    </div>
    
</div>

<!--奇舞团统计-->

<script src='https://s.ssl.qhimg.com/static/f5407c785655e6a1/monitor_analytic.js'></script>
<script>
    monitor.setProject('QH_171_1').getTrack().getClickAndKeydown().getClickHeatmap(10, 1);
</script>

<div class="hide">
    <script src="https://s95.cnzz.com/z_stat.php?id=1253147824&web_id=1253147824" language="JavaScript"></script>
</div>
<div class="backToTop_wrap off">
    <a id="back_to_top" class="backToTop" href="javascript:;" title="返回顶部"></a>
</div>
<script>
    var $backToTop_wrap = $(".backToTop_wrap"),
        $backToTop_btn = $("#back_to_top");

    if ($(window).scrollTop() > 100) {
        $backToTop_wrap.removeClass("off");
    }
    else {
        $backToTop_wrap.addClass("off");
    }

    $(window).on("scroll", function () {
        if ($(this).scrollTop() > 100) {
            $backToTop_wrap.removeClass("off");
        }
        else {
            $backToTop_wrap.addClass("off");
        }
    });

    $backToTop_btn.on("click", function () {
        $("html, body").animate({scrollTop: 0}, 120);
    });

    $(function () {
        var navlist = $('.nav-list > li');

        navlist.each(function () {
            $(this).on('mouseenter', function () {
                $(this).addClass('selected');
            });

            $(this).on('mouseleave', function () {
                $(this).removeClass('selected');
            });
        });
    })
</script>



</body>
</html>
