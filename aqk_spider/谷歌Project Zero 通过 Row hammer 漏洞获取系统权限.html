<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:wb="http://open.weibo.com/wb" xml:lang="en" lang="en">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="viewport"
          content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"/>
    <link rel="shortcut icon" href="http://bobao.360.cn/favicon.ico?v=1.1"/>
    <link rel="alternate" title="安全资讯" href="/rss?type=news" type="application/rss+xml"/>
    <link rel="alternate" title="安全知识" href="/rss?type=learning" type="application/rss+xml"/>
    <link rel="alternate" title="安全圈活动" href="/rss?type=activity" type="application/rss+xml"/>
    <link rel="alternate" title="所有漏洞" href="/rss?type=vul" type="application/rss+xml"/>
    <link rel="alternate" title="通用型漏洞" href="/rss?type=commonvul" type="application/rss+xml"/>
    <link rel="alternate" title="事件型漏洞" href="/rss?type=eventvul" type="application/rss+xml"/>
    <link rel="alternate" title="热门漏洞" href="/rss?type=hotvul" type="application/rss+xml"/>

        <title>谷歌Project Zero：通过“Row hammer”漏洞获取系统权限 - 安全客 - 有思想的安全新媒体</title>
    
        <meta name="keywords" content="Row hammer,漏洞,系统权限"/>
    
        <meta name="description" content="“Row hammer”是指，最近一些DRAM设备上反复访问一行内存可能造成相邻内存行的bit翻转问题。我们测试了一系列笔记本，并发现其中一部分存在这个问题。我们利用这个问题，开发了两套可用的提权溢出。一个溢出在64位Linux的Ring3受限用户进程中，使用“Row hammer——引导”bit翻转，来获得Ring0权限。"/>
        <meta property="wb:webmaster" content="224437c7be31d633"/>

    <script type="text/javascript" src="http://s7.qhimg.com/!56caa871/xpc_sync_height.js"></script>
    <link rel="stylesheet" type="text/css" href="/css/reset.css" />
    <link rel="stylesheet" type="text/css" href="/css/common_new.css?v=4.4.2.1" />
    <link rel="stylesheet" type="text/css" href="/css/jquery.notyfy.css" />
    <link rel="stylesheet" type="text/css" href="/css/notyfy.theme.default.css" />
    <link rel="stylesheet" type="text/css" href="/css/s_common.css?v=2.2.7" media="only screen and
    (max-device-width:900px), only screen and (max-width:900px)" />
    <script type="text/javascript" src="/js/jquery.min.js?v=3.1"></script>
    <script type="text/javascript" src="/js/jquery.notyfy.js"></script>
    <script type="text/javascript" src="/js/iscroll.js"></script>
    <script src="http://js.passport.qihucdn.com/5.0.3.js"></script>
    <script type="text/javascript">
        var myScroll, myNavScroll;

        function iscrollLoaded() {
            myScroll = new IScroll('#wrapper',
                {
                    scrollX: true,
                    scrollY: false,
                    bounceEasing: 'circular',
                    eventPassthrough: true,
                    preventDefault: false,
                    bounceTime: 500
                }
            );
        }

        $(function () {

            //导航横向滚动


            function setNavWidth() {

                /* 计算导航宽度 */
                var allWidth = $(window).width();
                var scroller = $('#scroller');

                if (allWidth > 900) {
                    scroller.find('ul').add(scroller.find('.scroll')).removeAttr('style');
                    scroller.css('overflow', 'visible');
                    if (myNavScroll) myNavScroll.destroy();
                } else {

                    var width = 0;
                    scroller.find('.scroll').children('ul').children('li').each(function (index, el) {
                        if (!$(this).hasClass('mobile-hide')) {
                            width += $(this).outerWidth();
                        }
                    });
                    scroller.find('ul').add(scroller.find('.scroll')).width(width);

                    if (myNavScroll) myNavScroll.destroy();

                    myNavScroll = new IScroll('#scroller', {
                        scrollX: true,
                        scrollY: false,
                        momentum: false,
                        click: true
                    });

                }

            }

            setNavWidth();
            $(window).resize(function (event) {
                setNavWidth();
            });

        });

    </script>
</head>
<body onload="iscrollLoaded();">
<div style='margin:0 auto;width:0px;height:0px;overflow:hidden;'>
    <img src=""/>
</div>

<div id="is-mobile"></div>
<div class="container">
        <div class="mobile-header">
        <div class="header clearfix">
            <div class="header-wrapper clearfix">
                <a href="/index/index" class="logo"><img class="slogan" src="/img/logo.png?v=1.5"/></a>
                                <form id="search" class="search-box" action="/search/index" method="GET">
                    <input class="keys" name="keywords" type="text" placeholder="搜索漏洞" required="required">
                    <input class="icon" type="submit" value="">
                    <input type="hidden" name="type" value=""/>
                </form>
                <div class="bug">
                    <div class="name"><span class="seled">全部</span><i class="arrow"></i></div>
                    <ul class="typelist">
                        <li data-index="3"><a href="javascript:void(0);">全部</a></li>
                        <li data-index="0"><a href="javascript:void(0);">漏洞</a></li>
                        <li data-index="1"><a href="javascript:void(0);">资讯</a></li>
                        <li data-index="2"><a href="javascript:void(0);">知识</a></li>
                    </ul>
                </div>
                                <div class="logNreg mobile-hide">
                    <div class="unlog">
                        <i></i>
                        <a href="log.html" class="log">登录</a>
                        <span>|</span>
                        <a href="reg.html" class="reg">注册</a>
                    </div>
                    <div class="loged">
                        <a href="/member/profile" class="user-center"><i></i><span class="user-name-tag">个人中心</span></a>
                        <div class="user-links">
                            <span class="arrow"></span>
                            <ul>
                                <li class="account-setting"><a href="http://i.360.cn/profile/accountmanage"
                                                               target="_blank"><i></i><span>账号设置</span></a></li>
                                <li class="alert-setting"><a href="/keywords/index"
                                                             target="_blank"><i></i><span>告警设置</span></a></li>
                                <li class="bug-alert"><a href="/myalarm/index" target="_blank"><i></i><span>漏洞告警</span></a>
                                </li>
                                <li class="my-knowl"><a href="/mylearn/index" target="_blank"><i></i><span>我的知识</span></a>
                                </li>
                                <li class="my-knowl"><a href="/mycourse/index" target="_blank"><i></i><span>我的课堂</span></a>
                                </li>
                                <li class="my-exit"><a
                                            href="http://login.360.cn/?src=pcw_adlab&op=logout&destUrl=http://bobao.360.cn"><i></i><span>退出系统</span></a>
                                </li>
                            </ul>
                        </div>

                        <a href="/message" class="message-center" target="_blank"><i></i><span>我的消息</span></a>
                        <div class="message-links">
                            <span class="arrow"></span>
                            <ul>
                                <li class="account-setting" style="display:none;"><a href="/myres/index"
                                                                                     target="_blank"><i></i><span>回复我的</span></a>
                                </li>
                                <li class="my-bug"><a href="/myvul/index"
                                                      target="_blank"><i></i><span>我的漏洞</span></a></li>
                                <!--<li class="my-bug"><a href="/myres/index" target="_blank"><i></i><span>我的评论</span></a></li>-->
                                <!--<li class="alert-setting"><a href="###" target="_blank"><i></i><span>提到我的</span></a>
                                </li>-->
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <style type="text/css">
            .nav {
                overflow: hidden;
            }

            .nav .scroll {
                width: auto;
            }
        </style>
        <div id="wrapper">
            <div id="scroller" class="nav">
                <div class="scroll">
                    <ul class="nav-list">
                        <li ><a class="link-nav"
                                                                                 href="/index/index">首页</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/vul/index">漏洞</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/introduce/list">招聘</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/news/index">资讯</a><!--<i class="arrow mobile-hide"></i>
                        <ul class="subnav-list mobile-hide">
                            <li><a class="link-subnav" href="/introduce/list">招聘</a></li>
                        </ul>
			-->
                        </li>
                        <li class="cur">
                        <a class="link-nav" href="/learning/index">知识</a><i class="arrow mobile-hide"></i>
                        <ul class="subnav-list mobile-hide">
                            <li><a class="link-subnav" href="/course/index">学院</a></li>
                        </ul>
                        </li>
                        <li ><a class="link-nav"
                                                               href="/activity/index">活动</a></li>
                        <li class="mobile-hide "><a class="link-nav"
                                                                                                   href="/ctf/index">CTF训练营</a>
                        </li>
                        <li ><a class="link-nav"
                                                               href="/interref/list">安全内参</a></li>
                        <li ><a class="link-nav" href="/app/index">APP</a></li>

                        <!--<li ><a href="/course/index">学院</a></li>-->
                        <!--<li ><a href="/introduce/list">招聘</a></li>-->
                        <!--<li  class="mobile-hide"><a href="/ctf/index">CTF训练营</a></li>-->
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <div class="mobile-content">
        <link rel="stylesheet" type="text/css" href="/css/news.css?v=3.5" />
<link rel="stylesheet" type="text/css" href="/ue/SyntaxHighlighter/shCoreDefault.css?v=1.0" />
<style>
    p .syntaxhighlighter {
        width: 80%;
    }
</style>

<div class="cur-pos w1000">当前位置：<a href="http://bobao.360.cn/">安全客</a> &gt;&gt; 知识详情</div>

<div class="content clearfix">
    <div class="main">
        <div class="article">
            <div id="article_box">
                <h2>谷歌Project Zero：通过“Row hammer”漏洞获取系统权限</h2>
                <div class="article-msg">
                    <span class="time">2015-03-16 11:54:58</span>
                                        <span class="read">阅读：26938次</span>
                    <span><a style="display: none;" class="good" href="javascript:;"
                             data-target="/learning/good" data-value="g_302"
                             data-type="learning">点赞(0)</a></span>
                    <span><a class="fav" href="javascript:;" data-target="/mylearning/add"
                             data-pk="302" data-type="learning">收藏</a></span>
                                        <span><a style="margin-left: 4px;" class="fav" href="http://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html"
                             target="_blank">来源： 360安全播报</a></span>
                    
                                    </div>
                <hr size="1">
                <div class="article-msg">
                    <p><!-- JiaThis Button BEGIN -->

<!--
<span class="jiathis_style"><span class="jiathis_txt">分享到：</span>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_tsina"></a>
    <a class="jiathis_button_tqq"></a>
    <a class="jiathis_button_qzone"></a>
    <a class="jiathis_button_renren"></a>
    <a class="jiathis_button_xiaoyou"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
</span>

-->
</p>
                </div>
                <p><p style="text-align:center"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;"><img alt="http://p6.qhimg.com/t014f17d8ef30d0800b.jpg" src="http://p6.qhimg.com/t014f17d8ef30d0800b.jpg" title="t014f17d8ef30d0800b.jpg"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">本文作者：Mark Seaborn,沙盒制作和逃逸。以及逆向工程师Thomas Dullien</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212);"><strong><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;">概述</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">“Row hammer”是指，最近一些DRAM设备上反复访问一行内存可能造成相邻内存行的bit翻转问题。我们测试了一系列笔记本，并发现其中一部分存在这个问题。我们利用这个问题，开发了两套可用的提权溢出。一个溢出在64位Linux的Ring3受限用户进程中，使用“Row hammer——引导”bit翻转，来获得Ring0权限。当程序跑在存在“Rowhammer”问题的主机中时，进程可以在PTE中印发bit翻转。这可以用来获得内存页的写入权限，进而获得全部物理内存的读写权限。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们还不确定到底有多少台计算机存在这个问题，也不知道有多少存在问题的主机可以修复。我们的溢出程序使用x86指令clflush来获得访问底层DRAM的权限，但是其他的技术是可以用在非x86系统上。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们期望我们基于PTE修改的溢出可以在其他操作系统上使用；这个问题不是Linux独有的。引起PTE表中的bit翻转仅仅是溢出的一种方法；其他的通过bit翻转的溢出也同样有效。我们前文提到的另一个溢出将通过Native Client沙盒逃逸来证明不仅仅可以修改PTE</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212); font-size: 16px;"><strong><span style="color: rgb(84, 141, 212); font-family: 微软雅黑,Microsoft YaHei;">“Rowhammer”问题介绍</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们从Yoongu Kim等人的论文《Flipping Bits in Memory Without Accessing Them:</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">An Experimental Study of DRAM Disturbance Errors》（全部作者：Yoongu Kim，Ross Daly，Jeremie Kim，Chris Fallin，Ji Hye Lee，Donghyuk Lee，Chris Wilkerson，Konrad Lai，Onur Mutlu，Carnegie Mellon University，Intel Labs）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">在论文中，他们演示，通过反复访问同一进程中的两个“敲击”内存地址，可以在被叫做“受波及”的地址引起bit翻转。这个地址很可能位于当前进程虚拟地址以外的内存空间——在与当前的“敲击”内存不同的行中，也就是存在于一个不同的4k内存页中（也是由于当前流行的内存Bank中每一行的容量都大于4k的缘故）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">这个问题是由于存储单元（内存存储的最小计算单元）现在做的越来越小，也越来越紧凑。由于内存制造业不断改进芯片工艺以容纳更多的存储单元，这使得保护存储单元远离相互之间的电器性影响越来越难。因此，访问一个内存地址是会影响到周围的内存，引发电荷逃逸或进入相邻的存储单元。当进行了足够次数的访问，就可以将一个存储单元从0变为1或者从1变为0。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">这篇论文解释道，下面这个简短的代码片就可以导致bit翻转。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">code1a:</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">&nbsp; mov (X), %eax&nbsp; // Read from address X</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">&nbsp; mov (Y), %ebx&nbsp; // Read from address Y</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">&nbsp; clflush (X)&nbsp; // Flush cache for address X</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">&nbsp; clflush (Y)&nbsp; // Flush cache for address Y</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">&nbsp; jmp code1a</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">两个引发bit翻转的的必要因素：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">地址的选取：要使用代码片code1a来引发bit翻转，需要地址X和地址Y位&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 于同一个内存Bank的不同行中。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">一些背景知识：每一个DRAM芯片都包含多个Bank，而每个Bank中很多&nbsp;&nbsp; 行的存储单元。每访问内存&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 中的1字节需要将对应行的数据读取至芯片的&nbsp;&nbsp;&nbsp; “Row Buffer”中（这个过程会放掉对应行中每一个存储单元的电）读取/写入&nbsp;&nbsp;&nbsp;&nbsp; “Row Buffer”的上下文，然后将“Row Buffer”的上下文写回原来的行中（只是&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 读取的具体操作的一种，其&nbsp;&nbsp;&nbsp;&nbsp; 他的可以参考豆丁文档&nbsp; http://www.docin.com/p-639315446.html 1.2中的内容）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">&nbsp;在这个“激活”一行（放电、充电）的过程中可以干扰到相邻的行。如果，在&nbsp; 相邻的行进行自动刷新的时候（通常每64ms进行一次），进行了足够多的“激 活”操作，就可以引发相邻行的bit翻转</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">“Row Buffer”扮演了一个缓存的角色，如果地址X和地址Y指向了同一行，那么在执行代码片code1a的时候，只会对“Row Buffer”进行操作，而不会进&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 行“激活”操作（具体可以参考豆丁文档中1.2节中提到的第三种读取方式）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">&nbsp;此外，内存中的每一个Bank拥有一套独立的“Row Buffer”（同样参考文档）。所以，如果地址X和地址Y位于不同的Bank中，在执行代码片code1a的&nbsp; 时候，也只会读取X、Y所在的个子的Bank中的“Row Buffer”而不会进行激&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 活操作。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">而然，如果地址X、Y指向了同一个Bank中的不同行，在执行代码片code1a&nbsp;&nbsp;&nbsp;&nbsp; 的时候，就会引发X、Y所在行之间不断的“激活”操作。这就叫做“Row &nbsp;&nbsp;&nbsp; Hammering”</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">绕过缓存：如果没有代码片code1a中的CLFLUSH指令，那么内存操作（MOVs）将只会记录在CPU的缓存（Cache）中。使用CLFLUSH刷写缓&nbsp;&nbsp;&nbsp; 存可以强制将内存访问命令发送到底层的DRAM中。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">&nbsp;注意到Yoongu Kim等人论文中的代码片code1a版本，还包含了MFENCE&nbsp;&nbsp;&nbsp; 指令，但是我们发没有必要调用MFENCE指令而且事实上调用后反而减少&nbsp; 了被翻转的bit。Yoongu Kim修正过的memtest函数也同样从他的“Row &nbsp;&nbsp;&nbsp;&nbsp; Hammering”代码中忽略掉了MFENCE指令。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">为“锤子”提炼需要选择的地址</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">使用物理地址映射</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">那么，我们如何来挑选成对的地址，来满足这个“不同行同Bank”的要求呢？</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">一种可能性是利用CPU集成的内存控制器对于物理地址到存储单元、内存行、Bank的映射的知识，以及其他相关的知识：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">&nbsp;内存的绝对物理地址，我们有权访问。Linux通过/proc/PID/pagemap</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">内存的相对物理地址，我们有权访问。Linux通过支持2M的连续物理地址&nbsp;&nbsp; 空间的内存页。通常一个普通的内存页仅有4K小于1个内存行，但是一个 2M的内存页，通常将包含多个内存行，其中比部分将存在于同一个Bank&nbsp;&nbsp; 中。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">Yoongu Kim等人通过这个方法。他们选择Y=X+8M基于Intel与AMD的CPU中内存控制器对于物理内存映射的知识。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 16px; color: rgb(84, 141, 212);"><strong><span style="font-size: 16px; font-family: 微软雅黑,Microsoft YaHei;">随机地址选取</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">CPU的物理地址映射很难被确定，尽管一些特性例如：/proc/PID/pagemap、大型内存页并不是通用的。此外，如果我们关于地址映射的猜测是错误的，我们可能会挑选一个降低“Row Hammering”成功率的偏移（比如：Y=X+8k可能使得地址总是在不同的Bank中）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">一个更简单的方法是随机的挑选一对地址。我们申请一大块内存（比如:1G）然后在这块内存中随机挑选虚拟地址。在一台拥有16个Bank的电脑上（例如我们的测试机拥有2个DIMM，每个DIMM拥有8个Bank），这样我们挑选的地址对就有1/16的概率位于同一个Bank中，这个概率已经很高了（当然，地址对位于同一行中的概率就微不足道了，一般一个Bank中有8k+个行）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">此外，我们可以通过修改代码片code1a，使其在每次循环中“Hammer”更多的地址对来提高我们“Row Hammering”的成功率。我们发现每次一次“Hammer”2或者4个地址对并不会增加多少时间。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212);"><strong><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">通过计时选择地址</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">另一种判断地址对时候满足“不同行同Bank”特性的方法是使用高精度计时（例如使用RDTSC 指令）记录非缓存访问这些地址所用的时间。拥有此特性的地址对的访问时间要长于其他情况地址对的访问时间。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212);"><strong><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">双侧“Hammering”</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们发现通过“Hammering”行N-1、N+1相比“Hammering”一个相邻行和另一个相对比较远的行，可以增加行N的bit翻转的成功率。我们称之为双侧“Hammering”</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">对于很多机器，双侧“Hammering”是在合理的时间内引发bit翻转的唯一方法。而对于那些通过随机选择地址对就已经可以引发bit翻转的，双侧“Hammering”可以在被翻转的bit数上产生一个非常显著的提高。我们在一台非常脆弱的主机层观察到1内存行超过25个bit的翻转。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">由于内存的几何结构使得执行双侧“Hammering”变得更加复杂。它需要攻击者了解或者能猜测到物理地址中同Bank相邻两行之间的偏移值究竟是多少。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">通过我们的测试，我们能够直接推断第4台样本笔记本（详见下表面的表格）的内存行偏移值是256k。我们得出这个结论是通过观察被翻转的bit发生的可能性相对于被选中的内存页到受影响的内存页之间的距离。这个可能性在我们给定目标内存行的情况下在256k上下达到最大值。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">“256k敲击内存区域，256k受波及内存区域，256k敲击内存区域”的设置被证明在同一厂商的其他笔记本上也同样有效。当然，对于其他厂商，这个设置很可能需要修改。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">这256k的内存行偏移，可以被解释成一种产品的内存行的大小、Bank的数量、等等DRAM在这才电脑上的参数，不过这需要更深入的了解引荐是如何将物理地址映射成行、列编号的。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">使用双侧“Hammering”需要我们获得物理上连续的内存页（比如：via /proc/PID/pagemap或者大型内存页）</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212);"><strong><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">溢出“Row Hammer” bit翻转</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">Yoongu Kim等人说“通过工程化的尝试，我们相信我们可以将code1a发展成干扰攻击，从而获得系统的控制权”，但是他们把这个当做未来的研究任务，而我们现在就做到了！</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们发现了存在bit翻转的各种主机（参考下面的实验结果），并写出了一下两个exp：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">第一个是运行在Native Client（以下简称NaCl）沙盒中的程序，成功逃逸， 并实现直接调用我们本地系统调用。我们已经通过禁用NaCl沙盒中&nbsp;&nbsp; 的程序调用CLFLUSH指令来缓解攻击（我之所以首先选择NaCl沙盒做溢&nbsp;&nbsp; 出，是因为我在这个项目工作，并在之前写过概念性的沙盒逃逸代码）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">第二个是运行在64位Linux系统中的正常进程，成功提权并获得了全部物&nbsp;&nbsp;&nbsp; 理内存的权限。这个在实体机器上很难做到有效的攻击缓解。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212); font-size: 16px;"><strong><span style="color: rgb(84, 141, 212); font-family: 微软雅黑,Microsoft YaHei;">NaCl沙盒逃逸</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">NaCl是一个只允许运行部分x86-64指令的沙盒系统（包括其他构架）。在运行一个x86-64可执行程序前，NaCl会使用一个校验器来检验这个程序的代码是否都在NaCl所认为安全的指令集。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">然而，NaCl假设硬件行为是正确的。它假设内存地址除非调用指令改写，否则是不会改变的！NaCl对于机器码的检验方法在bit翻转面前是非常脆弱的，因为：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">&nbsp;1bit的翻转在验证过的代码中就可以使得一个安全的指令变得不安全。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">在NaCl沙盒中，程序的代码段是可读的。这意味着程序可以检是否发生了&nbsp;&nbsp; bit翻转，并检查是否或者如何利用这个翻转。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们的溢出目的是NaCl沙盒下的直接跳转指令序列，例如如下形式：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">andl $~31, %eax // Truncate address to 32 bits and mask to be 32-byte-aligned.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">addq %r15, %rax // Add %r15, the sandbox base address.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">jmp *%rax // Indirect jump.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">溢出原理是通过触发这段指令序列的bit翻转。我们前文已经提到溢出会有13%的可能性造成bit翻转。在这里我们仅使用bit翻转来篡改所用的寄存器（通过进一步研究，还有其他的可利用的方法，比如：篡改操作码）举个栗子，如果在jmp *%rax代表寄存器字节的最低bit发生翻转，这就变成了jmp *%rcx，此时由于rcx没有被审查，这就允许我们可以跳转到任意地址上。通常情况下NaCl只允许直接跳转到32字节对齐的地址（并且还要确保指令没有穿越32位约束的边界）当一个程序可以跳转到一个非对齐的地址时，它就可以从沙盒中逃逸。因为该程序可以将不安全的x86指令隐含在安全的x86指令中。例如：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">20ea0: 48 b8 0f 05 eb 0c f4 f4 f4 f4 movabs $0xf4f4f4f40ceb050f,%rax</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">这里在地址0x20ea2上隐藏了一条SYSCALL指令（0f 05）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们的NaCl溢出程序作了如下的工作：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">它使用NaCl信任的直接调转指令填充了由NaCl自带函数dyncode_create声 明的250M的动态代码空间</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">在每次循环中，程序首先挑选随机地址对，对动态代码空间通过CLFLUSH&nbsp; 进行“Row Hammer”。再对动态代码空间进行搜索。如果发现可利用的bit翻&nbsp;&nbsp;&nbsp;&nbsp; 转，就使用它并跳转到隐藏在NACl认证过的指令中的ShellCode。如果，没&nbsp;&nbsp;&nbsp;&nbsp; 有引发可利用的bit翻转，那么继续循环。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们已经通过修改在NaCl中禁用CLFLUSH的策略指令来缓解攻击。（用兴趣的可以跟踪CVE-2015-0565）然而，除了调用CLFLUSH也许还存在其他的方法来引发“Row Hammer”</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">在NaCl中禁用CLFLUSH，可能不仅束缚了NaCl的溢出，还能防止类似后面提到的系统提权，以至于让一个Chrome软件店中的软件仅仅通过一个底层的硬件Bug，就可以获得内核权限。据我们所知，目前Chrome软件店还没有这样的应用。PNaCl，一个在开源Web上面可用的框架，由于拥有一个特殊的保护层，溢出在调用CLFLUSH前，还需要先干掉PNaCl的指令解析器。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 16px; color: rgb(84, 141, 212);"><strong><span style="font-size: 16px; font-family: 微软雅黑,Microsoft YaHei;">内核提权</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们的内核提权的原理是，使用“Row Hammer”引发PTE基址处的1bit翻转。这可以使得PTE指向一个包含攻击者进程页表的物理内存。这赋予了攻击者进程对于自身页表的读写全，进而控制全部物理内存。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">以下两点可以帮助我们的bit翻转具有一个很高的可利用性：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">&nbsp;1、“Row Hammer”引发的bit翻转具有很大的反复测试的可能性。这意味着，&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们可以进一步讨论，当一个存储单元可能会翻转，其中的某个bit的位置 对于溢出是否有意义。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">举个栗子：第51bit超过64位PTE中的最高位。如果这里从0变为1，这将 会产生一个比当前系统内存还要大的页号。而这对于我们的溢出是没有任何&nbsp;&nbsp; 意义的，所以我们可以跳过对于这个bit翻转的利用。然而，第12bit作为 PTE的物理页号的中间位。如果，我们将其翻转，那么PTE将依然指向一个&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 有效的物理内存页。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">2、我们喷射大量带有页表的物理内存。这意味着，当PTE物理页号被篡改&nbsp; 的时候，将会有很大的可能性指向我们喷射的页表。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们通过反复mmap相同的文件来达到喷射的效果。这个过程执行起来会迅 速，使用页表喷满3G内存在我们的测试机器上只需要3秒！</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">还有两点注意：</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们的溢出程序是一个正常的Linux进程。从沙盒中的溢出还需要进一步的&nbsp; 研究（例如：Chromium的渲染进程）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们的测试是在一台没有占用过多内存的机器上进行测试的。如果想在一个 内存使用频繁的机器上溢出成功，还需要做更多的工作。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212);"><strong><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">接下来：溢出步骤</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">第一步是</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">&nbsp;调用mmap映射一大片内存</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">&nbsp;通过“Row Hammering”随机地址对，找到可以对应的“攻击”地址/“受波及”地&nbsp; 址。我们通过搜索/proc/self/pagemap来找出刚刚跑出结果的物理地址。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">&nbsp;如果我们发现被翻转的bit不能用于我们的溢出，那么跳过这个地址</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">否则，释放掉出目标地址以外的全部内存页然后开始溢出攻击</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">为准备喷射内存页表，我们在/dev/shm （一个共享的内存区段）中创建一个文件。随后我们将频繁的映射它。（随后，我们将介绍如何确定这个文件的大小）我们在这个文件的每4k的开始写入一个标记数，当随后我们检查PTE的变动的时候，我们就可以非常容易的识别我们自己映射的内存页。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">同时，我们也意识到我们的这些内存页不能被分配到连续的物理内存地址中。因为随后的当我们进行bit翻转的时候，很可能导致PTE的指针从一个我们的内存页指向另一个我们映射的内存页。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">为避免这样的问题发生，我们首先要故意碎片化物理内存，这样系统从物理内存上分配出来的地址就随机的了：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">调用mmap（使用参数MAP_POPULATE）从机器的物理内存上申请一大块 空间。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">随后，我们通过调用madvise（使用参数MADV_DONTNEED）从这篇空间 中释放掉一个内存页，都会引起系统申请一个4k的内存页（例如：页表）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们现在已经做好内存喷射前的所有准备工作。要进行内存喷射，我们需要反复的调用mmap来映射之前生成的文件：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们希望每一次映射都会在以2M对齐的虚拟地址上，因此，每一个4k的&nbsp;&nbsp;&nbsp; 页表对应一个2M的虚拟地址空间。我们使用参数MAP_FIXED来达到这个&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 效果</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们通过访问相似的内存页来引导系统构建一些PTE。我们只需要对每个页 表构建一个PTE，因为我们知道我们的bit翻转会命中页表中的第N个PTE，&nbsp;&nbsp;&nbsp; 因为，为了效率，我们只对每一个2M内存区域的第N个4k内存页进行检 查。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">&nbsp;Linux对于每一个进程可以进性的mmap的数量作了限制（2^16）。这意味&nbsp;&nbsp;&nbsp;&nbsp; 着，我们之前在/dev/shm生成的文件必须足够大，以至于，当我们映射了2^16&nbsp; 此后，所申请的空间足够填充大部分的物理内存。但与此同时，我们希望保&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 持文件尽可能的小，这样就浪费掉本来可以用页表填充的内存。因此，在选 择这个文件的大小的时候，我们非常谨慎。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">在喷射内存的过程中，我们调用munmap来释放掉可以进行bit翻转的内存&nbsp;&nbsp; 页。而系统就会有很高的可能性紧接着使用这片物理内存保存页表。我们虽&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 然不能直接操作这片内存页，但是我们可以通过“Row Hammering”来篡改它。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">当完成喷射完成，接下来就是“Hammer”时间。我们通过“Hammer”攻击地址。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 来期望它引发“受波及”地址的bit翻转。不同于前一个溢出例子，这次我们 不能直接观察bit翻转。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">现在，我们来检查PTEs的改变是否可以利用。我们对我们映射的这一大片内存区域进行扫描，看看是否有PTE现在指向了我们申请的空间之外的内存。同样，为了效率，我们只需要检测每2M区域中的第N个内存页。我们可以检测我们之前写入的标记数。如果，我们发现如果所有的标记数都没有改动，那么我们的攻击失败了（胜败乃比家常事，大侠请从新来过）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">如果，我们发现一个标记数被修改了，那么我们已经获得了非法访问一个物理内存页的权限。而且有希望是我当前地址空间的内存页。如果希望更谨慎一点，我们可以来验证一下这个内存页是否看上去像是我们的一个页表项。在这第N个内存页的64位应该看起来像一个PTE（对应的一些标志位是0还是1）。如果，不像那么我们的攻击失败了（胜败乃比家常事，大侠请从新来过）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">能到达在这里，说明我们已经具备对一个很可能是我们自己进程的页表的写入权限。然而，我们还不知道这个页表对应的虚拟地址。我们可以动过下面的步骤来判断：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">在这个内存页中写入一个PTE（比如PTE指向物理内存页0）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">对地址空间做第二次扫描，去找第二个虚拟地址页同样没有指向我们的数据 文件。如果我们不能找到，说明我们的攻击失败（胜败乃比家常事，大侠请&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从新来过）</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212);"><strong><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">用页表的写入权限溢出</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们现在已经拥有对于我们当前进程的一个页表的写入权。通过篡改这个页表，我们可以访问物理内存中的任意内存页。对于接下来的溢出，我们现在拥有许多的方法。这些方法在可移植性、简洁性和运行速度上有所不同。高可移植性的方法可以不依赖于对于系统内核数据结构的了解。更快的方法可以在O(1)时间内完成，尽管慢一点的方法啊可能需要扫描全部的物理内存来定位一个数据结构</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">一些方法，如下：</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们所使用的方法：篡改一个可执行程序，例如/bin/ping（以root权限运行&nbsp;&nbsp; 但不需要su的程序），使用我们的ShellCode来覆盖程序入口，然后执行程 序。这时我们的ShellCode就将运行在root权限下。这个方法非常迅速而且&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 方便移植，但是这需要访问“/proc/PID/pagemap”。我们载入/bin/ping（通过调 用open和以MAP_POPULATE为参数的mmap）并通过/proc/self/pagema查&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 询文件被载入了哪个物理页面</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">一个相似的方法是修改一个可执行程序的动态库例如&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /lib64/ld-linux-x86-64.so.2（在一些系统上，像/bin/ping这些程序由于他们的&nbsp;&nbsp;&nbsp;&nbsp; 访问许可被锁死，会导致open调用失败）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">其他，低可移植性的方法可以篡改系统内核代码和内核数据结构</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们可以篡改当前进程的UID。这需要定位当前进程的cred结构体，并 了解它的结构</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们可以篡改系统调用的处理代码。我们可以通过SIDT指令快速定位&nbsp;&nbsp; 到对应的物理地址。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">引发“Row Hammering”的途径</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们的概念性的exp使用的x86指令CLFLUSH，因为这是最简单的发送强制内存访问到底层DRAM，并引发“Row Hammering”的方法</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">由于CLFLUSH指令在系统内核以及设备驱动以外，使用的概率是非常小的，因此CLFLUSH指令在用户层代码中可用是令人吃惊的。相比而言，ARM在用户层指令集中不存在这么一条缓存刷新指令。（Linux的ARM版本中JIT所使用的，确实有一个叫做cacheflush的系统调用。它被用来同步指令和数据缓存。而在x86版本中i-cache和d-cache是自动同步的，因此CLFLUSH对于刷新缓存是没有意义的）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们已经修改了NaCl的x86校验器来屏蔽CLFLUSH指令。不幸的是，系统不能屏蔽来自用户层对于CLFLUSH指令的调用。当前，CLFLUSH不能被拦截或者屏蔽，即使使用了VMX（x86虚化技术）（例如RDTSC不用VMX支持就可以拦截。VMX允许拦截很多指令包括WBINVD和CPUID，但还不能拦截CLFLUSH）要拦截CLFLUSH也许需要修改x86构架。从一个安全工程师的角度来看，去掉不必要的受攻击面是好的习惯。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">然而，不通过CLFLUSH也许还有其他的方法来引发“Row Hammering”，这也许可以使用在非x86构架上：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">正常的内存访问：正常访问内存经过足够多的次数或者正确的方式，可以造 成大量的缓存未命中，从而引起“Row Hammer”的bit翻转吗？这需要使得每&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一层缓存都未命中（L1、L2、L3等等）这是否可行取决于这些缓存之间的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 关联性。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">如果这个方法可行，这将会是一个严重的问题。因为，可能当打开网页执行 JavaScript时，通过JavaScript的数组就可以造成bit翻转。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">绕过Cache的内存访问：在x86指令集中，有一类叫做非暂时移动指令（例 如：MOVNTI, MOVNTQ,MOVNTDQ(A), MOVNTPD, MOVNTSD and &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOVNTSS）和预读取指令（例如：PREFETCHNTA） （编者注：这些指令&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 是不同过Cache直接读写内存的）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">原子内存访问：一些报告称无恶意的使用spinlock可以引发“Row &nbsp;&nbsp;&nbsp; Hammering”，然而这些报告细节不够具体，我们也无从验证（论文《</span><a style="text-decoration: underline; font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;" href="http://www.futureplus.com/images/FS2800/The%20Known%20Failure%20Mechanism%20in%20DDR3%20memory%20called%20Row%20Hammer.pdf"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">The &nbsp; Known Failure Mechanism in DDR3 memory called “Row Hammer”</span></a><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">》作者：&nbsp; Barbara Aichinger）但这看上去在共享最高级缓存的多核心系统中不太可能实&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 现。然而，它可能在核心之&nbsp;&nbsp;&nbsp;&nbsp; 间没有共享Cache的多路系统中 实现。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">未对齐原子内存访问：x86处理器可以保证使用LOCK前缀的指令对内存的 访问是原子级别的，即使要访问的地址是未对齐的，甚至超过了缓存界限。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （详见《Intel® 64 and IA-32 Architectures Developer&#39;s Manual》8.1.2.2节&nbsp;&nbsp; “Software Controlled Bus Locking”。其中提到总线锁的完整性是不受地址是&nbsp;&nbsp; 否对齐的影响的）这个性质为了向后兼容而存在至今。在这种情况下，CPU&nbsp;&nbsp; 为了内存访问的原子操作而放弃使用缓存一致性机制。相反，CPU回到原始&nbsp;&nbsp;&nbsp;&nbsp; 的总线锁机制，我们相信CPU将使用非缓存的内容访问方式。（在一些多&nbsp; 路CPU非一致性内存访问的主机上，总线锁是通过QPI协议而不是物理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOCK针脚）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">如果非对齐原子操作产生了非缓存DRAM访问，那么这可能会引发“Row &nbsp;&nbsp; Hammering”</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">初步调查表明这些原子操作确实绕过了缓存，但是这些访问太缓慢，以至于 不能在有效的时间（64ms的刷新间隔）内进行足够的内存访问操作，来产&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 生bit翻转</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">非缓存内存页：例如，Windows中CreateFileMapping函数使用参数&nbsp; SEC_NOCACHE可以申请到一片非缓存内存页映射。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">其他操作系统的接口：这可能发生在系统内核或者设备驱动中（例如GPU&nbsp;&nbsp;&nbsp; 驱动）可以在用户层代码中进行绕过缓存的内存访问。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212); font-size: 16px;"><strong><span style="color: rgb(84, 141, 212); font-family: 微软雅黑,Microsoft YaHei;">实验结果</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们通过使用CLFLUSH随机地址对测试了一系列x86笔记本（都没有使用ECC内存）。我们发现其中大部分的机器存在“Row Hammer”引发bit翻转的现象。这个结果已经展示在下面的表格中</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">这个测试所使用的“rowhammer-test”测试程序可以从这里获得：</span></p><p style="text-indent: 2em; text-align: left;"><a style="text-decoration: underline; font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;" href="https://github.com/google/rowhammer-test"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">https://github.com/google/rowhammer-test</span></a></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">注意：</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们的样本空间还不足够作为一个严格的代表</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">一台给定电脑上的一个否定结果（没有bit翻转）并不意味着“Row Hammer” 在这台机器上不可能引发bit翻转了。我们没有进行足够的测试来证明一台&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 给定的机器是安全的。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">作为结果，我们决定隐藏一部我们的数据</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">所有被测试的机器都使用DDR3内存。我们没有办法鉴别出所有的内存使用年限。</span></p><p style="text-align:center"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;"><img alt="http://p2.qhimg.com/t013c34db03148aa6db.png" src="http://p2.qhimg.com/t013c34db03148aa6db.png" title="t013c34db03148aa6db.png"/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">同时，我们也测试了一些桌面电脑，但是在它们上面没有发现任何bit翻转。这可能是由于，都是使用了ECC内存的高档电脑吧。ECC技术可以隐藏掉bit翻转。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212);"><strong><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">测试你自己的电脑</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">用户可能希望通过上面提到的“rowhammer-test”测试程序来测试它们自己的电脑。如果一台电脑在测试的过程中产生了bit翻转，那么用户一定希望变得安全并信任关于机器的结果</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">与此同时在测试过程中没有bit翻转的机器也并不意味着安全。这个测试仅仅证明引发bit翻转在这台电脑上比较困难</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212); font-size: 16px;"><strong><span style="color: rgb(84, 141, 212); font-family: 微软雅黑,Microsoft YaHei;">攻击缓解</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">针对附近内存行的刷新</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">为防止“Row Hammer”引发bit翻转，一些方案提出改进DRAM，改进内存控制器，或两者兼而有之。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">Yoongu Kim等人在他们的论文中讨论了。一个系统可以确保在一个给定的时间周期内，即使没有确定相邻的内存航是否正在刷新，也不会对给定的内存行进行过多次数的“激活”。他们的论文中提出“维护一组计数器”（无论保存在内存控制器中还是DRAM中），用来记录“激活”的次数。这篇论文建议另一个叫做“PARA”的概率性的方案。这个方案并不是很正规也因此不需要维护计数器。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">有迹象显示一些较新的硬件已经具有缓解能力：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">JEDEC近期发布的LPDDR4（“LP”代表低电压）将了两个“Row Hammer”攻击缓解技术列入说明书。这两个技术很可能将用于内存控制器中。（具体看以查看JEDEC &nbsp;document JESD209-4，虽然从JEDEC官网注册后才能下载，但是注册是免费的）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">“目标行刷新”模式（TTR），这允许内存控制器要求DRAM设备刷新指定行的周围行</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">“最大‘激活’计数”（MAC），这指定了一内存在其相邻内存行需要刷新前，所能承受的安全的“激活”次数</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">（LPDDR4的说明书并没有直接提到“Row Hammer”这一次，但是他们使用了术语“受波及的内存行”）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们还发现至少一家DRAM生产商在他们的公开数据中表示他们不需要借助特殊的内存控制器的支持，已经在DRAM设备中加入了“Row Hammer”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 攻击缓解方案。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们测试的一些较新型号的笔记本确实没有出现bit翻转。一个很可能的解释是这些笔记本都具有了“Row Hammer”攻击缓解能力</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">BIOS升级与加快刷新频率</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">硬件生产商是不是已经悄悄的推出BIOS升级？通过修改BIOS对于CPU内存控制器的配置，缓解了“Row Hammer”问题。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">举个栗（实）子（验），我们对第4台样本笔记本进行双侧“Hammering”来观察发生bit翻转所需要的时间。这个观察到时间都没有超过5分钟。随后我们将笔记本的BIOS更新到最新的版本，然后重新进行“Row Hammering”测试。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们最初以为现在的BIOS已经修复了这个问题。然而，经过接近40分钟的连续“Row Hammering”测试，还是出现了bit翻转。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们推测更新的BIOS提高了DRAM的刷新频率。这使得在DRAM的刷新间隔中造成足够多的干扰标的更加困难，但也还存在成功的可能性。这个与Yoongu Kim等人的论文中所提到的相符（参考论文第四个表格）在他们的论文中提到，对于一些DRAM型号，32ms的刷新周期是不足以将bit翻转概率降至0的。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们没有大范围的对笔记本上的BIOS升级进行测试。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">使用性能计数器监视“Row Hammering”</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">CPU性能计数器也许可以被用来检测“Row Hammering”攻击。为了有效地“Hammer”一片内存区域，攻击者必须在短时间内产生大量对底层DRAM的访问。不论攻击者使用CLFLUSH还是通过正常的内存访问，这都会产生大量的缓存未命中。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">现代的CPU为性能分析提供允许监视缓存未命事件的方法。这些方法可以被防御方，有目的的用来监视系统突发的缓存未命中，因为正常的缓存未命中的访问方式在台式机和笔记本上都是极少发生的。通过记录每N个缓存未命中发生所需要的时间并监视不正常的变化，即使在系统繁忙的时候，我们也可以发现“Hammer”攻击。不行的是，即使我们检测到可能的“Hammer”攻击时，我们即无法做出明确的响应，也不知道正常的缓存未命中如何确定。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">与此同时，攻击者也可以使他们的攻击规避这些这种检测，这将增工程量，让这个监控程序变成了一个指令检测程序。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 16px; color: rgb(84, 141, 212);"><strong><span style="font-size: 16px; font-family: 微软雅黑,Microsoft YaHei;">揭露真相</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">计算机行业（谷歌也是其中一员）对于软件中的安全问题已经习以为常了。这也使得，对于公开讨论和披露的安全问题的重要性已经形成了共识。通过这些公开的讨论，也使得对于存在安全风险的Bug得到了更深入的认识。虽然这个行业对于硬件Bug还不太了解，但是通过公开讨论和披露这些相同的方式，也可以让硬件安全获益。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">考虑到这一点，我们可以得出两点经验：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">Bug的可以用性：回过头来，如果有更多的关于“Row Hammer”的披露，这个问题就会被更早的当做一个安全问题。看来生产商对于“Row Hammer”的了解已经有一段时间了，就像刚刚提到的LPDDR4中的“Row Hammer”攻击缓解的方案。也许是因为生产商并不认为这是一个具有威胁的安全问题。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">评估计算机风险：期待公布更多的关于“Row Hammer”的技术细节，这将有助于评估一台计算机究竟存不存在这个问题。截止到这篇文章结束，还是很难断言一台计算机不受“Row Hammer”影响。测试可以说明一台计算机存在漏洞，但不能证明完全不存在漏洞。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">我们接下来具体阐明这两点</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">Bug的可以用性</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">生产商并不会认为这是一个具有威胁的安全问题，假设这个溢出很难实现。我们所看到的关于“Row Hammer”的材料，没有一篇（除了Yoongu Kim等人的论文）探讨其安全威胁。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">然而，许多问题看上去很难实现溢出，但实际被证明可以被利用。这些问题最初可能被认为仅仅是一个无关紧要的问题，结果最终变成了一个安全问题。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">举个极端的栗子，最近Project Zero的Blog上描述的一个很难溢出的问题（地址：http://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html）这里展示了通过一字节偏移的覆盖实现了溢出以一个正常用户获得了root权限</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">对于大多数安全研究人员，尤其是那些练习写验证性溢出程序的人员，大家都知道bit翻转是可以被拿来利用的。例如一篇2003年的论文就像我们展示了如何利用随机bit翻转来实现JAVA虚拟机的逃逸。（详见“利用内存错误攻击虚拟机”，作者Sudhakar GovindavajhalaAndrew W. Appel.，地址：</span></p><p style="text-indent: 2em; text-align: left;"><a style="text-decoration: underline; font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;" href="https://www.cs.princeton.edu/~appel/papers/memerr.pdf）"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">https://www.cs.princeton.edu/~appel/papers/memerr.pdf）</span></a></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">而且，就像我们文章中所说的，“Row Hammer”引发的bit翻转是比随机bit翻转更加好利用，因为“Row Hammer”引发的bit翻转是可重复尝试的。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">评估计算机风险</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们鼓励生产商公布设备的信息，这样安全研究人员和公众可以用以评估他们的计算机是否存在“Row Hammer”问题</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">接下来信息对于我们的评估将会是有帮助的：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">对于每一种DRAM设备：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">这个DRAM设备在物理层面上容易被“Row Hammer”引发bit翻转吗？</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">这个DRAM设备包含了那些“Row Hammer”的缓解方法？它包含TRR或者MAC吗？这些缓解方法是否需要CPU内存控制器的支持？</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">对于每一款CPU：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">这款CPU的内存控制器中包含那些缓解方法？这些方法需要DRAM设备支持吗？</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">是否有关于在计算机初始化时如何配置CPU内存控制器的公开文档？</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">当初始化完成后，还是否有可能读写内存控制器的配置内容，用来验证是否开启了缓解方法？</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">内存控制器是如何将物理地址与DRAM中的存储单元、行、Bank对应起来的？这对于发觉究竟是哪几种内存访问方式可以引起“Row Hammering”是有很大帮助的</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">对于每一种BIOS：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">究竟哪一种缓解机制被BIOS在CPU内存控制器中开启了？例如，BIOS开启了双倍的刷新频率或者使用了TRR？这些配置都可见吗？</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">截止到发布这篇文章，我们都不能找到一点关于以上内容的公开信息。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">如果以上的信息大部分都可以获得，那么评估一台计算机将会非常简单。这也使得我们可以更容易的在测试没有产生bit翻转时，判断这台计算机是否存在这个问题。当一台机器经过测试没有发现bit翻转时，我们可以解释说是因为DRAM包含了缓解措施，或者因为DRAM物理层面上不易受到影响（究其原因，是生产商使用了旧的生产工艺）或者因为BIOS初始化了两倍的内存刷新频率。如此解释，会让我们在测试没有结果的时候有更多的自信判断这台计算机并不受这个问题影响，而不是因为我们反复的测试中存在一些不足的地方。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们希望研究人员在接下来的时间里，会对评估“Row Hammer”缓解方案感兴趣。例如，让DRAM设备记录内存行“激活”的次数（就像MAC方案中建议的一样）或者像PARA使用概率的方法。这些缓解方案的效果在双侧“Hammering”和单侧 “Hammering”下一致吗？DRAM设备和内存控制器独立的缓解方案是否会互相影响。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212); font-size: 16px;"><strong><span style="color: rgb(84, 141, 212); font-family: 微软雅黑,Microsoft YaHei;">结论</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们展示了两种通过“Row Hammering”的溢出案例。历史不断向我们证明，一个看似不可利用的错误，最终变成了严重的安全问题，而本文中的“Row Hammer”就印证了这一点。许多的安全软件还停留在除非对地址进行操作，否则内存不会被篡改的思想里。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">在过去的十年里，公开讨论软件的瑕疵和对应的利用使得计算机行业对于安全的理解有了巨大的发展。也使得可靠的软件生产商在他们的产品出现问题时及时通知用户进行升级。虽然相比于软件问题，计算机行业还不太习惯于硬件问题，我们应该鼓励硬件生产商采取相同的态度，来彻底的分析这些看似不可利用的错误所带来的影响，提供详尽的说明、缓解方案以及固件或者BIOS的升级。通过讨论可以使得硬件更加安全，而让广大的用户从中受益。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212);"><strong><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">友情出演</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">Matthew Dempsky提出通过对PTE进行bit翻转来实现“Row Hammer”攻击</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">Thomas Dullien帮助测试了大量受影响的计算机，提出了双侧“Hammering”的思路，作了BIOS升级实验，并帮助具体的完善了PTE<span style="font-size: 16px; font-family: 仿宋_GB2312;">的</span><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;">bit</span><span style="font-size: 16px; font-family: 仿宋_GB2312;">翻转溢出。</span></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 16px; font-family: 仿宋_GB2312;"><br/></span></p></p>
                <hr/>
                <p style="text-align: center;">
                    <img src="http://bobao.360.cn/img/app.jpeg"/>
                    <img src="http://bobao.360.cn/img/weixin.jpeg"/>
                </p>
                                <p>本文由 安全客 翻译，转载请注明“转自安全客”，并附上链接。<br/><a class="text-more" href="http://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html" target="_blank">原文链接：http://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html</a></p>
                            </div>
            <div style="margin-top: 20px;background-color:#FFFFFF">
    <input type="hidden" id="detail_title" name="detail_title" value="谷歌Project Zero：通过“Row hammer”漏洞获取系统权限 - 安全客 - 有思想的安全新媒体" />
    <input type="hidden" id="use_nickname" name="use_nickname" value="0" />
    <a name="mao"></a>
    <div class="reg-log mobile-hiden">
        <div class="" id="userTo">   
            <div id="to-list" class="input-text" style="">
                <textarea disabled="disabled" class="hide"  id="comment-content" to="to"></textarea>
                <ul id="preadded" style="display:none">       
                </ul>
                <div id="to-auto" style="width: 200px">
                    <ul id="feed">
                    </ul>
                </div>
            </div>
        </div>
        <input type="hidden" id="source-id" value="302" />
        <input type="hidden" id="source-type" value="learning" />
        <input type="hidden" id="post-comment-url" value="/comment/add" />
        <input type="hidden" id="post-nickname-url-ajax" value="/comment/randnicknameajax" />
        <input type="hidden" id="post-check-login-url-ajax" value="/comment/checklogin" />
        <input type="hidden" id="stoken_comment_set" value="64d932c9bb50dc5a83db601d9b02e735">                 <span class="join">参与讨论，请先 <a href="javascript:;" class="comment-login">登录</a> | <a href="javascript:;" class="comment-reg">注册</a> |  <a href="javascript:;" class="anonymous-comment">匿名评论</a></span>
            </div>
    <div class="mobile-hide" style="width: 870px; margin: 0 auto;">
        <label style="vertical-align:middle;" for="use_nickname">匿名</label> 
        <input style="vertical-align:middle;" id="trigger-nickname" name="use_nickname" class="use_nickname" type="checkbox" value="0" />

        <a href="javascript:;" class="apply-use button" id="submit-comment" data-target="/comment/add">发布</a>
    </div>


    <div class="clearfix"></div>
    <div class="comments">
        <div class="comments-head">
            <span class="title">用户评论</span>
        </div>
                <div class="comment-none alarm-info bg-primary">无任何评论</div>
            </div>
</div>
<script>
    $(function () {
        $('.anonymous-comment').click(function () {
            $(".join").hide();
            $(".reg-log textarea").first().removeAttr("disabled").show();
            $('#use_nickname').val('1');
//            $('#trigger-nickname').attr('checked', true);
            $('#trigger-nickname').trigger('click');
        });
        //为所有复选框绑定事件
//        checkbox_on_click();
        //ajax随机获取昵称
//        randnicknameajax(0);
        //ajax检测登录状态
        comment_check_login();
    });



    function input_checkbox(flag) {
        $('input:checkbox').each(function () {
            var value = flag ? 1 : 0;
            $(this).prop('checked', flag);
            $(this).val(value);
        });
    }

//ajax随机获取昵称
    function randnicknameajax(flag) {
        $.ajax({
            type: 'POST',
            url: $('#post-nickname-url-ajax').val(),
            data: {limit: 1, flag: flag},
            dataType: "json",
            success: function (data) {
                $('#nick-name').val(data.data[0]);
                _nick_name=data.data[0];
            }
        });
    }
    $();
//ajax检测登录状态
    function comment_check_login() {
        $.ajax({
            type: 'POST',
            url: $('#post-check-login-url-ajax').val(),
            data: {},
            dataType: "json",
            success: function (data) {
                if (data.success) {
                    $('.join').hide();
                    $(".reg-log textarea").first().removeAttr("disabled").show();
                    $("#span_use_nickname").show();
                    $('#use_nickname').val('0');
                    $('#use_nickname').attr('checked', false);
                }
            }
        });
    }
</script>        </div>
    </div>
    <div class="side-bar">
        <div class="mod hot-news">
    <div class="head-bar clearfix">
        <h2><i class="icon icon-hot"></i><span>热门知识</span></h2>
    </div>
    <ul class="links-list">
                                <li><a href="/learning/detail/4411.html" alt="【漏洞预警】一个换行符引发的奥斯卡0day漏洞(CVE-2017-8759)重现——最新的Office高级威胁攻击预警" target="_blank">【漏洞预警】一个换行符引发的奥斯卡...</a></li>
                                <li><a href="/learning/detail/4416.html" alt="【漏洞预警】Microsoft .NET Framework漏洞（CVE–2017–8759）预警" target="_blank">【漏洞预警】Microsoft .NE...</a></li>
                                <li><a href="/learning/detail/4414.html" alt="【技术分享】妙用JavaScript绕过XSS过滤" target="_blank">【技术分享】妙用JavaScrip...</a></li>
                                <li><a href="/learning/detail/4425.html" alt="【安全报告】XShellGhost事件技术回顾报告" target="_blank">【安全报告】XShellGhost事件...</a></li>
                                <li><a href="/learning/detail/4424.html" alt="【知识】9月16日 - 每日安全知识热点" target="_blank">【知识】9月16日 - 每日安全知识热...</a></li>
                                <li><a href="/learning/detail/4418.html" alt="【技术分享】利用威胁情报数据平台拓展APT攻击线索一例" target="_blank">【技术分享】利用威胁情报数据平台拓...</a></li>
            </ul>
</div>        <!-- 友情链接 -->
        <div class="mod blog-links mobile-hide">
    <div class="head-bar clearfix">
        <h2><i class="icon icon-link"></i><span>友情链接</span></h2>
        <a href="/links/index.html" class="more">更多<i></i></a>
    </div>
        <ul class="links-list">
                <li><a href="http://bbs.360safe.com" alt="360安全社区" target="_blank">360安全社区</a></li>
                <li><a href="http://zhuji.360.cn" alt="360主机卫士" target="_blank">360主机卫士</a></li>
                <li><a href="http://blogs.360.cn/" alt="奇虎360技术博客" target="_blank">奇虎360技术博客</a></li>
                <li><a href="http://wangzhan.360.cn/" alt="360网站卫士" target="_blank">360网站卫士</a></li>
                <li><a href="http://webscan.360.cn/" alt="360网站安全检测" target="_blank">360网站安全检测</a></li>
                <li><a href="http://research.360.cn/report/" alt="360研究报告" target="_blank">360研究报告</a></li>
                <li><a href="http://unicorn.360.cn/" alt="360 Unicorn Team" target="_blank">360 Unicorn Team</a></li>
                <li><a href="http://appscan.360.cn/" alt="360捉虫猎手" target="_blank">360捉虫猎手</a></li>
                <li><a href="https://threathunter.org/" alt="ThreatHunter社区" target="_blank">ThreatHunter社区</a></li>
                <li><a href="http://security.360.cn/" alt="360安全应急响应中心" target="_blank">360安全应急响应中心</a></li>
            </ul>
    </div>
        <!-- 联系我们 -->
        <div class="mod contact mobile-hide" style="text-align:center">
    <div class="head-bar clearfix">
        <h2><i></i><span>关注我们</span></h2>
    </div>
    <!-- 微信关注 -->
    <ul class="contact-way">
        <li><a>微信关注</a></li>
    </ul>
    <div style="padding-left:20px;padding-bottom:15px;">
    <img src="/img/qrcode_adlab_weixin.png?v=1.1"  width="145px" height="145px;"/>
    </div>
    
    <!-- APP下载 -->
    <ul class="contact-way">
        <li><a>安全播报APP</a></li>
    </ul>
    <div style="padding-left:20px;padding-bottom:15px;">
    <img src="/img/scan_code_big.png?v=1.1"  width="145px" height="145px;"/>
    </div>
    
</div>

    </div>
</div>

<script type="text/javascript" src="/js/jquery-ui.min.js?v=3.0"></script>
<script type="text/javascript" src="/js/jquery.noty.packaged.min.js?v=3.0"></script>
<script type="text/javascript" src="/js/common.js?v=4.5"></script>
<script>$(function() {sync_count('comment');});</script>


<!-- 语法高亮 -->
<script type="text/javascript" src="/ue/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">SyntaxHighlighter.all();sync_count('vul');sync_count('news');sync_count('learning');sync_count('activity');sync_count('course');sync_count('ctf');</script>
    </div>

        <div class="footer">
        <div class="friend-link">
            <a href="http://www.360.cn/" target="_blank">360首页</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">关于我们</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">联系我们</a>
            <span>|</span>
            <a href="/links/index.html" target="_blank">友情链接</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">招贤纳士</a>
        </div>
        <div class="copy">
            Copyright &copy; 360网络攻防实验室 All Rights Reserved <span class="copy_icp">京ICP证080047号[京ICP备08010314号-6]</span>
        </div>
    </div>
    
</div>

<!--奇舞团统计-->

<script src='https://s.ssl.qhimg.com/static/f5407c785655e6a1/monitor_analytic.js'></script>
<script>
    monitor.setProject('QH_171_1').getTrack().getClickAndKeydown().getClickHeatmap(10, 1);
</script>

<div class="hide">
    <script src="https://s95.cnzz.com/z_stat.php?id=1253147824&web_id=1253147824" language="JavaScript"></script>
</div>
<div class="backToTop_wrap off">
    <a id="back_to_top" class="backToTop" href="javascript:;" title="返回顶部"></a>
</div>
<script>
    var $backToTop_wrap = $(".backToTop_wrap"),
        $backToTop_btn = $("#back_to_top");

    if ($(window).scrollTop() > 100) {
        $backToTop_wrap.removeClass("off");
    }
    else {
        $backToTop_wrap.addClass("off");
    }

    $(window).on("scroll", function () {
        if ($(this).scrollTop() > 100) {
            $backToTop_wrap.removeClass("off");
        }
        else {
            $backToTop_wrap.addClass("off");
        }
    });

    $backToTop_btn.on("click", function () {
        $("html, body").animate({scrollTop: 0}, 120);
    });

    $(function () {
        var navlist = $('.nav-list > li');

        navlist.each(function () {
            $(this).on('mouseenter', function () {
                $(this).addClass('selected');
            });

            $(this).on('mouseleave', function () {
                $(this).removeClass('selected');
            });
        });
    })
</script>



</body>
</html>
