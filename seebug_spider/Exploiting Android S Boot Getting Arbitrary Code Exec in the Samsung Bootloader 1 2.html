<!DOCTYPE html>


<html xmlns:wb="http://open.weibo.com/wb">

<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta property="wb:webmaster" content="ccd3e79934f3322d"/>
  <title>Exploiting Android S-Boot: Getting Arbitrary Code Exec in the Samsung Bootloader (1/2)</title>
  <meta name="keywords" content="漏洞文档,漏洞分析,安全技术"/>
  <meta name="description" content=""/>

  <meta name="HandheldFriendly" content="True"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

  <link rel="shortcut icon" href="/static/images/favicon.ico">
  <link rel="stylesheet" type="text/css" href="/static/css/screen.css"/>
  <link rel="stylesheet" type="text/css" href="/static/css/font.css"/>
  <link rel="stylesheet"
        href="//libs.baidu.com/fontawesome/4.0.3/css/font-awesome.min.css">
  <link rel="stylesheet" type="text/css" href="/static/css/prism.css"/>
  <link rel="stylesheet" type="text/css" href="/static/css/monokai.css" media="screen"/>
  <link rel="stylesheet" type="text/css" href="/static/css/custom.css?t=20170821"/>
  <link rel="stylesheet" type="text/css" href="/static/css/print.css?t=20170821" media="print"/>
  <script>
    var _hmt = _hmt || [];
    (function () {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?ef67a70a7641da3b52452a05b3bbecae";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>

<body class="home-template">
<div class="weixin-share-img" style="display: none">
  <img src="/static/images/weixin-share.png" alt="Paper"/>
</div>

<div id="wrapper" class="">

<div id="sidebar">
  <button type="button" class="hamburger is-closed" data-toggle="offcanvas">
    <span class="hamb-top"></span>
    <span class="hamb-middle"></span>
    <span class="hamb-bottom"></span>
  </button>
  <div id="sidebar-content" class="inner">
    <h2 class="blog-title"><a href="/">Paper</a></h2>
    <h3 class="blog-description">安全技术精粹</h3>

    <form id="search" action="/">
      <button type="submit" style="background: #13313f; border: #13313f; position: absolute; right: -4px; margin-top: -3px;">
        <i class="fa fa-search search-button" style="position: absolute;right:10px; margin-top:6px;" > </i>
      </button>
      <input id="search-field" name="keyword" value="" placeholder="Search"/>

    </form>
    <div class="overlay"></div>
    <div id="sidebar-links">
      <ul id="subscription-links">
        <li><a target="_blank" href="/rss/"><i class="fa fa-rss"></i>RSS 订阅</a>
        </li>
        <li><a href="https://www.seebug.org/contribute/paper"><i
            class="fa fa-envelope-o"></i>投稿</a></li>
      </ul>
      <ul id="navigation">
        <li class="nav-" role="presentation"><a href="/"><i
            class="fa fa-angle-right"></i>首页</a></li>
        
  <li class="nav-" role="presentation"><a href="/category/vul-analysis/"><i
      class="fa fa-angle-right"></i>漏洞分析</a></li>

  <li class="nav-" role="presentation"><a href="/category/tools/"><i
      class="fa fa-angle-right"></i>安全工具&amp;安全开发</a></li>

  <li class="nav-" role="presentation"><a href="/category/information/"><i
      class="fa fa-angle-right"></i>情报分析</a></li>

  <li class="nav-" role="presentation"><a href="/category/experience/"><i
      class="fa fa-angle-right"></i>经验心得</a></li>

  <li class="nav-" role="presentation"><a href="/category/web-security/"><i
      class="fa fa-angle-right"></i>Web安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/bin-security/"><i
      class="fa fa-angle-right"></i>二进制安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/mobile-security/"><i
      class="fa fa-angle-right"></i>移动安全</a></li>

  <li class="nav-" role="presentation"><a href="/category/paper-archive/"><i
      class="fa fa-angle-right"></i>纸篓</a></li>

  <li class="nav-" role="presentation"><a href="/category/prime/"><i
      class="fa fa-angle-right"></i>安全基础&amp;教学篇</a></li>


        <li class="nav-" role="presentation"><a href="/call-for-paper/"><i
            class="fa fa-angle-right"></i>如何投稿</a></li>
        <li class="nav-" role="presentation"><a href="https://paper.seebug.org/papers/"><i
            class="fa fa-angle-right"></i>归档文件</a></li>
      </ul>
      <ul id="sidebar-external">
      </ul>
    </div>

    <footer class="site-footer">
      <section class="copyright">Copyright @ 404 Team from Knownsec.</section>
    </footer>
  </div>
</div>

<main>
  <div class="main-inner">
    <section id="results"></section>
    
  <article class="">
    <header class="post-header">

      <h1 class="post-title">Exploiting Android S-Boot: Getting Arbitrary Code Exec in the Samsung Bootloader (1/2)</h1>

      <span class="post-print">
        <a href="javascript:window.print()">
        <i class="fa fa-print fa-2x" aria-hidden="true"></i>
        </a>
      </span>
      <section class="post-meta">
        <span class="post-time">
          <i class='fa fa-calendar'></i>
          <time datetime="2017-03-03" class="timeago">6 月，2 周 之前</time>
          <time datetime="2017-03-03" class="fulldate">三月 03, 2017</time>
        </span>
        
          <br>
          <i class='fa fa-tag'></i>
          
            <a href="/category/mobile-security/">移动安全</a>
            
          
        








      </section>
    </header>

    <section class="post-content">
      <p><input type="hidden" class="Authorrss"  value="知道创宇404实验室" name="#" /></p>
<p>原文：<a href="http://hexdetective.blogspot.tw/">hexdetective</a></p>
<p>作者：Nitay Artenstein (<a href="https://twitter.com/nitayart">@nitayart</a>) and Gilad Goldman (<a href="https://twitter.com/gnull00">@gnull00</a>)</p>
<p>译：<strong>Holic (知道创宇404安全实验室)</strong></p>
<p>三星的 Android 安全引导程序（<strong>S-Boot</strong>）是其<a href="https://kp-cdn.samsungknox.com/bb91024cad9080904523821f727b9593.pdf">信任链概念</a>的核心。
攻击者利用 S-Boot 可能会加载不受信任的内核和系统映像这点，以此绕过大多数手机的安全机制。</p>
<p>这是众所周知的攻击思路。它经常被 Android rooting 和 mod 社区使用，而我猜它大概更受执法和政府机构喜爱。</p>
<p>更有意思的是，S-boot 启动时存在几个内存破坏漏洞，其中一个可用于在引导加载程序中实现完整的代码执行。</p>
<p>我们目前在 Exynos 芯片上确认存在该漏洞。貌似在三星S5，S6，S7 上有 90% 使用了 Exynos 的 ROM。最新的 S7 的 ROM 似乎修复了这个漏洞，而我们会在这几天内确认这一点。</p>
<p>漏洞覆盖面很大，那么我们将把它分成两篇文章。在本文中，我们将重点介绍一些 S-Boot 内部机制，然后探索加载程序的攻击面并获得基本的调试功能。我们以发现一个有趣的攻击面作为结束。在下一篇文章中，我们将公开真正的漏洞并利用它得以在 S-boot 中代码执行。</p>
<p>我们不会深入太多逆向 S-Boot 的基础知识，比如 IDA 加载或查找基址。Fernand Lone Sang (@_kamino_) 会放出一篇关于本文的精彩文章，当它发表之时，我会提供链接。如果你需要其他帮助，私信我即可，我很乐意提供帮助。</p>
<h3>理解 S-Boot</h3>
<p><img alt="" src="https://images.seebug.org/content/images/2017/03/bl2.jpg-w331s" /></p>
<p>三星的 Android 启动过程开始于 Boot ROM 中运行的代码，使用了 OEM 公钥（在三星设备中被称为三星安全启动密钥（SSBK））验证下一阶段引导加载程序的完整性。然后它将两个独立进程加载到内存中：一个是 S-Boot 本身，另一个是在 TrustZone TEE （可信执行环境）中运行的 “安全世界”。</p>
<p>这两个进程协同工作。TEE 操作系统，在Exynos 处理器的情况下对应 Trustonic（之前的 MoboCore），由 S-Boot 调用，以验证镜像在加载之前的签名。因此 S-Boot 或 TEE 中的任何一个都可能成为整个系统的潜在风险。</p>
<p>S-Boot本身分为两部分：第一阶段 Bootloader BL1 由 Boot ROM 调用并初始化低级系统原语。BL1 在验证其签名后跳入 BL2，这是自身已经是最小的操作系统，完成了对 USB，显示器和 I/O 的驱动支持。</p>
<p>既然我们有兴趣找到 bug，那么让我们破坏启动的引导过程吧，我们决定找到它尽可能接近实际的内核启动方式。这是因为我们知道已经有了一个初始化的系统，，进一步的操作，比如磁盘 I/O - 我们需要做的是刷入自定义的镜像 - 做一点微小的工作。因此，我们决定在此阶段跳入 BL2 并忽略 BL1 （虽然我们确定此后会破坏这一阶段）。</p>
<p>此阶段下，没有任何调试功能，只是 sboot.bin 与三星 Exynos 标准镜像合并在了一起。那么我们在 IDA 中打开它，对 BL2 进行研究。</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/03/Screenshot-from-2017-03-01-02-53-50.png-w331s" /></p>
<p><center>A typical function in BL2. Notice the quantity of strings</center></p>
<p>其实挺简单的：知道了 BL1 主要负责底层初始化，而 BL2 几乎是一个全功能的操作系统，我们可以由此得出结论，属于 BL2 的功能肯定更多，而且具有更多的调试字符串和其他函数引用。一旦我们确定 BL2 的位置，我们使用经典的逆向技巧即可确定内存中映像的基址。</p>
<p>在更高的层次上，BL2 有几个有趣的任务，包括且不仅限于：</p>
<ol>
<li>启动内核</li>
<li>闪存刷入新的固件镜像</li>
<li>在固件更新期间显示基本的用户界面</li>
<li>调试（运气好的话）</li>
</ol>
<p>BootLoader 阶段，加载新固件映像的机制通常是最好的攻击面，因为它涉及到与攻击者的输入直接交互以及各种复杂的逻辑。那么下面就是我们首先看到的。</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/03/Windows-7-x64-2017-03-01-02-05-01.png-w331s" /></p>
<h3>Into Odin</h3>
<p>对三星 Android 手机有过研究的人都知道 Odin，这是个可敬但有些笨重的软件，它的功能是将固件 ROM 刷入设备存储器中。</p>
<p>在设备端，刷入新的固件要先把手机切换到下载模式，这个在 S-Boot 中得以实现，然后通过 USB 连接到运行 Odin 客户端的主机。然后 Odin 客户端将选中的固件镜像发送到设备上运行的 Odin 服务器。当然，你不能刷入任何镜像，在有锁的三星设备上，BootLoader 将拒绝未签名的三星固件。</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/03/download_mode.jpg-w331s" />
<center>Download mode. Locked bootloaders reject unsigned images</center></p>
<p>在 BootLoader 一端，Odin 引导 BootLoader使用了相当全面的协议，通过 USB 接收传输数据。这就是我们率先发力之处。</p>
<p>如果想继续跟进分析，我们使用的 ROM 版本是 <strong>G930FXXU1APF2</strong>。这是三星 Galaxy S7 的 ROM，可以直接从 <a href="https://www.sammobile.com/firmwares/download/77386/G930FXXU1APF2_G930FH3G1APF1_H3G/">Sam Mobile</a> 下载。</p>
<p>Odin 处理程序代码中有个关键函数是 <code>process_packet</code>（位于地址 0x8F00A0A4 处），它几乎处理了所有的 Odin 协议。刚读到函数代码我们就遇到一个问题：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/03/bug1_cropped.png-w331s" />
<center>The beginning of process_packet</center></p>
<p>如你所见，Odin 协议查找数据包 ID，并选择代码分支。数据包 ID 0x65 告诉 Odin 要进行一个 PIT 文件相关的操作（PIT 包含分区信息，可参考<a href="https://forum.xda-developers.com/showthread.php?t=999097">此 XDA 串</a>）。</p>
<p>当代码运行至 ID 0x65，它会将当前 PIT 文件读取到缓冲区，或者写入一个新的 PIT 文件到保存 PIT 数据的特殊分区。如果第二个字节是 1，Odin 继续将当前 PIT 复制到缓冲区，然后传递至 Odin 客户端。客户端需要它来确认新的固件是否适合当前分区方案。</p>
<p>但是 PIT 被复制的目标缓冲区（xfer_data.pit_buf）在哪里被初始化呢？显然，它在这种情况下被分配：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/03/init_2.png-w331s" />
<center>The allocated of pit_buf</center></p>
<p>这意味着你必须在缓冲区分配之前发送初始化数据包（ID 0x64）。如果没有的话，缓冲区是指向 0 地址的。如果你试图在缓冲区分配之前复制 PIT ，代码会继续向 0 地址空间复制：经典的空指针解引用漏洞。</p>
<p>这个类似于我们在 Odin 中发现的其他漏洞，它能使 BootLoader 崩溃，但不一定能利用。这种情况下，鉴于 ARM64 架构，0 地址空间没有映射，任何尝试复制到这儿的操作都会使它马上崩溃，而在 ARM32 体系上就不是那么糟糕了，因为0地址可能包含被覆盖的异常向量表（EVT）。那么问题来了，我们写入的数据依然是不可控的，因为我们无法控制 PIT 数据。</p>
<p>但是这个漏洞确实给了我们很多额外的东西。当我们触发漏洞并崩溃 BootLoader 时，屏幕上会显示什么？</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/03/upload_mode_2.jpg-w331s" />
<center>Inside Upload Mode</center></p>
<h3>Dumping Memory</h3>
<p>代码表明 BootLoader 处理的异常输出到了屏幕上面，然后输入参考引用为“上传模式”的东西。这个方面的开发就有意思了：上传模式是一个半密码引导的 BootLoader 模式，且已经<a href="https://forum.xda-developers.com/showthread.php?t=858233">困惑了mod社区多年</a>。有些用户报告内核恐慌后得以触发，也有人说，它是由于 PMIC 问题。现在我们知道了可以在 BootLoader 异常的时候进入该模式。</p>
<p>观察对应代码，我们看到上传模式位于 <code>usbd3_rdx_process</code>（对应地址 0x8F028C1C），属于内联函数。我对代码进行了一些修改简化，以便观察。</p>
<div class="codehilite"><pre><span></span><span class="n">mode_switch</span> <span class="o">=</span> <span class="n">p_board_info</span><span class="o">-&gt;</span><span class="n">mode_switch</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">mode_switch</span> <span class="o">&amp;</span> <span class="n">UPLOAD_MODE</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">transaction_data</span><span class="p">.</span><span class="n">response_buffer</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">transaction_data</span><span class="p">.</span><span class="n">response_buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x80000</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">transaction_data</span><span class="p">.</span><span class="n">response_buffer</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: buffer allocation failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;usbd3_rdx_process&quot;</span><span class="p">);</span>
      <span class="k">goto</span> <span class="n">INFINITE_LOOP</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">packet_buf</span><span class="p">,</span> <span class="s">&quot;PoWeRdOwN&quot;</span><span class="p">)</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">goto</span> <span class="n">POWERDOWN</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">packet_buf</span><span class="p">,</span> <span class="s">&quot;PrEaMbLe&quot;</span><span class="p">)</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">transaction_data</span><span class="p">.</span><span class="n">response_buffer</span><span class="p">,</span> <span class="s">&quot;AcKnOwLeDgMeNt&quot;</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
    <span class="k">goto</span> <span class="n">SEND_RESPONSE</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">packet_buf</span><span class="p">,</span> <span class="s">&quot;PrObE&quot;</span><span class="p">)</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">transaction_data</span><span class="p">.</span><span class="n">response_buffer</span><span class="p">,</span> <span class="n">log_location_buf</span><span class="p">,</span> <span class="n">log_location_buf_size</span><span class="p">);</span>
    <span class="k">goto</span> <span class="n">SEND_RESPONSE</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="p">...</span>
  <span class="n">dump_start_addr</span> <span class="o">=</span> <span class="n">strtol</span><span class="p">(</span><span class="n">packet_buf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
  <span class="n">dump_end_addr</span> <span class="o">=</span> <span class="n">strtol</span><span class="p">(</span><span class="n">packet_buf</span> <span class="o">+</span> <span class="mi">9</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
  <span class="p">...</span>
  <span class="p">(</span><span class="n">some</span> <span class="n">length</span> <span class="n">checks</span><span class="p">)</span>
  <span class="p">...</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">transaction_data</span><span class="p">.</span><span class="n">response_buffer</span><span class="p">,</span> <span class="n">dump_start_addr</span><span class="p">,</span>   <span class="n">dump_end_addr</span> <span class="o">-</span> <span class="n">dump_start_addr</span><span class="p">);</span>
  <span class="k">goto</span> <span class="n">SEND_RESPONSE</span><span class="p">;</span>
</pre></div>


<p>这是个相当基础的协议，用于设备的内存转储。发送一系列初始化数据包后，只需再发送转储起始地址和结束地址，然后通过 USB 恢复转储。</p>
<p>这对调试和逆向分析很有用，因为我们可以在崩溃之后转储内存，查看寄存器和堆栈，然后弄清发生了什么。当然还可以 dump 全部内存以帮助我们逆向。我们将会看到这种能力在文章第二部分很有用。</p>
<p>由于我们没有找到公开的工具用来通过上传模式转储 RAM，然后<a href="https://github.com/nitayart/sboot_dump">我自己写了个</a>。</p>
<h3>Fuzzing Odin</h3>
<p>这时，我们回到 Odin 协议，希望找到一个可利用的 bug。进入新的攻击面之时，我们要写出基本的 fuzz 工具，以便尽快达成目标。</p>
<p>实施证明 S-Boot 还是有点难度的，因为它使用 CDC ACM（一种串口形式）的专有协议，很难使其正常运行。一些小细节至关重要：比如，你必须在每个标准数据包后发送一个空包，一些数据包需要 1024 字节，即使它实际只包含 4 个字节的有效数据。时间有限，从零开始 fuzz 就太慢了。</p>
<p>Benjamin Dobell 的 <a href="https://github.com/Benjamin-Dobell/Heimdall">Heimdall</a> 此处就该登场了。Heimdall 是个开源的 Odin 客户端协议交互工具，它辅助处理与 Odin BootLoader 交互的部分，所以我们将其作为 fuzzer 的基础，然后进行一些扩展。</p>
<p>我们添加了一个名为 “fuzz” 的命令行选项，仅需一些原始数据包，可以使用 Python 预先生成，然后将它们依次发送至设备，同时处理底层细节。<a href="https://github.com/nitayart/heimdall_fuzz">点此下载</a></p>
<p>我们使用这种方法在 Odin 中发生了一些有趣的崩溃，但貌似不能利用。此时我们决定花一些时间扩展 Odin 应用，那么就需要更深入的研究 Odin。下面是我们的一些有趣的发现。</p>
<h3>The UART Console</h3>
<p>搜索二进制，我们在 0x8F08BD78 处找到一些可疑的字符串指针。</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/03/comm_2.png-w331s" />
<center>The possible command list</center></p>
<p>看起来像是配对的命令名称和描述，可能是某种终端用于诊断的命令 - 在其他嵌入式项目中挺常见的，但此处并不是我们想要的。</p>
<p>要是有某种串口，能使我们连接到这个终端就好了，我们发现 XDA 的成员已经<a href="https://forum.xda-developers.com/showthread.php?t=1901376">做到了这一步</a>。</p>
<p>事实证明，三星已经留下了一个 UART 终端，可以通过 BootLoader 打开，通过它暴露了一些低级的命令用户服务诊断。其中一些命令可以使用特殊参数启动内核，从存储器读取或写入，并触发各种 USB 模式。</p>
<p>然而，自从 2012 年 XDA 发布以来，还没有人对这些终端的输入做公开报告，使很多研究人员以为这个借口已被切断。我们想要对这一假设进行测试。</p>
<p>进一步阅读后，尤其是 <a href="https://media.blackhat.com/us-13/US-13-Ossmann-Multiplexed-Wired-Attack-Surfaces-WP.pdf">Michael Ossmann和Kyle Osborn 2013年的Black Hat</a> 演示，我们意识到三星手机以及所有的 Google Nexus手机都有一个多路复用 IC（MUIC），它位于 USB 连接器和 USB 控制器之间。通过检测 USB 连接器上的 ID 和接地直接的电阻，多路复用器在设备上切换了不同的连接路径。</p>
<p>公开文档有记录这两个路径的是普通的 USB 和 USB OTG。另一种模式，在公共文档中没有提到的是 UART。</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/03/anyway.jpg-w331s" /></p>
<p><center>The Samsung Anyway</center></p>
<p>然后调整设置，以获取该没有公开记录的 UART 的连接方式。调用的第一个端口便是<a href="https://www.xda-developers.com/what-is-the-samsung-anyway-jig/">Samsung Anyway Jig</a>，这是三星比较隐秘的一个设备。这个东西通常只有三星工程师使用，很难搞到，尽管它每一段时间就会出现在 eBay 上。</p>
<p>显然，Anyway 只是为ID 引脚设置了几个预定义的电阻电平，并将 D+/D- 线分接到 DBUS 连接器，然后就可以通过串口 USB 适配器连接到 PC。</p>
<p>在 eBay 上收了个二手的，然后我测试了各种开关组合，试着让 MUIC 切换到 UART 终端模式。这在旧三星机器上管用，而我们只是成功获取到输入交互 - 我们从 BootLoader 和内核获取日志，但是并没有得到终端。</p>
<p>在此阶段，我们决定自己制作一条临时的 UART 电缆，类似于 Joshua Drake 的 <a href="https://www.optiv.com/blog/building-a-nexus-4-uart-debug-cable">Nexus 4 UART </a>电缆。我们从 XDA 收集了一些关于 ID 引脚电阻以及相关制造商的各种数据，还从内核 DTS 文件中得到一些提示。下面假想电路图：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/03/drawing.jpg-w331s" /></p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/03/jig.jpg-w331s" /></p>
<p><center>Our makeshift jig</center></p>
<p>由于需要控制一系列电阻，我们使用了一个可变电阻，将其设为需要的值（万用表测量），并将其连接到 S7。</p>
<p>jig 相当简单：RS232-to-USB 的TX / RX线连接到micro USB连接器的D/D- USB线，ID 引脚通过可变电阻连接接地引脚。</p>
<p>结果正确的电阻值是 619K 欧姆。设置成此电阻的时候，能够在启动设备时得到一些输出。但是并不完美，输出几行后就没反应了 - 我们仍然无法得到一个终端。</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/03/log.png-w331s" /></p>
<p><center>The initial UART output. Logs went silent after ifconn_com_to_open</center></p>
<p>为了深入理解问题的根源，来看看标记为 <code>get_initial_uart_str（0x8F006ECC</code> 的函数。似乎 UART 控制台只有在此函数返回非空时才会启动：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/03/termcode2.png-w331s" /></p>
<p><center>get_initial_uart_str</center></p>
<p>这里特别是 LABEL_9 ，我们可以看到 BootLoader 要求在进入控制台模式之前至少有四个连续的回车。</p>
<p>此时一目了然：通过连接 jig 启动时按下 “回车” 键，同时按下音量和电源按钮，我们试着清除了 <code>ifconn_com_to_open</code> 的检测和终端校验。</p>
<p>最后，我们的付出得到了回报：</p>
<p><img alt="" src="https://images.seebug.org/content/images/2017/03/IMG_5376.jpg-w331s" /></p>
<p>如你所见，控制台暴露了一些非常有趣的命令。而下一篇文章将会更加有趣。</p>
      
<hr>
<p><img src="https://images.seebug.org/content/images/2017/08/0e69b04c-e31f-4884-8091-24ec334fbd7e.jpeg" alt="Paper" style="width: 220px">
本文由 Seebug Paper 发布，如需转载请注明来源。本文地址：<a href="https://paper.seebug.org/237/">https://paper.seebug.org/237/</a></p>
            
    </section>

  <nav class="pagination" role="navigation" style="padding: 3rem;">
    
      <a class="newer-posts" href="/235/"><span aria-hidden="true">&larr;</span> 一个有意思的APPLE XSS（CVE-2016-77...</a>
    
    
      <a class="older-posts" href="/232/">阴阳师：一个非酋的逆向旅程 <span aria-hidden="true">&rarr;</span></a>
    
  </nav>


    

      
        <footer class="post-footer">
          <figure class="author-image">
            <a class="img" href="/users/author/?nickname=%E7%9F%A5%E9%81%93%E5%88%9B%E5%AE%87404%E5%AE%9E%E9%AA%8C%E5%AE%A4"
               style="background-image: url(https://images.seebug.org/uploads/2017/09/2016.6.27404_logo-03.png)"><span
                class="hidden">'s Picture</span></a>
          </figure>

          <section class="author">
            <h4><a
                href="/users/author/?nickname=%E7%9F%A5%E9%81%93%E5%88%9B%E5%AE%87404%E5%AE%9E%E9%AA%8C%E5%AE%A4">知道创宇404实验室</a>
            </h4>
            <p>阅读更多有关<a
                href="/users/author/?nickname=%E7%9F%A5%E9%81%93%E5%88%9B%E5%AE%87404%E5%AE%9E%E9%AA%8C%E5%AE%A4">该作者</a>的文章
            </p>
            
            <div class="author-meta">
            </div>
          </section>

          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          

        </footer>
      
    
    <br>
    <section class="plugin_comment">
    </section>

  </article>
  <section class="plugin_feedback"></section>


  </div>
</main>
</div>

<script type="text/javascript" src="/static/js/jquery.min.js"></script>
<script type="text/javascript" src="/static/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/static/js/index.js"></script>
<script type="text/javascript" src="/static/js/prism-loader.js"></script>
<script type="text/javascript" src="/static/js/prism.js"></script>
<script type="text/javascript" src="/static/js/jquery.ghostHunter.js"></script>
<script type="text/javascript" src="/static/js/js.cookie.js"></script>
<script type="text/javascript" src="/static/js/custom.js?t=20170821"></script>
<script type="text/javascript" src="https://www.seebug.org/static/dist2/scripts/comment_main.js"></script>
<script type="text/javascript" src="https://www.seebug.org/static/dist2/scripts/plugin_feedback.js"></script>
</body>

</html>
